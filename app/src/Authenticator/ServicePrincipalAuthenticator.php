<?php

declare(strict_types=1);

namespace App\Authenticator;

use Authentication\Authenticator\AbstractAuthenticator;
use Authentication\Authenticator\Result;
use Authentication\Authenticator\ResultInterface;
use App\Model\Entity\ServicePrincipal;
use App\Model\Entity\ServicePrincipalToken;
use Cake\I18n\DateTime;
use Cake\ORM\TableRegistry;
use Psr\Http\Message\ServerRequestInterface;

/**
 * Authenticates API clients via API token.
 *
 * Validates token format, looks up service principal, checks IP restrictions,
 * and updates last used timestamps for security auditing.
 *
 * Token format: Base64-encoded token (generated by ServicePrincipalToken::generateToken())
 * Transport:
 * - Authorization: Bearer {token}
 * - X-API-Key: {token}
 * - api_key query param
 */
class ServicePrincipalAuthenticator extends AbstractAuthenticator
{
    /**
     * Default configuration
     *
     * @var array<string, mixed>
     */
    protected array $_defaultConfig = [
        'header' => 'Authorization',
        'tokenPrefix' => 'Bearer',
        'apiKeyHeader' => 'X-API-Key',
        'apiKeyQueryParam' => 'api_key',
    ];

    /** @var int|null Token ID for audit logging */
    protected ?int $authenticatedTokenId = null;

    /**
     * Authenticate an API request using Bearer token.
     *
     * @param \Psr\Http\Message\ServerRequestInterface $request Request
     * @return \Authentication\Authenticator\ResultInterface
     */
    public function authenticate(ServerRequestInterface $request): ResultInterface
    {
        // 1. Extract Bearer token from Authorization header
        $token = $this->extractToken($request);
        if ($token === null) {
            return new Result(
                null,
                Result::FAILURE_CREDENTIALS_MISSING,
                ['No Bearer token provided']
            );
        }

        // 2. Hash the token and look it up
        $tokenHash = ServicePrincipalToken::hashToken($token);
        $tokensTable = TableRegistry::getTableLocator()->get('ServicePrincipalTokens');

        $tokenEntity = $tokensTable->find()
            ->contain(['ServicePrincipals'])
            ->where(['ServicePrincipalTokens.token_hash' => $tokenHash])
            ->first();

        if (!$tokenEntity) {
            return new Result(
                null,
                Result::FAILURE_IDENTITY_NOT_FOUND,
                ['Invalid API token']
            );
        }

        // 3. Check token expiration
        if ($tokenEntity->isExpired()) {
            return new Result(
                null,
                Result::FAILURE_CREDENTIALS_EXPIRED,
                ['API token has expired']
            );
        }

        // 4. Validate service principal is active
        $servicePrincipal = $tokenEntity->service_principal;
        if (!$servicePrincipal || !$servicePrincipal->is_active) {
            return new Result(
                null,
                Result::FAILURE_OTHER,
                ['Service principal is inactive']
            );
        }

        // 5. Validate IP allowlist
        $clientIp = $request->getServerParams()['REMOTE_ADDR'] ?? null;
        if ($clientIp && !$servicePrincipal->isIpAllowed($clientIp)) {
            return new Result(
                null,
                Result::FAILURE_OTHER,
                ['IP address not allowed']
            );
        }

        // 6. Update last used timestamps (non-blocking)
        $now = DateTime::now();
        $tokensTable->updateAll(
            ['last_used_at' => $now],
            ['id' => $tokenEntity->id]
        );
        
        $servicePrincipalsTable = TableRegistry::getTableLocator()->get('ServicePrincipals');
        $servicePrincipalsTable->updateAll(
            ['last_used_at' => $now],
            ['id' => $servicePrincipal->id]
        );

        // 7. Store token ID for audit logging
        $this->authenticatedTokenId = $tokenEntity->id;

        // 8. Return successful authentication
        return new Result($servicePrincipal, Result::SUCCESS);
    }

    /**
     * Extract API token from request.
     *
     * Supports:
     * - Authorization: Bearer <token>
     * - X-API-Key: <token>
     * - ?api_key=<token>
     *
     * @param \Psr\Http\Message\ServerRequestInterface $request Request
     * @return string|null Token or null if not found
     */
    protected function extractToken(ServerRequestInterface $request): ?string
    {
        $header = $request->getHeaderLine($this->_config['header']);
        if (!empty($header)) {
            $prefix = $this->_config['tokenPrefix'] . ' ';
            if (stripos($header, $prefix) === 0) {
                return trim(substr($header, strlen($prefix)));
            }
        }

        $apiKeyHeader = $request->getHeaderLine($this->_config['apiKeyHeader']);
        if (!empty($apiKeyHeader)) {
            return trim($apiKeyHeader);
        }

        $apiKeyQueryParam = $this->_config['apiKeyQueryParam'];
        $apiKeyQueryValue = $request->getQueryParams()[$apiKeyQueryParam] ?? null;
        if (is_string($apiKeyQueryValue) && $apiKeyQueryValue !== '') {
            return trim($apiKeyQueryValue);
        }

        return null;
    }

    /**
     * Get the authenticated token ID for audit logging.
     *
     * @return int|null
     */
    public function getAuthenticatedTokenId(): ?int
    {
        return $this->authenticatedTokenId;
    }
}
