(self["webpackChunk"] = self["webpackChunk"] || []).push([["/js/controllers"],{

/***/ "./assets/css/app.css":
/*!****************************!*\
  !*** ./assets/css/app.css ***!
  \****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./assets/css/cover.css":
/*!******************************!*\
  !*** ./assets/css/cover.css ***!
  \******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./assets/css/dashboard.css":
/*!**********************************!*\
  !*** ./assets/css/dashboard.css ***!
  \**********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./assets/css/signin.css":
/*!*******************************!*\
  !*** ./assets/css/signin.css ***!
  \*******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./assets/js/controllers/activity-toggle-controller.js":
/*!*************************************************************!*\
  !*** ./assets/js/controllers/activity-toggle-controller.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * ActivityToggleController
 * 
 * Handles enabling/disabling the custom description field when an activity
 * checkbox is toggled on the gathering edit form.
 */
class ActivityToggleController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["checkbox", "descriptionField"];

  /**
   * Toggle the description field based on checkbox state
   */
  toggleDescription(event) {
    const checkbox = event.target;
    const descriptionField = this.descriptionFieldTarget;
    if (checkbox.checked) {
      descriptionField.disabled = false;
    } else {
      descriptionField.disabled = true;
      descriptionField.value = ''; // Clear the value when unchecked
    }
  }
}

// Add to global controllers registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["activity-toggle"] = ActivityToggleController;

/***/ }),

/***/ "./assets/js/controllers/activity-waiver-manager-controller.js":
/*!*********************************************************************!*\
  !*** ./assets/js/controllers/activity-waiver-manager-controller.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * Activity Waiver Manager Controller
 * 
 * Manages the waiver selection interface for gathering activities.
 * Provides visual feedback and validation for waiver associations.
 */
class ActivityWaiverManagerController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["waiverCheckbox", "selectedCount", "waiverList"];
  static values = {
    minWaivers: {
      type: Number,
      default: 0
    },
    maxWaivers: {
      type: Number,
      default: 99
    }
  };

  /**
   * Initialize the controller
   */
  connect() {
    this.updateSelectedCount();
    this.updateVisualState();
  }

  /**
   * Handle waiver checkbox toggle
   */
  toggleWaiver(event) {
    this.updateSelectedCount();
    this.updateVisualState();
    this.validateSelection();
  }

  /**
   * Update the selected waiver count display
   */
  updateSelectedCount() {
    if (!this.hasSelectedCountTarget) return;
    const selectedCount = this.getSelectedWaivers().length;
    const countText = selectedCount === 0 ? "No waivers selected" : selectedCount === 1 ? "1 waiver selected" : `${selectedCount} waivers selected`;
    this.selectedCountTarget.textContent = countText;
  }

  /**
   * Update visual state of selected waivers
   */
  updateVisualState() {
    this.waiverCheckboxTargets.forEach(checkbox => {
      const container = checkbox.closest('.form-check, .checkbox');
      if (!container) return;
      if (checkbox.checked) {
        container.classList.add('selected');
      } else {
        container.classList.remove('selected');
      }
    });
  }

  /**
   * Validate waiver selection
   */
  validateSelection() {
    const selectedCount = this.getSelectedWaivers().length;
    const isValid = selectedCount >= this.minWaiversValue && selectedCount <= this.maxWaiversValue;

    // Update validation state
    if (this.hasWaiverListTarget) {
      if (!isValid && selectedCount > 0) {
        this.waiverListTarget.classList.add('is-invalid');
      } else {
        this.waiverListTarget.classList.remove('is-invalid');
      }
    }
    return isValid;
  }

  /**
   * Get array of selected waiver IDs
   */
  getSelectedWaivers() {
    return this.waiverCheckboxTargets.filter(checkbox => checkbox.checked).map(checkbox => checkbox.value);
  }

  /**
   * Select all waivers
   */
  selectAll() {
    this.waiverCheckboxTargets.forEach(checkbox => {
      checkbox.checked = true;
    });
    this.updateSelectedCount();
    this.updateVisualState();
    this.validateSelection();
  }

  /**
   * Deselect all waivers
   */
  deselectAll() {
    this.waiverCheckboxTargets.forEach(checkbox => {
      checkbox.checked = false;
    });
    this.updateSelectedCount();
    this.updateVisualState();
    this.validateSelection();
  }
}

// Add to global controllers registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["activity-waiver-manager"] = ActivityWaiverManagerController;

// Export as default for ES6 import
/* harmony default export */ __webpack_exports__["default"] = (ActivityWaiverManagerController);

/***/ }),

/***/ "./assets/js/controllers/add-activity-modal-controller.js":
/*!****************************************************************!*\
  !*** ./assets/js/controllers/add-activity-modal-controller.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * AddActivityModalController
 * 
 * Handles the add activity modal, updating the default description
 * when an activity is selected from the dropdown.
 */
class AddActivityModalController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["activitySelect", "defaultDescription", "customDescription", "activityData"];

  /**
   * Update the default description display when an activity is selected
   */
  updateDefaultDescription(event) {
    const selectedActivityId = event.target.value;
    if (!selectedActivityId) {
      this.defaultDescriptionTarget.textContent = 'Select an activity to see its default description';
      return;
    }

    // Find the activity data element with matching ID
    const activityDataElement = this.activityDataTargets.find(element => element.dataset.activityId === selectedActivityId);
    if (activityDataElement) {
      const description = activityDataElement.dataset.activityDescription;
      this.defaultDescriptionTarget.textContent = description || 'No default description available';
    }
  }
}

// Add to global controllers registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["add-activity-modal"] = AddActivityModalController;

/***/ }),

/***/ "./assets/js/controllers/app-setting-form-controller.js":
/*!**************************************************************!*\
  !*** ./assets/js/controllers/app-setting-form-controller.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

const {
  Controller
} = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

/**
 * **INTERNAL CODE DOCUMENTATION COMPLETE**
 * 
 * App Setting Form Controller
 * 
 * A Stimulus controller that manages application settings forms with controlled submission
 * and button state management. Provides form validation workflow control and submit
 * button management for administrative configuration interfaces.
 * 
 * Key Features:
 * - Controlled form submission with event prevention
 * - Submit button state management and focus control
 * - Form validation integration support
 * - Administrative settings workflow management
 * - Bootstrap form integration patterns
 * 
 * @class AppSettingForm
 * @extends Controller
 * 
 * Targets:
 * - submitBtn: The form submit button element
 * - form: The form element to be submitted
 * 
 * HTML Structure Example:
 * ```html
 * <form data-controller="app-setting-form" 
 *       data-app-setting-form-target="form"
 *       method="post" 
 *       action="/admin/settings">
 *   <div class="mb-3">
 *     <label for="setting-key" class="form-label">Setting Key</label>
 *     <input type="text" 
 *            class="form-control" 
 *            id="setting-key" 
 *            name="key"
 *            data-action="input->app-setting-form#enableSubmit">
 *   </div>
 *   
 *   <div class="mb-3">
 *     <label for="setting-value" class="form-label">Setting Value</label>
 *     <input type="text" 
 *            class="form-control" 
 *            id="setting-value" 
 *            name="value"
 *            data-action="input->app-setting-form#enableSubmit">
 *   </div>
 *   
 *   <button type="submit" 
 *           data-app-setting-form-target="submitBtn"
 *           data-action="click->app-setting-form#submit"
 *           class="btn btn-primary" 
 *           disabled>
 *     Save Setting
 *   </button>
 * </form>
 * ```
 */
class AppSettingForm extends Controller {
  static targets = ["submitBtn", "form"];

  /**
   * Handle form submission with event prevention
   * Prevents default form submission behavior and manually triggers form submit
   * Allows for additional validation or processing before submission
   * 
   * @param {Event} event - The form submit event
   */
  submit(event) {
    event.preventDefault();
    this.formTarget.submit();
  }

  /**
   * Enable submit button and set focus
   * Called when form validation passes or content changes
   * Provides immediate user feedback for form readiness
   */
  enableSubmit() {
    this.submitBtnTarget.disabled = false;
    this.submitBtnTarget.focus();
  }
}
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["app-setting-form"] = AppSettingForm;

/***/ }),

/***/ "./assets/js/controllers/app-setting-modal-controller.js":
/*!***************************************************************!*\
  !*** ./assets/js/controllers/app-setting-modal-controller.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * AppSettingModal Stimulus Controller
 * 
 * Manages the edit modal for app settings, handling:
 * - Loading edit form via turbo-frame when edit button is clicked
 * - Coordinating with outlet-btn controller for data passing
 * - Managing modal state and turbo-frame loading
 * 
 * Features:
 * - Dynamic form loading via turbo-frame
 * - Integration with outlet-btn for row data
 * - Bootstrap modal coordination
 * - Loading state management
 * 
 * Values:
 * - editUrl: String - Base URL for edit action
 * - modalId: String - ID of the modal element (default: editAppSettingModal)
 * - frameId: String - ID of the turbo-frame element (default: editAppSettingFrame)
 * 
 * Note: This controller uses direct DOM queries for the modal and frame elements
 * because they are rendered in the modals block which is outside the controller's
 * DOM scope. Stimulus targets only work within the controller's element tree.
 * 
 * Usage:
 * <div data-controller="app-setting-modal"
 *      data-app-setting-modal-edit-url-value="/app-settings/edit"
 *      data-app-setting-modal-modal-id-value="editAppSettingModal"
 *      data-app-setting-modal-frame-id-value="editAppSettingFrame">
 *   <!-- Grid with edit buttons -->
 * </div>
 * <!-- Modal rendered separately in modals block -->
 * <div id="editAppSettingModal" class="modal">
 *   <turbo-frame id="editAppSettingFrame">
 *     <!-- Content loaded here -->
 *   </turbo-frame>
 * </div>
 */
class AppSettingModalController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static values = {
    editUrl: String,
    modalId: {
      type: String,
      default: 'editAppSettingModal'
    },
    frameId: {
      type: String,
      default: 'editAppSettingFrame'
    }
  };

  /**
   * Initialize controller
   */
  initialize() {
    this.modalInstance = null;
    this.boundHandleOutletClick = this.handleOutletClick.bind(this);
  }

  /**
   * Get the modal element by ID
   * Uses direct DOM query since modal is outside controller scope
   */
  get modalElement() {
    return document.getElementById(this.modalIdValue);
  }

  /**
   * Get the frame element by ID
   * Uses direct DOM query since frame is outside controller scope
   */
  get frameElement() {
    return document.getElementById(this.frameIdValue);
  }

  /**
   * Connect - set up event listeners
   */
  connect() {
    console.log('AppSettingModal controller connected');

    // Initialize Bootstrap modal (deferred until first use)
    // Listen for outlet-btn clicks from the grid
    document.addEventListener('outlet-btn:outlet-button-clicked', this.boundHandleOutletClick);
  }

  /**
   * Disconnect - clean up event listeners
   */
  disconnect() {
    document.removeEventListener('outlet-btn:outlet-button-clicked', this.boundHandleOutletClick);
  }

  /**
   * Handle outlet button click event
   * Loads the edit form for the clicked setting
   * 
   * @param {CustomEvent} event - The outlet-button-clicked event
   */
  handleOutletClick(event) {
    const data = event.detail;

    // Check if this is for our modal (the button target is our modal)
    const clickedButton = event.target;
    if (!clickedButton) return;
    const modalTarget = clickedButton.getAttribute('data-bs-target');
    if (modalTarget !== `#${this.modalIdValue}`) return;
    console.log('AppSettingModal: Edit clicked for setting:', data);
    if (data && data.id) {
      this.loadEditForm(data.id);
    }
  }

  /**
   * Load the edit form into the turbo-frame
   * 
   * @param {string|number} id - The app setting ID to edit
   */
  loadEditForm(id) {
    const frameEl = this.frameElement;
    if (!frameEl) {
      console.error('AppSettingModal: Frame element not found with ID:', this.frameIdValue);
      return;
    }

    // Build the edit URL with the setting ID
    const editUrl = `${this.editUrlValue}/${id}`;
    console.log('AppSettingModal: Loading edit form from:', editUrl);

    // Reset frame content to show loading state first
    frameEl.innerHTML = `
            <div class="modal-header">
                <h5 class="modal-title">Edit App Setting</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="text-center p-5">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mt-2">Loading setting...</p>
                </div>
            </div>
        `;

    // Set the src to trigger turbo-frame load
    frameEl.src = editUrl;
  }
}

// Add to global controllers registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["app-setting-modal"] = AppSettingModalController;

/***/ }),

/***/ "./assets/js/controllers/auto-complete-controller.js":
/*!***********************************************************!*\
  !*** ./assets/js/controllers/auto-complete-controller.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * **INTERNAL CODE DOCUMENTATION COMPLETE**
 * 
 * Auto Complete Controller
 * 
 * A comprehensive Stimulus controller providing advanced autocomplete functionality with
 * AJAX search capabilities, keyboard navigation, and flexible value management. Supports
 * remote data loading, local filtering, custom value support, and accessibility features.
 * 
 * Key Features:
 * - Remote AJAX data loading with configurable endpoints
 * - Local data filtering from pre-loaded datalists
 * - Keyboard navigation (arrow keys, enter, escape)
 * - Custom value support for "allow other" scenarios
 * - Hidden field integration for form submission
 * - Debounced search with configurable delay
 * - Accessibility support with ARIA attributes
 * - Clear button functionality with state management
 * - Real-time validation and selection feedback
 * - Bootstrap styling integration
 * 
 * @class AutoComplete
 * @extends Controller
 * 
 * Targets:
 * - input: The visible text input field
 * - hidden: Hidden field for storing selected value ID
 * - hiddenText: Hidden field for storing selected display text
 * - results: Container for autocomplete results dropdown
 * - dataList: Pre-loaded data options container
 * - clearBtn: Button to clear current selection
 * 
 * Values:
 * - ready: Boolean - Controller readiness state
 * - submitOnEnter: Boolean - Auto-submit form on Enter key
 * - url: String - AJAX endpoint for remote data
 * - minLength: Number - Minimum characters before search
 * - allowOther: Boolean - Allow custom values not in list
 * - required: Boolean - Field is required for form validation
 * - initSelection: Object - Initial selection value and text
 * - delay: Number - Debounce delay in milliseconds (default: 300)
 * - queryParam: String - Query parameter name (default: "q")
 * 
 * Classes:
 * - selected: Applied to selected option elements
 * 
 * HTML Structure Example:
 * ```html
 * <!-- Remote AJAX autocomplete for member search -->
 * <div data-controller="auto-complete"
 *      data-auto-complete-url-value="/members/search"
 *      data-auto-complete-min-length-value="2"
 *      data-auto-complete-allow-other-value="false"
 *      data-auto-complete-delay-value="300">
 *   <input type="text" 
 *          data-auto-complete-target="input"
 *          class="form-control"
 *          placeholder="Start typing member name...">
 *   <input type="hidden" data-auto-complete-target="hidden" name="member_id">
 *   <input type="hidden" data-auto-complete-target="hiddenText" name="member_name">
 *   <button type="button" 
 *           data-auto-complete-target="clearBtn"
 *           class="btn btn-outline-secondary"
 *           disabled>Clear</button>
 *   <div data-auto-complete-target="results" class="autocomplete-results"></div>
 * </div>
 * 
 * <!-- Local datalist autocomplete with pre-loaded options -->
 * <div data-controller="auto-complete"
 *      data-auto-complete-allow-other-value="true">
 *   <input type="text" 
 *          data-auto-complete-target="input"
 *          class="form-control">
 *   <div data-auto-complete-target="dataList" style="display: none;">
 *     <div data-value="1" data-text="Option 1">Option 1</div>
 *     <div data-value="2" data-text="Option 2">Option 2</div>
 *   </div>
 * </div>
 * ```
 */

const optionSelector = "[role='option']:not([aria-disabled='true'])";
const activeSelector = "[aria-selected='true']";
class AutoComplete extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["input", "hidden", "hiddenText", "results", "dataList", "clearBtn"];
  static classes = ["selected"];
  static values = {
    ready: Boolean,
    submitOnEnter: Boolean,
    url: String,
    minLength: Number,
    allowOther: Boolean,
    required: Boolean,
    initSelection: Object,
    delay: {
      type: Number,
      default: 300
    },
    queryParam: {
      type: String,
      default: "q"
    }
  };
  static uniqOptionId = 0;
  initialize() {
    this._selectOptions = [];
    this._datalistLoaded = false;
  }

  // Getter for the value property
  get value() {
    // if there is a hidden value return that
    if (this.hasHiddenTarget.value != "") {
      return this.hiddenTarget.value;
    } else {
      //if we allow other values return the input value
      if (this.allowOtherValue) {
        return this.inputTarget.value;
      }
      return "";
    }
  }

  // Setter for the value property
  set value(newValue) {
    //check if the new value is an object with a "value" property and "text" property
    if (typeof newValue === "object" && newValue.hasOwnProperty("value") && newValue.hasOwnProperty("text")) {
      this.inputTarget.value = newValue.text;
      this.hiddenTarget.value = newValue.value;
      this.hiddenTextTarget.value = newValue.text;
      this.clearBtnTarget.disabled = false;
      this.inputTarget.disabled = true;
      return;
    }
    //if the value matches an option set the input value to the option text
    if (newValue != "" && newValue != null) {
      let option = this._selectOptions.find(option => option.value == newValue && option.enabled != false);
      if (option) {
        this.inputTarget.value = option.text;
        this.hiddenTextTarget.value = option.text;
        this.hiddenTarget.value = option.value;
        this.clearBtnTarget.disabled = false;
        this.inputTarget.disabled = true;
        return;
      } else {
        if (this.allowOtherValue) {
          if (this.hasDataListTarget) {
            var newOptions = this.options;
            newOptions.push({
              value: newValue,
              text: newValue
            });
            this.options = newOptions;
          }
          this.inputTarget.value = newValue;
          this.hiddenTextTarget.value = newValue;
          this.hiddenTarget.value = newValue;
        } else {
          this.inputTarget.value = "";
          this.hiddenTextTarget.value = "";
          this.hiddenTarget.value = "";
          newValue = "";
        }
        if (newValue != "") {
          this.clearBtnTarget.disabled = false;
          this.inputTarget.disabled = true;
        } else {
          this.clearBtnTarget.disabled = true;
          this.inputTarget.disabled = false;
        }
        return;
      }
    }
    this.inputTarget.value = "";
    this.hiddenTarget.value = "";
    this.hiddenTextTarget.value = "";
    this.clearBtnTarget.disabled = true;
    this.inputTarget.disabled = false;
  }
  get value() {
    return this.hiddenTarget.value;
  }
  get disabled() {
    return this.inputTarget.disabled;
  }
  set disabled(newValue) {
    this.hiddenTarget.disabled = newValue;
    this.hiddenTextTarget.disabled = newValue;
    if (this.inputTarget.value != "") {
      this.inputTarget.disabled = true;
      this.clearBtnTarget.disabled = newValue;
    } else {
      this.clearBtnTarget.disabled = true;
      this.inputTarget.disabled = newValue;
    }
  }
  get hidden() {
    return this.element.hidden;
  }
  set hidden(newValue) {
    this.element.hidden = newValue;
  }
  get options() {
    return this._selectOptions;
  }
  set options(newValue) {
    this._selectOptions = newValue;
    this.makeDataListItems();
  }
  connect() {
    this.close();
    if (!this.inputTarget.hasAttribute("autocomplete")) this.inputTarget.setAttribute("autocomplete", "off");
    this.inputTarget.setAttribute("spellcheck", "false");
    this.mouseDown = false;
    this.onInputChange = debounce(this.onInputChange, this.delayValue);
    this.inputTarget.addEventListener("keydown", this.onKeydown);
    this.inputTarget.addEventListener("blur", this.onInputBlur);
    this.inputTarget.addEventListener("input", this.onInputChange);
    this.inputTarget.addEventListener("click", this.onInputClick);
    this.inputTarget.addEventListener("change", this.onInputChangeTriggered);
    this.resultsTarget.addEventListener("mousedown", this.onResultsMouseDown);
    this.resultsTarget.addEventListener("click", this.onResultsClick);
    if (this.inputTarget.hasAttribute("autofocus")) {
      this.inputTarget.focus();
    }
    this.shimElement();
    this.readyValue = true;
    this.element.dispatchEvent(new CustomEvent("ready", {
      detail: this.element.dataset
    }));
  }
  disconnect() {
    if (this.hasInputTarget) {
      this.inputTarget.removeEventListener("keydown", this.onKeydown);
      this.inputTarget.removeEventListener("blur", this.onInputBlur);
      this.inputTarget.removeEventListener("input", this.onInputChange);
      this.inputTarget.removeEventListener("click", this.onInputClick);
      this.inputTarget.removeEventListener("change", this.onInputChangeTriggered);
    }
    if (this.hasResultsTarget) {
      this.resultsTarget.removeEventListener("mousedown", this.onResultsMouseDown);
      this.resultsTarget.removeEventListener("click", this.onResultsClick);
    }
  }
  initSelectionValueChanged() {
    if (this._datalistLoaded) {
      if (this.initSelectionValue == null || !this.initSelectionValue.hasOwnProperty("value")) {
        return;
      }
      let newOption = this.initSelectionValue;
      if (!newOption.value && (!newOption.text || newOption.text == "")) {
        return;
      }
      if (this.allowOtherValue) {
        if (newOption.value == null) {
          newOption.value = newOption.text;
        }
      }
      let option = this._selectOptions.find(option => option.value == newOption.value);
      if (option) {
        this.value = option.value;
      } else {
        this.addOption(newOption);
        this.value = newOption.value;
      }
    } else {
      //check if there is a value key in the initSelectionValue object
      if (this.initSelectionValue.hasOwnProperty("value")) {
        this.hiddenTarget.value = this.initSelectionValue.value;
        this.hiddenTextTarget.value = this.initSelectionValue.text;
        this.inputTarget.value = this.initSelectionValue.text;
      }
    }
  }
  addOption(option) {
    if (option.hasOwnProperty("value") && option.hasOwnProperty("text")) {
      this._selectOptions.push(option);
      this.makeDataListItems();
    }
  }
  makeDataListItems() {
    if (this.hasDataListTarget) {
      this.dataListTarget.textContent = "";
      var items = JSON.stringify(this._selectOptions);
      this.dataListTarget.textContent = items;
    }
  }
  dataListTargetConnected() {
    this._selectOptions = JSON.parse(this.dataListTarget.textContent);
    this._datalistLoaded = true;
    if (this.hasInitSelectionValue) {
      this.initSelectionValueChanged();
    }
  }
  shimElement() {
    Object.defineProperty(this.element, 'value', {
      get: () => {
        return this.value;
      },
      set: newValue => {
        this.value = newValue;
      }
    });
    this.element.focus = () => {
      this.inputTarget.focus();
    };
    let proto = this.element;
    while (proto && !Object.getOwnPropertyDescriptor(proto, 'hidden')) {
      proto = Object.getPrototypeOf(proto);
    }
    if (proto) {
      this.baseHidden = Object.getOwnPropertyDescriptor(proto, 'hidden');
      Object.defineProperty(this.element, 'hidden', {
        get: () => {
          return this.baseHidden.get.call(this.element);
        },
        set: newValue => {
          this.baseHidden.set.call(this.element, newValue);
          if (newValue) {
            this.hiddenTarget.disabled = true;
            this.hiddenTextTarget.disabled = true;
            this.inputTarget.disabled = true;
            this.close();
          } else {
            this.hiddenTarget.disabled = false;
            this.hiddenTextTarget.disabled = false;
            this.inputTarget.disabled = false;
          }
        }
      });
    }
    Object.defineProperty(this.element, 'disabled', {
      get: () => {
        return this.disabled;
      },
      set: newValue => {
        this.disabled = newValue;
      }
    });
    Object.defineProperty(this.element, 'options', {
      get: () => {
        return this.options;
      },
      set: newValue => {
        this.options = newValue;
      }
    });
  }
  sibling(next) {
    const options = this.options;
    const selected = this.selectedOption;
    const index = options.indexOf(selected);
    const sibling = next ? options[index + 1] : options[index - 1];
    const def = next ? options[0] : options[options.length - 1];
    return sibling || def;
  }
  select(target) {
    const previouslySelected = this.selectedOption;
    if (previouslySelected) {
      previouslySelected.removeAttribute("aria-selected");
      previouslySelected.classList.remove(...this.selectedClassesOrDefault);
    }
    target.setAttribute("aria-selected", "true");
    target.classList.add(...this.selectedClassesOrDefault);
    this.inputTarget.setAttribute("aria-activedescendant", target.id);
    target.scrollIntoView({
      behavior: "auto",
      block: "nearest"
    });
  }
  onInputChangeTriggered = event => {
    event.stopPropagation();
    this.hiddenTextTarget.value = this.inputTarget.value;
  };
  onInputClick = event => {
    this.state = "start";
    if (this.hasDataListTarget) {
      const query = this.inputTarget.value.trim();
      this.fetchResults(query);
    }
    this.hiddenTextTarget.value = this.inputTarget.value;
  };
  onKeydown = event => {
    this.hiddenTextTarget.value = this.inputTarget.value;
    const handler = this[`on${event.key}Keydown`];
    this.hiddenTextTarget.value = this.inputTarget.value;
    if (handler) handler(event);
  };
  onEscapeKeydown = event => {
    this.hiddenTextTarget.value = this.inputTarget.value;
    if (!this.resultsShown) return;
    this.hideAndRemoveOptions();
    event.stopPropagation();
    event.preventDefault();
  };
  onArrowDownKeydown = event => {
    this.hiddenTextTarget.value = this.inputTarget.value;
    const item = this.sibling(true);
    if (item) this.select(item);
    event.preventDefault();
  };
  onArrowUpKeydown = event => {
    this.hiddenTextTarget.value = this.inputTarget.value;
    const item = this.sibling(false);
    if (item) this.select(item);
    event.preventDefault();
  };
  onTabKeydown = event => {
    this.hiddenTextTarget.value = this.inputTarget.value;
    if (this.allowOtherValue) {
      this.fireChangeEvent(this.inputTarget.value, this.inputTarget.value, null);
    } else {
      if (this.inputTarget.value != "") {
        let newValue = this.inputTarget.value;
        let option = this._selectOptions.find(option => option.text == newValue && option.enabled != false);
        this.value = option ? option.value : "";
      } else {
        this.clear();
      }
    }
  };
  onEnterKeydown = event => {
    this.hiddenTextTarget.value = this.inputTarget.value;
    const selected = this.selectedOption;
    if (selected && this.resultsShown) {
      this.commit(selected);
      if (!this.hasSubmitOnEnterValue) {
        event.preventDefault();
      }
    }
  };
  onInputBlur = () => {
    this.hiddenTextTarget.value = this.inputTarget.value;
    if (this.mouseDown) {
      return;
    }
    if (this.state == "open") {
      if (this.allowOtherValue) {
        this.fireChangeEvent(this.inputTarget.value, this.inputTarget.value, null);
      } else {
        if (this.inputTarget.value != "") {
          let newValue = this.inputTarget.value;
          let option = this._selectOptions.find(option => option.text == newValue && option.enabled != false);
          this.value = option ? option.value : "";
        } else {
          this.clear();
        }
      }
    }
    this.close();
    console.log("leaving");
  };
  commit(selected) {
    this.hiddenTextTarget.value = this.inputTarget.value;
    if (selected.getAttribute("aria-disabled") === "true") return;
    if (selected instanceof HTMLAnchorElement) {
      selected.click();
      this.close();
      return;
    }
    const textValue = selected.getAttribute("data-ac-label") || selected.textContent.trim();
    const value = selected.getAttribute("data-ac-value") || textValue;
    this.inputTarget.value = textValue;
    if (this.hasHiddenTarget) {
      this.hiddenTarget.value = value;
      this.hiddenTarget.dispatchEvent(new Event("input"));
      this.hiddenTarget.dispatchEvent(new Event("change"));
    } else {
      this.inputTarget.value = value;
    }
    if (this.hasHiddenTextTarget) {
      this.hiddenTextTarget.value = textValue;
    }
    this.inputTarget.focus();
    this.state = "finished";
    this.fireChangeEvent(value, textValue, selected);
    this.hideAndRemoveOptions();
  }
  fireChangeEvent(value, textValue, selected) {
    this.hiddenTextTarget.value = this.inputTarget.value;
    this.element.dispatchEvent(new CustomEvent("autocomplete.change", {
      bubbles: true,
      detail: {
        value: value,
        textValue: textValue,
        selected: selected
      }
    }));
    if (this.inputTarget.value == "") {
      this.clearBtnTarget.disabled = true;
      this.inputTarget.disabled = false;
    } else {
      this.clearBtnTarget.disabled = false;
      this.inputTarget.disabled = true;
    }
    this.element.dispatchEvent(new CustomEvent("change"), {
      bubbles: true
    });
    this.state = "finished";
  }
  clear() {
    this.inputTarget.value = "";
    if (this.hasHiddenTarget) this.hiddenTarget.value = "";
    if (this.hasHiddenTextTarget) this.hiddenTextTarget.value = "";
    this.clearBtnTarget.disabled = true;
    this.inputTarget.disabled = false;
    this.close();
  }
  onResultsClick = event => {
    this.hiddenTextTarget.value = this.inputTarget.value;
    if (!(event.target instanceof Element)) return;
    const selected = event.target.closest(optionSelector);
    if (selected) this.commit(selected);
  };
  onResultsMouseDown = () => {
    this.hiddenTextTarget.value = this.inputTarget.value;
    this.mouseDown = true;
    this.resultsTarget.addEventListener("mouseup", () => {
      this.mouseDown = false;
    }, {
      once: true
    });
  };
  onInputChange = () => {
    this.hiddenTextTarget.value = this.inputTarget.value;
    if (this.hasHiddenTarget) this.hiddenTarget.value = "";
    if (this.hasHiddenTextTarget) this.hiddenTextTarget.value = "";
    const query = this.inputTarget.value.trim();
    if (query && query.length >= this.minLengthValue || this.hasDataListTarget) {
      this.fetchResults(query);
    } else {
      this.hideAndRemoveOptions();
    }
  };
  identifyOptions() {
    const prefix = this.resultsTarget.id || "stimulus-autocomplete";
    const optionsWithoutId = this.resultsTarget.querySelectorAll(`${optionSelector}:not([id])`);
    optionsWithoutId.forEach(el => el.id = `${prefix}-option-${AutoComplete.uniqOptionId++}`);
  }
  hideAndRemoveOptions() {
    this.close();
    this.resultsTarget.innerHTML = null;
  }
  fetchResults = async query => {
    if (!this.hasUrlValue) {
      if (!this.hasDataListTarget) {
        throw new Error("You must provide a URL or a DataList target");
      } else {
        this.resultsTarget.innerHTML = null;
        let allItems = this._selectOptions;
        for (let item of allItems) {
          if (item.text.toLowerCase().includes(query.toLowerCase()) && (item.enabled != false || query == "")) {
            let itemHtml = document.createElement("li");
            itemHtml.setAttribute("data-ac-value", item.value);
            itemHtml.classList.add("list-group-item");
            if (item.enabled == false) {
              itemHtml.setAttribute("aria-disabled", "true");
              itemHtml.classList.add("disabled");
            } else {
              itemHtml.setAttribute("aria-disabled", "false");
            }
            itemHtml.setAttribute("role", "option");
            itemHtml.setAttribute("aria-selected", "false");

            //add a span around matching string to highlight it
            if (query != "") {
              let filteredOptions = item.text;
              itemHtml.innerHTML = filteredOptions.replace(new RegExp(query, 'gi'), match => `<span class="text-primary">${match}</span>`);
            } else {
              itemHtml.innerHTML = item.text;
            }
            this.resultsTarget.appendChild(itemHtml);
          }
        }
        if (this.state != "finished") {
          this.identifyOptions();
          this.open();
          this.state = "open";
        }
        return;
      }
    }
    const url = this.buildURL(query);
    try {
      this.element.dispatchEvent(new CustomEvent("loadstart"));
      const html = await this.doFetch(url);
      if (this.state != "finished") {
        this.replaceResults(html);
        this.state = "open";
      }
      this.element.dispatchEvent(new CustomEvent("load"));
      this.element.dispatchEvent(new CustomEvent("loadend"));
    } catch (error) {
      this.element.dispatchEvent(new CustomEvent("error"));
      this.element.dispatchEvent(new CustomEvent("loadend"));
      throw error;
    }
  };
  buildURL(query) {
    const url = new URL(this.urlValue, window.location.href);
    const params = new URLSearchParams(url.search.slice(1));
    params.append(this.queryParamValue, query);
    url.search = params.toString();
    return url.toString();
  }
  doFetch = async url => {
    const response = await fetch(url, this.optionsForFetch());
    if (!response.ok) {
      throw new Error(`Server responded with status ${response.status}`);
    }
    const html = await response.text();
    return html;
  };
  replaceResults(html) {
    this.hiddenTextTarget.value = this.inputTarget.value;
    this.resultsTarget.innerHTML = html;
    this.identifyOptions();
    if (!!this.options) {
      this.state = "results";
      this.open();
    } else {
      this.state = "empty list";
      this.close();
    }
  }
  open() {
    if (this.resultsShown) return;
    this.resultsShown = true;
    this.element.setAttribute("aria-expanded", "true");
    this.hiddenTextTarget.value = this.inputTarget.value;
    this.element.dispatchEvent(new CustomEvent("toggle", {
      detail: {
        action: "open",
        inputTarget: this.inputTarget,
        resultsTarget: this.resultsTarget
      }
    }));
  }
  close() {
    if (!this.resultsShown) {
      return;
    }
    this.state = "finished";
    this.resultsShown = false;
    this.inputTarget.removeAttribute("aria-activedescendant");
    this.element.setAttribute("aria-expanded", "false");
    this.hiddenTextTarget.value = this.inputTarget.value;
    this.element.dispatchEvent(new CustomEvent("toggle", {
      detail: {
        action: "close",
        inputTarget: this.inputTarget,
        resultsTarget: this.resultsTarget
      }
    }));
  }
  get resultsShown() {
    return !this.resultsTarget.hidden;
  }
  set resultsShown(value) {
    this.resultsTarget.hidden = !value;
  }
  get selectedClassesOrDefault() {
    return this.hasSelectedClass ? this.selectedClasses : ["active"];
  }
  optionsForFetch() {
    return {
      headers: {
        "X-Requested-With": "XMLHttpRequest",
        "Accept": "application/json"
      }
    };
  }
}
const debounce = (fn, delay = 10) => {
  let timeoutId = null;
  return (...args) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(fn, delay);
  };
};
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["ac"] = AutoComplete;

/***/ }),

/***/ "./assets/js/controllers/base-gathering-form-controller.js":
/*!*****************************************************************!*\
  !*** ./assets/js/controllers/base-gathering-form-controller.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseGatheringFormController: function() { return /* binding */ BaseGatheringFormController; }
/* harmony export */ });
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * Base Gathering Form Controller
 * 
 * Provides shared date validation logic for gathering forms.
 * Extended by gathering-form-controller and gathering-clone-controller.
 * 
 * Features:
 * - Automatically defaults end date to start date when start date changes
 * - Validates that end date is not before start date
 * - Provides real-time feedback to users
 */
class BaseGatheringFormController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  // Define targets - elements this controller interacts with
  static targets = ["startDate", "endDate", "submitButton"];

  /**
   * Connect function - runs when controller connects to DOM
   */
  connect() {
    // Set up initial validation when page loads
    if (this.hasStartDateTarget && this.hasEndDateTarget) {
      this.validateDates();
    }
  }

  /**
   * Handle start date changes
   * Automatically updates end date to match start date if end date is empty or before start date
   */
  startDateChanged(event) {
    const startDate = this.startDateTarget.value;
    const endDate = this.endDateTarget.value;

    // If end date is empty or before start date, set it to start date
    if (!endDate || endDate < startDate) {
      this.endDateTarget.value = startDate;
    }

    // Validate dates
    this.validateDates();
  }

  /**
   * Handle end date changes
   * Validates that end date is not before start date
   */
  endDateChanged(event) {
    this.validateDates();
  }

  /**
   * Validate dates
   * Ensures end date is on or after start date
   */
  validateDates() {
    if (!this.hasStartDateTarget || !this.hasEndDateTarget) {
      return true;
    }
    const startDate = this.startDateTarget.value;
    const endDate = this.endDateTarget.value;

    // Clear any previous validation messages
    this.clearValidationMessages();
    if (startDate && endDate && endDate < startDate) {
      // End date is before start date - show error
      this.showValidationError(this.endDateTarget, 'End date cannot be before start date');

      // Disable submit button
      if (this.hasSubmitButtonTarget) {
        this.submitButtonTarget.disabled = true;
      }
      return false;
    } else {
      // Dates are valid - enable submit button
      if (this.hasSubmitButtonTarget) {
        this.submitButtonTarget.disabled = false;
      }
      return true;
    }
  }

  /**
   * Validate form before submission
   */
  validateForm(event) {
    if (!this.validateDates()) {
      event.preventDefault();
      return false;
    }
    return true;
  }

  /**
   * Show validation error message
   */
  showValidationError(element, message) {
    // Add invalid class to element
    element.classList.add('is-invalid');

    // Create or update feedback element
    let feedbackElement = element.parentElement.querySelector('.invalid-feedback');
    if (!feedbackElement) {
      feedbackElement = document.createElement('div');
      feedbackElement.className = 'invalid-feedback';
      element.parentElement.appendChild(feedbackElement);
    }
    feedbackElement.textContent = message;
    feedbackElement.style.display = 'block';
  }

  /**
   * Clear validation messages
   */
  clearValidationMessages() {
    // Remove invalid classes
    if (this.hasStartDateTarget) {
      this.startDateTarget.classList.remove('is-invalid');
    }
    if (this.hasEndDateTarget) {
      this.endDateTarget.classList.remove('is-invalid');
    }

    // Remove feedback elements
    const feedbackElements = this.element.querySelectorAll('.invalid-feedback');
    feedbackElements.forEach(el => {
      el.style.display = 'none';
    });
  }
}

/***/ }),

/***/ "./assets/js/controllers/branch-links-controller.js":
/*!**********************************************************!*\
  !*** ./assets/js/controllers/branch-links-controller.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * BranchLinks Stimulus Controller
 * 
 * Manages dynamic branch link collection with URL validation, link type categorization,
 * and form integration. Provides a user-friendly interface for adding, removing, and
 * organizing branch-related links with Bootstrap UI components.
 * 
 * Features:
 * - Dynamic link addition with URL sanitization
 * - Link type selection with Bootstrap Icons
 * - Duplicate prevention and validation
 * - Real-time form value synchronization
 * - Bootstrap-styled UI components
 * 
 * Targets:
 * - new: Input field for new link URLs
 * - formValue: Hidden field containing JSON array of all links
 * - displayList: Container for displaying added links
 * - linkType: Element for link type selection with icon display
 * 
 * Usage:
 * <div data-controller="branch-links">
 *   <input data-branch-links-target="new" type="url" placeholder="Enter URL">
 *   <div data-branch-links-target="linkType" data-value="link" class="bi bi-link"></div>
 *   <button data-action="click->branch-links#add">Add Link</button>
 *   <div data-branch-links-target="displayList"></div>
 *   <input data-branch-links-target="formValue" type="hidden" name="links">
 * </div>
 */
class BrancheLinks extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["new", "formValue", "displayList", "linkType"];

  /**
   * Initialize controller state
   * Sets up empty items array for link management
   */
  initialize() {
    this.items = [];
  }

  /**
   * Set the link type for new link additions
   * Updates the link type icon and stores the selected type
   * 
   * @param {Event} event - Click event from link type selector
   */
  setLinkType(event) {
    event.preventDefault();
    let linkType = event.target.getAttribute('data-value');
    let previousLinkType = this.linkTypeTarget.dataset.value;
    this.linkTypeTarget.classList.remove('bi-' + previousLinkType);
    this.linkTypeTarget.classList.add('bi-' + linkType);
    this.linkTypeTarget.dataset.value = linkType;
  }

  /**
   * Add a new link to the collection
   * Validates input, sanitizes URL, prevents duplicates, and updates display
   * 
   * @param {Event} event - Click event from add button
   */
  add(event) {
    event.preventDefault();
    if (!this.newTarget.checkValidity()) {
      this.newTarget.reportValidity();
      return;
    }
    if (!this.newTarget.value) {
      return;
    }
    let url = KMP_utils.sanitizeUrl(this.newTarget.value);
    let type = this.linkTypeTarget.dataset.value;
    //check urls for duplicate url and type
    if (this.items.find(item => item.url === url && item.type === type)) {
      return;
    }
    let item = {
      "url": KMP_utils.sanitizeUrl(this.newTarget.value),
      "type": this.linkTypeTarget.dataset.value
    };
    this.items.push(item);
    this.createListItem(item);
    this.formValueTarget.value = JSON.stringify(this.items);
    this.newTarget.value = '';
    this.linkTypeTarget.dataset.value = 'link';
    this.linkTypeTarget.classList.remove('bi-' + type);
    this.linkTypeTarget.classList.add('bi-link');
  }

  /**
   * Remove a link from the collection
   * Filters out the specified item and updates the display
   * 
   * @param {Event} event - Click event from remove button
   */
  remove(event) {
    event.preventDefault();
    let id = event.target.getAttribute('data-id');
    let removeItem = JSON.parse(id);
    this.items = this.items.filter(item => {
      return item.url !== removeItem.url || item.type !== removeItem.type;
    });
    this.formValueTarget.value = JSON.stringify(this.items);
    event.target.parentElement.remove();
  }

  /**
   * Connect controller to DOM
   * Loads existing links from form value and recreates the display
   */
  connect() {
    if (this.formValueTarget.value && this.formValueTarget.value.length > 0) {
      this.items = JSON.parse(this.formValueTarget.value);
      this.items.forEach(item => {
        //create a remove button
        this.createListItem(item);
      });
    }
  }

  /**
   * Create a visual list item for a link
   * Generates Bootstrap input group with icon, URL display, and remove button
   * 
   * @param {Object} item - Link object with url and type properties
   */
  createListItem(item) {
    let removeButton = document.createElement('button');
    removeButton.innerHTML = 'Remove';
    removeButton.setAttribute('data-action', 'branch-links#remove');
    removeButton.setAttribute('data-id', JSON.stringify(item));
    removeButton.setAttribute('class', 'btn btn-danger btn-sm');
    removeButton.setAttribute('type', 'button');
    //create a list item
    let inputGroup = document.createElement('div');
    inputGroup.setAttribute('class', 'input-group mb-1');
    let iconSpan = document.createElement('span');
    iconSpan.setAttribute('class', 'input-group-text bi bi-' + item.type);
    inputGroup.appendChild(iconSpan);
    let span = document.createElement('span');
    span.innerHTML = item.url;
    span.setAttribute('class', 'form-control');
    inputGroup.appendChild(span);
    inputGroup.appendChild(removeButton);
    this.displayListTarget.appendChild(inputGroup);
  }
}
// add to window.Controllers with a name of the controller
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["branch-links"] = BrancheLinks;

/***/ }),

/***/ "./assets/js/controllers/code-editor-controller.js":
/*!*********************************************************!*\
  !*** ./assets/js/controllers/code-editor-controller.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * Code Editor Controller
 * 
 * Provides syntax validation and enhanced editing for YAML and JSON content.
 * Shows real-time validation errors and line numbers.
 * 
 * Usage:
 * <div data-controller="code-editor"
 *      data-code-editor-language-value="yaml"
 *      data-code-editor-validate-on-change-value="true">
 *   <textarea data-code-editor-target="textarea"></textarea>
 *   <div data-code-editor-target="errorDisplay"></div>
 * </div>
 * 
 * Values:
 * - language: 'yaml' or 'json'
 * - validateOnChange: boolean, whether to validate as user types
 * - minHeight: minimum height of the editor (default: '300px')
 */
class CodeEditorController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["textarea", "errorDisplay", "lineNumbers"];
  static values = {
    language: {
      type: String,
      default: 'yaml'
    },
    validateOnChange: {
      type: Boolean,
      default: true
    },
    minHeight: {
      type: String,
      default: '300px'
    }
  };
  connect() {
    this.setupEditor();
    this.validateContent();
  }
  disconnect() {
    if (this._onInput && this.hasTextareaTarget) {
      this.textareaTarget.removeEventListener('input', this._onInput);
    }
    if (this._onScroll && this.hasTextareaTarget) {
      this.textareaTarget.removeEventListener('scroll', this._onScroll);
    }
    if (this._onKeydown && this.hasTextareaTarget) {
      this.textareaTarget.removeEventListener('keydown', this._onKeydown);
    }
    this._onInput = this._onScroll = this._onKeydown = null;
  }
  setupEditor() {
    if (!this.hasTextareaTarget) return;
    if (this._isSetup) return;
    const textarea = this.textareaTarget;

    // Create wrapper for editor with line numbers
    const wrapper = document.createElement('div');
    wrapper.className = 'code-editor-wrapper';
    wrapper.style.cssText = `
            display: flex;
            border: 1px solid #ced4da;
            border-radius: 0.375rem;
            overflow: hidden;
            min-height: ${this.minHeightValue};
        `;

    // Create line numbers element
    const lineNumbers = document.createElement('div');
    lineNumbers.className = 'code-editor-line-numbers';
    lineNumbers.style.cssText = `
            background: #f7f7f7;
            border-right: 1px solid #ddd;
            padding: 10px 8px;
            font-family: SFMono-Regular, Menlo, Monaco, Consolas, monospace;
            font-size: 13px;
            line-height: 1.5;
            color: #999;
            text-align: right;
            user-select: none;
            min-width: 40px;
        `;
    lineNumbers.setAttribute('data-code-editor-target', 'lineNumbers');
    this.lineNumbersElement = lineNumbers;

    // Style the textarea
    textarea.style.cssText = `
            flex: 1;
            border: none;
            padding: 10px;
            font-family: SFMono-Regular, Menlo, Monaco, Consolas, monospace;
            font-size: 13px;
            line-height: 1.5;
            resize: vertical;
            outline: none;
            min-height: ${this.minHeightValue};
            white-space: pre;
            overflow-wrap: normal;
            overflow-x: auto;
            tab-size: 2;
        `;

    // Insert wrapper before textarea
    textarea.parentNode.insertBefore(wrapper, textarea);
    wrapper.appendChild(lineNumbers);
    wrapper.appendChild(textarea);

    // Update line numbers on content change
    this._onInput = () => {
      this.updateLineNumbers();
      if (this.validateOnChangeValue) {
        this.validateContent();
      }
    };
    textarea.addEventListener('input', this._onInput);
    this._onScroll = () => {
      lineNumbers.scrollTop = textarea.scrollTop;
    };
    textarea.addEventListener('scroll', this._onScroll);
    this._onKeydown = e => this.handleKeydown(e);
    textarea.addEventListener('keydown', this._onKeydown);

    // Initial line numbers
    this.updateLineNumbers();
    this._isSetup = true;
  }
  updateLineNumbers() {
    if (!this.lineNumbersElement || !this.hasTextareaTarget) return;
    const lines = this.textareaTarget.value.split('\n');
    const lineNumbers = [];
    for (let i = 1; i <= lines.length; i++) {
      lineNumbers.push(i);
    }
    this.lineNumbersElement.innerHTML = lineNumbers.join('<br>');
  }
  handleKeydown(e) {
    const textarea = this.textareaTarget;

    // Handle Tab key for indentation
    if (e.key === 'Tab') {
      e.preventDefault();
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const spaces = '  '; // 2 spaces for YAML/JSON indentation

      if (e.shiftKey) {
        // Shift+Tab: Remove indentation
        const beforeCursor = textarea.value.substring(0, start);
        const lineStart = beforeCursor.lastIndexOf('\n') + 1;
        const lineEndSearch = textarea.value.indexOf('\n', start);
        const lineEnd = lineEndSearch === -1 ? textarea.value.length : lineEndSearch;
        const line = textarea.value.substring(lineStart, lineEnd);
        let removeCount = 0;
        if (line.startsWith('  ')) {
          removeCount = 2;
        } else if (line.startsWith(' ')) {
          removeCount = 1;
        }
        if (removeCount > 0) {
          const newLine = line.substring(removeCount);
          const beforeLine = textarea.value.substring(0, lineStart);
          const afterLine = textarea.value.substring(lineEnd);
          textarea.value = beforeLine + newLine + afterLine;
          const adjust = removeCount;
          const newSelectionStart = start >= lineStart + adjust ? start - adjust : lineStart;
          const newSelectionEnd = end >= lineStart + adjust ? end - adjust : lineStart;
          textarea.selectionStart = newSelectionStart;
          textarea.selectionEnd = newSelectionEnd;
        }
      } else {
        // Tab: Add indentation
        textarea.value = textarea.value.substring(0, start) + spaces + textarea.value.substring(end);
        textarea.selectionStart = textarea.selectionEnd = start + spaces.length;
      }
      this.updateLineNumbers();
      if (this.validateOnChangeValue) {
        this.validateContent();
      }
    }

    // Handle Enter key - auto-indent
    if (e.key === 'Enter') {
      const start = textarea.selectionStart;
      const beforeCursor = textarea.value.substring(0, start);
      const currentLineStart = beforeCursor.lastIndexOf('\n') + 1;
      const currentLine = beforeCursor.substring(currentLineStart);
      const indent = currentLine.match(/^\s*/)[0];

      // Don't prevent default, but set up to add indent after
      setTimeout(() => {
        const newPos = textarea.selectionStart;
        textarea.value = textarea.value.substring(0, newPos) + indent + textarea.value.substring(newPos);
        textarea.selectionStart = textarea.selectionEnd = newPos + indent.length;
        this.updateLineNumbers();
      }, 0);
    }
  }
  validateContent() {
    if (!this.hasTextareaTarget) return;
    const content = this.textareaTarget.value;
    let error = null;
    if (this.languageValue === 'json') {
      error = this.validateJSON(content);
    } else if (this.languageValue === 'yaml') {
      error = this.validateYAML(content);
    }
    this.displayError(error);
    return error === null;
  }
  validateJSON(content) {
    if (!content.trim()) return null;
    try {
      JSON.parse(content);
      return null;
    } catch (e) {
      // Extract line number from error message if possible
      const match = e.message.match(/position (\d+)/);
      let lineInfo = '';
      if (match) {
        const position = parseInt(match[1]);
        const lines = content.substring(0, position).split('\n');
        lineInfo = ` (line ${lines.length}, column ${lines[lines.length - 1].length + 1})`;
      }
      return `JSON Error${lineInfo}: ${e.message}`;
    }
  }
  validateYAML(content) {
    if (!content.trim()) return null;

    // Basic YAML validation - check for common issues
    const lines = content.split('\n');
    const errors = [];
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const lineNum = i + 1;

      // Skip empty lines and comments
      if (!line.trim() || line.trim().startsWith('#')) continue;

      // Check for tabs (YAML should use spaces)
      if (line.includes('\t')) {
        errors.push(`Line ${lineNum}: Tabs are not allowed in YAML, use spaces`);
      }

      // Check for missing space after colon in key-value pairs
      const colonMatch = line.match(/^(\s*)([^:]+):([^\s])/);
      if (colonMatch && !line.includes(': ') && !line.match(/:\s*$/)) {
        // This might be a string with colon, check if it looks like a key
        const beforeColon = colonMatch[2].trim();
        if (!beforeColon.includes(' ') && !beforeColon.startsWith('-')) {
          errors.push(`Line ${lineNum}: Missing space after colon`);
        }
      }
    }

    // Try to parse as JavaScript object to catch more errors
    // This is a heuristic check for common YAML patterns
    try {
      // Check for basic structure issues
      if (content.includes('{{') && content.includes('}}')) {
        // Template syntax, skip strict validation
        return null;
      }

      // Check for unquoted special characters that need quoting
      const specialChars = /[{}\[\]&*#?|>!%@`]/;
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (line.trim().startsWith('-') || line.trim().startsWith('#')) continue;
        const colonIndex = line.indexOf(':');
        if (colonIndex > 0) {
          const value = line.substring(colonIndex + 1).trim();
          // Check if unquoted value starts with special char
          if (value && !value.startsWith('"') && !value.startsWith("'")) {
            if (value[0] && specialChars.test(value[0]) && value[0] !== '>') {
              errors.push(`Line ${i + 1}: Value may need to be quoted: ${value.substring(0, 20)}...`);
            }
          }
        }
      }
    } catch (e) {
      errors.push(`Parse error: ${e.message}`);
    }
    if (errors.length > 0) {
      return errors.slice(0, 3).join('\n'); // Show first 3 errors
    }
    return null;
  }
  displayError(error) {
    const applyContent = container => {
      if (error) {
        container.innerHTML = this.formatError(error);
        container.classList.remove('d-none');
        container.classList.add('alert', 'alert-danger', 'mt-2', 'mb-0', 'small');
      } else {
        container.innerHTML = '';
        container.classList.add('d-none');
        container.classList.remove('alert', 'alert-danger');
      }
    };
    if (this.hasErrorDisplayTarget) {
      applyContent(this.errorDisplayTarget);
      return;
    }
    const container = this._resolveErrorContainer();
    if (!container) return;

    // Find or create the error element within the container
    let errorEl = container.querySelector('.code-editor-error');
    if (!errorEl) {
      errorEl = document.createElement('div');
      errorEl.className = 'code-editor-error d-none';
      container.appendChild(errorEl);
    }
    applyContent(errorEl);
  }
  _resolveErrorContainer() {
    if (this.hasErrorDisplayTarget) {
      return this.errorDisplayTarget;
    }
    if (this.hasTextareaTarget) {
      const group = this.textareaTarget.closest('.form-group');
      if (group) return group;
    }
    return this.element;
  }
  formatError(error) {
    return `<i class="bi bi-exclamation-triangle me-1"></i><strong>Syntax Error:</strong><br><pre class="mb-0 mt-1" style="white-space: pre-wrap;">${this.escapeHtml(error)}</pre>`;
  }
  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // Action to manually trigger validation
  validate(event) {
    event?.preventDefault();
    const isValid = this.validateContent();
    return isValid;
  }

  // Check validation before form submit
  beforeSubmit(event) {
    if (!this.validateContent()) {
      const proceed = confirm('There are syntax errors in the content. Do you want to save anyway?');
      if (!proceed) {
        event.preventDefault();
      }
    }
  }
}

// Add to global controllers registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["code-editor"] = CodeEditorController;

/***/ }),

/***/ "./assets/js/controllers/csv-download-controller.js":
/*!**********************************************************!*\
  !*** ./assets/js/controllers/csv-download-controller.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * CsvDownload Stimulus Controller
 * 
 * Handles CSV file downloads with AJAX requests and automatic file saving.
 * Provides seamless CSV export functionality with error handling and 
 * proper resource cleanup.
 * 
 * Features:
 * - AJAX-based file download
 * - Automatic file saving via browser download
 * - Configurable filename and URL
 * - Error handling with user feedback
 * - Automatic resource cleanup
 * 
 * Values:
 * - url: String - URL to download CSV from
 * - filename: String - Name for downloaded file
 * 
 * Targets:
 * - button: Optional button element for click handling
 * 
 * Usage:
 * <button data-controller="csv-download" 
 *         data-csv-download-url-value="/export.csv"
 *         data-csv-download-filename-value="members.csv">
 *   Download CSV
 * </button>
 */
class CsvDownloadController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static values = {
    url: String,
    filename: String
  };
  static targets = ["button"];

  /**
   * Download CSV file via AJAX and trigger browser download
   * Handles the complete download workflow with error handling
   * 
   * @param {Event} event - Click event from download trigger
   */
  async download(event) {
    event.preventDefault();
    const url = this.urlValue || this.element.getAttribute('href') || this.element.dataset.url;
    if (!url) {
      alert("No CSV URL provided.");
      return;
    }
    try {
      const response = await fetch(url, {
        headers: {
          'X-Requested-With': 'XMLHttpRequest'
        }
      });
      if (!response.ok) {
        throw new Error(`Failed to download CSV: ${response.status}`);
      }
      const blob = await response.blob();
      const downloadUrl = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = downloadUrl;
      a.download = this.filenameValue || 'export.csv';
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        window.URL.revokeObjectURL(downloadUrl);
        a.remove();
      }, 100);
    } catch (error) {
      alert("Error downloading CSV: " + error.message);
    }
  }

  /**
   * Connect controller to DOM
   * Sets up event listeners for download triggering
   */
  connect() {
    if (this.hasButtonTarget) {
      this.buttonTarget.addEventListener('click', this.download.bind(this));
    } else {
      this.element.addEventListener('click', this.download.bind(this));
    }
  }

  /**
   * Disconnect controller from DOM
   * Cleans up event listeners
   */
  disconnect() {
    if (this.hasButtonTarget) {
      this.buttonTarget.removeEventListener('click', this.download.bind(this));
    } else {
      this.element.removeEventListener('click', this.download.bind(this));
    }
  }
}
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["csv-download"] = CsvDownloadController;

/***/ }),

/***/ "./assets/js/controllers/delayed-forward-controller.js":
/*!*************************************************************!*\
  !*** ./assets/js/controllers/delayed-forward-controller.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

const {
  Controller
} = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

/**
 * **INTERNAL CODE DOCUMENTATION COMPLETE**
 * 
 * Delayed Forward Controller
 * 
 * A Stimulus controller that provides automatic page redirection after a configurable delay.
 * Useful for implementing splash screens, automatic redirects after form submissions, or
 * timed navigation scenarios with user feedback periods.
 * 
 * Key Features:
 * - Configurable delay timing for redirect control
 * - Automatic cleanup to prevent memory leaks
 * - Timeout management with proper cancellation
 * - Immediate activation on controller connection
 * - Console logging for debugging redirect behavior
 * 
 * @class DelayForwardController
 * @extends Controller
 * 
 * Values:
 * - url: String - Target URL for redirection
 * - delayMs: Number - Delay in milliseconds before redirect
 * 
 * HTML Structure Example:
 * ```html
 * <!-- Basic delayed redirect after 3 seconds -->
 * <div data-controller="delayed-forward" 
 *      data-delayed-forward-url-value="/dashboard"
 *      data-delayed-forward-delay-ms-value="3000">
 *   <div class="text-center">
 *     <h2>Processing your request...</h2>
 *     <p>You will be redirected automatically in 3 seconds.</p>
 *     <div class="spinner-border" role="status">
 *       <span class="visually-hidden">Loading...</span>
 *     </div>
 *   </div>
 * </div>
 * 
 * <!-- Post-form submission redirect with feedback -->
 * <div data-controller="delayed-forward"
 *      data-delayed-forward-url-value="/members/list" 
 *      data-delayed-forward-delay-ms-value="2000">
 *   <div class="alert alert-success">
 *     <h4>Success!</h4>
 *     <p>Member has been created successfully.</p>
 *     <p>Redirecting to member list...</p>
 *   </div>
 * </div>
 * ```
 */
class DelayForwardController extends Controller {
  static values = {
    url: String,
    delayMs: Number
  };

  /** @type {number|null} Timer reference for cleanup management */
  timeout = null;

  /**
   * Initialize controller and start delayed forward process
   * Automatically begins the redirect timer upon connection
   */
  connect() {
    console.log("DelayForwardController connected");
    this.timeout = null;
    this.forward();
  }

  /**
   * Manage delayed redirect with timeout control
   * Cancels any existing timeout before setting a new one to prevent multiple redirects
   * Uses window.location.href for full page navigation
   */
  forward() {
    if (this.timeout) {
      clearTimeout(this.timeout);
    }
    this.timeout = setTimeout(() => {
      console.log("Forwarding to " + this.urlValue);
      window.location.href = this.urlValue;
    }, this.delayMsValue);
  }

  /**
   * Clean up timeout on controller disconnection
   * Prevents redirect execution if controller is disconnected before timeout completes
   * Essential for preventing memory leaks and unwanted redirects
   */
  disconnect() {
    if (this.timeout) {
      clearTimeout(this.timeout);
    }
  }
}
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["delay-forward"] = DelayForwardController;

/***/ }),

/***/ "./assets/js/controllers/delete-confirmation-controller.js":
/*!*****************************************************************!*\
  !*** ./assets/js/controllers/delete-confirmation-controller.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * Delete Confirmation Controller
 * 
 * Provides enhanced confirmation dialogs for delete actions with
 * context-aware messaging and undo capability hints.
 */
class DeleteConfirmationController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static values = {
    itemType: String,
    itemName: String,
    hasReferences: {
      type: Boolean,
      default: false
    },
    referenceCount: {
      type: Number,
      default: 0
    }
  };

  /**
   * Handle delete button click
   */
  confirm(event) {
    const message = this.buildConfirmMessage();
    if (!confirm(message)) {
      event.preventDefault();
      event.stopPropagation();
      return false;
    }
    return true;
  }

  /**
   * Build context-aware confirmation message
   */
  buildConfirmMessage() {
    const itemType = this.itemTypeValue || 'item';
    let message = `Are you sure you want to delete this ${itemType}?`;
    if (this.hasItemNameValue) {
      message = `Are you sure you want to delete "${this.itemNameValue}"?`;
    }
    if (this.hasReferencesValue) {
      message += `\n\nWarning: This ${itemType} is referenced by `;
      message += this.referenceCountValue === 1 ? "1 other item" : `${this.referenceCountValue} other items`;
      message += ". Deleting it may affect those items.";
    }
    message += "\n\nThis action cannot be undone.";
    return message;
  }
}

// Add to global controllers registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["delete-confirmation"] = DeleteConfirmationController;

// Export as default for ES6 import
/* harmony default export */ __webpack_exports__["default"] = (DeleteConfirmationController);

/***/ }),

/***/ "./assets/js/controllers/detail-tabs-controller.js":
/*!*********************************************************!*\
  !*** ./assets/js/controllers/detail-tabs-controller.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * DetailTabs Stimulus Controller
 * 
 * Manages tabbed interfaces with URL state management and browser history integration.
 * Automatically handles tab activation, URL updates, and Turbo frame reloading for
 * dynamic content management.
 * 
 * Features:
 * - URL-based tab selection and state persistence
 * - Browser history integration with pushState
 * - Automatic first tab activation
 * - Turbo frame reloading on tab change
 * - Configurable URL update behavior
 * - Scroll management for better UX
 * 
 * Values:
 * - updateUrl: Boolean (default: true) - Whether to update URL on tab change
 * 
 * Targets:
 * - tabBtn: Tab button elements for navigation
 * - tabContent: Tab content panels (optional)
 * 
 * Usage:
 * <div data-controller="detail-tabs" data-detail-tabs-update-url-value="true">
 *   <nav>
 *     <button data-detail-tabs-target="tabBtn" id="nav-info-tab">Info</button>
 *     <button data-detail-tabs-target="tabBtn" id="nav-history-tab">History</button>
 *   </nav>
 *   <turbo-frame id="info-frame">...</turbo-frame>
 *   <turbo-frame id="history-frame">...</turbo-frame>
 * </div>
 */
class DetailTabsController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["tabBtn", "tabContent"];
  static values = {
    updateUrl: {
      type: Boolean,
      default: true
    }
  };
  foundFirst = false;

  /**
   * Handle tab button connection to DOM
   * Sets up tab activation based on URL parameters or defaults to first tab
   * 
   * @param {HTMLElement} event - Connected tab button element
   */
  tabBtnTargetConnected(event) {
    var tab = event.id.replace('nav-', '').replace('-tab', '');
    var urlTab = KMP_utils.urlParam('tab');
    if (urlTab) {
      if (tab == urlTab) {
        event.click();
        this.foundFirst = true;
        window.scrollTo(0, 0);
      }
    } else {
      if (!this.foundFirst) {
        // Get the first tab based on CSS order, not DOM order
        const firstTab = this.getFirstTabByOrder();
        if (firstTab) {
          firstTab.click();
          this.foundFirst = true;
        }
        window.scrollTo(0, 0);
      }
    }
    event.addEventListener('click', this.tabBtnClicked.bind(this));
  }

  /**
   * Get the first tab button based on CSS order attribute
   * Respects the data-tab-order attribute for mixed plugin/template tabs
   * 
   * @returns {HTMLElement|null} First tab button by order, or null if none found
   */
  getFirstTabByOrder() {
    if (this.tabBtnTargets.length === 0) {
      return null;
    }

    // Sort tabs by their order attribute (lower number = first)
    const sortedTabs = [...this.tabBtnTargets].sort((a, b) => {
      const orderA = parseInt(a.dataset.tabOrder || '999', 10);
      const orderB = parseInt(b.dataset.tabOrder || '999', 10);
      return orderA - orderB;
    });
    return sortedTabs[0];
  }

  /**
   * Handle tab button clicks
   * Updates URL history and triggers frame reloading for dynamic content
   * 
   * @param {Event} event - Click event from tab button
   */
  tabBtnClicked(event) {
    // Get first tab based on order, not DOM position
    const firstTab = this.getFirstTabByOrder();
    const firstTabId = firstTab?.id || this.tabBtnTargets[0]?.id;
    var eventTabId = event.target.id;
    var tab = event.target.id.replace('nav-', '').replace('-tab', '');
    if (this.updateUrlValue) {
      if (firstTabId != eventTabId) {
        window.history.pushState({}, '', '?tab=' + tab);
      } else {
        //only push state if there is a tab in the querystring
        var urlTab = KMP_utils.urlParam('tab');
        if (urlTab) {
          window.history.pushState({}, '', window.location.pathname);
        }
      }
    }
    var frame = document.getElementById(tab + '-frame');
    if (frame) {
      // Check if frame has been loaded before - if it has a src and is complete, reload it
      // Otherwise, let the lazy loading handle the initial load
      if (frame.loaded || frame.complete && !frame.hasAttribute('loading')) {
        frame.reload();
      }
    }
  }

  /**
   * Handle tab button disconnection from DOM
   * Cleans up event listeners to prevent memory leaks
   * 
   * @param {HTMLElement} event - Disconnected tab button element
   */
  tabBtnTargetDisconnected(event) {
    event.removeEventListener('click', this.tabBtnClicked.bind(this));
  }
}
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["detail-tabs"] = DetailTabsController;

/***/ }),

/***/ "./assets/js/controllers/edit-activity-description-controller.js":
/*!***********************************************************************!*\
  !*** ./assets/js/controllers/edit-activity-description-controller.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * EditActivityDescriptionController
 * 
 * Handles populating the edit activity description modal with data
 * when the edit button is clicked.
 */
class EditActivityDescriptionController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["activityId", "activityName", "defaultDescription", "customDescription"];
  connect() {
    // Store bound function reference for proper cleanup
    this.boundHandleModalShow = this.handleModalShow.bind(this);

    // Listen for modal show event to populate data
    const modal = document.getElementById('editActivityDescriptionModal');
    if (modal) {
      modal.addEventListener('show.bs.modal', this.boundHandleModalShow);
    }
  }

  /**
   * Handle modal show event - populate with data from the clicked button
   */
  handleModalShow(event) {
    // Get the button that triggered the modal
    const button = event.relatedTarget;
    if (button) {
      // Extract data from button attributes
      const activityId = button.getAttribute('data-activity-id');
      const activityName = button.getAttribute('data-activity-name');
      const defaultDescription = button.getAttribute('data-default-description');
      const customDescription = button.getAttribute('data-custom-description');

      // Populate the modal fields
      if (this.hasActivityIdTarget) {
        this.activityIdTarget.value = activityId;
      }
      if (this.hasActivityNameTarget) {
        this.activityNameTarget.textContent = activityName;
      }
      if (this.hasDefaultDescriptionTarget) {
        this.defaultDescriptionTarget.textContent = defaultDescription || 'No default description';
      }
      if (this.hasCustomDescriptionTarget) {
        this.customDescriptionTarget.value = customDescription || '';
      }
    }
  }
  disconnect() {
    const modal = document.getElementById('editActivityDescriptionModal');
    if (modal && this.boundHandleModalShow) {
      modal.removeEventListener('show.bs.modal', this.boundHandleModalShow);
      this.boundHandleModalShow = null;
    }
  }
}

// Add to global controllers registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["edit-activity-description"] = EditActivityDescriptionController;

/***/ }),

/***/ "./assets/js/controllers/email-template-editor-controller.js":
/*!*******************************************************************!*\
  !*** ./assets/js/controllers/email-template-editor-controller.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/* harmony import */ var easymde__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! easymde */ "./node_modules/easymde/src/js/easymde.js");
/* harmony import */ var easymde__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(easymde__WEBPACK_IMPORTED_MODULE_1__);



/**
 * Email Template Editor Controller
 * 
 * Extends markdown editor functionality with variable insertion support for email templates.
 * Provides buttons to insert available variables into the template.
 * 
 * Usage:
 * <div data-controller="email-template-editor"
 *      data-email-template-editor-variables-value='[{"name":"userName","description":"User name"}]'>
 *   <textarea data-email-template-editor-target="editor"></textarea>
 *   <div data-email-template-editor-target="variableButtons"></div>
 * </div>
 * 
 * Values:
 * - variables: Array of available variables [{name, description}]
 * - placeholder: Placeholder text for the editor
 * - minHeight: Minimum height of the editor
 */
class EmailTemplateEditorController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["editor", "variableButtons"];
  static values = {
    variables: {
      type: Array,
      default: []
    },
    placeholder: {
      type: String,
      default: "Enter email template..."
    },
    minHeight: {
      type: String,
      default: "400px"
    }
  };
  initialize() {
    this.editor = null;
  }
  connect() {
    // Initialize EasyMDE on the textarea
    this.editor = new (easymde__WEBPACK_IMPORTED_MODULE_1___default())({
      element: this.editorTarget,
      placeholder: this.placeholderValue,
      minHeight: this.minHeightValue,
      spellChecker: false,
      status: ["lines", "words", "cursor"],
      toolbar: this.buildToolbar(),
      forceSync: true,
      autosave: {
        enabled: false
      },
      previewRender: plainText => {
        return this.renderPreview(plainText);
      }
    });

    // Render variable insertion buttons if we have variables
    if (this.hasVariableButtonsTarget && this.variablesValue.length > 0) {
      this.renderVariableButtons();
    }
    console.log('Email template editor initialized with', this.variablesValue.length, 'variables');
  }
  disconnect() {
    if (this.editor) {
      this.editor.toTextArea();
      this.editor = null;
    }
  }

  /**
   * Build custom toolbar with variable insertion button
   */
  buildToolbar() {
    const toolbar = ["bold", "italic", "heading", "|", "quote", "unordered-list", "ordered-list", "|", "link", "|", "preview", "side-by-side", "fullscreen", "|"];

    // Add custom variable insertion button
    if (this.variablesValue.length > 0) {
      toolbar.push({
        name: "insert-variable",
        action: editor => {
          this.showVariableMenu(editor);
        },
        className: "fa fa-code",
        title: "Insert Variable"
      });
    }
    toolbar.push("guide");
    return toolbar;
  }

  /**
   * Show variable insertion menu
   */
  showVariableMenu(editor) {
    // Get cursor position
    const cm = editor.codemirror;
    const cursor = cm.getCursor();

    // Create a simple prompt with variable options
    const varNames = this.variablesValue.map(v => v.name).join(', ');
    const selectedVar = prompt(`Available variables:\n${varNames}\n\nEnter variable name to insert:`);
    if (selectedVar) {
      const variable = this.variablesValue.find(v => v.name === selectedVar);
      if (variable) {
        cm.replaceSelection(`{{${variable.name}}}`);
      } else {
        alert('Invalid variable name');
      }
    }
  }

  /**
   * Render variable insertion buttons
   */
  renderVariableButtons() {
    const container = this.variableButtonsTarget;
    container.innerHTML = '<div class="mb-2"><strong>Available Variables:</strong> Click to insert</div>';
    const buttonGroup = document.createElement('div');
    buttonGroup.className = 'btn-group flex-wrap mb-3';
    buttonGroup.setAttribute('role', 'group');
    this.variablesValue.forEach(variable => {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'btn btn-sm btn-outline-primary';
      btn.textContent = `{{${variable.name}}}`;
      btn.title = variable.description || variable.name;
      btn.addEventListener('click', e => {
        e.preventDefault();
        this.insertVariable(variable.name);
      });
      buttonGroup.appendChild(btn);
    });
    container.appendChild(buttonGroup);

    // Add syntax help
    const helpText = document.createElement('div');
    helpText.className = 'alert alert-info small';
    helpText.innerHTML = '<strong>Syntax:</strong> Use <code>{{variableName}}</code> or <code>${variableName}</code> to insert variables. They will be replaced with actual values when the email is sent.';
    container.appendChild(helpText);
  }

  /**
   * Insert a variable at the current cursor position
   */
  insertVariable(variableName) {
    if (!this.editor) return;
    const cm = this.editor.codemirror;
    const doc = cm.getDoc();
    const cursor = doc.getCursor();
    doc.replaceRange(`{{${variableName}}}`, cursor);

    // Move cursor after the inserted text
    cm.focus();
  }

  /**
   * Render preview with variable highlighting
   */
  renderPreview(plainText) {
    // Convert markdown to HTML
    let html = this.editor.markdown(plainText);

    // Highlight variables in the preview
    html = html.replace(/\{\{([^}]+)\}\}/g, '<span class="badge bg-primary">{{$1}}</span>');
    html = html.replace(/\$\{([^}]+)\}/g, '<span class="badge bg-success">${$1}</span>');
    return html;
  }

  /**
   * Get the editor content
   */
  getValue() {
    return this.editor ? this.editor.value() : '';
  }

  /**
   * Set the editor content
   */
  setValue(value) {
    if (this.editor) {
      this.editor.value(value);
    }
  }
}

// Add to global controllers registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["email-template-editor"] = EmailTemplateEditorController;

/***/ }),

/***/ "./assets/js/controllers/email-template-form-controller.js":
/*!*****************************************************************!*\
  !*** ./assets/js/controllers/email-template-form-controller.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * Email Template Form Controller
 * 
 * Manages the dynamic behavior of the email template form:
 * - Populates action methods based on selected mailer class
 * - Updates available variables when action is selected
 * - Updates default subject when action is selected
 * 
 * Usage:
 * <div data-controller="email-template-form"
 *      data-email-template-form-mailers-value='[...]'>
 *   <select data-email-template-form-target="mailerSelect"
 *           data-action="email-template-form#mailerChanged"></select>
 *   <select data-email-template-form-target="actionSelect"
 *           data-action="email-template-form#actionChanged"></select>
 *   <input data-email-template-form-target="availableVars">
 *   <input data-email-template-form-target="subjectTemplate">
 * </div>
 */
class EmailTemplateFormController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["mailerSelect", "actionSelect", "availableVars", "subjectTemplate"];
  static values = {
    mailers: {
      type: Array,
      default: []
    }
  };

  /**
   * Handle mailer class selection change
   * Populates the action method dropdown with methods from the selected mailer
   */
  mailerChanged(event) {
    const selectedClass = this.mailerSelectTarget.value;

    // Clear action select
    this.actionSelectTarget.innerHTML = '<option value="">-- Select Action --</option>';
    if (!selectedClass) {
      return;
    }

    // Find the selected mailer
    const mailer = this.mailersValue.find(m => m.class === selectedClass);
    if (!mailer || !mailer.methods) {
      return;
    }

    // Populate action methods
    mailer.methods.forEach(method => {
      const option = document.createElement('option');
      option.value = method.name;
      option.textContent = method.name;
      option.dataset.vars = JSON.stringify(method.availableVars || []);
      option.dataset.subject = method.defaultSubject || '';
      this.actionSelectTarget.appendChild(option);
    });
    console.log(`Populated ${mailer.methods.length} methods for mailer: ${mailer.shortName}`);
  }

  /**
   * Handle action method selection change
   * Updates available variables and default subject
   */
  actionChanged(event) {
    const selectedOption = this.actionSelectTarget.selectedOptions[0];

    // If no option selected, clear everything and return
    if (!selectedOption) {
      return;
    }

    // Always update available vars (clear if dataset.vars is missing)
    if (this.hasAvailableVarsTarget) {
      const varsValue = selectedOption.dataset.vars || '';
      this.availableVarsTarget.value = varsValue;
      if (varsValue) {
        console.log('Updated available vars:', varsValue);
      }
    }

    // Always update subject template (clear if dataset.subject is missing)
    if (this.hasSubjectTemplateTarget) {
      const subjectValue = selectedOption.dataset.subject || '';
      this.subjectTemplateTarget.value = subjectValue;
      if (subjectValue) {
        console.log('Updated subject template:', subjectValue);
      }
    }
  }
}

// Add to global controllers registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["email-template-form"] = EmailTemplateFormController;

/***/ }),

/***/ "./assets/js/controllers/file-size-validator-controller.js":
/*!*****************************************************************!*\
  !*** ./assets/js/controllers/file-size-validator-controller.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ "./node_modules/@babel/runtime/helpers/esm/objectSpread2.js");
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");



/**
 * File Size Validator Controller
 * 
 * Validates file sizes against PHP upload limits before submission.
 * Provides immediate feedback to users when files exceed server limits,
 * preventing failed uploads and improving user experience.
 * 
 * Features:
 * - Pre-upload file size validation
 * - Multiple file support
 * - Customizable warning messages
 * - Integration with existing upload controls
 * - Real-time feedback on file selection
 * 
 * Values:
 * - maxSize: Maximum file size in bytes (from PHP upload_max_filesize/post_max_size)
 * - maxSizeFormatted: Human-readable max size (e.g., '25MB')
 * - totalMaxSize: Maximum total size for multiple files (defaults to maxSize)
 * - showWarning: Whether to show warning messages (default: true)
 * 
 * Targets:
 * - fileInput: File input element(s) to monitor
 * - warning: Container for warning messages (optional)
 * - submitButton: Submit button to disable when files are invalid (optional)
 * 
 * Events Dispatched:
 * - file-size-validator:valid - All files are valid
 * - file-size-validator:invalid - One or more files exceed limits
 * - file-size-validator:warning - Warning displayed to user
 * 
 * Usage:
 * ```html
 * <div data-controller="file-size-validator"
 *      data-file-size-validator-max-size-value="26214400"
 *      data-file-size-validator-max-size-formatted-value="25MB">
 *   
 *   <input type="file" 
 *          data-file-size-validator-target="fileInput"
 *          data-action="change->file-size-validator#validateFiles">
 *   
 *   <div data-file-size-validator-target="warning" 
 *        class="alert alert-warning d-none"></div>
 *   
 *   <button type="submit" 
 *           data-file-size-validator-target="submitButton">
 *     Upload
 *   </button>
 * </div>
 * ```
 * 
 * @example Multiple Files
 * ```html
 * <input type="file" 
 *        multiple
 *        data-file-size-validator-target="fileInput"
 *        data-action="change->file-size-validator#validateFiles">
 * ```
 * 
 * @example Custom Total Limit
 * ```html
 * <div data-controller="file-size-validator"
 *      data-file-size-validator-max-size-value="26214400"
 *      data-file-size-validator-total-max-size-value="52428800">
 * ```
 */
class FileSizeValidatorController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_1__.Controller {
  static targets = ["fileInput", "warning", "submitButton"];
  static values = {
    maxSize: Number,
    // Maximum single file size in bytes
    maxSizeFormatted: String,
    // Human-readable format (e.g., '25MB')
    totalMaxSize: Number,
    // Maximum total size for multiple files
    showWarning: {
      type: Boolean,
      default: true
    },
    warningClass: {
      type: String,
      default: 'alert alert-warning'
    },
    errorClass: {
      type: String,
      default: 'alert alert-danger'
    }
  };

  /**
   * Initialize controller
   */
  connect() {
    console.log('FileSizeValidatorController connected', {
      maxSize: this.maxSizeValue,
      maxSizeFormatted: this.maxSizeFormattedValue,
      totalMaxSize: this.totalMaxSizeValue
    });

    // Default total max to single max if not specified
    if (!this.hasTotalMaxSizeValue) {
      this.totalMaxSizeValue = this.maxSizeValue;
    }

    // Validate any pre-selected files
    if (this.hasFileInputTarget) {
      this.fileInputTargets.forEach(input => {
        if (input.files && input.files.length > 0) {
          this.validateFiles({
            target: input
          });
        }
      });
    }
  }

  /**
   * Validate selected files
   * 
   * @param {Event} event - File input change event
   */
  validateFiles(event) {
    const input = event.target;

    // Collect all files from all file inputs in this controller's scope
    let allFiles = [];
    if (this.hasFileInputTarget) {
      this.fileInputTargets.forEach(inputEl => {
        if (inputEl.files && inputEl.files.length > 0) {
          allFiles = allFiles.concat(Array.from(inputEl.files));
        }
      });
    }
    if (allFiles.length === 0) {
      this.clearWarning();
      this.enableSubmit();
      return;
    }
    const validation = this.checkFileSizes(allFiles);
    if (!validation.valid) {
      this.showInvalidFilesWarning(validation);
      this.disableSubmit();

      // Dispatch invalid event
      this.dispatch('invalid', {
        detail: {
          files: validation.invalidFiles,
          message: validation.message
        }
      });
    } else if (validation.warning) {
      this.showTotalSizeWarning(validation);

      // Still allow submission but warn user
      this.enableSubmit();

      // Dispatch warning event
      this.dispatch('warning', {
        detail: {
          totalSize: validation.totalSize,
          message: validation.message
        }
      });
    } else {
      this.clearWarning();
      this.enableSubmit();

      // Dispatch valid event
      this.dispatch('valid', {
        detail: {
          files: allFiles.map(f => ({
            name: f.name,
            size: f.size
          })),
          totalSize: validation.totalSize
        }
      });
    }
  }

  /**
   * Check file sizes and return validation result
   * 
   * @param {File[]} files - Array of File objects
   * @returns {Object} Validation result
   */
  checkFileSizes(files) {
    const invalidFiles = [];
    let totalSize = 0;
    files.forEach(file => {
      totalSize += file.size;
      if (file.size > this.maxSizeValue) {
        invalidFiles.push({
          name: file.name,
          size: file.size,
          formattedSize: this.formatBytes(file.size),
          exceededBy: file.size - this.maxSizeValue
        });
      }
    });

    // Check if any individual files exceed limit
    if (invalidFiles.length > 0) {
      return {
        valid: false,
        invalidFiles,
        totalSize,
        totalFileCount: files.length,
        message: this.buildInvalidFilesMessage(invalidFiles)
      };
    }

    // Check if total size exceeds limit (for multiple files or accumulated uploads)
    // Show warning when total size exceeds the post_max_size limit
    if (totalSize > this.totalMaxSizeValue) {
      return {
        valid: true,
        warning: true,
        totalSize,
        totalFileCount: files.length,
        formattedTotal: this.formatBytes(totalSize),
        message: this.buildTotalSizeWarningMessage(totalSize, files.length)
      };
    }
    return {
      valid: true,
      warning: false,
      totalSize,
      totalFileCount: files.length,
      formattedTotal: this.formatBytes(totalSize)
    };
  }

  /**
   * Escape HTML special characters to prevent XSS
   * 
   * @param {string} str - String to escape
   * @returns {string} Escaped string
   */
  escapeHtml(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  }

  /**
   * Build error message for invalid files
   * 
   * @param {Array} invalidFiles - Array of invalid file objects
   * @returns {string} Error message with HTML-escaped file names
   */
  buildInvalidFilesMessage(invalidFiles) {
    const maxSize = this.maxSizeFormattedValue || this.formatBytes(this.maxSizeValue);
    if (invalidFiles.length === 1) {
      const file = invalidFiles[0];
      const escapedName = this.escapeHtml(file.name);
      return `The file "${escapedName}" (${file.formattedSize}) exceeds the maximum upload size of ${maxSize}.`;
    }
    const fileList = invalidFiles.map(f => ` ${this.escapeHtml(f.name)} (${f.formattedSize})`).join('\n');
    return `${invalidFiles.length} file(s) exceed the maximum upload size of ${maxSize}:\n\n${fileList}\n\nPlease remove or replace these files before uploading.`;
  }

  /**
   * Build warning message for total size
   * 
   * @param {number} totalSize - Total size in bytes
   * @param {number} fileCount - Number of files
   * @returns {string} Warning message
   */
  buildTotalSizeWarningMessage(totalSize, fileCount) {
    const totalFormatted = this.formatBytes(totalSize);
    const maxFormatted = this.formatBytes(this.totalMaxSizeValue);
    if (fileCount === 1) {
      return `Warning: The file size (${totalFormatted}) exceeds the recommended upload limit of ${maxFormatted}. The upload may fail depending on server configuration.`;
    }
    return `Warning: You have selected ${fileCount} file(s) with a combined size of ${totalFormatted}, which exceeds the recommended limit of ${maxFormatted}. The upload may fail depending on server configuration.`;
  }

  /**
   * Show warning for invalid files
   * 
   * @param {Object} validation - Validation result
   */
  showInvalidFilesWarning(validation) {
    if (!this.showWarningValue || !this.hasWarningTarget) {
      // Still show browser alert if no warning target
      alert(validation.message);
      return;
    }
    this.warningTarget.innerHTML = this.formatWarningMessage(validation.message, 'error');
    this.warningTarget.className = this.errorClassValue;
    this.warningTarget.classList.remove('d-none');
  }

  /**
   * Show warning for total size
   * 
   * @param {Object} validation - Validation result
   */
  showTotalSizeWarning(validation) {
    if (!this.showWarningValue || !this.hasWarningTarget) {
      // Still show browser alert if no warning target
      alert(validation.message);
      return;
    }
    this.warningTarget.innerHTML = this.formatWarningMessage(validation.message, 'warning');
    this.warningTarget.className = this.warningClassValue;
    this.warningTarget.classList.remove('d-none');
  }

  /**
   * Format warning message with icon
   * 
   * @param {string} message - Warning message
   * @param {string} type - Message type ('error' or 'warning')
   * @returns {string} Formatted HTML
   */
  formatWarningMessage(message, type = 'warning') {
    const icon = type === 'error' ? '<i class="bi bi-exclamation-triangle-fill"></i>' : '<i class="bi bi-exclamation-circle-fill"></i>';

    // Preserve line breaks
    const formattedMessage = message.replace(/\n/g, '<br>');
    return `${icon} ${formattedMessage}`;
  }

  /**
   * Clear warning message
   */
  clearWarning() {
    if (this.hasWarningTarget) {
      this.warningTarget.classList.add('d-none');
      this.warningTarget.innerHTML = '';
    }
  }

  /**
   * Disable submit button
   */
  disableSubmit() {
    if (this.hasSubmitButtonTarget) {
      this.submitButtonTargets.forEach(button => {
        button.disabled = true;
      });
    }
  }

  /**
   * Enable submit button
   */
  enableSubmit() {
    if (this.hasSubmitButtonTarget) {
      this.submitButtonTargets.forEach(button => {
        button.disabled = false;
      });
    }
  }

  /**
   * Format bytes to human-readable string
   * 
   * @param {number} bytes - Size in bytes
   * @param {number} decimals - Number of decimal places
   * @returns {string} Formatted size string
   */
  formatBytes(bytes, decimals = 2) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + sizes[i];
  }

  /**
   * Dispatch custom event
   * 
   * @param {string} eventName - Event name (without prefix)
   * @param {Object} options - Event options
   */
  dispatch(eventName, options = {}) {
    const event = new CustomEvent(`file-size-validator:${eventName}`, (0,_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__["default"])({
      bubbles: true,
      cancelable: true
    }, options));
    this.element.dispatchEvent(event);
  }
}

// Register controller
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["file-size-validator"] = FileSizeValidatorController;
/* harmony default export */ __webpack_exports__["default"] = (FileSizeValidatorController);

/***/ }),

/***/ "./assets/js/controllers/filter-grid-controller.js":
/*!*********************************************************!*\
  !*** ./assets/js/controllers/filter-grid-controller.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * FilterGrid Stimulus Controller
 * 
 * Handles form submission for grid filtering and search functionality.
 * Provides automatic form submission when filter criteria are changed,
 * enabling dynamic grid updates without manual form submission.
 * 
 * Features:
 * - Automatic form submission on filter changes
 * - Grid refresh and pagination support
 * - Integration with CakePHP search forms
 * - Console logging for debugging
 * 
 * Usage:
 * <form data-controller="filter-grid" method="get">
 *   <input type="text" data-action="input->filter-grid#submitForm">
 *   <select data-action="change->filter-grid#submitForm">
 *     <option value="">All</option>
 *   </select>
 * </form>
 */
class FilterGrid extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  /**
   * Submit the form to update grid results
   * Triggers form submission for filtering and pagination updates
   * 
   * @param {Event} event - Input/change event from form elements
   */
  submitForm(event) {
    console.log("submitting form");
    this.element.requestSubmit();
  }
}
// add to window.Controllers with a name of the controller
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["filter-grid"] = FilterGrid;

/***/ }),

/***/ "./assets/js/controllers/gathering-clone-controller.js":
/*!*************************************************************!*\
  !*** ./assets/js/controllers/gathering-clone-controller.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _base_gathering_form_controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base-gathering-form-controller */ "./assets/js/controllers/base-gathering-form-controller.js");


/**
 * Gathering Clone Controller
 * 
 * Handles the clone gathering modal form interactions with date validation and defaulting.
 * Extends BaseGatheringFormController for shared date validation logic.
 * 
 * Features:
 * - Automatically defaults end date to start date when start date changes
 * - Validates that end date is not before start date
 * - Provides real-time feedback to users
 */
class GatheringCloneController extends _base_gathering_form_controller__WEBPACK_IMPORTED_MODULE_0__.BaseGatheringFormController {
  // Define additional targets specific to clone form
  static targets = ["nameInput", "startDate", "endDate", "submitButton"];

  // All date validation functionality inherited from BaseGatheringFormController
}

// Add to global controllers registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["gathering-clone"] = GatheringCloneController;

/***/ }),

/***/ "./assets/js/controllers/gathering-form-controller.js":
/*!************************************************************!*\
  !*** ./assets/js/controllers/gathering-form-controller.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _base_gathering_form_controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base-gathering-form-controller */ "./assets/js/controllers/base-gathering-form-controller.js");


/**
 * Gathering Form Controller
 * 
 * Manages client-side validation and UX improvements for gathering forms.
 * Extends BaseGatheringFormController for shared date validation logic.
 * 
 * Features:
 * - Automatically defaults end date to start date when start date changes
 * - Validates that end date is not before start date
 * - Provides real-time feedback to users
 */
class GatheringFormController extends _base_gathering_form_controller__WEBPACK_IMPORTED_MODULE_0__.BaseGatheringFormController {
  // All functionality inherited from BaseGatheringFormController
}

// Add to global controllers registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["gathering-form"] = GatheringFormController;

/***/ }),

/***/ "./assets/js/controllers/gathering-location-autocomplete-controller.js":
/*!*****************************************************************************!*\
  !*** ./assets/js/controllers/gathering-location-autocomplete-controller.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * GatheringLocationAutocompleteController
 * 
 * Provides Google Places Autocomplete for gathering location input fields
 * using the classic google.maps.places.Autocomplete API.
 * 
 * Note: We use the classic API instead of PlaceAutocompleteElement because
 * the new web component API doesn't expose selected place data programmatically.
 * The classic API provides reliable place_changed events and getPlace() method.
 * 
 * @example
 * <input type="text" 
 *        data-controller="gathering-location-autocomplete"
 *        data-gathering-location-autocomplete-api-key-value="YOUR-KEY">
 */
class GatheringLocationAutocompleteController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static values = {
    apiKey: String // Google Maps API key
  };
  static targets = ["input", "latitude", "longitude"]; // Input field and hidden form fields for lat/lng

  /**
   * Initialize the controller
   */
  initialize() {
    this.autocompleteElement = null;
    this.isGoogleMapsLoaded = false;
    this.isInitialized = false; // Prevent re-initialization loop
    this.lastSelectedAddress = null; // Store the selected address
    this.lastSelectedPlace = null; // Store the full place object with geometry
  }

  /**
   * Connect function - runs when controller connects to DOM
   */
  async connect() {
    console.log("GatheringLocationAutocompleteController connected");

    // Prevent re-initialization if already set up
    if (this.isInitialized) {
      console.log("Autocomplete already initialized, skipping");
      return;
    }
    try {
      // Load Google Maps Places library if not already loaded
      await this.loadGoogleMapsPlaces();

      // Initialize autocomplete on the input field
      this.initAutocomplete();

      // Only mark as initialized after both succeed
      this.isInitialized = true;
      console.log("Autocomplete initialization complete");
    } catch (error) {
      // Reset flag on failure to allow future reconnects to retry
      this.isInitialized = false;
      console.error("Failed to initialize autocomplete:", error);
      // Optionally rethrow or handle gracefully
      // throw error;
    }
  }

  /**
   * Load Google Maps Places library
   */
  async loadGoogleMapsPlaces() {
    // Check if already loaded
    if (typeof google !== 'undefined' && google.maps && google.maps.places) {
      this.isGoogleMapsLoaded = true;
      return Promise.resolve();
    }
    return new Promise((resolve, reject) => {
      // Create script tag to load Google Maps with Places library
      const script = document.createElement('script');
      const apiKey = this.apiKeyValue || '';
      const keyParam = apiKey ? `key=${apiKey}&` : '';
      script.src = `https://maps.googleapis.com/maps/api/js?${keyParam}libraries=places&loading=async&callback=initGatheringLocationAutocomplete`;
      script.async = true;
      script.defer = true;

      // Set up callback
      window.initGatheringLocationAutocomplete = () => {
        this.isGoogleMapsLoaded = true;
        delete window.initGatheringLocationAutocomplete;
        resolve();
      };
      script.onerror = () => {
        console.error('Failed to load Google Maps Places library');
        reject(new Error('Failed to load Google Maps Places library'));
      };
      document.head.appendChild(script);
    });
  }

  /**
   * Initialize Google Places Autocomplete using the classic Autocomplete class
   * (PlaceAutocompleteElement doesn't expose data programmatically, so we use the old API)
   */
  initAutocomplete() {
    if (!this.isGoogleMapsLoaded) {
      console.error('Google Maps not loaded');
      return;
    }

    // Use the old Autocomplete API which actually works
    // Use 'geocode' type for addresses, or omit types to get all place types
    this.autocomplete = new google.maps.places.Autocomplete(this.inputTarget, {
      types: ['geocode']
    });

    // Listen for place selection
    this.autocomplete.addListener('place_changed', () => {
      const place = this.autocomplete.getPlace();
      if (place && place.formatted_address) {
        console.log(' Place selected:', place.formatted_address);
        this.lastSelectedAddress = place.formatted_address;
        this.lastSelectedPlace = place;
        this.inputTarget.value = place.formatted_address;

        // Extract and store latitude/longitude if available
        if (place.geometry && place.geometry.location) {
          const lat = place.geometry.location.lat();
          const lng = place.geometry.location.lng();
          console.log(' Coordinates:', lat, lng);

          // Update hidden form fields if they exist
          if (this.hasLatitudeTarget) {
            this.latitudeTarget.value = lat;
            console.log(' Set latitude field:', lat);
          }
          if (this.hasLongitudeTarget) {
            this.longitudeTarget.value = lng;
            console.log(' Set longitude field:', lng);
          }
        } else {
          console.log(' No geometry data available for selected place');
        }
      }
    });
    console.log('Google Places Autocomplete initialized (classic API)');
  }

  /**
   * Cleanup when controller disconnects
   */
  disconnect() {
    // Clean up the autocomplete
    if (this.autocomplete) {
      google.maps.event.clearInstanceListeners(this.autocomplete);
    }
    this.autocomplete = null;
    this.isInitialized = false;
  }
}

// Add to global controllers registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["gathering-location-autocomplete"] = GatheringLocationAutocompleteController;
console.log("GatheringLocationAutocompleteController registered in window.Controllers");

/***/ }),

/***/ "./assets/js/controllers/gathering-map-controller.js":
/*!***********************************************************!*\
  !*** ./assets/js/controllers/gathering-map-controller.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


// Module-scoped promise to memoize Google Maps loading and prevent concurrent script injections
let googleMapsLoaderPromise = null;

/**
 * GatheringMapController
 * 
 * Handles interactive map display for gathering locations using Google Maps.
 * Displays the location on a map and provides options to open in external mapping services
 * for directions and navigation.
 * 
 * @example
 * <div data-controller="gathering-map" 
 *      data-gathering-map-location-value="123 Main St, City, State"
 *      data-gathering-map-gathering-name-value="Great Western War">
 *   <div data-gathering-map-target="map"></div>
 * </div>
 */
class GatheringMapController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  // Define targets - elements this controller interacts with
  static targets = ["map", "error"];

  // Define values - properties that can be set from HTML
  static values = {
    location: String,
    // The address/location string
    gatheringName: String,
    // Name of the gathering
    apiKey: String,
    // Google Maps API key (optional)
    latitude: Number,
    // Stored latitude (optional, saves API call)
    longitude: Number,
    // Stored longitude (optional, saves API call)
    zoom: {
      // Default zoom level
      type: Number,
      default: 15
    }
  };

  /**
   * Initialize the controller
   */
  initialize() {
    this.map = null;
    this.marker = null;
    this.geocoded = false;
  }

  /**
   * Connect function - runs when controller connects to DOM
   */
  connect() {
    console.log("GatheringMapController connected");
    if (!this.locationValue) {
      this.showError("No location provided");
      return;
    }

    // Initialize Google Maps
    this.initGoogleMap();
  }

  /**
   * Initialize Google Maps
   */
  async initGoogleMap() {
    try {
      // Check if Google Maps API is loaded
      if (typeof google === 'undefined' || !google.maps) {
        // Load Google Maps API dynamically if not present
        await this.loadGoogleMapsScript();
      }

      // Initialize the map with required configuration for AdvancedMarkerElement
      const mapOptions = {
        zoom: this.zoomValue,
        center: {
          lat: 0,
          lng: 0
        },
        // Will be updated after geocoding
        mapId: 'GATHERING_MAP',
        // Required for AdvancedMarkerElement
        mapTypeId: 'roadmap'
      };
      this.map = new google.maps.Map(this.mapTarget, mapOptions);

      // Geocode the location and add marker
      await this.geocodeAndDisplayGoogle();
    } catch (error) {
      console.error("Error initializing Google Maps:", error);
      this.showError("Failed to load map. Please try again later.");
    }
  }

  /**
   * Load Google Maps Script dynamically with marker library
   * Memoized to prevent concurrent script injections and share a single Promise
   */
  loadGoogleMapsScript() {
    // Return existing promise if already loading
    if (googleMapsLoaderPromise) {
      console.log("Google Maps already loading, returning existing promise");
      return googleMapsLoaderPromise;
    }

    // Check if already loaded
    if (typeof google !== 'undefined' && google.maps) {
      console.log("Google Maps already loaded");
      return Promise.resolve();
    }

    // Check if script tag already exists to prevent duplicates
    const existingScript = document.querySelector('script[src*="maps.googleapis.com/maps/api/js"]');
    if (existingScript) {
      console.log("Google Maps script already in DOM, waiting for load");
      // Script exists but may not be loaded yet, create a promise to wait for it
      googleMapsLoaderPromise = new Promise((resolve, reject) => {
        // Check if it's already loaded
        if (typeof google !== 'undefined' && google.maps) {
          resolve();
          googleMapsLoaderPromise = null;
          return;
        }

        // Wait for the existing script to load
        const checkInterval = setInterval(() => {
          if (typeof google !== 'undefined' && google.maps) {
            clearInterval(checkInterval);
            resolve();
            googleMapsLoaderPromise = null;
          }
        }, 100);

        // Timeout after 10 seconds
        setTimeout(() => {
          clearInterval(checkInterval);
          googleMapsLoaderPromise = null;
          reject(new Error('Timeout waiting for Google Maps to load'));
        }, 10000);
      });
      return googleMapsLoaderPromise;
    }

    // Create and assign the promise once
    googleMapsLoaderPromise = new Promise((resolve, reject) => {
      const script = document.createElement('script');
      const apiKey = this.apiKeyValue || '';
      const keyParam = apiKey ? `key=${apiKey}&` : '';
      // Load with marker library for AdvancedMarkerElement and loading=async for performance
      script.src = `https://maps.googleapis.com/maps/api/js?${keyParam}libraries=marker&loading=async&callback=initGoogleMapsCallback`;
      script.async = true;
      script.defer = true;
      window.initGoogleMapsCallback = () => {
        console.log("Google Maps loaded successfully");
        // Cleanup global callback
        delete window.initGoogleMapsCallback;
        // Reset module-scoped promise on success
        googleMapsLoaderPromise = null;
        resolve();
      };
      script.onerror = error => {
        console.error("Failed to load Google Maps script");
        // Cleanup global callback
        delete window.initGoogleMapsCallback;
        // Reset module-scoped promise on failure to allow retries
        googleMapsLoaderPromise = null;
        reject(new Error('Failed to load Google Maps script'));
      };
      document.head.appendChild(script);
      console.log("Google Maps script appended to DOM");
    });
    return googleMapsLoaderPromise;
  }

  /**
   * Geocode location and display on Google Maps with AdvancedMarkerElement
   * Uses stored lat/lng if available to avoid geocoding API call
   */
  async geocodeAndDisplayGoogle() {
    // Check if we have stored coordinates to avoid API call
    if (this.hasLatitudeValue && this.hasLongitudeValue) {
      console.log('Using stored coordinates:', this.latitudeValue, this.longitudeValue);
      const location = {
        lat: this.latitudeValue,
        lng: this.longitudeValue
      };

      // Center map on stored location
      this.map.setCenter(location);

      // Create marker at stored location
      await this.createMarker(location);
      return;
    }

    // No stored coordinates, use geocoding API
    console.log('No stored coordinates, geocoding address:', this.locationValue);
    const geocoder = new google.maps.Geocoder();
    geocoder.geocode({
      address: this.locationValue
    }, async (results, status) => {
      if (status === 'OK' && results[0]) {
        const location = results[0].geometry.location;

        // Center map on location
        this.map.setCenter(location);

        // Create marker
        await this.createMarker(location);
        this.geocoded = true;
      } else {
        console.error('Geocode was not successful:', status);
        this.showError(`Unable to find location: ${this.locationValue}`);
      }
    });
  }

  /**
   * Create marker on the map
   * @param {Object} location - Google Maps LatLng or {lat, lng} object
   */
  async createMarker(location) {
    try {
      // Import the AdvancedMarkerElement library
      const {
        AdvancedMarkerElement
      } = await google.maps.importLibrary("marker");

      // Create marker using AdvancedMarkerElement
      this.marker = new AdvancedMarkerElement({
        map: this.map,
        position: location,
        title: this.gatheringNameValue || 'Gathering Location'
      });

      // Add info window
      const infoWindow = new google.maps.InfoWindow({
        content: `
                    <div style="padding: 8px;">
                        <strong>${this.gatheringNameValue || 'Gathering Location'}</strong><br>
                        <span style="color: #666;">${this.locationValue}</span>
                    </div>
                `
      });

      // Add click listener to marker
      this.marker.addListener('click', () => {
        infoWindow.open({
          anchor: this.marker,
          map: this.map
        });
      });

      // Open info window by default
      infoWindow.open({
        anchor: this.marker,
        map: this.map
      });
      this.geocoded = true;
    } catch (error) {
      console.error('Error creating marker:', error);
      this.showError('Failed to display marker on map');
    }
  }

  /**
   * Open location in Google Maps (new window/tab)
   * Uses stored lat/lng if available for precise location, otherwise uses address string
   */
  openInGoogleMaps(event) {
    event.preventDefault();
    let url;
    if (this.hasLatitudeValue && this.hasLongitudeValue) {
      // Use precise coordinates
      url = `https://www.google.com/maps/search/?api=1&query=${this.latitudeValue},${this.longitudeValue}`;
    } else {
      // Fall back to address string
      url = `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(this.locationValue)}`;
    }
    window.open(url, '_blank');
  }

  /**
   * Open location in Apple Maps (works on supported devices)
   * Uses stored lat/lng if available for precise location, otherwise uses address string
   */
  openInAppleMaps(event) {
    event.preventDefault();
    let url;
    if (this.hasLatitudeValue && this.hasLongitudeValue) {
      // Use precise coordinates - Apple Maps uses ll parameter
      url = `https://maps.apple.com/?ll=${this.latitudeValue},${this.longitudeValue}&q=${encodeURIComponent(this.locationValue)}`;
    } else {
      // Fall back to address string
      url = `https://maps.apple.com/?q=${encodeURIComponent(this.locationValue)}`;
    }
    window.open(url, '_blank');
  }

  /**
   * Get directions to location in Google Maps
   * Uses stored lat/lng if available for precise destination, otherwise uses address string
   */
  getDirections(event) {
    event.preventDefault();
    let url;
    if (this.hasLatitudeValue && this.hasLongitudeValue) {
      // Use precise coordinates
      url = `https://www.google.com/maps/dir/?api=1&destination=${this.latitudeValue},${this.longitudeValue}`;
    } else {
      // Fall back to address string
      url = `https://www.google.com/maps/dir/?api=1&destination=${encodeURIComponent(this.locationValue)}`;
    }
    window.open(url, '_blank');
  }

  /**
   * Show error message
   */
  showError(message) {
    if (this.hasErrorTarget) {
      this.errorTarget.textContent = message;
      this.errorTarget.style.display = 'block';
    } else {
      console.error(message);
      // Create error display if target doesn't exist
      const errorDiv = document.createElement('div');
      errorDiv.className = 'alert alert-warning';
      errorDiv.innerHTML = `<i class="bi bi-exclamation-triangle"></i> ${message}`;
      this.mapTarget.parentNode.insertBefore(errorDiv, this.mapTarget);
    }

    // Hide map container if there's an error
    if (this.hasMapTarget) {
      this.mapTarget.style.display = 'none';
    }
  }

  /**
   * Cleanup when controller disconnects
   */
  disconnect() {
    if (this.map) {
      // Clean up map resources
      this.map = null;
      this.marker = null;
    }
  }
}

// Add to global controllers registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["gathering-map"] = GatheringMapController;

/***/ }),

/***/ "./assets/js/controllers/gathering-public-controller.js":
/*!**************************************************************!*\
  !*** ./assets/js/controllers/gathering-public-controller.js ***!
  \**************************************************************/
/***/ (function() {



/***/ }),

/***/ "./assets/js/controllers/gathering-schedule-controller.js":
/*!****************************************************************!*\
  !*** ./assets/js/controllers/gathering-schedule-controller.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/* provided dependency */ var bootstrap = __webpack_require__(/*! bootstrap */ "./node_modules/bootstrap/dist/js/bootstrap.esm.js");


/**
 * Gathering Schedule Controller
 * 
 * Manages the gathering schedule interface including:
 * - Adding new scheduled activities via modal
 * - Editing existing scheduled activities via modal
 * - Deleting scheduled activities
 * - Dynamic form field updates based on activity selection
 */
class GatheringScheduleController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["scheduleList", "addModal", "editModal", "activitySelect", "isOtherCheckbox", "addForm", "editForm", "editActivitySelect", "editIsOtherCheckbox", "startDatetime", "endDatetime", "editStartDatetime", "editEndDatetime", "hasEndTimeCheckbox", "editHasEndTimeCheckbox", "endTimeContainer", "editEndTimeContainer"];
  static values = {
    gatheringId: Number,
    gatheringStart: String,
    // YYYY-MM-DD format
    gatheringEnd: String,
    // YYYY-MM-DD format
    addUrl: String,
    editUrl: String,
    deleteUrl: String
  };

  /**
   * Initialize controller
   */
  connect() {
    console.log('Gathering schedule controller connected');
    // Note: setupDateTimeLimits() is called when the modal opens (resetAddForm)
    // because Stimulus values may not be initialized yet during connect()
  }

  /**
   * Setup min/max limits on datetime inputs based on gathering dates
   * This is called when modals open to ensure values are set
   */
  setupDateTimeLimits() {
    // Validate that gathering dates are present and in correct format (YYYY-MM-DDTHH:MM)
    const datetimePattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/;
    if (!this.gatheringStartValue || !this.gatheringEndValue || !datetimePattern.test(this.gatheringStartValue) || !datetimePattern.test(this.gatheringEndValue)) {
      console.warn('Invalid gathering dates - skipping datetime limits setup');
      console.log('Start:', this.gatheringStartValue, 'End:', this.gatheringEndValue);
      return;
    }

    // Use the gathering start/end times directly (already in gathering timezone)
    const minDatetime = this.gatheringStartValue;
    const maxDatetime = this.gatheringEndValue;

    // Set limits on add form inputs
    if (this.hasStartDatetimeTarget) {
      this.startDatetimeTarget.min = minDatetime;
      this.startDatetimeTarget.max = maxDatetime;

      // Set default to start of gathering if empty
      if (!this.startDatetimeTarget.value) {
        this.startDatetimeTarget.value = this.gatheringStartValue;
      }
    }
    if (this.hasEndDatetimeTarget) {
      this.endDatetimeTarget.min = minDatetime;
      this.endDatetimeTarget.max = maxDatetime;

      // Don't set a default value - end time is optional
    }

    // Set limits on edit form inputs
    if (this.hasEditStartDatetimeTarget) {
      this.editStartDatetimeTarget.min = minDatetime;
      this.editStartDatetimeTarget.max = maxDatetime;
    }
    if (this.hasEditEndDatetimeTarget) {
      this.editEndDatetimeTarget.min = minDatetime;
      this.editEndDatetimeTarget.max = maxDatetime;
    }
  }

  /**
   * Reset add form when modal is opened
   */
  resetAddForm(event) {
    // Setup datetime limits when modal opens (values are guaranteed to be available now)
    this.setupDateTimeLimits();

    // Validate that gathering dates are present and in correct format (YYYY-MM-DDTHH:MM)
    const datetimePattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/;
    if (!this.gatheringStartValue || !this.gatheringEndValue || !datetimePattern.test(this.gatheringStartValue) || !datetimePattern.test(this.gatheringEndValue)) {
      console.warn('Invalid gathering dates - skipping form reset defaults');
      return;
    }

    // Reset to defaults - use gathering start time
    if (this.hasStartDatetimeTarget) {
      this.startDatetimeTarget.value = this.gatheringStartValue;
    }
    if (this.hasEndDatetimeTarget) {
      // Don't set a default value - end time is optional
      this.endDatetimeTarget.value = '';
    }
  }

  /**
   * Handle activity select change - disable/enable based on "other" checkbox
   */
  handleActivityChange(event) {
    const isOther = this.isOtherCheckboxTarget.checked;
    this.activitySelectTarget.disabled = isOther;
    if (isOther) {
      this.activitySelectTarget.value = '';
    }
  }

  /**
   * Handle "other" checkbox change for add form
   */
  handleOtherChange(event) {
    const isOther = event.target.checked;
    this.activitySelectTarget.disabled = isOther;
    this.activitySelectTarget.required = !isOther;
    if (isOther) {
      this.activitySelectTarget.value = '';
    }
  }

  /**
   * Handle "other" checkbox change for edit form
   */
  handleEditOtherChange(event) {
    const isOther = event.target.checked;
    this.editActivitySelectTarget.disabled = isOther;
    this.editActivitySelectTarget.required = !isOther;
    if (isOther) {
      this.editActivitySelectTarget.value = '';
    }
  }

  /**
   * Toggle end time field visibility for add form
   */
  toggleEndTime(event) {
    const hasEndTime = event.target.checked;
    if (this.hasEndTimeContainerTarget) {
      this.endTimeContainerTarget.style.display = hasEndTime ? 'block' : 'none';
    }

    // Clear end time if unchecking
    if (!hasEndTime && this.hasEndDatetimeTarget) {
      this.endDatetimeTarget.value = '';
    } else {
      // If checking, set default end time to one hour after start time
      if (this.hasStartDatetimeTarget && this.startDatetimeTarget.value) {
        const startDate = new Date(this.startDatetimeTarget.value);
        startDate.setHours(startDate.getHours() + 1);
        const year = startDate.getFullYear();
        const month = String(startDate.getMonth() + 1).padStart(2, '0');
        const day = String(startDate.getDate()).padStart(2, '0');
        const hours = String(startDate.getHours()).padStart(2, '0');
        const minutes = String(startDate.getMinutes()).padStart(2, '0');
        this.endDatetimeTarget.value = `${year}-${month}-${day}T${hours}:${minutes}`;
      }
    }
  }

  /**
   * Toggle end time field visibility for edit form
   */
  toggleEditEndTime(event) {
    const hasEndTime = event.target.checked;
    if (this.hasEditEndTimeContainerTarget) {
      this.editEndTimeContainerTarget.style.display = hasEndTime ? 'block' : 'none';
    }

    // Clear end time if unchecking
    if (!hasEndTime && this.hasEditEndDatetimeTarget) {
      this.editEndDatetimeTarget.value = '';
    } else {
      // If checking, set default end time to one hour after start time
      if (this.hasEditStartDatetimeTarget && this.editStartDatetimeTarget.value) {
        const startDate = new Date(this.editStartDatetimeTarget.value);
        startDate.setHours(startDate.getHours() + 1);
        const year = startDate.getFullYear();
        const month = String(startDate.getMonth() + 1).padStart(2, '0');
        const day = String(startDate.getDate()).padStart(2, '0');
        const hours = String(startDate.getHours()).padStart(2, '0');
        const minutes = String(startDate.getMinutes()).padStart(2, '0');
        this.editEndDatetimeTarget.value = `${year}-${month}-${day}T${hours}:${minutes}`;
      }
    }
  }

  /**
   * Open edit modal and populate with activity data
   */
  openEditModal(event) {
    event.preventDefault();

    // Setup datetime limits when modal opens (values are guaranteed to be available now)
    this.setupDateTimeLimits();
    const button = event.currentTarget;

    // Get data attributes from the button
    const activityId = button.dataset.activityId;
    const activityName = button.dataset.activityName;
    const gatheringActivityId = button.dataset.gatheringActivityId;
    const startDatetime = button.dataset.startDatetime;
    const endDatetime = button.dataset.endDatetime;
    const displayTitle = button.dataset.displayTitle;
    const description = button.dataset.description;
    const preRegister = button.dataset.preRegister === 'true';
    const isOther = button.dataset.isOther === 'true';
    const hasEndTime = button.dataset.hasEndTime === 'true';

    // Populate form fields
    const form = this.editFormTarget;
    form.action = this.editUrlValue.replace('__ID__', activityId);
    form.querySelector('[name="gathering_activity_id"]').value = gatheringActivityId || '';
    form.querySelector('[name="start_datetime"]').value = startDatetime;
    form.querySelector('[name="end_datetime"]').value = endDatetime || '';
    form.querySelector('[name="display_title"]').value = displayTitle;
    form.querySelector('[name="description"]').value = description || '';

    // Use getElementById for checkboxes to avoid hidden input conflicts
    document.getElementById('edit-pre-register').checked = preRegister;
    document.getElementById('edit-is-other').checked = isOther;
    document.getElementById('edit-has-end-time').checked = hasEndTime;

    // Handle activity select state based on is_other
    const activitySelect = this.editActivitySelectTarget;
    activitySelect.disabled = isOther;
    activitySelect.required = !isOther;

    // Handle end time container visibility
    if (this.hasEditEndTimeContainerTarget) {
      this.editEndTimeContainerTarget.style.display = hasEndTime ? 'block' : 'none';
    }

    // Show the modal
    const modal = new bootstrap.Modal(this.editModalTarget);
    modal.show();
  }

  /**
   * Validate datetime is within gathering range
   */
  validateDatetimeRange(event) {
    const input = event.target;
    const value = input.value;
    if (!value) return;
    const minDatetime = `${this.gatheringStartValue}T00:00`;
    const maxDatetime = `${this.gatheringEndValue}T23:59`;
    const selectedDate = new Date(value);
    const minDate = new Date(minDatetime);
    const maxDate = new Date(maxDatetime);
    if (selectedDate < minDate || selectedDate > maxDate) {
      input.setCustomValidity(`Date must be between ${this.formatDate(minDate)} and ${this.formatDate(maxDate)}`);
      input.reportValidity();
    } else {
      input.setCustomValidity('');
    }
  }

  /**
   * Format date for display
   */
  formatDate(date) {
    return date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric',
      hour: 'numeric',
      minute: '2-digit'
    });
  }

  /**
   * Normalize error response into a readable string
   * Handles errors that may be an array, object, string, or missing
   */
  normalizeErrors(result) {
    if (!result.errors) {
      return result.message || 'An error occurred';
    }

    // If errors is already an array, join it
    if (Array.isArray(result.errors)) {
      return result.errors.join(', ');
    }

    // If errors is a string, use it directly
    if (typeof result.errors === 'string') {
      return result.errors;
    }

    // If errors is an object, try to extract values
    if (typeof result.errors === 'object') {
      try {
        // Try to flatten nested arrays and join
        const errorValues = Object.values(result.errors).flat();
        if (errorValues.length > 0) {
          return errorValues.join(', ');
        }
        // Fall back to JSON stringify for complex objects
        return JSON.stringify(result.errors);
      } catch (e) {
        console.error('Error parsing errors object:', e);
        return result.message || 'An error occurred';
      }
    }

    // Final fallback
    return result.message || 'An error occurred';
  }

  /**
   * Submit add form via AJAX
   */
  async submitAddForm(event) {
    event.preventDefault();
    const form = event.target;
    const formData = new FormData(form);
    try {
      const response = await fetch(this.addUrlValue, {
        method: 'POST',
        body: formData,
        headers: {
          'X-Requested-With': 'XMLHttpRequest'
        }
      });
      const result = await response.json();
      if (result.success) {
        // Close modal
        const modal = bootstrap.Modal.getInstance(this.addModalTarget);
        modal.hide();

        // Reset form
        form.reset();

        // Show success message and reload page
        this.showFlashMessage('success', result.message);
        window.location.reload();
      } else {
        // Show error message
        const errorMsg = this.normalizeErrors(result);
        this.showFlashMessage('error', errorMsg);
      }
    } catch (error) {
      console.error('Error submitting form:', error);
      this.showFlashMessage('error', 'An error occurred while adding the scheduled activity.');
    }
  }

  /**
   * Submit edit form via AJAX
   */
  async submitEditForm(event) {
    event.preventDefault();
    const form = event.target;
    const formData = new FormData(form);
    try {
      const response = await fetch(form.action, {
        method: 'POST',
        body: formData,
        headers: {
          'X-Requested-With': 'XMLHttpRequest'
        }
      });
      const result = await response.json();
      if (result.success) {
        // Close modal
        const modal = bootstrap.Modal.getInstance(this.editModalTarget);
        modal.hide();

        // Show success message and reload page
        this.showFlashMessage('success', result.message);
        window.location.reload();
      } else {
        // Show error message
        const errorMsg = this.normalizeErrors(result);
        this.showFlashMessage('error', errorMsg);
      }
    } catch (error) {
      console.error('Error submitting form:', error);
      this.showFlashMessage('error', 'An error occurred while updating the scheduled activity.');
    }
  }

  /**
   * Show flash message
   */
  showFlashMessage(type, message) {
    // Create flash message element
    const flashContainer = document.querySelector('.flash-messages') || this.createFlashContainer();
    const alertClass = type === 'success' ? 'alert-success' : 'alert-danger';
    const flashDiv = document.createElement('div');
    flashDiv.className = `alert ${alertClass} alert-dismissible fade show`;
    flashDiv.role = 'alert';

    // Safely add message text using textContent (prevents XSS)
    const messageText = document.createTextNode(message);
    flashDiv.appendChild(messageText);

    // Create close button separately with proper attributes
    const closeButton = document.createElement('button');
    closeButton.type = 'button';
    closeButton.className = 'btn-close';
    closeButton.setAttribute('data-bs-dismiss', 'alert');
    closeButton.setAttribute('aria-label', 'Close');
    flashDiv.appendChild(closeButton);
    flashContainer.appendChild(flashDiv);

    // Auto-dismiss after 5 seconds
    setTimeout(() => {
      flashDiv.remove();
    }, 5000);
  }

  /**
   * Create flash message container if it doesn't exist
   */
  createFlashContainer() {
    const container = document.createElement('div');
    container.className = 'flash-messages container mt-3';
    const main = document.querySelector('main') || document.body;
    main.prepend(container);
    return container;
  }
}

// Add to global controllers registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["gathering-schedule"] = GatheringScheduleController;

/***/ }),

/***/ "./assets/js/controllers/gathering-type-form-controller.js":
/*!*****************************************************************!*\
  !*** ./assets/js/controllers/gathering-type-form-controller.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * Gathering Type Form Controller
 * 
 * Handles real-time validation and user feedback for gathering type forms.
 * Provides immediate feedback on name availability and description length.
 */
class GatheringTypeFormController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["name", "description", "nameError", "descriptionCount", "descriptionError", "submitButton"];
  static values = {
    maxDescriptionLength: {
      type: Number,
      default: 500
    },
    checkNameUrl: String
  };

  /**
   * Initialize the controller
   */
  connect() {
    if (this.hasDescriptionTarget) {
      this.updateDescriptionCount();
      // Set maxLength attribute to prevent typing beyond limit
      this.descriptionTarget.setAttribute('maxlength', this.maxDescriptionLengthValue);
    }
  }

  /**
   * Validate name field on blur
   */
  validateName() {
    if (!this.hasNameTarget) return;
    const name = this.nameTarget.value.trim();
    if (name.length === 0) {
      this.showNameError("Name is required");
      return false;
    }
    if (name.length < 3) {
      this.showNameError("Name must be at least 3 characters");
      return false;
    }
    if (name.length > 128) {
      this.showNameError("Name must be less than 128 characters");
      return false;
    }
    this.clearNameError();
    return true;
  }

  /**
   * Update description character count
   */
  updateDescriptionCount() {
    if (!this.hasDescriptionTarget || !this.hasDescriptionCountTarget) return true;
    let length = this.descriptionTarget.value.length;

    // Prevent typing beyond max length
    if (length > this.maxDescriptionLengthValue) {
      this.descriptionTarget.value = this.descriptionTarget.value.substring(0, this.maxDescriptionLengthValue);
      length = this.maxDescriptionLengthValue;
    }
    const remaining = this.maxDescriptionLengthValue - length;
    this.descriptionCountTarget.textContent = `${length} / ${this.maxDescriptionLengthValue} characters`;
    if (remaining < 50) {
      this.descriptionCountTarget.classList.add('text-warning');
      this.descriptionCountTarget.classList.remove('text-muted');
    } else {
      this.descriptionCountTarget.classList.remove('text-warning');
      this.descriptionCountTarget.classList.add('text-muted');
    }
    if (length > this.maxDescriptionLengthValue) {
      this.descriptionCountTarget.classList.add('text-danger');
      this.descriptionCountTarget.classList.remove('text-warning');
      this.showDescriptionError(`Description cannot exceed ${this.maxDescriptionLengthValue} characters`);
      this.disableSubmit();
      return false;
    } else {
      this.descriptionCountTarget.classList.remove('text-danger');
      this.clearDescriptionError();
      this.enableSubmit();
      return true;
    }
  }

  /**
   * Show description error message
   */
  showDescriptionError(message) {
    if (this.hasDescriptionTarget) {
      this.descriptionTarget.classList.add('is-invalid');
      this.descriptionTarget.setAttribute('aria-invalid', 'true');
    }

    // Create or update error element if it doesn't exist
    let errorElement;
    if (this.hasDescriptionErrorTarget) {
      errorElement = this.descriptionErrorTarget;
    } else {
      // Create error element dynamically
      errorElement = document.createElement('div');
      errorElement.className = 'invalid-feedback';
      errorElement.id = 'description-error';
      errorElement.setAttribute('data-gathering-type-form-target', 'descriptionError');
      this.descriptionTarget.parentElement.appendChild(errorElement);
    }
    errorElement.textContent = message;
    errorElement.classList.remove('d-none');
    errorElement.style.display = 'block';
    if (this.hasDescriptionTarget) {
      this.descriptionTarget.setAttribute('aria-describedby', 'description-error');
    }
  }

  /**
   * Clear description error message
   */
  clearDescriptionError() {
    if (this.hasDescriptionTarget) {
      this.descriptionTarget.classList.remove('is-invalid');
      this.descriptionTarget.removeAttribute('aria-invalid');
      this.descriptionTarget.removeAttribute('aria-describedby');
    }
    if (this.hasDescriptionErrorTarget) {
      this.descriptionErrorTarget.classList.add('d-none');
      this.descriptionErrorTarget.style.display = 'none';
    }
  }

  /**
   * Disable submit button
   */
  disableSubmit() {
    if (this.hasSubmitButtonTarget) {
      this.submitButtonTarget.disabled = true;
    }
  }

  /**
   * Enable submit button
   */
  enableSubmit() {
    if (this.hasSubmitButtonTarget) {
      this.submitButtonTarget.disabled = false;
    }
  }

  /**
   * Show name error message
   */
  showNameError(message) {
    if (this.hasNameErrorTarget) {
      this.nameErrorTarget.textContent = message;
      this.nameErrorTarget.classList.remove('d-none');
    }
    if (this.hasNameTarget) {
      this.nameTarget.classList.add('is-invalid');
    }
  }

  /**
   * Clear name error message
   */
  clearNameError() {
    if (this.hasNameErrorTarget) {
      this.nameErrorTarget.classList.add('d-none');
    }
    if (this.hasNameTarget) {
      this.nameTarget.classList.remove('is-invalid');
      this.nameTarget.classList.add('is-valid');
    }
  }

  /**
   * Validate entire form before submission
   */
  validateForm(event) {
    let isValid = true;
    if (this.hasNameTarget) {
      isValid = this.validateName() && isValid;
    }
    if (this.hasDescriptionTarget) {
      isValid = this.updateDescriptionCount() && isValid;
    }
    if (!isValid) {
      event.preventDefault();
      this.showValidationSummary();
    }
    return isValid;
  }

  /**
   * Show validation summary
   */
  showValidationSummary() {
    // Check for existing alert and clean it up
    const existingAlert = this.element.querySelector('.alert.alert-danger.validation-summary');
    if (existingAlert) {
      // Clear any pending timeout
      if (existingAlert.dataset.timeoutId) {
        clearTimeout(parseInt(existingAlert.dataset.timeoutId));
      }
      existingAlert.remove();
    }

    // Flash a message at the top of the form
    const alert = document.createElement('div');
    alert.className = 'alert alert-danger alert-dismissible fade show validation-summary';
    alert.role = 'alert';
    alert.innerHTML = `
            <strong>Validation Error:</strong> Please correct the errors below.
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        `;
    this.element.prepend(alert);

    // Store timeout ID for cleanup
    const timeoutId = setTimeout(() => {
      alert.remove();
    }, 5000);
    alert.dataset.timeoutId = timeoutId.toString();

    // Handle manual close button click
    const closeButton = alert.querySelector('.btn-close');
    if (closeButton) {
      closeButton.addEventListener('click', () => {
        if (alert.dataset.timeoutId) {
          clearTimeout(parseInt(alert.dataset.timeoutId));
        }
      });
    }

    // Handle Bootstrap dismissal event
    alert.addEventListener('closed.bs.alert', () => {
      if (alert.dataset.timeoutId) {
        clearTimeout(parseInt(alert.dataset.timeoutId));
      }
    });
  }
}

// Add to global controllers registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["gathering-type-form"] = GatheringTypeFormController;

// Export as default for ES6 import
/* harmony default export */ __webpack_exports__["default"] = (GatheringTypeFormController);

/***/ }),

/***/ "./assets/js/controllers/gatherings-calendar-controller.js":
/*!*****************************************************************!*\
  !*** ./assets/js/controllers/gatherings-calendar-controller.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/* provided dependency */ var bootstrap = __webpack_require__(/*! bootstrap */ "./node_modules/bootstrap/dist/js/bootstrap.esm.js");


/**
 * Gatherings Calendar Controller
 *
 * Manages the interactive calendar view for gatherings across the kingdom.
 * 
 * Features:
 * - Quick view modal for gathering details
 * - Toggle attendance for gatherings
 * - Location map integration
 * - Real-time UI updates
 * - Responsive calendar navigation
 * 
 * HTML Structure:
 * ```html
 * <div data-controller="gatherings-calendar"
 *      data-gatherings-calendar-year-value="2025"
 *      data-gatherings-calendar-month-value="10"
 *      data-gatherings-calendar-view-value="month">
 *   
 *   <!-- Calendar grid -->
 *   <div class="gathering-item"
 *        data-action="click->gatherings-calendar#showQuickView"
 *        data-gathering-id="123">
 *     Gathering Name
 *   </div>
 * </div>
 * ```
 */
class GatheringsCalendarController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static values = {
    year: Number,
    month: Number,
    view: String
  };

  /**
   * Initialize the calendar controller
   */
  initialize() {
    this.modalElement = null;
    this.modalInstance = null;
    this.turboFrame = null;
  }

  /**
   * Connect event - setup Bootstrap modal
   */
  connect() {
    console.log('Gatherings Calendar Controller connected');

    // Find the modal and turbo-frame elements
    this.modalElement = document.getElementById('gatheringQuickViewModal');
    this.turboFrame = document.getElementById('gatheringQuickView');
    console.log('Modal element:', this.modalElement);
    console.log('Turbo frame:', this.turboFrame);
    if (this.modalElement) {
      this.modalInstance = new bootstrap.Modal(this.modalElement);
      console.log('Modal instance created');
    } else {
      console.error('Modal element not found!');
    }
    if (!this.turboFrame) {
      console.error('Turbo frame element not found!');
    }
  }

  /**
   * Show quick view modal for a gathering
   * 
   * @param {Event} event Click event
   */
  async showQuickView(event) {
    event.preventDefault(); // Prevent normal navigation

    console.log('showQuickView called - opening modal');

    // Get the gathering URL from the link
    const url = event.currentTarget.getAttribute('href');
    console.log('Loading gathering from:', url);

    // Show the modal first
    if (this.modalInstance) {
      this.modalInstance.show();
      console.log('Modal shown');
    } else {
      console.error('Modal instance not found');
      return;
    }

    // Fetch and load content into turbo-frame
    if (this.turboFrame) {
      try {
        console.log('Fetching content from:', url);
        const response = await fetch(url, {
          headers: {
            'Accept': 'text/html',
            'Turbo-Frame': 'gatheringQuickView'
          }
        });
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const html = await response.text();
        console.log('Received HTML, length:', html.length);

        // Parse the HTML to extract just the turbo-frame content
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const turboFrameContent = doc.querySelector('turbo-frame#gatheringQuickView');
        if (turboFrameContent) {
          // Clear existing content
          while (this.turboFrame.firstChild) {
            this.turboFrame.removeChild(this.turboFrame.firstChild);
          }

          // Move child nodes from parsed content to our turbo-frame
          // This preserves attributes without HTML encoding
          while (turboFrameContent.firstChild) {
            this.turboFrame.appendChild(turboFrameContent.firstChild);
          }
          console.log('Content loaded into turbo-frame');

          // Fix close button - Bootstrap's event delegation doesn't work on dynamically loaded content
          const closeButton = this.modalElement.querySelector('.btn-close');
          // Remove previous listener if exists to avoid accumulating handlers
          if (this._closeButtonHandler && closeButton) {
            closeButton.removeEventListener('click', this._closeButtonHandler);
          }
          if (closeButton) {
            this._closeButtonHandler = () => {
              if (this.modalInstance) {
                this.modalInstance.hide();
              }
            };
            closeButton.addEventListener('click', this._closeButtonHandler);
          }
        } else {
          console.error('Could not find turbo-frame in response');
          console.log('Response HTML:', html.substring(0, 500));
          this.turboFrame.innerHTML = '<div class="alert alert-danger">Failed to load gathering details</div>';
        }
      } catch (error) {
        console.error('Error loading gathering:', error);
        this.turboFrame.innerHTML = '<div class="alert alert-danger">Error loading gathering details</div>';
      }
    } else {
      console.error('Turbo frame not found');
    }
  }

  /**
   * Show attendance modal with prepopulated data
   * 
   * @param {Event} event Click event
   */
  /**
   * Show attendance modal for marking or editing attendance
   * Loads modal content dynamically from server to get full form UI
   * 
   * @param {Event} event Click event
   */
  async showAttendanceModal(event) {
    const button = event.currentTarget;
    const action = button.dataset.attendanceAction || 'add';
    const gatheringId = button.dataset.gatheringId;
    const attendanceId = button.dataset.attendanceId || '';

    // Get the attendance modal
    const attendanceModal = document.getElementById('attendanceModal');
    if (!attendanceModal) {
      console.error('Attendance modal not found');
      return;
    }
    const modalContent = document.getElementById('attendanceModalContent');
    if (!modalContent) {
      console.error('Attendance modal content container not found');
      return;
    }
    try {
      // Show loading state
      modalContent.innerHTML = `
                <div class="modal-header">
                    <h5 class="modal-title">Loading...</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body text-center py-5">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                </div>
            `;

      // Show modal
      const bsModal = new bootstrap.Modal(attendanceModal);
      bsModal.show();

      // Fetch the modal content from server
      let url;
      if (action === 'edit' && attendanceId) {
        url = `/gatherings/attendance-modal/${gatheringId}?attendance_id=${attendanceId}`;
      } else {
        url = `/gatherings/attendance-modal/${gatheringId}`;
      }
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const html = await response.text();
      modalContent.innerHTML = html;

      // Manually attach click handler to close button since Bootstrap's event delegation
      // doesn't work on dynamically inserted content. Remove previous listener first.
      const closeButton = modalContent.querySelector('.btn-close');
      if (this._attendanceCloseHandler && closeButton) {
        closeButton.removeEventListener('click', this._attendanceCloseHandler);
      }
      if (closeButton) {
        this._attendanceCloseHandler = () => {
          const bsModal = bootstrap.Modal.getInstance(attendanceModal);
          if (bsModal) {
            bsModal.hide();
          }
        };
        closeButton.addEventListener('click', this._attendanceCloseHandler);
      }
    } catch (error) {
      console.error('Error loading attendance modal:', error);
      modalContent.innerHTML = `
                <div class="modal-header">
                    <h5 class="modal-title text-danger">Error</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-danger">
                        Failed to load attendance form. Please try again or refresh the page.
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            `;
    }
  }
  /**
   * Mark attendance for a gathering from quick view
   * 
   * @param {Event} event Click event
   */
  async markAttendance(event) {
    if (event) {
      event.preventDefault();
    }
    const button = event?.currentTarget;
    const gatheringId = button?.dataset.gatheringId;
    if (!gatheringId) {
      console.error('No gathering ID found');
      return;
    }
    if (button && !button.dataset.attendanceAction) {
      button.dataset.attendanceAction = 'add';
    }
    return this.showAttendanceModal(event);
  }

  /**
   * Update attendance for a gathering from quick view
   * 
   * @param {Event} event Click event
   */
  async updateAttendance(event) {
    if (event) {
      event.preventDefault();
    }
    const button = event?.currentTarget;
    if (button && !button.dataset.attendanceAction) {
      button.dataset.attendanceAction = 'edit';
    }
    return this.showAttendanceModal(event);
  }

  /**
   * Toggle attendance for a gathering (legacy method for list view)
   * 
   * @param {Event} event Click event
   */
  async toggleAttendance(event) {
    const button = event.currentTarget;
    const gatheringId = button.dataset.gatheringId;
    const attendanceId = button.dataset.attendanceId;
    const isCurrentlyAttending = button.dataset.attending === 'true';
    if (!gatheringId) {
      console.error('No gathering ID found');
      return;
    }

    // Disable button during request
    const originalContent = button.innerHTML;
    button.disabled = true;
    button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status"></span> Processing...';
    try {
      let url, method, body;
      if (isCurrentlyAttending) {
        // Remove attendance - use DELETE request
        if (!attendanceId) {
          throw new Error('No attendance ID found for removal');
        }
        url = `/gathering-attendances/delete/${attendanceId}`;
        method = 'DELETE';
        // No body needed for DELETE
      } else {
        // Add attendance - use POST request
        url = `/gathering-attendances/add`;
        method = 'POST';
        body = new FormData();
        body.append('gathering_id', gatheringId);
        body.append('status', 'attending');
      }
      const fetchOptions = {
        method: method,
        headers: {
          'X-Requested-With': 'XMLHttpRequest',
          'X-CSRF-Token': this.getCsrfToken()
        }
      };

      // Add body only for POST requests
      if (body) {
        fetchOptions.body = body;
      }
      const response = await fetch(url, fetchOptions);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();

      // Update UI based on action
      if (data.success) {
        if (isCurrentlyAttending) {
          // Removed attendance
          button.dataset.attending = 'false';
          button.removeAttribute('data-attendance-id');
          button.classList.remove('btn-success');
          button.classList.add('btn-outline-success');
          button.innerHTML = '<i class="bi bi-calendar-check"></i> Attend';

          // Show success message
          this.showToast('Success!', 'Your attendance has been removed.', 'success');
        } else {
          // Added attendance
          button.dataset.attending = 'true';
          if (data.attendance_id) {
            button.dataset.attendanceId = data.attendance_id;
          }
          button.classList.remove('btn-outline-success');
          button.classList.add('btn-success');
          button.innerHTML = '<i class="bi bi-check-circle"></i> Attending';

          // Show success message
          this.showToast('Success!', 'Your attendance has been recorded.', 'success');
        }

        // Reload page to update calendar display
        setTimeout(() => {
          window.location.reload();
        }, 1500);
      } else {
        throw new Error(data.message || 'Failed to update attendance');
      }
    } catch (error) {
      console.error('Error toggling attendance:', error);
      this.showToast('Error', 'Failed to update attendance. Please try again.', 'danger');

      // Restore button
      button.disabled = false;
      button.innerHTML = originalContent;
    }
  }

  /**
   * Show location map for a gathering
   * 
   * @param {Event} event Click event
   */
  showLocation(event) {
    const gatheringId = event.currentTarget.dataset.gatheringId;
    if (!gatheringId) {
      console.error('No gathering ID found');
      return;
    }

    // Navigate to gathering view with location tab active
    window.location.href = `/gatherings/view/${gatheringId}#nav-location-tab`;
  }

  /**
   * Get CSRF token from meta tag or form
   * 
   * @returns {string} CSRF token
   */
  getCsrfToken() {
    const meta = document.querySelector('meta[name="csrf-token"]');
    if (meta) {
      return meta.getAttribute('content');
    }
    const input = document.querySelector('input[name="_csrfToken"]');
    if (input) {
      return input.value;
    }
    return '';
  }

  /**
   * Show toast notification
   * 
   * @param {string} title Toast title
   * @param {string} message Toast message
   * @param {string} type Bootstrap color type (success, danger, warning, info)
   */
  showToast(title, message, type = 'info') {
    // Create toast container if it doesn't exist
    let container = document.getElementById('toast-container');
    if (!container) {
      container = document.createElement('div');
      container.id = 'toast-container';
      container.className = 'toast-container position-fixed top-0 end-0 p-3';
      container.style.zIndex = '9999';
      document.body.appendChild(container);
    }

    // Create toast element
    const toastId = `toast-${Date.now()}`;
    const toastHtml = `
            <div id="${toastId}" class="toast align-items-center text-white bg-${type} border-0" role="alert" aria-live="assertive" aria-atomic="true">
                <div class="d-flex">
                    <div class="toast-body">
                        <strong>${title}</strong><br>
                        ${message}
                    </div>
                    <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                </div>
            </div>
        `;
    container.insertAdjacentHTML('beforeend', toastHtml);

    // Show toast
    const toastElement = document.getElementById(toastId);
    const toast = new bootstrap.Toast(toastElement, {
      autohide: true,
      delay: 3000
    });
    toast.show();

    // Remove from DOM after hidden
    toastElement.addEventListener('hidden.bs.toast', () => {
      toastElement.remove();
    });
  }

  /**
   * Disconnect event - cleanup
   */
  disconnect() {
    // Remove event listeners attached to dynamically loaded modal content
    try {
      if (this.modalElement) {
        const closeButton = this.modalElement.querySelector('.btn-close');
        if (closeButton && this._closeButtonHandler) {
          closeButton.removeEventListener('click', this._closeButtonHandler);
          this._closeButtonHandler = null;
        }
      }
      if (this.turboFrame) {
        // If attendance modal content was rendered into a separate container, try to clean it
        const attendanceClose = document.querySelector('#attendanceModalContent .btn-close');
        if (attendanceClose && this._attendanceCloseHandler) {
          attendanceClose.removeEventListener('click', this._attendanceCloseHandler);
          this._attendanceCloseHandler = null;
        }
      }
      if (this.modalInstance) {
        this.modalInstance.dispose();
      }
    } catch (e) {
      console.warn('Error during disconnect cleanup:', e);
    }
  }
}

// Register controller globally
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["gatherings-calendar"] = GatheringsCalendarController;
/* harmony default export */ __webpack_exports__["default"] = (GatheringsCalendarController);

/***/ }),

/***/ "./assets/js/controllers/grid-view-controller.js":
/*!*******************************************************!*\
  !*** ./assets/js/controllers/grid-view-controller.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ "./node_modules/@babel/runtime/helpers/esm/objectSpread2.js");
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");



/**
 * Grid View Controller - Simplified Architecture
 * 
 * This controller follows a clean MVC pattern where:
 * - Server generates complete state
 * - Templates display state
 * - Controller captures user actions and navigates
 * 
 * NO state management in JavaScript - server is source of truth.
 */
class GridViewController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_1__.Controller {
  static targets = ["gridState", "searchInput"];
  static values = {
    stickyQuery: String,
    stickyDefault: Object
  };

  /**
   * Initialize controller
   */
  connect() {
    console.log("GridViewController (simplified) connected");

    // State will be loaded when frame loads
    this.state = null;

    // Track active filter tab (for UX persistence)
    this.activeFilterKey = null;

    // Initialize sticky query parameter support
    this.stickyParams = {};
    if (this.hasStickyDefaultValue && this.stickyDefaultValue) {
      this.stickyParams = (0,_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__["default"])({}, this.stickyDefaultValue);
    }
    this.captureStickyParamsFromUrl(window.location.href);

    // Bind handler once for use in addEventListener/removeEventListener
    this.boundHandleFrameLoad = this.handleFrameLoad.bind(this);

    // Listen for Turbo Frame updates
    document.addEventListener('turbo:frame-load', this.boundHandleFrameLoad);

    // Check if state is already present (inline rendered content)
    this.loadInlineState();
  }

  /**
   * Load state from inline rendered content (when table frame doesn't have src)
   * This handles the case where grid content is pre-rendered on initial page load.
   */
  loadInlineState() {
    // Find the table frame within this controller
    const tableFrame = this.element.querySelector('turbo-frame[id$="-table"]');
    if (!tableFrame) return;

    // If the frame has a src attribute and no content yet, it will load via turbo:frame-load
    // Only load inline state if there's no src (content is pre-rendered)
    if (tableFrame.hasAttribute('src')) return;

    // Look for the state script tag
    const stateScript = tableFrame.querySelector('script[type="application/json"]');
    if (!stateScript) return;
    try {
      const stateJson = stateScript.textContent;
      this.state = JSON.parse(stateJson);
      console.log('Grid state loaded from inline content:', this.state);

      // Update toolbar UI based on state
      this.updateToolbar();

      // Capture sticky parameters for inline-rendered frame content
      this.captureStickyParamsFromFrame(tableFrame);
    } catch (e) {
      console.error('Failed to parse inline grid state:', e);
    }
  }

  /**
   * Cleanup when controller disconnects
   */
  disconnect() {
    document.removeEventListener('turbo:frame-load', this.boundHandleFrameLoad);
  }

  /**
   * Handle Turbo Frame load - update state from table frame
   */
  handleFrameLoad(event) {
    // Only handle frames that belong to THIS grid controller
    // Check if the event target is inside this controller's element
    if (!this.element.contains(event.target)) {
      return;
    }

    // Check if this is a table frame load (ends with -table)
    if (event.target.id && event.target.id.endsWith('-table')) {
      // Direct table frame load - get state from its script tag
      const tableFrame = event.target;
      const stateScript = tableFrame.querySelector('script[type="application/json"]');
      if (!stateScript) {
        console.warn('No state script found in table frame');
        return;
      }
      try {
        const stateJson = stateScript.textContent;
        this.state = JSON.parse(stateJson);
        console.log('Grid state updated from table frame:', this.state);

        // Update toolbar UI based on new state
        this.updateToolbar();

        // Capture sticky parameters based on the loaded frame
        this.captureStickyParamsFromFrame(tableFrame);
      } catch (e) {
        console.error('Failed to parse grid state from table frame:', e);
      }
    } else {
      // Outer grid frame loaded - check if it contains an inline table frame with state
      // This happens when dv_grid_content renders with inline data (no nested src)
      this.loadInlineState();
    }
  }

  /**
   * Update toolbar UI based on current state
   */
  updateToolbar() {
    // Update all UI elements from state
    this.updateViewTabs();
    this.updateFilterPills();
    this.updateSearchDisplay();
    this.updateFilterCount();
    this.updateFilterDropdownCheckboxes();
    this.updateFilterNavigation();
    this.updateFilterPanels();
    this.updateClearFiltersFooter();
    this.updateColumnPicker();
  }

  /**
   * Update filter pill display
   */
  updateFilterPills() {
    const container = this.element.querySelector('[data-filter-pills-container]');
    if (!container) return;

    // Clear existing pills
    container.innerHTML = '';

    // If no filters, hide container
    if (!this.state.filters.active || Object.keys(this.state.filters.active).length === 0) {
      //container.classList.add('d-none')
      return;
    }
    container.classList.remove('d-none');

    // Get OR grouping information from state
    const orGroups = this.state.filters.grouping?.orGroups || [];

    // Get locked filters from config
    const lockedFilters = this.state.config?.lockedFilters || [];

    // Build map of field -> group index for quick lookup
    const fieldToGroup = new Map();
    orGroups.forEach((group, groupIndex) => {
      group.forEach(field => {
        fieldToGroup.set(field, groupIndex);
      });
    });

    // Organize filters by OR groups and multi-value filters
    const groupedFilters = new Map(); // groupIndex -> array of {column, value} objects
    const ungroupedFilters = []; // Filters not in any OR group
    let nextAutoGroupIndex = orGroups.length; // Start auto-group indices after explicit OR groups

    Object.entries(this.state.filters.active).forEach(([column, values]) => {
      const valueArray = Array.isArray(values) ? values : [values];

      // Check direct match or date range base field match (e.g., expires_on_end matches expires_on)
      let groupIndex = null;
      if (fieldToGroup.has(column)) {
        groupIndex = fieldToGroup.get(column);
      } else {
        // Try matching date range suffixes (_start, _end) to base field
        const baseField = column.replace(/_(start|end)$/, '');
        if (baseField !== column && fieldToGroup.has(baseField)) {
          groupIndex = fieldToGroup.get(baseField);
        }
      }
      if (groupIndex !== null) {
        // This filter is part of an explicit expression-based OR group
        if (!groupedFilters.has(groupIndex)) {
          groupedFilters.set(groupIndex, []);
        }
        valueArray.forEach(value => {
          groupedFilters.get(groupIndex).push({
            column,
            value
          });
        });
      } else if (valueArray.length > 1) {
        // Multiple values for same field (IN clause) - create implicit OR group
        const autoGroupIndex = `auto-${nextAutoGroupIndex++}`;
        groupedFilters.set(autoGroupIndex, []);
        valueArray.forEach(value => {
          groupedFilters.get(autoGroupIndex).push({
            column,
            value
          });
        });
      } else {
        // Single value, not part of OR group
        ungroupedFilters.push({
          column,
          value: valueArray[0]
        });
      }
    });

    // Render ungrouped filters first
    ungroupedFilters.forEach(({
      column,
      value
    }) => {
      const isLocked = this.isFilterLocked(column, lockedFilters);
      const pill = this.createFilterPill(column, value, isLocked);
      container.appendChild(pill);
    });

    // Render OR groups with visual indicators
    groupedFilters.forEach((filters, groupIndex) => {
      if (filters.length === 0) return;

      // Create a wrapper for the OR group
      const groupWrapper = document.createElement('div');
      groupWrapper.className = 'd-inline-flex align-items-center gap-1';
      groupWrapper.style.cssText = 'padding: 2px 6px; border-radius: 6px; background-color: rgba(13, 110, 253, 0.08); border: 1px dashed rgba(13, 110, 253, 0.3);';
      groupWrapper.setAttribute('data-or-group', groupIndex);
      filters.forEach((filterData, index) => {
        const isLocked = this.isFilterLocked(filterData.column, lockedFilters);
        const pill = this.createFilterPill(filterData.column, filterData.value, isLocked);
        groupWrapper.appendChild(pill);

        // Add OR indicator between pills (but not after the last one)
        if (index < filters.length - 1) {
          const orIndicator = document.createElement('span');
          orIndicator.className = 'text-primary fw-bold px-1';
          orIndicator.style.cssText = 'font-size: 0.65rem; letter-spacing: 0.5px;';
          orIndicator.textContent = 'OR';
          orIndicator.setAttribute('title', 'These filters are combined with OR logic - any one can match');
          groupWrapper.appendChild(orIndicator);
        }
      });
      container.appendChild(groupWrapper);
    });
  }

  /**
   * Create a filter pill element
   * 
   * @param {string} column - The filter column key
   * @param {string} value - The filter value
   * @param {boolean} isLocked - Whether this filter is locked (cannot be removed)
   */
  createFilterPill(column, value, isLocked = false) {
    // Match the exact styling from grid_view_toolbar.php
    const badge = document.createElement('span');
    badge.className = 'badge d-inline-flex align-items-center gap-1 pe-1';
    badge.style.cssText = 'background-color: #f6f6f7; color: #202223; border: 1px solid #c9cccf; font-weight: 500; font-size: 0.75rem; padding: 0.25rem 0.4rem 0.25rem 0.5rem; border-radius: 0.4rem;';
    badge.setAttribute('data-filter-badge', '');
    if (isLocked) {
      badge.setAttribute('data-filter-locked', 'true');
    }

    // Get the label for this value from filters metadata
    const valueLabel = this.getFilterValueLabel(column, value);
    const columnLabel = this.getFilterColumnLabel(column);
    const textSpan = document.createElement('span');
    textSpan.innerHTML = `${columnLabel}: <strong>${this.escapeHtml(valueLabel)}</strong>`;
    badge.appendChild(textSpan);

    // Only add remove button if filter is not locked
    if (!isLocked) {
      const removeBtn = document.createElement('button');
      removeBtn.type = 'button';
      removeBtn.className = 'btn btn-link p-0 m-0 text-decoration-none d-flex align-items-center justify-content-center';
      removeBtn.style.cssText = 'width: 18px; height: 18px; border-radius: 50%; background: rgba(0,0,0,0.1); color: #202223; font-size: 0.7rem; line-height: 1;';
      removeBtn.setAttribute('aria-label', 'Remove filter');
      removeBtn.setAttribute('data-action', 'click->grid-view#removeFilter');
      removeBtn.setAttribute('data-filter-column', column);
      removeBtn.setAttribute('data-filter-value', value);
      const icon = document.createElement('i');
      icon.className = 'bi bi-x';
      icon.style.cssText = 'font-size: 0.9rem; font-weight: bold;';
      removeBtn.appendChild(icon);
      badge.appendChild(removeBtn);
    } else {
      // For locked filters, add a lock icon instead
      const lockIcon = document.createElement('i');
      lockIcon.className = 'bi bi-lock-fill ms-1';
      lockIcon.style.cssText = 'font-size: 0.65rem; opacity: 0.5;';
      lockIcon.setAttribute('title', 'This filter cannot be removed');
      badge.appendChild(lockIcon);
    }
    return badge;
  }

  /**
   * Get filter column label from metadata
   */
  getFilterColumnLabel(column) {
    if (this.state.filters.available && this.state.filters.available[column]) {
      return this.state.filters.available[column].label;
    }
    return this.formatColumnName(column);
  }

  /**
   * Get filter value label from metadata
   */
  getFilterValueLabel(column, value) {
    if (this.state.filters.available && this.state.filters.available[column]) {
      const filterMeta = this.state.filters.available[column];

      // For date range filters, just return the value (it's already a formatted date)
      if (filterMeta.type === 'date-range-start' || filterMeta.type === 'date-range-end') {
        return value;
      }

      // For dropdown filters, look up the option label
      const options = filterMeta.options;
      if (options) {
        const option = options.find(opt => opt.value === value);
        if (option) {
          return option.label;
        }
      }
    }
    return value;
  }

  /**
   * Escape HTML for safe insertion
   */
  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  /**
   * Format column name for display
   */
  formatColumnName(column) {
    // Simple title case formatting
    return column.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
  }

  /**
   * Update search display
   */
  updateSearchDisplay() {
    const container = this.element.querySelector('[data-filter-pills-container]');
    if (!container) return;

    // Update search input value
    if (this.hasSearchInputTarget) {
      this.searchInputTarget.value = this.state.search || '';
    }

    // Remove existing search badge if present
    const existingSearchBadge = container.querySelector('[data-search-badge]');
    if (existingSearchBadge) {
      existingSearchBadge.remove();
    }

    // If search is active, create and insert search badge as first element
    if (this.state.search) {
      const searchBadge = this.createSearchBadge(this.state.search);
      container.insertBefore(searchBadge, container.firstChild);
    }
  }

  /**
   * Create a search badge element
   */
  createSearchBadge(searchTerm) {
    // Match the exact styling from grid_view_toolbar.php
    const badge = document.createElement('span');
    badge.className = 'badge d-inline-flex align-items-center gap-1 pe-1';
    badge.style.cssText = 'background-color: #f6f6f7; color: #202223; border: 1px solid #c9cccf; font-weight: 500; font-size: 0.75rem; padding: 0.25rem 0.4rem 0.25rem 0.5rem; border-radius: 0.4rem;';
    badge.setAttribute('data-search-badge', '');
    const textSpan = document.createElement('span');
    textSpan.innerHTML = `Search: <strong data-search-text>${this.escapeHtml(searchTerm)}</strong>`;
    badge.appendChild(textSpan);
    const removeBtn = document.createElement('button');
    removeBtn.type = 'button';
    removeBtn.className = 'btn btn-link p-0 m-0 text-decoration-none d-flex align-items-center justify-content-center';
    removeBtn.style.cssText = 'width: 18px; height: 18px; border-radius: 50%; background: rgba(0,0,0,0.1); color: #202223; font-size: 0.7rem; line-height: 1;';
    removeBtn.setAttribute('aria-label', 'Remove search');
    removeBtn.setAttribute('data-action', 'click->grid-view#clearSearch');
    const icon = document.createElement('i');
    icon.className = 'bi bi-x';
    icon.style.cssText = 'font-size: 0.9rem; font-weight: bold;';
    removeBtn.appendChild(icon);
    badge.appendChild(removeBtn);
    return badge;
  }

  /**
   * Update filter count badge
   */
  updateFilterCount() {
    // Find the filter button (it has a Filter icon and text)
    const filterButton = Array.from(this.element.querySelectorAll('button')).find(btn => btn.textContent.includes('Filter') && btn.querySelector('.bi-funnel'));
    if (!filterButton) return;

    // Calculate active filter count (matching PHP logic)
    let activeCount = 0;

    // Count search as 1 filter if present
    if (this.state.search) {
      activeCount++;
    }

    // Count each active filter value
    if (this.state.filters && this.state.filters.active) {
      Object.values(this.state.filters.active).forEach(values => {
        activeCount += Array.isArray(values) ? values.length : 1;
      });
    }

    // Find or create badge
    let badge = filterButton.querySelector('.badge');
    if (activeCount > 0) {
      if (!badge) {
        // Create badge if it doesn't exist
        badge = document.createElement('span');
        badge.className = 'badge bg-primary rounded-circle';
        filterButton.appendChild(badge);
      }
      badge.textContent = activeCount;
    } else {
      // Remove badge if count is 0
      if (badge) {
        badge.remove();
      }
    }
  }

  /**
   * Update filter dropdown checkboxes to match current state
   * (This is now mostly redundant since we rebuild the panels,
   * but keeping it for any dynamic checkbox updates)
   */
  updateFilterDropdownCheckboxes() {
    if (!this.state.filters || !this.state.filters.active) return;

    // Get all filter checkboxes and sync their state
    const checkboxes = this.element.querySelectorAll('[data-filter-column][type="checkbox"]');
    checkboxes.forEach(checkbox => {
      const column = checkbox.dataset.filterColumn;
      const value = checkbox.value;

      // Check if this filter value is active in the current state
      const activeValues = this.state.filters.active[column];
      let isActive = false;
      if (activeValues !== undefined) {
        if (Array.isArray(activeValues)) {
          isActive = activeValues.includes(value);
        } else {
          isActive = activeValues === value;
        }
      }
      checkbox.checked = isActive;
    });
  }

  /**
   * Update view tabs from state
   */
  updateViewTabs() {
    const container = this.element.querySelector('[data-view-tabs-container]');
    if (!container) return;

    // Check if we should show "All" tab (marker present means DON'T show it)
    const showAllTab = !this.element.querySelector('[data-no-all-tab]');

    // Find the "Create View" button to preserve it
    const createViewBtn = container.querySelector('[data-action*="saveView"]')?.closest('li');

    // Find the marker element to preserve it
    const markerElement = container.querySelector('[data-no-all-tab]')?.closest('li');

    // Clear existing tabs (except create button and marker)
    container.querySelectorAll('li').forEach(li => {
      if (li !== createViewBtn && li !== markerElement) {
        li.remove();
      }
    });

    // Add "All" tab if enabled
    if (showAllTab) {
      const allTab = this.createViewTab('All', null, !this.state.view.currentId, false, false);
      container.insertBefore(allTab, createViewBtn);
    }

    // Add user views
    if (this.state.view.available && Array.isArray(this.state.view.available)) {
      this.state.view.available.forEach(view => {
        const isActive = this.state.view.currentId == view.id;
        const isPreferred = view.isPreferred || view.isUserDefault || false;
        const canManage = view.canManage !== false;
        const count = view.count || null;
        const viewTab = this.createViewTab(view.name, view.id, isActive, isPreferred, canManage, count);
        container.insertBefore(viewTab, createViewBtn);
      });
    }
  }

  /**
   * Create a view tab element
   * @param {string} name Tab name
   * @param {string|null} viewId View ID (null for 'All' tab)
   * @param {boolean} isActive Is this the active tab
   * @param {boolean} isPreferred Is this the preferred (default) view
   * @param {boolean} canManage Can this view be managed
   * @param {number|null} count Optional count for badge display
   */
  createViewTab(name, viewId, isActive, isPreferred, canManage, count = null) {
    const li = document.createElement('li');
    li.className = 'nav-item';
    li.setAttribute('role', 'presentation');
    if (isActive && canManage) {
      // Active tab with dropdown
      const btnGroup = document.createElement('div');
      btnGroup.className = 'btn-group';
      btnGroup.setAttribute('role', 'group');
      btnGroup.style.marginBottom = '-1px';
      const mainBtn = document.createElement('button');
      mainBtn.type = 'button';
      mainBtn.className = 'nav-link active split-tab-left';
      mainBtn.setAttribute('role', 'tab');
      mainBtn.setAttribute('aria-selected', 'true');
      if (viewId) {
        mainBtn.setAttribute('data-action', 'click->grid-view#switchView');
        mainBtn.setAttribute('data-view-id', viewId);
      } else {
        mainBtn.setAttribute('data-action', 'click->grid-view#showAll');
      }
      mainBtn.textContent = name;
      if (count !== null) {
        mainBtn.appendChild(document.createTextNode(' '));
        const badge = document.createElement('span');
        badge.className = 'badge bg-secondary ms-1';
        badge.textContent = count;
        mainBtn.appendChild(badge);
      }
      if (isPreferred) {
        const star = document.createElement('i');
        star.className = 'bi bi-star-fill text-warning';
        star.style.fontSize = '0.75rem';
        mainBtn.appendChild(document.createTextNode(' '));
        mainBtn.appendChild(star);
      }
      const dropdownBtn = document.createElement('button');
      dropdownBtn.type = 'button';
      dropdownBtn.className = 'nav-link active dropdown-toggle dropdown-toggle-split split-tab-right';
      dropdownBtn.setAttribute('data-bs-toggle', 'dropdown');
      dropdownBtn.setAttribute('aria-expanded', 'false');
      dropdownBtn.style.cssText = 'padding-left: 5px; padding-right: 5px;';
      dropdownBtn.innerHTML = '<span class="visually-hidden">Toggle Dropdown</span>';
      const dropdownMenu = document.createElement('ul');
      dropdownMenu.className = 'dropdown-menu';
      if (viewId && canManage) {
        // Update View
        const updateItem = document.createElement('li');
        updateItem.innerHTML = `
                    <button type="button" class="dropdown-item" data-action="click->grid-view#updateView">
                        <i class="bi bi-arrow-repeat me-2"></i> Update View
                    </button>
                `;
        dropdownMenu.appendChild(updateItem);
      }

      // Set/Clear Default
      const defaultItem = document.createElement('li');
      if (isPreferred) {
        defaultItem.innerHTML = `
                    <button type="button" class="dropdown-item" data-action="click->grid-view#clearDefault">
                        <i class="bi bi-star-fill me-2"></i> Remove as Default
                    </button>
                `;
      } else {
        defaultItem.innerHTML = `
                    <button type="button" class="dropdown-item" data-action="click->grid-view#setDefault">
                        <i class="bi bi-star me-2"></i> Set as Default
                    </button>
                `;
      }
      dropdownMenu.appendChild(defaultItem);
      if (viewId && canManage) {
        // Divider
        const divider = document.createElement('li');
        divider.innerHTML = '<hr class="dropdown-divider">';
        dropdownMenu.appendChild(divider);

        // Delete View
        const deleteItem = document.createElement('li');
        deleteItem.innerHTML = `
                    <button type="button" class="dropdown-item text-danger" data-action="click->grid-view#deleteView">
                        <i class="bi bi-trash me-2"></i> Delete View
                    </button>
                `;
        dropdownMenu.appendChild(deleteItem);
      }
      btnGroup.appendChild(mainBtn);
      btnGroup.appendChild(dropdownBtn);
      btnGroup.appendChild(dropdownMenu);
      li.appendChild(btnGroup);
    } else if (isActive && !canManage) {
      // Active system view with limited dropdown
      const btnGroup = document.createElement('div');
      btnGroup.className = 'btn-group';
      btnGroup.setAttribute('role', 'group');
      btnGroup.style.marginBottom = '-1px';
      const mainBtn = document.createElement('button');
      mainBtn.type = 'button';
      mainBtn.className = 'nav-link active split-tab-left';
      mainBtn.setAttribute('role', 'tab');
      mainBtn.setAttribute('aria-selected', 'true');
      mainBtn.textContent = name;
      if (count !== null) {
        mainBtn.appendChild(document.createTextNode(' '));
        const badge = document.createElement('span');
        badge.className = 'badge bg-secondary ms-1';
        badge.textContent = count;
        mainBtn.appendChild(badge);
      }
      if (isPreferred) {
        const star = document.createElement('i');
        star.className = 'bi bi-star-fill text-warning';
        star.style.fontSize = '0.75rem';
        mainBtn.appendChild(document.createTextNode(' '));
        mainBtn.appendChild(star);
      }
      const dropdownBtn = document.createElement('button');
      dropdownBtn.type = 'button';
      dropdownBtn.className = 'nav-link active dropdown-toggle dropdown-toggle-split split-tab-right';
      dropdownBtn.setAttribute('data-bs-toggle', 'dropdown');
      dropdownBtn.setAttribute('aria-expanded', 'false');
      dropdownBtn.style.cssText = 'padding-left: 5px; padding-right: 5px;';
      dropdownBtn.innerHTML = '<span class="visually-hidden">Toggle Dropdown</span>';
      const dropdownMenu = document.createElement('ul');
      dropdownMenu.className = 'dropdown-menu';
      const defaultItem = document.createElement('li');
      if (isPreferred) {
        defaultItem.innerHTML = `
                    <button type="button" class="dropdown-item" data-action="click->grid-view#clearDefault">
                        <i class="bi bi-star-fill me-2"></i> Remove as Default
                    </button>
                `;
      } else {
        defaultItem.innerHTML = `
                    <button type="button" class="dropdown-item" data-action="click->grid-view#setDefault">
                        <i class="bi bi-star me-2"></i> Set as Default
                    </button>
                `;
      }
      dropdownMenu.appendChild(defaultItem);
      btnGroup.appendChild(mainBtn);
      btnGroup.appendChild(dropdownBtn);
      btnGroup.appendChild(dropdownMenu);
      li.appendChild(btnGroup);
    } else {
      // Inactive tab
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'nav-link';
      btn.setAttribute('role', 'tab');
      btn.setAttribute('aria-selected', 'false');
      if (viewId) {
        btn.setAttribute('data-action', 'click->grid-view#switchView');
        btn.setAttribute('data-view-id', viewId);
      } else {
        btn.setAttribute('data-action', 'click->grid-view#showAll');
      }
      btn.textContent = name;
      if (count !== null) {
        btn.appendChild(document.createTextNode(' '));
        const badge = document.createElement('span');
        badge.className = 'badge bg-secondary ms-1';
        badge.textContent = count;
        btn.appendChild(badge);
      }
      if (isPreferred) {
        const star = document.createElement('i');
        star.className = 'bi bi-star-fill text-warning';
        star.style.fontSize = '0.75rem';
        btn.appendChild(document.createTextNode(' '));
        btn.appendChild(star);
      }
      li.appendChild(btn);
    }
    return li;
  }

  /**
   * Update filter navigation (left side filter tabs)
   */
  updateFilterNavigation() {
    const container = this.element.querySelector('[data-filter-nav-container]');
    if (!container) return;
    container.innerHTML = '';
    if (!this.state.filters.available) return;

    // Group date range filters by base field
    const filterGroups = new Map();
    const standaloneFilters = [];
    Object.entries(this.state.filters.available).forEach(([key, meta]) => {
      if (meta.type === 'date-range-start' || meta.type === 'date-range-end') {
        const baseField = meta.baseField || key.replace(/_start$|_end$/, '');
        if (!filterGroups.has(baseField)) {
          filterGroups.set(baseField, {
            baseField,
            label: meta.label.replace(' (after)', '').replace(' (before)', ''),
            filters: []
          });
        }
        filterGroups.get(baseField).filters.push({
          key,
          meta
        });
      } else {
        standaloneFilters.push({
          key,
          meta
        });
      }
    });

    // Build array of all filters (standalone + grouped date ranges)
    const allFilterItems = [...standaloneFilters.map(({
      key,
      meta
    }) => ({
      key,
      label: meta.label,
      type: 'dropdown',
      meta
    })), ...Array.from(filterGroups.values()).map(group => ({
      key: group.baseField,
      label: group.label,
      type: 'date-range',
      group
    }))];
    if (allFilterItems.length === 0) return;

    // Determine which filter should be active (preserve user's selection or default to first)
    const firstFilterKey = allFilterItems[0].key;
    const activeKey = this.activeFilterKey && allFilterItems.some(item => item.key === this.activeFilterKey) ? this.activeFilterKey : firstFilterKey;

    // Update activeFilterKey to the determined value
    this.activeFilterKey = activeKey;
    allFilterItems.forEach(item => {
      let activeCount = 0;
      if (item.type === 'date-range') {
        // Count active date range filters
        item.group.filters.forEach(({
          key
        }) => {
          if (this.state.filters.active[key]) activeCount++;
        });
      } else {
        // Count active dropdown filters
        const activeValues = this.state.filters.active?.[item.key] || [];
        const activeArray = Array.isArray(activeValues) ? activeValues : [activeValues];
        activeCount = activeArray.filter(v => v !== null && v !== undefined && v !== '').length;
      }
      const button = document.createElement('button');
      button.type = 'button';
      button.className = `list-group-item list-group-item-action d-flex justify-content-between align-items-center${item.key === activeKey ? ' active' : ''}`;
      button.setAttribute('data-filter-key', item.key);
      button.setAttribute('data-filter-type', item.type);
      button.setAttribute('data-filter-nav-item', '');
      button.setAttribute('data-action', 'click->grid-view#selectFilter');
      const label = document.createElement('span');
      label.textContent = item.label;
      button.appendChild(label);
      if (activeCount > 0) {
        const badge = document.createElement('span');
        badge.className = 'badge bg-primary rounded-pill';
        badge.textContent = activeCount;
        button.appendChild(badge);
      }
      container.appendChild(button);
    });
  }

  /**
   * Update filter panels (right side filter options)
   */
  updateFilterPanels() {
    const container = this.element.querySelector('[data-filter-panels-container]');
    if (!container) return;
    container.innerHTML = '';
    if (!this.state.filters.available) return;

    // Get locked filters from config
    const lockedFilters = this.state.config?.lockedFilters || [];

    // Group date range filters by base field (same logic as navigation)
    const filterGroups = new Map();
    const standaloneFilters = [];
    Object.entries(this.state.filters.available).forEach(([key, meta]) => {
      if (meta.type === 'date-range-start' || meta.type === 'date-range-end') {
        const baseField = meta.baseField || key.replace(/_start$|_end$/, '');
        if (!filterGroups.has(baseField)) {
          filterGroups.set(baseField, {
            baseField,
            label: meta.label.replace(' (after)', '').replace(' (before)', ''),
            filters: []
          });
        }
        filterGroups.get(baseField).filters.push({
          key,
          meta
        });
      } else {
        standaloneFilters.push({
          key,
          meta
        });
      }
    });

    // Build array of all filters (standalone + grouped date ranges)
    const allFilterItems = [...standaloneFilters.map(({
      key,
      meta
    }) => ({
      key,
      label: meta.label,
      type: 'dropdown',
      meta
    })), ...Array.from(filterGroups.values()).map(group => ({
      key: group.baseField,
      label: group.label,
      type: 'date-range',
      group
    }))];
    if (allFilterItems.length === 0) return;

    // Use the same active key logic as navigation
    const firstFilterKey = allFilterItems[0].key;
    const activeKey = this.activeFilterKey && allFilterItems.some(item => item.key === this.activeFilterKey) ? this.activeFilterKey : firstFilterKey;
    allFilterItems.forEach(item => {
      const panel = document.createElement('div');
      panel.className = item.key === activeKey ? '' : 'd-none';
      panel.setAttribute('data-filter-key', item.key);
      panel.setAttribute('data-filter-panel', '');
      const innerDiv = document.createElement('div');
      innerDiv.className = 'px-3 py-3 border-bottom';
      if (item.type === 'date-range') {
        // Render date range panel with From/To inputs
        const startFilter = item.group.filters.find(f => f.meta.type === 'date-range-start');
        const endFilter = item.group.filters.find(f => f.meta.type === 'date-range-end');
        const startValue = startFilter ? this.state.filters.active[startFilter.key] || '' : '';
        const endValue = endFilter ? this.state.filters.active[endFilter.key] || '' : '';
        const activeCount = (startValue ? 1 : 0) + (endValue ? 1 : 0);

        // Check if this date range filter is locked
        const isLocked = this.isFilterLocked(item.key, lockedFilters);
        const headerDiv = document.createElement('div');
        headerDiv.className = 'd-flex justify-content-between align-items-center mb-1';
        const title = document.createElement('strong');
        title.textContent = item.label;
        if (isLocked) {
          const lockIcon = document.createElement('i');
          lockIcon.className = 'bi bi-lock-fill ms-2';
          lockIcon.style.cssText = 'font-size: 0.75rem; opacity: 0.5;';
          lockIcon.setAttribute('title', 'This filter is locked and cannot be changed');
          title.appendChild(lockIcon);
        }
        headerDiv.appendChild(title);
        if (activeCount > 0) {
          const countText = document.createElement('small');
          countText.className = 'text-muted';
          countText.textContent = `${activeCount} selected`;
          headerDiv.appendChild(countText);
        }
        innerDiv.appendChild(headerDiv);
        const helpText = document.createElement('div');
        helpText.className = 'text-muted small mb-3';
        helpText.textContent = isLocked ? 'This filter is locked' : 'Select date range';
        innerDiv.appendChild(helpText);

        // Create row for From/To inputs
        const row = document.createElement('div');
        row.className = 'row g-2';

        // From date
        if (startFilter) {
          const fromCol = document.createElement('div');
          fromCol.className = 'col-12';
          const fromLabel = document.createElement('label');
          fromLabel.className = 'form-label small text-muted';
          fromLabel.textContent = 'From';
          fromCol.appendChild(fromLabel);
          const fromInput = document.createElement('input');
          fromInput.type = 'date';
          fromInput.className = 'form-control';
          fromInput.value = startValue;
          fromInput.setAttribute('data-filter-column', startFilter.key);
          if (isLocked) {
            fromInput.disabled = true;
            fromInput.setAttribute('title', 'This filter is locked and cannot be changed');
          } else {
            fromInput.setAttribute('data-action', 'change->grid-view#updateDateRangeFilter');
          }
          fromCol.appendChild(fromInput);
          row.appendChild(fromCol);
        }

        // To date
        if (endFilter) {
          const toCol = document.createElement('div');
          toCol.className = 'col-12';
          const toLabel = document.createElement('label');
          toLabel.className = 'form-label small text-muted';
          toLabel.textContent = 'To';
          toCol.appendChild(toLabel);
          const toInput = document.createElement('input');
          toInput.type = 'date';
          toInput.className = 'form-control';
          toInput.value = endValue;
          toInput.setAttribute('data-filter-column', endFilter.key);
          if (isLocked) {
            toInput.disabled = true;
            toInput.setAttribute('title', 'This filter is locked and cannot be changed');
          } else {
            toInput.setAttribute('data-action', 'change->grid-view#updateDateRangeFilter');
          }
          toCol.appendChild(toInput);
          row.appendChild(toCol);
        }
        innerDiv.appendChild(row);
      } else {
        // Render dropdown panel with checkboxes
        const activeValues = this.state.filters.active?.[item.key] || [];
        const activeArray = Array.isArray(activeValues) ? activeValues : [activeValues];
        const activeFiltered = activeArray.filter(v => v !== null && v !== undefined && v !== '');
        const activeCount = activeFiltered.length;

        // Check if this filter is locked
        const isLocked = this.isFilterLocked(item.key, lockedFilters);
        const headerDiv = document.createElement('div');
        headerDiv.className = 'd-flex justify-content-between align-items-center mb-1';
        const title = document.createElement('strong');
        title.textContent = item.label;
        if (isLocked) {
          const lockIcon = document.createElement('i');
          lockIcon.className = 'bi bi-lock-fill ms-2';
          lockIcon.style.cssText = 'font-size: 0.75rem; opacity: 0.5;';
          lockIcon.setAttribute('title', 'This filter is locked and cannot be changed');
          title.appendChild(lockIcon);
        }
        headerDiv.appendChild(title);
        if (activeCount > 0) {
          const countText = document.createElement('small');
          countText.className = 'text-muted';
          countText.textContent = `${activeCount} selected`;
          headerDiv.appendChild(countText);
        }
        innerDiv.appendChild(headerDiv);
        const helpText = document.createElement('div');
        helpText.className = 'text-muted small mb-2';
        helpText.textContent = isLocked ? 'This filter is locked' : 'Choose one or more options';
        innerDiv.appendChild(helpText);

        // Add checkboxes for each option
        item.meta.options.forEach(option => {
          const isChecked = activeFiltered.includes(option.value);
          const formCheck = document.createElement('div');
          formCheck.className = 'form-check mb-1';
          const checkbox = document.createElement('input');
          checkbox.className = 'form-check-input';
          checkbox.type = 'checkbox';
          checkbox.id = `filter_${item.key}_${option.value}`;
          checkbox.value = option.value;
          checkbox.checked = isChecked;
          checkbox.setAttribute('data-filter-column', item.key);
          if (isLocked) {
            checkbox.disabled = true;
            checkbox.setAttribute('title', 'This filter is locked and cannot be changed');
          } else {
            checkbox.setAttribute('data-action', 'change->grid-view#toggleFilter');
          }
          const label = document.createElement('label');
          label.className = 'form-check-label';
          if (isLocked) {
            label.classList.add('text-muted');
          }
          label.htmlFor = checkbox.id;
          label.textContent = option.label;
          formCheck.appendChild(checkbox);
          formCheck.appendChild(label);
          innerDiv.appendChild(formCheck);
        });
      }
      panel.appendChild(innerDiv);
      container.appendChild(panel);
    });
  }

  /**
   * Update clear filters footer visibility
   */
  updateClearFiltersFooter() {
    const container = this.element.querySelector('[data-clear-filters-container]');
    if (!container) return;
    const hasSearch = this.state.search && this.state.search.trim() !== '';
    const hasFilters = this.state.filters.active && Object.keys(this.state.filters.active).length > 0;
    if (hasSearch || hasFilters) {
      container.style.display = '';
    } else {
      container.style.display = 'none';
    }
  }

  /**
   * Update column picker modal
   */
  updateColumnPicker() {
    const container = this.element.querySelector('[data-column-list-container]');
    if (!container) return;
    container.innerHTML = '';
    if (!this.state.columns || !this.state.columns.all) return;

    // Normalize columns.visible to array (handle both array and object formats from PHP)
    const visibleColumns = Array.isArray(this.state.columns.visible) ? this.state.columns.visible : Object.values(this.state.columns.visible);

    // Build ordered list: visible first, then remaining
    const orderedColumns = [];
    const orderedKeys = [];

    // Add visible columns first
    visibleColumns.forEach(key => {
      if (this.state.columns.all[key]) {
        orderedColumns.push((0,_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__["default"])({
          key
        }, this.state.columns.all[key]));
        orderedKeys.push(key);
      }
    });

    // Add remaining columns
    Object.entries(this.state.columns.all).forEach(([key, column]) => {
      if (!orderedKeys.includes(key)) {
        orderedColumns.push((0,_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__["default"])({
          key
        }, column));
      }
    });

    // Create list items
    orderedColumns.forEach(column => {
      // Skip export-only columns - they shouldn't appear in the column picker
      if (column.exportOnly) return;
      const isVisible = visibleColumns.includes(column.key);
      const isRequired = column.required || false;
      const label = document.createElement('label');
      label.className = `list-group-item d-flex align-items-center${!isVisible ? ' list-group-item-secondary' : ''}`;
      label.setAttribute('data-sortable-list-target', 'item');
      label.setAttribute('data-column-key', column.key);
      if (isRequired) {
        label.setAttribute('data-column-required', 'true');
      }
      label.draggable = true;
      label.setAttribute('data-action', `dragstart->sortable-list#dragStart 
                dragover->sortable-list#dragOver 
                dragenter->sortable-list#dragEnter 
                dragleave->sortable-list#dragLeave 
                drop->sortable-list#drop 
                dragend->sortable-list#dragEnd`);

      // Drag handle
      const dragHandle = document.createElement('span');
      dragHandle.className = 'drag-handle me-2';
      dragHandle.style.cursor = 'move';
      dragHandle.title = 'Drag to reorder';
      dragHandle.innerHTML = '<i class="bi bi-grip-vertical"></i>';
      label.appendChild(dragHandle);

      // Checkbox
      const checkbox = document.createElement('input');
      checkbox.className = 'form-check-input me-2';
      checkbox.type = 'checkbox';
      checkbox.value = column.key;
      checkbox.checked = isVisible;
      if (isRequired) {
        checkbox.disabled = true;
      }
      checkbox.setAttribute('data-action', 'change->grid-view#toggleColumn');
      checkbox.setAttribute('data-column-key', column.key);
      label.appendChild(checkbox);

      // Label content
      const contentDiv = document.createElement('div');
      contentDiv.className = 'flex-grow-1';
      const columnLabel = column.label && column.label.trim() !== '' ? column.label : column.key;
      const strong = document.createElement('strong');
      strong.textContent = columnLabel;
      contentDiv.appendChild(strong);
      if (isRequired) {
        const requiredText = document.createElement('small');
        requiredText.className = 'text-muted ms-1';
        requiredText.textContent = '(Required)';
        contentDiv.appendChild(requiredText);
      }
      if (column.description) {
        contentDiv.appendChild(document.createElement('br'));
        const desc = document.createElement('small');
        desc.className = 'text-muted';
        desc.textContent = column.description;
        contentDiv.appendChild(desc);
      }
      label.appendChild(contentDiv);
      container.appendChild(label);
    });
  }

  // ============================================================================
  // View Actions
  // ============================================================================

  /**
   * Show all records (clear view selection)
   */
  showAll() {
    // When showing all, clear everything except ignore_default
    const url = new URL(window.location.href);
    url.search = ''; // Clear all query parameters
    url.searchParams.set('ignore_default', '1');
    this.navigate(url.pathname + url.search); // Table frame nav
  }

  /**
   * Switch to a specific view
   */
  switchView(event) {
    const viewId = event.currentTarget.dataset.viewId;
    if (!viewId) return;

    // When switching to a view, clear everything except the view_id
    const url = new URL(window.location.href);
    url.search = ''; // Clear all query parameters
    url.searchParams.set('view_id', viewId);
    this.navigate(url.pathname + url.search); // Table frame nav
  }

  /**
   * Save current state as new view
   */
  async saveView() {
    const name = prompt("Enter a name for this view:");
    if (!name || name.trim() === "") return;
    const config = this.getCurrentConfig();
    try {
      const response = await fetch(`/grid-views/add`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json",
          "X-CSRF-Token": this.getCsrfToken(),
          "X-Requested-With": "XMLHttpRequest"
        },
        credentials: "same-origin",
        body: JSON.stringify({
          gridKey: this.state.config.gridKey,
          name: name.trim(),
          config: config
        })
      });
      const data = await response.json();
      if (response.ok && data.success) {
        alert("View saved successfully");
        // Navigate to the new view
        const url = this.buildUrl({
          view_id: data.data.view.id
        });
        window.location.assign(url);
      } else {
        throw new Error(data.error || "Failed to save view");
      }
    } catch (error) {
      console.error("Error saving view:", error);
      alert("Failed to save view: " + error.message);
    }
  }

  /**
   * Update existing view with current state
   */
  async updateView() {
    if (!this.state.view.currentId) {
      alert("No view selected to update");
      return;
    }
    if (!confirm("Update this view with current settings?")) return;
    const config = this.getCurrentConfig();
    try {
      const response = await fetch(`/grid-views/edit/${this.state.view.currentId}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json",
          "X-CSRF-Token": this.getCsrfToken(),
          "X-Requested-With": "XMLHttpRequest"
        },
        credentials: "same-origin",
        body: JSON.stringify({
          config: config
        })
      });
      const data = await response.json();
      if (response.ok && data.success) {
        alert("View updated successfully");
        window.location.reload();
      } else {
        throw new Error(data.error || "Failed to update view");
      }
    } catch (error) {
      console.error("Error updating view:", error);
      alert("Failed to update view: " + error.message);
    }
  }

  /**
   * Delete current view
   */
  async deleteView() {
    if (!this.state.view.currentId) {
      alert("No view selected to delete");
      return;
    }
    if (!confirm("Are you sure you want to delete this view?")) return;
    try {
      const response = await fetch(`/grid-views/delete/${this.state.view.currentId}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json",
          "X-CSRF-Token": this.getCsrfToken(),
          "X-Requested-With": "XMLHttpRequest"
        },
        credentials: "same-origin"
      });
      const data = await response.json();
      if (response.ok && data.success) {
        alert("View deleted successfully");
        const url = this.buildUrl({
          view_id: null
        });
        window.location.assign(url);
      } else {
        throw new Error(data.error || "Failed to delete view");
      }
    } catch (error) {
      console.error("Error deleting view:", error);
      alert("Failed to delete view: " + error.message);
    }
  }

  /**
   * Set current view as user default
   */
  async setDefault() {
    if (!this.state.view.currentId) {
      alert("No view selected to set as default");
      return;
    }
    try {
      const response = await fetch(`/grid-views/set-default/${this.state.view.currentId}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json",
          "X-CSRF-Token": this.getCsrfToken(),
          "X-Requested-With": "XMLHttpRequest"
        },
        credentials: "same-origin",
        body: JSON.stringify({
          gridKey: this.state.config.gridKey
        })
      });
      const data = await response.json();
      if (response.ok && data.success) {
        alert("Default view set successfully");
        window.location.reload();
      } else {
        throw new Error(data.error || "Failed to set default");
      }
    } catch (error) {
      console.error("Error setting default:", error);
      alert("Failed to set default: " + error.message);
    }
  }

  /**
   * Clear user default view
   */
  async clearDefault() {
    try {
      const response = await fetch(`/grid-views/clear-default`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json",
          "X-CSRF-Token": this.getCsrfToken(),
          "X-Requested-With": "XMLHttpRequest"
        },
        credentials: "same-origin",
        body: JSON.stringify({
          gridKey: this.state.config.gridKey
        })
      });
      const data = await response.json();
      if (response.ok && data.success) {
        alert("Default view cleared successfully");
        window.location.reload();
      } else {
        throw new Error(data.error || "Failed to clear default");
      }
    } catch (error) {
      console.error("Error clearing default:", error);
      alert("Failed to clear default: " + error.message);
    }
  }

  // ============================================================================
  // Search Actions
  // ============================================================================

  /**
   * Handle search input keyup with debouncing
   */
  handleSearchKeyup(event) {
    if (event.key === 'Enter') return; // Handled separately

    if (this.searchDebounceTimer) {
      clearTimeout(this.searchDebounceTimer);
    }
    this.searchDebounceTimer = setTimeout(() => {
      this.performSearch(event);
    }, 500);
  }

  /**
   * Perform search
   */
  performSearch() {
    const searchTerm = this.searchInputTarget.value.trim();
    const updates = {
      search: searchTerm || null
    };

    // If we're on a view and search differs from view default, mark as dirty
    if (this.state.view.currentId && searchTerm !== (this.state.view.search || '')) {
      updates['dirty[search]'] = '1';
    }
    const url = this.buildUrl(updates);
    this.navigate(url);
  }

  /**
   * Clear search
   */
  clearSearch() {
    const updates = {
      search: ''
    }; // Use empty string instead of null to explicitly clear

    // If we're on a view, mark search as dirty to override the view's potential saved search
    if (this.state.view.currentId) {
      updates['dirty[search]'] = '1';
    }
    const url = this.buildUrl(updates);
    this.navigate(url);
  }

  /**
   * Apply date range filter
   */
  applyDateRangeFilter(event) {
    const input = event.currentTarget;
    const fieldName = input.dataset.dateRangeField;
    const value = input.value;

    // Build updates object with the date range parameter
    const updates = {};
    updates[fieldName] = value || null;

    // If value is empty, explicitly set to null to clear the filter
    if (!value) {
      updates[fieldName] = null;
    }

    // Mark filters as dirty to ensure they're applied
    updates['dirty[filters]'] = '1';
    const url = this.buildUrl(updates);
    this.navigate(url);
  }

  // ============================================================================
  // Filter Actions
  // ============================================================================

  /**
   * Toggle a filter value
   */
  toggleFilter(event) {
    const checkbox = event.currentTarget;
    const column = checkbox.dataset.filterColumn;
    const value = checkbox.value;

    // Check if this filter is locked
    const lockedFilters = this.state.config?.lockedFilters || [];
    if (this.isFilterLocked(column, lockedFilters)) {
      console.warn(`Filter '${column}' is locked and cannot be toggled`);
      // Restore checkbox to its previous state
      checkbox.checked = !checkbox.checked;
      return;
    }

    // Get current filter values for this column
    let currentValues = this.state.filters.active[column] || [];
    if (!Array.isArray(currentValues)) {
      currentValues = currentValues ? [currentValues] : [];
    }

    // Toggle the value
    const newValues = checkbox.checked ? [...currentValues, value] : currentValues.filter(v => v !== value);

    // Build URL with updated filter
    const filterParams = (0,_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__["default"])({}, this.state.filters.active);
    if (newValues.length > 0) {
      filterParams[column] = newValues;
    } else {
      delete filterParams[column];
    }
    let url = this.buildUrlWithFilters(filterParams);

    // If we're on a view, mark filters as dirty
    if (this.state.view.currentId) {
      const urlObj = new URL(url, window.location.origin);
      urlObj.searchParams.set('dirty[filters]', '1');
      url = urlObj.pathname + urlObj.search;
    }
    this.navigate(url);
  }

  /**
   * Remove a specific filter value
   */
  removeFilter(event) {
    const column = event.currentTarget.dataset.filterColumn;
    const value = event.currentTarget.dataset.filterValue;

    // Check if this filter is locked
    const lockedFilters = this.state.config?.lockedFilters || [];
    if (this.isFilterLocked(column, lockedFilters)) {
      console.warn(`Filter '${column}' is locked and cannot be removed`);
      return;
    }

    // Get current filter values for this column (ensure it's an array)
    let currentValues = this.state.filters.active[column] || [];
    if (!Array.isArray(currentValues)) {
      currentValues = [currentValues];
    }
    const newValues = currentValues.filter(v => v !== value);

    // Build URL with updated filter
    const filterParams = (0,_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__["default"])({}, this.state.filters.active);
    if (newValues.length > 0) {
      filterParams[column] = newValues;
    } else {
      delete filterParams[column];
    }

    // Build URL and mark filters as dirty (keep view_id)
    let url = this.buildUrlWithFilters(filterParams);
    const urlObj = new URL(url, window.location.origin);

    // If we're on a view, mark filters as dirty
    if (this.state.view.currentId) {
      urlObj.searchParams.set('dirty[filters]', '1');
    }
    url = urlObj.pathname + urlObj.search;
    this.navigate(url); // Frame nav - toolbar will update via handleFrameLoad
  }

  /**
   * Clear all filters and search (preserves locked filters)
   */
  clearAllFilters() {
    const lockedFilters = this.state.config?.lockedFilters || [];

    // Build filter params preserving only locked filters
    const preservedFilters = {};
    if (this.state.filters.active && lockedFilters.length > 0) {
      for (const [column, values] of Object.entries(this.state.filters.active)) {
        if (this.isFilterLocked(column, lockedFilters)) {
          preservedFilters[column] = values;
        }
      }
    }

    // Build URL with only locked filters preserved
    let url;
    if (Object.keys(preservedFilters).length > 0) {
      // Has locked filters - use buildUrlWithFilters to preserve them
      url = this.buildUrlWithFilters(preservedFilters);
      const urlObj = new URL(url, window.location.origin);
      // Clear search
      urlObj.searchParams.delete('search');
      // If we're on a view, mark filters as dirty
      if (this.state.view.currentId) {
        urlObj.searchParams.set('dirty[filters]', '1');
      }
      url = urlObj.pathname + urlObj.search;
    } else {
      // No locked filters - simple clear
      const updates = {
        search: null
      };
      // If we're on a view, mark filters as dirty instead of removing view
      if (this.state.view.currentId) {
        updates['dirty[filters]'] = '1';
      }
      url = this.buildUrl(updates);
    }
    this.navigate(url);
  }

  /**
   * Check if a filter column is locked
   * 
   * @param {string} column - The filter column key
   * @param {string[]} lockedFilters - Array of locked filter keys
   * @returns {boolean} True if the filter is locked
   */
  isFilterLocked(column, lockedFilters) {
    // Check exact match
    if (lockedFilters.includes(column)) {
      return true;
    }
    // Check date range variants (e.g., 'expires_on' locks 'expires_on_start' and 'expires_on_end')
    const baseField = column.replace(/_(start|end)$/, '');
    if (baseField !== column && lockedFilters.includes(baseField)) {
      return true;
    }
    return false;
  }

  /**
   * Show specific filter panel in dropdown
   */
  selectFilter(event) {
    const key = event.currentTarget.dataset.filterKey;

    // Remember which filter tab is active
    this.activeFilterKey = key;

    // Hide all panels
    this.element.querySelectorAll('[data-filter-panel]').forEach(panel => {
      panel.classList.add('d-none');
    });

    // Show selected panel
    const targetPanel = this.element.querySelector(`[data-filter-panel][data-filter-key="${key}"]`);
    if (targetPanel) {
      targetPanel.classList.remove('d-none');
    }

    // Update nav item active states
    this.element.querySelectorAll('[data-filter-nav-item]').forEach(item => {
      item.classList.remove('active');
    });
    event.currentTarget.classList.add('active');
  }

  /**
   * Update date range filter value
   */
  updateDateRangeFilter(event) {
    const columnKey = event.target.dataset.filterColumn;
    const value = event.target.value;

    // Check if this filter is locked
    const lockedFilters = this.state.config?.lockedFilters || [];
    if (this.isFilterLocked(columnKey, lockedFilters)) {
      console.warn(`Filter '${columnKey}' is locked and cannot be changed`);
      // Restore the input to its previous value
      const activeValue = this.state.filters.active[columnKey] || '';
      event.target.value = activeValue;
      return;
    }

    // Build URL with updated filter
    const filterParams = (0,_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__["default"])({}, this.state.filters.active);
    if (value) {
      filterParams[columnKey] = value;
    } else {
      delete filterParams[columnKey];
    }

    // Build URL and mark filters as dirty (keep view_id)
    let url = this.buildUrlWithFilters(filterParams);
    const urlObj = new URL(url, window.location.origin);

    // If we're on a view, mark filters as dirty
    if (this.state.view.currentId) {
      urlObj.searchParams.set('dirty[filters]', '1');
    }
    url = urlObj.pathname + urlObj.search;
    this.navigate(url); // Frame nav - toolbar will update via handleFrameLoad
  }

  // ============================================================================
  // Sort Actions
  // ============================================================================

  /**
   * Apply sort to a column
   */
  applySort(event) {
    const field = event.currentTarget.dataset.columnKey;
    if (!field) return;
    const currentSort = this.state.sort;

    // Cycle through: none -> asc -> desc -> none
    let direction = null;
    if (!currentSort || currentSort.field !== field) {
      direction = 'asc';
    } else if (currentSort.direction === 'asc') {
      direction = 'desc';
    }
    // else direction stays null (clear sort)

    const updates = {
      sort: direction ? field : null,
      direction: direction
    };

    // If we're on a view, mark sort as dirty
    if (this.state.view.currentId) {
      updates['dirty[sort]'] = '1';
    }
    const url = this.buildUrl(updates);
    this.navigate(url);
  }

  // ============================================================================
  // Column Actions
  // ============================================================================

  /**
   * Toggle column visibility (checkbox in modal)
   */
  toggleColumn(event) {
    const columnKey = event.currentTarget.dataset.columnKey;
    const listItem = event.currentTarget.closest('[data-column-key]');

    // Prevent toggling required columns
    if (listItem && listItem.dataset.columnRequired === 'true') {
      event.preventDefault();
      return;
    }
    const isVisible = event.currentTarget.checked;

    // Update visual state
    if (listItem) {
      console.log(`Toggling column ${columnKey}: ${isVisible ? 'visible' : 'hidden'}`);
      if (isVisible) {
        listItem.classList.remove('list-group-item-secondary');
        console.log(`Removed 'list-group-item-secondary' class from ${columnKey}`);
      } else {
        listItem.classList.add('list-group-item-secondary');
        console.log(`Added 'list-group-item-secondary' class to ${columnKey}`);
      }
      // Force a visual refresh
      listItem.offsetHeight;
    }
  }

  /**
   * Handle column reorder from sortable list
   */
  handleColumnReorder(event) {
    console.log("Column reorder detected:", event.detail.order);
  }

  /**
   * Apply column changes (from modal)
   */
  applyColumnChanges() {
    // Get visible columns from checkboxes in modal
    const modal = this.element.querySelector(`#columnPickerModal-${this.state.config.gridKey.replace(/\./g, '\\.')}`);
    if (!modal) return;
    const visibleColumns = [];

    // Include checked columns
    modal.querySelectorAll('input[type="checkbox"]:checked').forEach(checkbox => {
      const key = checkbox.dataset.columnKey || checkbox.value;
      if (key) visibleColumns.push(key);
    });

    // Always include required columns even if disabled
    modal.querySelectorAll('[data-column-required="true"]').forEach(item => {
      const key = item.dataset.columnKey;
      if (key && !visibleColumns.includes(key)) {
        visibleColumns.push(key);
      }
    });
    const url = this.buildUrl({
      columns: visibleColumns.join(',')
    });
    this.navigate(url);
  }

  // ============================================================================
  // Helper Methods
  // ============================================================================

  getStickyKeys() {
    if (!this.hasStickyQueryValue || !this.stickyQueryValue) {
      return [];
    }
    return this.stickyQueryValue.split(',').map(key => key.trim()).filter(Boolean);
  }
  captureStickyParamsFromUrl(url) {
    const stickyKeys = this.getStickyKeys();
    if (!stickyKeys.length || !url) {
      return;
    }
    let parsedUrl;
    try {
      parsedUrl = new URL(url, window.location.origin);
    } catch (error) {
      console.warn('Unable to parse URL for sticky parameters:', url, error);
      return;
    }
    stickyKeys.forEach(key => {
      if (parsedUrl.searchParams.has(key)) {
        const value = parsedUrl.searchParams.get(key);
        if (value !== undefined && value !== null) {
          this.stickyParams[key] = value;
        }
      }
    });
  }
  captureStickyParamsFromFrame(frame) {
    if (!frame) {
      return;
    }
    const src = frame.getAttribute('src') || frame.dataset.gridSrc;
    if (src) {
      this.captureStickyParamsFromUrl(src);
    }
    this.updateBrowserUrlWithStickyParams();
  }
  updateBrowserUrlWithStickyParams() {
    const stickyKeys = this.getStickyKeys();
    if (!stickyKeys.length) {
      return;
    }
    const params = new URLSearchParams(window.location.search);
    let changed = false;
    stickyKeys.forEach(key => {
      const value = this.stickyParams[key];
      if (value !== undefined && value !== null && value !== '') {
        const stringValue = String(value);
        if (params.get(key) !== stringValue) {
          params.set(key, stringValue);
          changed = true;
        }
      }
    });
    if (!changed) {
      return;
    }
    const queryString = params.toString();
    const newUrl = queryString ? `${window.location.pathname}?${queryString}` : window.location.pathname;
    window.history.replaceState({}, '', newUrl);
  }
  applyStickyParamsToParams(params, updates = null) {
    const stickyKeys = this.getStickyKeys();
    if (!stickyKeys.length) {
      return;
    }
    stickyKeys.forEach(key => {
      if (updates && Object.prototype.hasOwnProperty.call(updates, key)) {
        const updateValue = updates[key];
        if (updateValue === null || updateValue === undefined || updateValue === '') {
          params.delete(key);
          delete this.stickyParams[key];
        } else {
          const stringValue = String(updateValue);
          params.set(key, stringValue);
          this.stickyParams[key] = stringValue;
        }
      } else {
        const storedValue = this.stickyParams[key];
        if (storedValue !== undefined && storedValue !== null && storedValue !== '') {
          params.set(key, String(storedValue));
        }
      }
    });
  }

  /**
   * Build URL with updated parameters
   */
  buildUrl(updates) {
    const params = new URLSearchParams(window.location.search);

    // Apply updates
    for (const [key, value] of Object.entries(updates)) {
      if (value === null || value === undefined) {
        // Only delete if value is null/undefined
        params.delete(key);
      } else if (value === '') {
        // Empty string means explicitly set to empty (e.g., clearing search on a view)
        params.set(key, '');
      } else {
        params.set(key, value);
      }
    }

    // Ensure sticky parameters persist across navigations
    this.applyStickyParamsToParams(params, updates);

    // Remove filter parameters if not explicitly included
    if (!('filter' in updates)) {
      // Keep existing filters unless we're explicitly clearing them
      // (This is handled by buildUrlWithFilters)
    }
    const queryString = params.toString();
    return queryString ? `${window.location.pathname}?${queryString}` : window.location.pathname;
  }

  /**
   * Build URL with filter parameters
   */
  buildUrlWithFilters(filterParams) {
    const url = new URL(window.location);
    const params = url.searchParams;

    // If we're on a saved view and search hasn't been explicitly dirtied,
    // preserve the current search value in the URL
    const hasSearchDirty = params.has('dirty[search]');
    if (this.state.view.currentId && !hasSearchDirty && this.state.search) {
      params.set('search', this.state.search);
    }

    // Remove all existing filter parameters (both filter[] and date range)
    const keysToDelete = [];
    for (const key of params.keys()) {
      if (key.startsWith('filter[')) {
        keysToDelete.push(key);
      }
      // Also remove date range parameters (_start and _end suffixes)
      if (key.endsWith('_start') || key.endsWith('_end')) {
        keysToDelete.push(key);
      }
    }
    keysToDelete.forEach(key => params.delete(key));

    // Add new filter parameters
    for (const [column, values] of Object.entries(filterParams)) {
      // Check if this is a date range filter (has _start or _end suffix)
      const isDateRangeFilter = column.endsWith('_start') || column.endsWith('_end');
      if (isDateRangeFilter) {
        // Date range filters use direct query parameters (no filter[] prefix)
        const valueArray = Array.isArray(values) ? values : [values];
        if (valueArray.length > 0) {
          params.set(column, valueArray[0]);
        }
      } else {
        // Regular filters use filter[] prefix
        // Always use array syntax (filter[column][]) for consistency, even with single values
        const valueArray = Array.isArray(values) ? values : [values];
        valueArray.forEach(v => params.append(`filter[${column}][]`, v));
      }
    }

    // Reset to page 1
    params.delete('page');

    // Ensure sticky parameters persist
    this.applyStickyParamsToParams(params);
    const queryString = params.toString();
    return queryString ? `${url.pathname}?${queryString}` : url.pathname;
  }

  /**
   * Navigate to URL via Turbo (frame or full page)
   */
  navigate(url, fullPage = false) {
    console.log('Navigating to:', url, 'fullPage:', fullPage);
    if (fullPage) {
      // Full page navigation
      if (window.Turbo) {
        window.Turbo.visit(url);
      } else {
        window.location.assign(url);
      }
    } else {
      // Frame navigation - find the table frame and update its src
      const tableFrame = this.element.querySelector('turbo-frame[id$="-table"]');
      if (tableFrame) {
        // Get the base grid-data URL from the frame's current src
        // This handles embedded grids with custom endpoints like /members/roles-grid-data/1
        const currentSrc = tableFrame.getAttribute('src') || tableFrame.dataset.gridSrc || tableFrame.src;
        if (!currentSrc) {
          console.warn('Table frame has no src attribute');
          return;
        }

        // Parse current src to extract base URL and context parameters
        const currentSrcUrl = new URL(currentSrc, window.location.origin);
        const baseGridDataUrl = currentSrcUrl.pathname;

        // Context parameters that must be preserved (e.g., member_id, branch_id)
        // These identify which entity's data we're viewing
        const contextParams = ['member_id', 'branch_id', 'gathering_id'];

        // Parse the navigation URL to get new query params
        const urlObj = new URL(url, window.location.origin);

        // Build final URL starting with base path
        const finalUrl = new URL(baseGridDataUrl, window.location.origin);

        // Copy all params from the incoming URL
        // Use append() instead of set() to preserve multiple values for the same key (e.g., filter[status][])
        urlObj.searchParams.forEach((value, key) => {
          finalUrl.searchParams.append(key, value);
        });

        // Ensure sticky parameters are carried over for frame requests
        this.applyStickyParamsToParams(finalUrl.searchParams);

        // Preserve context params from original src if not in new URL
        contextParams.forEach(param => {
          if (currentSrcUrl.searchParams.has(param) && !finalUrl.searchParams.has(param)) {
            finalUrl.searchParams.set(param, currentSrcUrl.searchParams.get(param));
          }
        });
        const gridDataUrl = finalUrl.pathname + finalUrl.search;

        // Update browser history with the original URL (for page reload)
        window.history.pushState({}, '', url);

        // Persist sticky parameters based on the navigation URL
        this.captureStickyParamsFromUrl(finalUrl.toString());

        // Navigate the frame by setting src to gridData URL
        tableFrame.src = gridDataUrl;
      } else {
        console.warn('Table frame not found, falling back to full page navigation');
        if (window.Turbo) {
          window.Turbo.visit(url);
        } else {
          window.location.assign(url);
        }
      }
    }
  }

  /**
   * Get current configuration for saving
   */
  getCurrentConfig() {
    // Build filters array from active filters
    const filters = [];

    // Add search if present
    if (this.state.search) {
      filters.push({
        field: '_search',
        operator: 'contains',
        value: this.state.search
      });
    }

    // Add regular filters
    // First, collect date range pairs
    const dateRanges = new Map();
    const regularFilters = [];
    for (const [field, values] of Object.entries(this.state.filters.active)) {
      const valueArray = Array.isArray(values) ? values : [values];
      if (valueArray.length > 0) {
        // Check if this is a date range filter (field ends with _start or _end)
        if (field.endsWith('_start')) {
          const baseField = field.slice(0, -6); // Remove '_start' suffix
          if (!dateRanges.has(baseField)) {
            dateRanges.set(baseField, [null, null]);
          }
          dateRanges.get(baseField)[0] = valueArray[0];
        } else if (field.endsWith('_end')) {
          const baseField = field.slice(0, -4); // Remove '_end' suffix
          if (!dateRanges.has(baseField)) {
            dateRanges.set(baseField, [null, null]);
          }
          dateRanges.get(baseField)[1] = valueArray[0];
        } else {
          regularFilters.push({
            field: field,
            operator: 'in',
            value: valueArray
          });
        }
      }
    }

    // Add date range filters with [start, end] array
    for (const [field, range] of dateRanges) {
      filters.push({
        field: field,
        operator: 'dateRange',
        value: range
      });
    }

    // Add regular filters
    filters.push(...regularFilters);

    // Build sort array
    const sort = [];
    if (this.state.sort && this.state.sort.field) {
      sort.push({
        field: this.state.sort.field,
        direction: this.state.sort.direction
      });
    }

    // Build columns array - normalize visible columns (handle both array and object formats)
    const visibleColumns = Array.isArray(this.state.columns.visible) ? this.state.columns.visible : Object.values(this.state.columns.visible);
    const columns = visibleColumns.map((key, index) => ({
      key: key,
      visible: true,
      order: index
    }));
    return {
      filters: filters,
      sort: sort,
      columns: columns,
      pageSize: this.state.config.pageSize,
      search: this.state.search
    };
  }

  /**
   * Toggle sub-row expansion for additional details
   * 
   * @param {Event} event - Click event from cell with toggleSubRow action
   */
  toggleSubRow(event) {
    event.preventDefault();
    const link = event.currentTarget;
    const rowId = link.dataset.rowId;
    const subRowType = link.dataset.subrowType;
    if (!rowId || !subRowType) {
      console.error('Missing rowId or subRowType for toggleSubRow');
      return;
    }

    // Find the parent table row
    const mainRow = link.closest('tr');
    if (!mainRow) {
      console.error('Could not find parent row for toggleSubRow');
      return;
    }

    // Look for existing sub-row immediately after the main row
    const existingSubRow = mainRow.nextElementSibling;
    const subRowId = `subrow-${rowId}-${subRowType}`;
    if (existingSubRow && existingSubRow.id === subRowId) {
      // Sub-row exists - collapse it
      existingSubRow.remove();
      mainRow.classList.remove('row-expanded');

      // Update icon if present
      const icon = link.querySelector('.toggle-icon');
      if (icon) {
        icon.classList.remove('bi-chevron-down');
        icon.classList.add('bi-chevron-right');
      }
    } else {
      // Sub-row doesn't exist - expand it
      const colspan = mainRow.querySelectorAll('td').length;

      // Fetch sub-row content from server
      const url = `/members/sub-row/${rowId}/${subRowType}`;
      fetch(url, {
        headers: {
          'X-Requested-With': 'XMLHttpRequest',
          'Accept': 'text/html'
        }
      }).then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error ${response.status}`);
        }
        return response.text();
      }).then(html => {
        // Create sub-row element
        const subRow = document.createElement('tr');
        subRow.id = subRowId;
        subRow.className = 'sub-row';
        subRow.innerHTML = `<td colspan="${colspan}" class="sub-row-content">${html}</td>`;

        // Insert after main row
        mainRow.insertAdjacentElement('afterend', subRow);
        mainRow.classList.add('row-expanded');

        // Update icon if present
        const icon = link.querySelector('.toggle-icon');
        if (icon) {
          icon.classList.remove('bi-chevron-right');
          icon.classList.add('bi-chevron-down');
        }
      }).catch(error => {
        console.error('Error loading sub-row:', error);
        // Show error in a sub-row
        const subRow = document.createElement('tr');
        subRow.id = subRowId;
        subRow.className = 'sub-row sub-row-error';
        subRow.innerHTML = `<td colspan="${colspan}" class="sub-row-content text-danger">
                    <small>Error loading details. Please try again.</small>
                </td>`;
        mainRow.insertAdjacentElement('afterend', subRow);
      });
    }
  }

  /**
   * Export current grid data to CSV
   * 
   * Triggers a CSV export with current filters, search, sort, and column selection.
   * Uses the table frame's src URL as base (handles embedded grids with custom endpoints).
   */
  exportCsv() {
    // Find the table frame to get the correct data endpoint
    const tableFrame = this.element.querySelector('turbo-frame[id$="-table"]');
    if (!tableFrame) {
      console.warn('Table frame not found, cannot export');
      return;
    }

    // Get the base grid-data URL from the frame's src
    const currentSrc = tableFrame.getAttribute('src') || tableFrame.dataset.gridSrc || tableFrame.src;
    if (!currentSrc) {
      console.warn('Table frame has no src attribute');
      return;
    }

    // Parse current src to build export URL
    const srcUrl = new URL(currentSrc, window.location.origin);

    // Add export parameter
    srcUrl.searchParams.set('export', 'csv');

    // Navigate to CSV export URL (will trigger download)
    window.location.href = srcUrl.toString();
  }

  /**
   * Get CSRF token from meta tag
   */
  getCsrfToken() {
    const meta = document.querySelector('meta[name="csrf-token"]');
    return meta ? meta.content : "";
  }
}

// Register controller globally
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["grid-view"] = GridViewController;
/* harmony default export */ __webpack_exports__["default"] = (GridViewController);

/***/ }),

/***/ "./assets/js/controllers/guifier-controller.js":
/*!*****************************************************!*\
  !*** ./assets/js/controllers/guifier-controller.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var guifier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! guifier */ "./node_modules/guifier/dist/Guifier.js");

const {
  Controller
} = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

/**
 * Guifier Stimulus Controller
 * 
 * Integrates Guifier dynamic form generation library with Stimulus for 
 * JSON schema-based configuration interfaces. Provides real-time form 
 * generation and data binding with automatic change propagation.
 * 
 * Features:
 * - JSON schema-based form generation
 * - Real-time data binding and updates
 * - Fullscreen editing interface
 * - Automatic form collapse management
 * - Change event propagation
 * - Configurable data types (JSON, YAML, etc.)
 * 
 * Values:
 * - type: String - Data type for Guifier (json, yaml, etc.)
 * 
 * Targets:
 * - hidden: Hidden input field containing form data
 * - container: Container element for Guifier interface
 * 
 * Usage:
 * <div data-controller="guifier-control" data-guifier-control-type-value="json">
 *   <input data-guifier-control-target="hidden" type="hidden" name="settings">
 *   <div data-guifier-control-target="container" id="guifier-container"></div>
 * </div>
 */
class GuifierController extends Controller {
  static targets = ["hidden", "container"];
  static values = {
    type: String
  };

  /**
   * Connect controller and initialize Guifier
   * Sets up dynamic form interface with data binding and change handling
   */
  connect() {
    var params = {
      elementSelector: '#' + this.containerTarget.id,
      data: this.hiddenTarget.value,
      dataType: this.typeValue,
      rootContainerName: 'setting',
      fullScreen: true,
      autoDownloadFontAwesome: false,
      // Font Awesome is already loaded via @fortawesome/fontawesome-free
      onChange: () => {
        this.hiddenTarget.value = this.guifier.getData(this.typeValue);
        // console.log(this.hiddenTarget.value);
        this.hiddenTarget.dispatchEvent(new Event('change'));
      }
    };
    this.guifier = new guifier__WEBPACK_IMPORTED_MODULE_0__["default"](params);
    //find all the elements with guifierContainerCollapseButton class and click them
    var collapseButtons = this.containerTarget.querySelectorAll('.guifierContainerCollapseButton');
    collapseButtons.forEach(function (button) {
      button.click();
    });
  }
}
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["guifier-control"] = GuifierController;

/***/ }),

/***/ "./assets/js/controllers/image-preview-controller.js":
/*!***********************************************************!*\
  !*** ./assets/js/controllers/image-preview-controller.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * ImagePreview Stimulus Controller
 * 
 * Provides real-time image preview functionality for file upload forms.
 * Creates object URLs for selected images and displays them immediately
 * for better user experience during file selection.
 * 
 * Features:
 * - Instant image preview on file selection
 * - Object URL creation and management
 * - Loading state management
 * - Preview visibility control
 * - Automatic cleanup of resources
 * 
 * Targets:
 * - file: File input element for image selection
 * - preview: Image element for displaying preview
 * - loading: Loading indicator element
 * 
 * Usage:
 * <div data-controller="image-preview">
 *   <input data-image-preview-target="file" 
 *          data-action="change->image-preview#preview" 
 *          type="file" accept="image/*">
 *   <div data-image-preview-target="loading">Loading...</div>
 *   <img data-image-preview-target="preview" hidden>
 * </div>
 */
class ImagePreview extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ['file', 'preview', 'loading'];
  static values = {
    maxSize: Number,
    maxSizeFormatted: String
  };
  connect() {
    // If this controller doesn't have explicit max size values, try to
    // inherit them from the nearest enclosing file-size-validator scope.
    if (!this.hasMaxSizeValue) {
      const inherited = this.element.closest('[data-file-size-validator-max-size-value]');
      if (inherited?.dataset?.fileSizeValidatorMaxSizeValue) {
        const parsed = parseInt(inherited.dataset.fileSizeValidatorMaxSizeValue, 10);
        if (!Number.isNaN(parsed)) {
          this.maxSizeValue = parsed;
        }
      }
    }
    if (!this.hasMaxSizeFormattedValue) {
      const inherited = this.element.closest('[data-file-size-validator-max-size-formatted-value]');
      if (inherited?.dataset?.fileSizeValidatorMaxSizeFormattedValue) {
        this.maxSizeFormattedValue = inherited.dataset.fileSizeValidatorMaxSizeFormattedValue;
      }
    }
  }
  buildOversizeMessage(file) {
    const maxSize = this.maxSizeFormattedValue || this.formatBytes(this.maxSizeValue || 0);
    return `The file "${file.name}" (${this.formatBytes(file.size)}) exceeds the maximum upload size of ${maxSize}.`;
  }
  formatBytes(bytes, decimals = 2) {
    if (!bytes || bytes === 0) return '0 Bytes';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
  }

  /**
   * Generate and display image preview
   * Creates object URL for selected image and updates preview display
   * 
   * @param {Event} event - Change event from file input
   */
  preview(event) {
    if (event.target.files.length > 0) {
      const file = event.target.files[0];
      if (this.hasMaxSizeValue && this.maxSizeValue > 0 && file.size > this.maxSizeValue) {
        alert(this.buildOversizeMessage(file));

        // Clear invalid selection so validators + UI stay consistent
        event.target.value = '';
        return;
      }
      const reader = new FileReader();
      reader.onload = () => {
        this.previewTarget.src = reader.result; // This will be a data: URL
        this.loadingTarget.classList.add("d-none");
        this.previewTarget.hidden = false;
      };
      reader.readAsDataURL(file);
    }
  }
}
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["image-preview"] = ImagePreview;

/***/ }),

/***/ "./assets/js/controllers/kanban-controller.js":
/*!****************************************************!*\
  !*** ./assets/js/controllers/kanban-controller.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

const optionSelector = "[role='option']:not([aria-disabled])";
const activeSelector = "[aria-selected='true']";

/**
 * Kanban Stimulus Controller
 * 
 * Implements drag-and-drop functionality for Kanban board interfaces with
 * server synchronization and position tracking. Provides comprehensive
 * card movement, visual feedback, and AJAX-based persistence.
 * 
 * Features:
 * - Drag-and-drop card movement between columns
 * - Visual feedback during drag operations
 * - Position restoration on invalid drops
 * - Server synchronization via AJAX
 * - CSRF protection for security
 * - Validation callbacks before drop
 * - Automatic position calculation
 * 
 * Values:
 * - csrfToken: String - CSRF token for secure requests
 * - url: String - API endpoint for position updates
 * 
 * Targets:
 * - card: Individual card elements that can be dragged
 * - column: Column containers for card organization
 * 
 * Usage:
 * <div data-controller="kanban" 
 *      data-kanban-csrf-token-value="<%= @csrf_token %>"
 *      data-kanban-url-value="/api/cards/move">
 *   <div data-kanban-target="column" class="sortable" data-col="todo">
 *     <div data-kanban-target="card" data-rec-id="1" data-stack-rank="100"
 *          draggable="true" data-action="dragstart->kanban#grabCard">
 *       Card Content
 *     </div>
 *   </div>
 * </div>
 */
class Kanban extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["card", "column"];
  static values = {
    csrfToken: String,
    url: String
  };

  /**
   * Initialize controller state
   * Sets up drag tracking variables
   */
  initialize() {
    this.draggedItem = null;
  }

  /**
   * Register callback function to validate drops before processing
   * Allows custom validation logic for card movements
   * 
   * @param {Function} callback - Validation function returning boolean
   */
  registerBeforeDrop(callback) {
    this.beforeDropCallback = callback;
  }

  /**
   * Handle card drag operation
   * Processes drag movement without dropping
   * 
   * @param {DragEvent} event - Drag event from card element
   */
  cardDrag(event) {
    event.preventDefault();
    this.processDrag(event, false);
  }

  /**
   * Connect controller to DOM
   * Sets up global drag and drop event listeners
   */
  connect() {
    // Add event listeners for drag and drop events 
    document.addEventListener('dragover', this.handleDragOver.bind(this));
    document.addEventListener('drop', this.handleDrop.bind(this));
  }

  /**
   * Disconnect controller from DOM
   * Cleans up global event listeners
   */
  disconnect() {
    // Remove event listeners when the controller is disconnected
    document.removeEventListener('dragover', this.handleDragOver.bind(this));
    document.removeEventListener('drop', this.handleDrop.bind(this));
  }

  /**
   * Handle global drag over events
   * Prevents default behavior to enable drop
   * 
   * @param {DragEvent} event - Global dragover event
   */
  handleDragOver(event) {
    event.preventDefault();
  }

  /**
   * Handle global drop events
   * Restores original position if dropped outside valid area
   * 
   * @param {DragEvent} event - Global drop event
   */
  handleDrop(event) {
    event.preventDefault();
    if (!this.element.contains(event.target)) {
      console.log('Dropped outside of the table');
      // Handle the drop outside of the table
      this.restoreOriginalPosition();
    }
  }

  /**
   * Restore card to its original position
   * Used when drop is invalid or cancelled
   */
  restoreOriginalPosition() {
    if (this.draggedItem && this.originalParent) {
      // Insert the dragged item back to its original position
      if (this.originalIndex >= this.originalParent.children.length) {
        this.originalParent.appendChild(this.draggedItem);
      } else {
        this.originalParent.insertBefore(this.draggedItem, this.originalParent.children[this.originalIndex]);
      }
      this.draggedItem.classList.remove("opacity-25");
      this.draggedItem = null;
    }
  }

  /**
   * Handle card drop operation
   * Processes final drop with server synchronization
   * 
   * @param {DragEvent} event - Drop event from target element
   */
  dropCard(event) {
    event.preventDefault();
    this.processDrag(event, true);
    this.draggedItem.classList.remove("opacity-25");
    this.draggedItem = null;
  }

  /**
   * Handle card grab (drag start)
   * Sets up drag operation and records original position
   * 
   * @param {DragEvent} event - Dragstart event from card element
   */
  grabCard(event) {
    var target = event.target;
    target.classList.add("opacity-25");
    this.draggedItem = target;
    //record where the object is in the dom before it is moved
    this.originalParent = this.draggedItem.parentElement;
    this.originalIndex = Array.prototype.indexOf.call(this.originalParent.children, this.draggedItem);
  }

  /**
   * Process drag operation with position calculation and server sync
   * Handles both preview and final drop operations
   * 
   * @param {DragEvent} event - Drag or drop event
   * @param {Boolean} isDrop - Whether this is final drop operation
   */
  processDrag(event, isDrop) {
    //console.log(event);
    var targetCol = event.target;
    var entityId = this.draggedItem.dataset['recId'];
    var targetStackRank = null;
    while (!targetCol.classList.contains('sortable')) {
      if (targetCol.tagName == 'BODY') {
        return;
      }
      targetCol = targetCol.parentElement;
    }
    var targetBefore = event.target;
    var foundBefore = true;
    while (!targetBefore.classList.contains('card')) {
      if (targetBefore.tagName == 'TD') {
        foundBefore = false;
        break;
      }
      targetBefore = targetBefore.parentElement;
    }
    if (foundBefore) {
      targetStackRank = targetBefore.dataset['stackRank'];
    }
    if (targetCol.classList.contains('sortable')) {
      const data = event.dataTransfer.getData('Text');
      if (foundBefore) {
        targetCol.insertBefore(this.draggedItem, targetBefore);
      } else {
        targetCol.appendChild(this.draggedItem);
      }
      if (isDrop) {
        //in the targetCol get the card before the draggedItem
        var palaceAfter = -1;
        var palaceBefore = -1;
        var previousSibling = this.draggedItem.previousElementSibling;
        if (previousSibling) {
          palaceAfter = previousSibling.dataset['recId'];
        } else {
          palaceAfter = -1;
        }
        var nextSibling = this.draggedItem.nextElementSibling;
        if (nextSibling) {
          palaceBefore = nextSibling.dataset['recId'];
        } else {
          palaceBefore = -1;
        }
        var toCol = targetCol.dataset['col'];
        if (this.beforeDropCallback && !this.beforeDropCallback(entityId, toCol)) {
          this.restoreOriginalPosition();
          return;
        }
        fetch(this.urlValue + "/" + entityId, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": this.csrfTokenValue
          },
          body: JSON.stringify({
            newCol: targetCol.dataset['col'],
            placeAfter: palaceAfter,
            placeBefore: palaceBefore
          })
        });
      }
    }
  }
}
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["kanban"] = Kanban;

/***/ }),

/***/ "./assets/js/controllers/markdown-editor-controller.js":
/*!*************************************************************!*\
  !*** ./assets/js/controllers/markdown-editor-controller.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/* harmony import */ var easymde__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! easymde */ "./node_modules/easymde/src/js/easymde.js");
/* harmony import */ var easymde__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(easymde__WEBPACK_IMPORTED_MODULE_1__);



/**
 * Markdown Editor Controller
 * 
 * Initializes an EasyMDE markdown editor on a textarea element.
 * 
 * Usage:
 * <textarea data-controller="markdown-editor"
 *           data-markdown-editor-placeholder-value="Enter your markdown here..."
 *           data-markdown-editor-min-height-value="200px"></textarea>
 * 
 * Values:
 * - placeholder: Placeholder text for the editor (optional)
 * - minHeight: Minimum height of the editor (default: "300px")
 */
class MarkdownEditorController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static values = {
    placeholder: {
      type: String,
      default: "Enter text here..."
    },
    minHeight: {
      type: String,
      default: "300px"
    }
  };

  // Initialize function
  initialize() {
    this.editor = null;
  }

  // Connect function - runs when controller connects to DOM
  connect() {
    // Initialize EasyMDE on the textarea
    this.editor = new (easymde__WEBPACK_IMPORTED_MODULE_1___default())({
      element: this.element,
      placeholder: this.placeholderValue,
      minHeight: this.minHeightValue,
      spellChecker: false,
      autoDownloadFontAwesome: false,
      // Font Awesome is already loaded via @fortawesome/fontawesome-free
      status: ["lines", "words", "cursor"],
      toolbar: ["bold", "italic", "heading", "|", "quote", "unordered-list", "ordered-list", "|", "link", "image", "|", "preview", "side-by-side", "fullscreen", "|", "guide"],
      // Ensure the editor works with form submissions
      forceSync: true,
      // Configure autosave
      autosave: {
        enabled: false
      },
      // Improve the preview rendering
      previewRender: function (plainText) {
        // Basic markdown to HTML conversion for preview
        // You can enhance this with a proper markdown parser if needed
        return this.parent.markdown(plainText);
      }
    });

    // Log editor initialization
    console.log('Markdown editor initialized on:', this.element);
  }

  // Disconnect function - cleanup when controller disconnects
  disconnect() {
    if (this.editor) {
      this.editor.toTextArea();
      this.editor = null;
      console.log('Markdown editor cleaned up');
    }
  }

  // Public method to get markdown content
  getValue() {
    return this.editor ? this.editor.value() : '';
  }

  // Public method to set markdown content
  setValue(value) {
    if (this.editor) {
      this.editor.value(value);
    }
  }
}

// Add to global controllers registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["markdown-editor"] = MarkdownEditorController;

/***/ }),

/***/ "./assets/js/controllers/member-card-profile-controller.js":
/*!*****************************************************************!*\
  !*** ./assets/js/controllers/member-card-profile-controller.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * MemberCardProfile Stimulus Controller
 * 
 * Manages multi-card member profile displays with dynamic layout and content organization.
 * Automatically loads member data via AJAX and creates additional cards when content
 * overflow occurs, ensuring optimal readability and presentation.
 * 
 * Features:
 * - Dynamic card creation with overflow management
 * - AJAX-based member data loading
 * - Plugin content organization and display
 * - Membership status tracking and expiration handling
 * - Background check status display
 * - Responsive card layout with space calculation
 * - Multi-section content organization
 * 
 * Values:
 * - url: String - API endpoint for member data
 * 
 * Targets:
 * - cardSet: Container for all profile cards
 * - firstCard: Initial card element
 * - name: Member name display element
 * - scaName: SCA name display element
 * - branchName: Branch name display element
 * - membershipInfo: Membership information display
 * - backgroundCheck: Background check status display
 * - lastUpdate: Last update timestamp display
 * - loading: Loading indicator element
 * - memberDetails: Member details container
 * 
 * Usage:
 * <div data-controller="member-card-profile" data-member-card-profile-url-value="/api/member/123">
 *   <div data-member-card-profile-target="cardSet">
 *     <div data-member-card-profile-target="firstCard" class="auth_card">
 *       <div data-member-card-profile-target="loading">Loading...</div>
 *       <div data-member-card-profile-target="memberDetails" hidden>
 *         <div data-member-card-profile-target="name"></div>
 *         <div data-member-card-profile-target="scaName"></div>
 *         <!-- Additional profile elements -->
 *       </div>
 *     </div>
 *   </div>
 * </div>
 */
class MemberCardProfile extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["cardSet", "firstCard", "name", "scaName", "branchName", "membershipInfo", "backgroundCheck", "lastUpdate", "loading", "memberDetails"];
  static values = {
    url: String
  };

  /**
   * Initialize controller state
   * Sets up card management variables
   */
  initialize() {
    this.currentCard = null;
    this.cardCount = 1;
    this.maxCardLength = 0;
  }

  /**
   * Calculate used space in current card
   * Measures total height of all child elements
   * 
   * @returns {Number} Total height of card content in pixels
   */
  usedSpaceInCard() {
    var cardChildren = this.currentCard.children;
    var runningTotal = 0;
    for (var i = 0; i < cardChildren.length; i++) {
      runningTotal += cardChildren[i].offsetHeight;
    }
    return runningTotal;
  }

  /**
   * Append element to card with overflow handling
   * Creates new card if content would exceed available space
   * 
   * @param {HTMLElement} element - Element to append to card
   * @param {Number|null} minSpace - Minimum space percentage to maintain
   */
  appendToCard(element, minSpace) {
    this.currentCard.appendChild(element);
    if (minSpace === null) {
      minSpace = 2;
    }
    minSpace = this.maxCardLength * (minSpace / 100);
    if (this.usedSpaceInCard() > this.maxCardLength - minSpace) {
      this.currentCard.removeChild(element);
      this.startCard();
      this.currentCard.appendChild(element);
    }
  }

  /**
   * Create and initialize new card
   * Sets up new card structure and updates current card reference
   */
  startCard() {
    this.cardCount++;
    var card = document.createElement("div");
    card.classList.add("auth_card");
    card.id = "card_" + this.cardCount;
    var cardDetails = document.createElement("div");
    cardDetails.classList.add("cardbox");
    cardDetails.id = "cardDetails_" + this.cardCount;
    card.appendChild(cardDetails);
    this.cardSetTarget.appendChild(card);
    this.currentCard = cardDetails;
  }

  /**
   * Configure fetch options for AJAX requests
   * Sets up headers for JSON API communication
   * 
   * @returns {Object} Fetch options object
   */
  optionsForFetch() {
    return {
      headers: {
        "X-Requested-With": "XMLHttpRequest",
        "Accept": "application/json"
      }
    };
  }

  /**
   * Load member card data from API
   * Fetches member information and organizes plugin content into cards
   */
  loadCard() {
    this.currentCard = this.firstCardTarget;
    this.maxCardLength = this.firstCardTarget.offsetHeight;
    this.cardCount = 1;
    fetch(this.urlValue, this.optionsForFetch()).then(response => response.json()).then(data => {
      this.nameTarget.textContent = data.member.first_name + ' ' + data.member.last_name;
      this.scaNameTarget.textContent = data.member.sca_name;
      this.branchNameTarget.textContent = data.member.branch.name;
      if (data.member.membership_number && data.member.membership_number.length > 0) {
        var memberExpDate = new Date(data.member.membership_expires_on);
        if (memberExpDate < new Date()) {
          memberExpDate = "Expired";
        } else {
          memberExpDate = " - " + memberExpDate.toLocaleDateString();
        }
        this.membershipInfoTarget.textContent = data.member.membership_number + ' ' + memberExpDate;
      } else {
        this.membershipInfoTarget.innerHtml = "";
        this.membershipInfoTarget.textContent = "No Membership Info";
      }
      if (data.member.background_check_expires_on) {
        var backgroundCheckExpDate = new Date(data.member.background_check_expires_on);
        if (backgroundCheckExpDate < new Date()) {
          backgroundCheckExpDate = "Expired";
        } else {
          backgroundCheckExpDate = " - " + backgroundCheckExpDate.toLocaleDateString();
        }
        var strong = document.createElement("strong");
        strong.textContent = backgroundCheckExpDate;
        this.backgroundCheckTarget.innerHtml = "";
        this.backgroundCheckTarget.appendChild(strong);
      } else {
        this.backgroundCheckTarget.innerHtml = "";
        this.backgroundCheckTarget.textContent = "No Background Check";
      }
      var today = new Date();
      this.lastUpdateTarget.textContent = today.toLocaleDateString();
      this.loadingTarget.hidden = true;
      this.memberDetailsTarget.hidden = false;
      for (let key in data) {
        if (key === 'member') {
          continue;
        }
        var pluginData = data[key];
        for (let sectionKey in pluginData) {
          var sectionData = pluginData[sectionKey];
          var groupCount = sectionData.length;
          if (groupCount === 0) {
            continue;
          }
          var sectionHeader = document.createElement("h3");
          sectionHeader.textContent = sectionKey;
          this.appendToCard(sectionHeader, 20);
          for (let groupKey in sectionData) {
            var groupData = sectionData[groupKey];
            var groupHeader = document.createElement("h5");
            groupHeader.textContent = groupKey;
            var groupDiv = document.createElement("div");
            groupDiv.classList.add("cardGroup");
            groupDiv.appendChild(groupHeader);
            var groupList = document.createElement("ul");
            for (let i = 0; i < groupData.length; i++) {
              var itemValue = groupData[i];
              var listItem = document.createElement("li");
              listItem.textContent = itemValue;
              groupList.appendChild(listItem);
            }
            groupDiv.appendChild(groupList);
            this.appendToCard(groupDiv, 10);
          }
        }
      }
    });
  }

  /**
   * Connect controller to DOM
   * Initiates card loading process
   */
  connect() {
    this.loadCard();
  }
}
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["member-card-profile"] = MemberCardProfile;

/***/ }),

/***/ "./assets/js/controllers/member-mobile-card-menu-controller.js":
/*!*********************************************************************!*\
  !*** ./assets/js/controllers/member-mobile-card-menu-controller.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * MemberMobileCardMenu Stimulus Controller
 * 
 * Manages mobile-optimized menu interface for PWA member cards with floating
 * action button (FAB) style menu system. Provides plugin-based menu item
 * registration and navigation for mobile-optimized features.
 * 
 * Features:
 * - Floating action button (FAB) menu interface
 * - Plugin-registered menu items with icons and badges
 * - Mobile-optimized touch interactions
 * - Expandable/collapsible menu system
 * - Bootstrap icon integration
 * - Notification badge support
 * - Smooth animations and transitions
 * - Accessible ARIA attributes
 * 
 * Values:
 * - menuItems: String (JSON) - Array of menu item configurations from plugins
 * 
 * Targets:
 * - fab: Main floating action button
 * - menu: Menu items container
 * - menuItem: Individual menu item buttons
 * - badge: Notification badge elements
 * 
 * Menu Item Structure (from plugins):
 * {
 *   label: "Submit Waiver",
 *   icon: "bi-file-earmark-text",  // Bootstrap icon class
 *   url: "/waivers/mobile-submit",
 *   order: 10,
 *   badge: null | number,  // Optional notification count
 *   color: "primary" | "success" | "danger" | etc
 * }
 * 
 * Usage:
 * <div data-controller="member-mobile-card-menu"
 *      data-member-mobile-card-menu-menu-items-value='[...]'>
 *   <button data-member-mobile-card-menu-target="fab"
 *           data-action="click->member-mobile-card-menu#toggleMenu">
 *     <i class="bi bi-three-dots"></i>
 *   </button>
 *   <div data-member-mobile-card-menu-target="menu" hidden>
 *     <!-- Menu items rendered here -->
 *   </div>
 * </div>
 */
class MemberMobileCardMenu extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["fab", "menu", "menuItem", "badge"];
  static values = {
    menuItems: String
  };

  /**
   * Initialize controller state
   * Sets up menu state tracking
   */
  initialize() {
    this.menuOpen = false;
    this.items = [];
    this.isOnline = navigator.onLine;
    this.authCardUrl = null;
    // Create bound handler for outside clicks
    this._handleOutsideClick = this.handleOutsideClick.bind(this);
    // Create bound handler for connection status changes
    this._handleConnectionStatusChanged = this.handleConnectionStatusChanged.bind(this);
  }

  /**
   * Connect controller to DOM
   * Initializes menu with plugin-registered items
   */
  connect() {
    console.log("MemberMobileCardMenu connected");
    this.loadMenuItems();
    this.renderMenu();

    // Register outside click handler
    document.addEventListener('click', this._handleOutsideClick);
    document.addEventListener('touchstart', this._handleOutsideClick);

    // Register connection status handler
    document.addEventListener('connection-status-changed', this._handleConnectionStatusChanged);

    // Update initial offline state
    this.updateOfflineState();
  }

  /**
   * Load menu items from JSON value
   * Parses and validates plugin-registered menu items
   */
  loadMenuItems() {
    try {
      if (this.menuItemsValue) {
        this.items = JSON.parse(this.menuItemsValue);
        // Sort by order
        this.items.sort((a, b) => (a.order || 999) - (b.order || 999));
        console.log("Loaded menu items:", this.items);
      }
    } catch (error) {
      console.error("Error parsing menu items:", error);
      this.items = [];
    }
  }

  /**
   * Render menu items into DOM
   * Creates button elements for each menu item with icons and badges
   */
  renderMenu() {
    if (!this.hasMenuTarget || this.items.length === 0) {
      return;
    }

    // Clear existing menu items
    this.menuTarget.innerHTML = '';

    // Create menu items
    this.items.forEach(item => {
      const menuItem = this.createMenuItem(item);
      this.menuTarget.appendChild(menuItem);
    });
  }

  /**
   * Create menu item DOM element
   * Generates button with icon, label, and optional badge
   * 
   * @param {Object} item Menu item configuration
   * @returns {HTMLElement} Menu item button element
   */
  createMenuItem(item) {
    const button = document.createElement('a');
    button.href = item.url;
    button.className = `btn btn-${item.color || 'primary'} btn-lg w-100 mb-2 d-flex align-items-center justify-content-between mobile-menu-item`;
    button.setAttribute('data-member-mobile-card-menu-target', 'menuItem');
    button.setAttribute('data-action', 'click->member-mobile-card-menu#closeMenu');
    button.setAttribute('role', 'button');
    button.setAttribute('aria-label', item.label);

    // Store the item data for offline state management
    button.dataset.itemLabel = item.label;
    button.dataset.itemUrl = item.url;

    // Create content wrapper
    const content = document.createElement('span');
    content.className = 'd-flex align-items-center';

    // Add icon
    if (item.icon) {
      const icon = document.createElement('i');
      icon.className = `bi ${item.icon} me-2`;
      icon.setAttribute('aria-hidden', 'true');
      content.appendChild(icon);
    }

    // Add label
    const label = document.createElement('span');
    label.textContent = item.label;
    content.appendChild(label);
    button.appendChild(content);

    // Add badge if present
    if (item.badge !== null && item.badge !== undefined && item.badge > 0) {
      const badge = document.createElement('span');
      badge.className = 'badge bg-danger rounded-pill';
      badge.setAttribute('data-member-mobile-card-menu-target', 'badge');
      badge.textContent = item.badge;
      button.appendChild(badge);
    }
    return button;
  }

  /**
   * Toggle menu open/closed state
   * Handles FAB button click to show/hide menu
   * 
   * @param {Event} event Click event
   */
  toggleMenu(event) {
    event.preventDefault();
    if (this.menuOpen) {
      this.closeMenu();
    } else {
      this.openMenu();
    }
  }

  /**
   * Open menu display
   * Shows menu items with animation
   */
  openMenu() {
    if (!this.hasMenuTarget) return;
    this.menuOpen = true;
    this.menuTarget.hidden = false;

    // Add animation class
    this.menuTarget.classList.add('menu-opening');

    // Update FAB appearance
    if (this.hasFabTarget) {
      this.fabTarget.classList.add('menu-active');
    }

    // Remove animation class after animation completes
    setTimeout(() => {
      this.menuTarget.classList.remove('menu-opening');
    }, 300);
  }

  /**
   * Close menu display
   * Hides menu items with animation
   */
  closeMenu() {
    if (!this.hasMenuTarget) return;
    this.menuOpen = false;

    // Add closing animation class
    this.menuTarget.classList.add('menu-closing');

    // Update FAB appearance
    if (this.hasFabTarget) {
      this.fabTarget.classList.remove('menu-active');
    }

    // Hide after animation completes
    setTimeout(() => {
      this.menuTarget.hidden = true;
      this.menuTarget.classList.remove('menu-closing');
    }, 300);
  }

  /**
   * Handle clicks outside menu to close it
   * 
   * @param {Event} event Click event
   */
  handleOutsideClick(event) {
    if (!this.menuOpen) return;

    // Check if click is outside menu and FAB
    const clickedOutside = !this.element.contains(event.target);
    if (clickedOutside) {
      this.closeMenu();
    }
  }

  /**
   * Handle connection status changes from PWA controller
   * 
   * @param {CustomEvent} event Connection status event
   */
  handleConnectionStatusChanged(event) {
    this.isOnline = event.detail.isOnline;
    this.authCardUrl = event.detail.authCardUrl;
    this.updateOfflineState();
  }

  /**
   * Update menu items based on offline state
   * Disables/grays out non-auth-card items when offline
   */
  updateOfflineState() {
    if (!this.hasMenuItemTarget) return;
    this.menuItemTargets.forEach(item => {
      const itemUrl = item.dataset.itemUrl;
      const itemLabel = item.dataset.itemLabel;

      // Check if this is the Auth Card item
      const isAuthCard = itemLabel === 'Auth Card' || this.authCardUrl && itemUrl && itemUrl.includes('viewMobileCard');
      if (!this.isOnline && !isAuthCard) {
        // Offline and not auth card - disable
        item.classList.add('disabled');
        item.style.opacity = '0.5';
        item.style.pointerEvents = 'none';
        item.setAttribute('aria-disabled', 'true');
      } else {
        // Online or is auth card - enable
        item.classList.remove('disabled');
        item.style.opacity = '1';
        item.style.pointerEvents = 'auto';
        item.removeAttribute('aria-disabled');
      }
    });
  }

  /**
   * Disconnect controller from DOM
   * Cleans up event listeners
   */
  disconnect() {
    // Remove outside click handlers
    if (this._handleOutsideClick) {
      document.removeEventListener('click', this._handleOutsideClick);
      document.removeEventListener('touchstart', this._handleOutsideClick);
    }

    // Remove connection status handler
    if (this._handleConnectionStatusChanged) {
      document.removeEventListener('connection-status-changed', this._handleConnectionStatusChanged);
    }
    console.log("MemberMobileCardMenu disconnected");
  }
}

// Register controller globally
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["member-mobile-card-menu"] = MemberMobileCardMenu;

/***/ }),

/***/ "./assets/js/controllers/member-mobile-card-profile-controller.js":
/*!************************************************************************!*\
  !*** ./assets/js/controllers/member-mobile-card-profile-controller.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * MemberMobileCardProfile Stimulus Controller
 * 
 * Manages mobile-optimized member profile card display with PWA integration and
 * responsive design. Provides Bootstrap table layout optimized for mobile viewing
 * with automatic content organization and plugin data display.
 * 
 * Features:
 * - Mobile-optimized profile card layout
 * - PWA readiness integration and state management
 * - Bootstrap table-based responsive design
 * - Automatic plugin content organization
 * - Member status tracking with expiration handling
 * - Dynamic card generation for multiple sections
 * - Column-based data formatting for mobile display
 * - Real-time loading states and user feedback
 * 
 * Values:
 * - url: String - API endpoint for member profile data
 * - pwaReady: Boolean - PWA availability state for conditional loading
 * 
 * Targets:
 * - cardSet: Container for generated profile cards
 * - name: Member's full name display
 * - scaName: Member's SCA name display
 * - branchName: Member's branch name display
 * - membershipInfo: Membership number and expiration info
 * - backgroundCheck: Background check status and expiration
 * - lastUpdate: Last update timestamp display
 * - loading: Loading state indicator
 * - memberDetails: Container for member information
 * 
 * Usage:
 * <div data-controller="member-mobile-card-profile" 
 *      data-member-mobile-card-profile-url-value="/api/member/123/mobile"
 *      data-member-mobile-card-profile-pwa-ready-value="false">
 *   <div data-member-mobile-card-profile-target="loading">Loading...</div>
 *   <div data-member-mobile-card-profile-target="memberDetails" hidden>
 *     <h2 data-member-mobile-card-profile-target="name"></h2>
 *     <p data-member-mobile-card-profile-target="scaName"></p>
 *     <div data-member-mobile-card-profile-target="cardSet"></div>
 *   </div>
 * </div>
 */
class MemberMobileCardProfile extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["cardSet", "name", "scaName", "branchName", "membershipInfo", "backgroundCheck", "lastUpdate", "loading", "memberDetails"];
  static values = {
    url: String,
    pwaReady: Boolean
  };

  /**
   * Initialize controller state
   * Sets up card generation tracking variables
   */
  initialize() {
    this.currentCard = null;
    this.cardCount = 0;

    // Listen for PWA ready event
    this.handlePwaReady = this.handlePwaReady.bind(this);
  }

  /**
   * Disconnect controller from DOM
   * Cleans up event listeners
   */
  disconnect() {
    this.element.removeEventListener('pwa-ready', this.handlePwaReady);
  }

  /**
   * Handle PWA ready event from PWA controller
   */
  handlePwaReady() {
    this.pwaReadyValue = true;
  }

  /**
   * Create and initialize new mobile card with Bootstrap styling
   * Generates responsive card structure optimized for mobile viewing
   * 
   * @param {String} title - Title for the card section
   */
  startCard(title) {
    this.cardCount++;
    var card = document.createElement("div");
    card.classList.add("card", "cardbox", "m-3");
    card.id = "card_" + this.cardCount;
    var cardDetails = document.createElement("div");
    cardDetails.classList.add("card-body");
    cardDetails.id = "cardDetails_" + this.cardCount;
    var cardTitle = document.createElement("h3");
    cardTitle.classList.add("card-title", "text-center", "display-6");
    cardTitle.textContent = title;
    cardDetails.appendChild(cardTitle);
    card.appendChild(cardDetails);
    this.cardSetTarget.appendChild(card);
    this.currentCard = cardDetails;
  }

  /**
   * Handle PWA ready state changes
   * Triggers card loading when PWA becomes available
   */
  pwaReadyValueChanged() {
    if (this.pwaReadyValue) {
      this.loadCard();
    }
  }

  /**
   * Configure fetch options for AJAX requests
   * Sets up headers for mobile-optimized JSON API communication
   * 
   * @returns {Object} Fetch options object
   */
  optionsForFetch() {
    return {
      headers: {
        "X-Requested-With": "XMLHttpRequest",
        "Accept": "application/json"
      }
    };
  }

  /**
   * Load member profile data and generate mobile-optimized display
   * Creates responsive Bootstrap table layout with automatic content organization
   */
  loadCard() {
    this.cardSetTarget.innerHTML = "";
    this.loadingTarget.hidden = false;
    this.memberDetailsTarget.hidden = true;
    if (!this.pwaReadyValue) {
      return;
    }
    fetch(this.urlValue, this.optionsForFetch()).then(response => {
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      return response.json();
    }).then(data => {
      this.loadingTarget.hidden = true;
      this.memberDetailsTarget.hidden = false;
      this.nameTarget.textContent = data.member.first_name + ' ' + data.member.last_name;
      this.scaNameTarget.textContent = data.member.sca_name;
      this.branchNameTarget.textContent = data.member.branch.name;
      if (data.member.membership_number && data.member.membership_number.length > 0) {
        var memberExpDate = new Date(data.member.membership_expires_on);
        if (memberExpDate < new Date()) {
          memberExpDate = "Expired";
        } else {
          memberExpDate = " - " + memberExpDate.toLocaleDateString();
        }
        this.membershipInfoTarget.textContent = data.member.membership_number + ' ' + memberExpDate;
      } else {
        this.membershipInfoTarget.textContent = "No Membership Info";
      }
      if (data.member.background_check_expires_on) {
        var backgroundCheckExpDate = new Date(data.member.background_check_expires_on);
        if (backgroundCheckExpDate < new Date()) {
          backgroundCheckExpDate = "Expired";
        } else {
          backgroundCheckExpDate = 'Current' + backgroundCheckExpDate.toLocaleDateString();
        }
        this.backgroundCheckTarget.textContent = backgroundCheckExpDate;
      } else {
        this.backgroundCheckTarget.textContent = "Not on file";
      }
      this.lastUpdateTarget.textContent = new Date().toLocaleString();
      for (let key in data) {
        if (key === 'member') {
          continue;
        }
        var pluginData = data[key];
        for (let sectionKey in pluginData) {
          var sectionData = pluginData[sectionKey];
          var keysCount = Object.keys(sectionData).length;
          if (keysCount > 0) {
            this.startCard(sectionKey);
          } else {
            continue;
          }
          var groupTable = document.createElement("table");
          groupTable.classList.add("table", "card-body-table");
          var groupTableBody = document.createElement("tbody");
          groupTable.appendChild(groupTableBody);
          for (let groupKey in sectionData) {
            var groupData = sectionData[groupKey];
            if (groupData.length === 0) {
              continue;
            }
            var groupRow = document.createElement("tr");
            var groupHeader = document.createElement("th");
            groupHeader.classList.add("col-12", "text-center");
            groupHeader.colSpan = "2";
            groupHeader.textContent = groupKey;
            groupRow.appendChild(groupHeader);
            groupTableBody.appendChild(groupRow);
            var colCount = 0;
            var groupRow = document.createElement("tr");
            var textAlignClass = "text-center";
            for (let i = 0; i < groupData.length; i++) {
              var itemData = groupData[i];
              if (colCount == 2) {
                groupTableBody.appendChild(groupRow);
                groupRow = document.createElement("tr");
                textAlignClass = "text-center";
                colCount = 0;
              } else {
                textAlignClass = "text-center";
              }
              //if there is a : split it into 2 columns of data
              if (itemData.indexOf(":") > 2) {
                var itemValue = itemData.split(":");
                var itemValueRow = document.createElement("tr");
                var itemValueCol1 = document.createElement("td");
                itemValueCol1.classList.add("col-6", "text-end");
                itemValueCol1.textContent = itemValue[0];
                var itemValueCol2 = document.createElement("td");
                itemValueCol2.classList.add("col-6", "text-start");
                itemValueCol2.textContent = itemValue[1];
                itemValueRow.appendChild(itemValueCol1);
                itemValueRow.appendChild(itemValueCol2);
                groupTableBody.appendChild(itemValueRow);
              } else {
                var colspan = 1;
                if (i + 1 == groupData.length && colCount == 0) {
                  var colspan = 2;
                }
                var itemValueCol = document.createElement("td");
                itemValueCol.classList.add("col-6", textAlignClass);
                itemValueCol.colSpan = colspan;
                itemValueCol.textContent = itemData;
                groupRow.appendChild(itemValueCol);
                colCount++;
              }
            }
            groupTableBody.appendChild(groupRow);
          }
          this.currentCard.appendChild(groupTable);
        }
      }
    }).catch(error => {
      console.error("Error loading card:", error);
      this.loadingTarget.hidden = true;
      this.memberDetailsTarget.hidden = false;
      this.nameTarget.textContent = "Error loading card data";
    });
  }

  /**
   * Connect controller to DOM
   * Initializes mobile profile card interface and sets up PWA event listener
   */
  connect() {
    this.element.addEventListener('pwa-ready', this.handlePwaReady);

    // Check if PWA is already ready (event may have fired before we connected)
    if (this.pwaReadyValue) {
      this.loadCard();
    }
  }
}
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["member-mobile-card-profile"] = MemberMobileCardProfile;

/***/ }),

/***/ "./assets/js/controllers/member-mobile-card-pwa-controller.js":
/*!********************************************************************!*\
  !*** ./assets/js/controllers/member-mobile-card-pwa-controller.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * MemberMobileCardPWA Stimulus Controller
 * 
 * Manages Progressive Web App (PWA) functionality for mobile member cards with
 * service worker management, offline capability, and connection monitoring.
 * Provides seamless online/offline experience with automatic cache management.
 * 
 * Features:
 * - Service worker registration and management
 * - Online/offline status detection and display
 * - URL caching for offline access
 * - Automatic page refresh when online
 * - Visual status indicators with Bootstrap styling
 * - PWA readiness state management
 * - Connection monitoring with periodic refresh
 * 
 * Values:
 * - swUrl: String - Service worker script URL for registration
 * 
 * Targets:
 * - urlCache: Hidden element containing URLs to cache (JSON format)
 * - status: Status display element for online/offline indication
 * - refreshBtn: Button for manual page refresh
 * 
 * Usage:
 * <div data-controller="member-mobile-card-pwa" 
 *      data-member-mobile-card-pwa-sw-url-value="/sw.js">
 *   <script data-member-mobile-card-pwa-target="urlCache" type="application/json">
 *     ["/api/member/123", "/css/app.css"]
 *   </script>
 *   <div data-member-mobile-card-pwa-target="status" class="badge">Status</div>
 *   <button data-member-mobile-card-pwa-target="refreshBtn">Refresh</button>
 * </div>
 */
class MemberMobileCardPWA extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["urlCache", "status", "refreshBtn"];

  // Make refreshBtn optional
  static optionalTargets = ["refreshBtn"];
  static values = {
    swUrl: String,
    authCardUrl: String,
    // URL to the auth card page
    isAuthCard: Boolean // Whether current page is the auth card
  };
  initialize() {
    this.boundUpdateOnlineStatus = this.updateOnlineStatus.bind(this);
    this.boundManageOnlineStatus = this.manageOnlineStatus.bind(this);
  }

  /**
   * Handle URL cache target connection
   * Parses JSON cache configuration from DOM element
   */
  urlCacheTargetConnected() {
    this.urlCacheValue = JSON.parse(this.urlCacheTarget.textContent);
  }

  /**
   * Update online/offline status display and service worker communication
   * Changes visual indicators and manages service worker state
   * Dispatches custom events for other controllers to respond to offline state
   */
  updateOnlineStatus() {
    const statusDiv = this.statusTarget;
    const refreshButton = this.hasRefreshBtnTarget ? this.refreshBtnTarget : null;
    if (navigator.onLine) {
      statusDiv.textContent = 'Online';
      statusDiv.classList.remove('bg-danger');
      statusDiv.classList.add('bg-success');
      if (refreshButton) {
        refreshButton.hidden = false;
      }
      if (this.sw) {
        this.sw.active.postMessage({
          type: 'ONLINE'
        });
      }
      if (refreshButton) {
        refreshButton.click();
      }

      // Dispatch custom event for online state
      this.dispatchStatusEvent('online');
    } else {
      statusDiv.textContent = 'Offline';
      statusDiv.classList.remove('bg-success');
      statusDiv.classList.add('bg-danger');
      if (refreshButton) {
        refreshButton.hidden = true;
      }
      if (this.sw) {
        this.sw.active.postMessage({
          type: 'OFFLINE'
        });
      }

      // Dispatch custom event for offline state
      this.dispatchStatusEvent('offline');
    }
  }

  /**
   * Dispatch connection status event
   * 
   * @param {string} status - 'online' or 'offline'
   */
  dispatchStatusEvent(status) {
    const event = new CustomEvent('connection-status-changed', {
      bubbles: true,
      detail: {
        status: status,
        isOnline: status === 'online',
        isAuthCard: this.hasIsAuthCardValue && this.isAuthCardValue,
        authCardUrl: this.hasAuthCardUrlValue ? this.authCardUrlValue : null
      }
    });
    this.element.dispatchEvent(event);
  }

  /**
   * Initialize online status monitoring and service worker registration
   * Sets up event listeners and registers service worker with cache URLs
   */
  manageOnlineStatus() {
    this.updateOnlineStatus();
    window.addEventListener('online', this.boundUpdateOnlineStatus);
    window.addEventListener('offline', this.boundUpdateOnlineStatus);

    // Register service worker with a slight delay to ensure all controllers are connected
    setTimeout(() => {
      navigator.serviceWorker.register(this.swUrlValue).then(registration => {
        this.sw = registration;

        // Wait for service worker to be active
        const waitForActive = () => {
          if (registration.active) {
            registration.active.postMessage({
              type: 'CACHE_URLS',
              payload: this.urlCacheValue
            });

            // Dispatch custom event to notify profile controller PWA is ready
            const event = new CustomEvent('pwa-ready', {
              bubbles: true
            });
            this.element.dispatchEvent(event);
          } else if (registration.installing) {
            registration.installing.addEventListener('statechange', e => {
              if (e.target.state === 'activated') {
                waitForActive();
              }
            });
          } else if (registration.waiting) {
            // Attach statechange listener to avoid synchronous recursion
            registration.waiting.addEventListener('statechange', e => {
              if (e.target.state === 'activated') {
                waitForActive();
              }
            });
            // Also set a timeout fallback in case state doesn't change
            setTimeout(waitForActive, 100);
          } else {
            setTimeout(waitForActive, 100);
          }
        };
        waitForActive();
      }, error => {
        console.error('Service Worker registration failed:', error);
      });
    }, 100);
  }

  /**
   * Refresh page if online connection is available
   * Used for periodic updates to ensure fresh content
   */
  refreshPageIfOnline() {
    if (navigator.onLine) {
      window.location.reload();
    }
  }

  /**
   * Connect controller to DOM
   * Initializes service worker support and sets up periodic refresh
   * Falls back to basic online detection if Service Workers not available
   */
  connect() {
    if ('serviceWorker' in navigator) {
      // Start PWA initialization immediately or on DOMContentLoaded/load
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', this.boundManageOnlineStatus, {
          once: true
        });
      } else {
        // readyState is 'interactive' or 'complete', safe to initialize
        this.manageOnlineStatus();
      }
    } else {
      // Service Workers not available (likely HTTP on IP address)
      // Fall back to basic online/offline detection without PWA features
      console.warn('Service Workers not available - PWA features disabled. Access via localhost or HTTPS for full functionality.');
      this.updateOnlineStatus();
      window.addEventListener('online', this.boundUpdateOnlineStatus);
      window.addEventListener('offline', this.boundUpdateOnlineStatus);

      // Dispatch PWA ready event even without Service Workers
      // This allows the profile controller to load data
      setTimeout(() => {
        const event = new CustomEvent('pwa-ready', {
          bubbles: true
        });
        this.element.dispatchEvent(event);
      }, 100);
    }
    this.refreshIntervalId = setInterval(() => this.refreshPageIfOnline(), 300000);
  }

  /**
   * Disconnect controller from DOM
   * Cleans up event listeners and intervals to prevent memory leaks
   */
  disconnect() {
    // Clear refresh interval
    if (this.refreshIntervalId) {
      clearInterval(this.refreshIntervalId);
      this.refreshIntervalId = null;
    }

    // Remove online/offline listeners
    window.removeEventListener('online', this.boundUpdateOnlineStatus);
    window.removeEventListener('offline', this.boundUpdateOnlineStatus);
  }
}
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["member-mobile-card-pwa"] = MemberMobileCardPWA;

/***/ }),

/***/ "./assets/js/controllers/member-unique-email-controller.js":
/*!*****************************************************************!*\
  !*** ./assets/js/controllers/member-unique-email-controller.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * MemberUniqueEmail Stimulus Controller
 * 
 * Provides real-time email uniqueness validation with AJAX checking and 
 * Bootstrap validation feedback. Ensures email addresses are unique across
 * the system while providing immediate user feedback.
 * 
 * Features:
 * - Real-time email uniqueness validation
 * - AJAX-based server-side checking
 * - Bootstrap validation class integration
 * - Original email comparison for updates
 * - Custom HTML5 validation messages
 * - Visual feedback with is-valid/is-invalid classes
 * - Automatic event listener management
 * 
 * Values:
 * - url: String - API endpoint for email uniqueness checking
 * 
 * Required HTML attributes:
 * - data-original-value: Original email value for comparison during updates
 * 
 * Usage:
 * <input type="email" 
 *        data-controller="member-unique-email"
 *        data-member-unique-email-url-value="/api/check-email"
 *        data-original-value="existing@example.com"
 *        name="email" required>
 */
class MemberUniqueEmail extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static values = {
    url: String
  };

  /**
   * Connect controller to DOM
   * Sets up event listeners and removes conflicting attributes
   */
  connect() {
    this.element.removeAttribute('oninput');
    this.element.removeAttribute('oninvalid');
    this.element.addEventListener('change', this.checkEmail.bind(this));
  }

  /**
   * Disconnect controller from DOM
   * Cleans up event listeners
   */
  disconnect(event) {
    this.element.removeEventListener('change', this.checkEmail.bind(this));
  }

  /**
   * Configure fetch options for AJAX requests
   * Sets up headers for JSON API communication
   * 
   * @returns {Object} Fetch options object
   */
  optionsForFetch() {
    return {
      headers: {
        "X-Requested-With": "XMLHttpRequest",
        "Accept": "application/json"
      }
    };
  }

  /**
   * Check email uniqueness via AJAX
   * Validates email against server and updates UI with Bootstrap classes
   * 
   * @param {Event} event - Change event from email input
   */
  checkEmail(event) {
    var email = this.element.value;
    if (email == '') {
      this.element.classList.remove('is-invalid');
      this.element.classList.remove('is-valid');
      this.element.setCustomValidity('');
      return;
    }
    var originalEmail = this.element.dataset.originalValue.toLowerCase();
    if (email.toLowerCase() == originalEmail) {
      this.element.classList.add('is-valid');
      this.element.classList.remove('is-invalid');
      return;
    }
    var checkEmailUrl = this.urlValue + '?nostack=yes&email=' + encodeURIComponent(email);
    fetch(checkEmailUrl, this.optionsForFetch()).then(response => response.json()).then(data => {
      if (data) {
        this.element.classList.add('is-invalid');
        this.element.classList.remove('is-valid');
        this.element.setCustomValidity('This email address is already taken.');
      } else {
        this.element.classList.add('is-valid');
        this.element.classList.remove('is-invalid');
        this.element.setCustomValidity('');
      }
    });
  }
}
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["member-unique-email"] = MemberUniqueEmail;

/***/ }),

/***/ "./assets/js/controllers/member-verify-form-controller.js":
/*!****************************************************************!*\
  !*** ./assets/js/controllers/member-verify-form-controller.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * MemberVerifyForm Stimulus Controller
 * 
 * Manages member verification form with conditional field management and
 * dependent form controls. Provides dynamic field enabling/disabling based
 * on checkbox selections for parent/guardian and membership information.
 * 
 * Features:
 * - Conditional field management based on checkbox states
 * - Parent/guardian information toggle
 * - Membership information toggle
 * - Dynamic form field enabling/disabling
 * - Form workflow support for verification processes
 * 
 * Targets:
 * - scaMember: SCA member information field
 * - membershipNumber: Membership number input field
 * - membershipExpDate: Membership expiration date field
 * 
 * Usage:
 * <form data-controller="member-verify-form">
 *   <input type="checkbox" data-action="change->member-verify-form#toggleParent">
 *   <input data-member-verify-form-target="scaMember" disabled>
 *   
 *   <input type="checkbox" data-action="change->member-verify-form#toggleMembership">
 *   <input data-member-verify-form-target="membershipNumber" disabled>
 *   <input data-member-verify-form-target="membershipExpDate" disabled>
 * </form>
 */
class MemberVerifyForm extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ['scaMember', 'membershipNumber', 'membershipExpDate'];

  /**
   * Toggle parent/guardian information field
   * Enables or disables SCA member field based on checkbox state
   * 
   * @param {Event} event - Change event from parent checkbox
   */
  toggleParent(event) {
    var checked = event.target.checked;
    this.scaMemberTarget.disabled = !checked;
  }

  /**
   * Toggle membership information fields
   * Enables or disables membership-related fields based on checkbox state
   * 
   * @param {Event} event - Change event from membership checkbox
   */
  toggleMembership(event) {
    var checked = event.target.checked;
    this.membershipNumberTarget.disabled = !checked;
    this.membershipExpDateTarget.disabled = !checked;
  }
}
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["member-verify-form"] = MemberVerifyForm;

/***/ }),

/***/ "./assets/js/controllers/mobile-hub-controller.js":
/*!********************************************************!*\
  !*** ./assets/js/controllers/mobile-hub-controller.js ***!
  \********************************************************/
/***/ (function() {



/***/ }),

/***/ "./assets/js/controllers/mobile-offline-overlay-controller.js":
/*!********************************************************************!*\
  !*** ./assets/js/controllers/mobile-offline-overlay-controller.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * MobileOfflineOverlay Stimulus Controller
 * 
 * Manages offline state overlay for mobile pages that require internet connection.
 * Shows a blocking overlay when offline with option to return to the auth card.
 * The auth card page itself doesn't use this controller as it works offline.
 * 
 * Features:
 * - Detects offline state from PWA controller
 * - Shows blocking overlay with message
 * - Provides "Return to Auth Card" button
 * - Automatically hides when back online
 * - Only active on non-auth-card pages
 * 
 * Values:
 * - authCardUrl: String - URL to navigate to auth card
 * 
 * Usage:
 * <div data-controller="mobile-offline-overlay"
 *      data-mobile-offline-overlay-auth-card-url-value="/members/view-mobile-card/token">
 * </div>
 */
class MobileOfflineOverlayController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static values = {
    authCardUrl: String
  };

  /**
   * Initialize controller
   */
  initialize() {
    this.isOnline = navigator.onLine;
    this.overlay = null;
    this._handleConnectionStatusChanged = this.handleConnectionStatusChanged.bind(this);
  }

  /**
   * Connect controller to DOM
   */
  connect() {
    console.log("MobileOfflineOverlayController connected");

    // Listen for connection status changes
    document.addEventListener('connection-status-changed', this._handleConnectionStatusChanged);

    // Check initial state
    if (!this.isOnline) {
      this.showOverlay();
    }
  }

  /**
   * Handle connection status changes from PWA controller
   * 
   * @param {CustomEvent} event Connection status event
   */
  handleConnectionStatusChanged(event) {
    const wasOnline = this.isOnline;
    this.isOnline = event.detail.isOnline;

    // Update auth card URL if provided
    if (event.detail.authCardUrl) {
      this.authCardUrlValue = event.detail.authCardUrl;
    }

    // Show overlay when going offline, hide when coming online
    if (!this.isOnline && wasOnline) {
      this.showOverlay();
    } else if (this.isOnline && !wasOnline) {
      this.hideOverlay();
    }
  }

  /**
   * Show offline overlay
   */
  showOverlay() {
    if (this.overlay) return; // Already showing

    // Create overlay element
    this.overlay = document.createElement('div');
    this.overlay.className = 'mobile-offline-overlay';
    this.overlay.setAttribute('role', 'dialog');
    this.overlay.setAttribute('aria-modal', 'true');
    this.overlay.setAttribute('aria-labelledby', 'offline-title');

    // Build content
    const content = `
            <div class="mobile-offline-content">
                <div class="mobile-offline-icon">
                    <i class="bi bi-wifi-off" aria-hidden="true"></i>
                </div>
                <h2 id="offline-title" class="mobile-offline-title">You're Offline</h2>
                <p class="mobile-offline-message">
                    This page requires an internet connection. 
                    You can return to your Auth Card which works offline.
                </p>
                <div class="mobile-offline-buttons">
                    <a href="${this.authCardUrlValue}" 
                       class="btn btn-primary btn-lg">
                        <i class="bi bi-person-vcard me-2"></i>
                        Return to Auth Card
                    </a>
                </div>
            </div>
        `;
    this.overlay.innerHTML = content;
    document.body.appendChild(this.overlay);

    // Disable page interaction
    document.body.style.overflow = 'hidden';
  }

  /**
   * Hide offline overlay
   */
  hideOverlay() {
    if (!this.overlay) return;
    this.overlay.remove();
    this.overlay = null;

    // Re-enable page interaction
    document.body.style.overflow = '';
  }

  /**
   * Disconnect controller from DOM
   */
  disconnect() {
    // Remove event listener
    if (this._handleConnectionStatusChanged) {
      document.removeEventListener('connection-status-changed', this._handleConnectionStatusChanged);
    }

    // Remove overlay if present
    this.hideOverlay();
    console.log("MobileOfflineOverlayController disconnected");
  }
}

// Register controller globally
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["mobile-offline-overlay"] = MobileOfflineOverlayController;
/* harmony default export */ __webpack_exports__["default"] = (MobileOfflineOverlayController);

/***/ }),

/***/ "./assets/js/controllers/modal-opener-controller.js":
/*!**********************************************************!*\
  !*** ./assets/js/controllers/modal-opener-controller.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * ModalOpener Stimulus Controller
 * 
 * Provides programmatic modal triggering through value-driven activation.
 * Automatically opens Bootstrap modals when the modalBtn value is set,
 * enabling remote modal control and confirmation workflows.
 * 
 * Features:
 * - Value-driven modal activation
 * - Automatic modal triggering
 * - Bootstrap modal integration
 * - Programmatic control from other controllers
 * - Confirmation dialog support
 * - Remote modal opening capability
 * 
 * Values:
 * - modalBtn: String - ID of modal button element to trigger
 * 
 * Usage:
 * <div data-controller="modal-opener" 
 *      data-modal-opener-modal-btn-value="">
 *   <!-- Modal will be opened when modalBtn value is set -->
 * </div>
 * 
 * <button id="confirmModal" data-bs-toggle="modal" data-bs-target="#myModal">
 *   Hidden trigger button
 * </button>
 * 
 * JavaScript usage:
 * controller.modalBtnValue = "confirmModal"; // Triggers modal opening
 */
class ModalOpener extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static values = {
    modalBtn: String
  };

  /**
   * Handle modal button value changes
   * Automatically triggers modal opening when value is set
   */
  modalBtnValueChanged() {
    let modal = document.getElementById(this.modalBtnValue);
    modal.click();
  }
}
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["modal-opener"] = ModalOpener;

/***/ }),

/***/ "./assets/js/controllers/nav-bar-controller.js":
/*!*****************************************************!*\
  !*** ./assets/js/controllers/nav-bar-controller.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

const {
  Controller
} = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

/**
 * NavBar Stimulus Controller
 * 
 * Manages navigation bar expand/collapse state tracking and server synchronization.
 * Provides persistent navigation state across page loads by recording user
 * preferences via AJAX requests.
 * 
 * Features:
 * - Navigation expand/collapse state tracking
 * - Server-side state persistence via AJAX
 * - Automatic event listener management
 * - Dual-endpoint state recording (expand/collapse)
 * - Bootstrap navigation integration
 * 
 * Targets:
 * - navHeader: Navigation header elements with expand/collapse functionality
 * 
 * Usage:
 * <nav>
 *   <button data-nav-bar-target="navHeader" 
 *           data-expand-url="/api/nav/expand/menu1"
 *           data-collapse-url="/api/nav/collapse/menu1"
 *           aria-expanded="false">
 *     Menu Item
 *   </button>
 * </nav>
 * 
 * Required attributes on navHeader targets:
 * - data-expand-url: URL to call when navigation expands
 * - data-collapse-url: URL to call when navigation collapses
 * - aria-expanded: Current expansion state
 */
class NavBarController extends Controller {
  static targets = ["navHeader"];

  /**
   * Handle navigation header clicks
   * Records expansion state to server based on aria-expanded attribute
   * 
   * @param {Event} event - Click event from navigation header
   */
  navHeaderClicked(event) {
    var state = event.target.getAttribute('aria-expanded');
    if (state === 'true') {
      var recordExpandUrl = event.target.getAttribute('data-expand-url');
      fetch(recordExpandUrl, this.optionsForFetch());
    } else {
      var recordCollapseUrl = event.target.getAttribute('data-collapse-url');
      fetch(recordCollapseUrl, this.optionsForFetch());
    }
  }

  /**
   * Handle navigation header connection to DOM
   * Sets up click event listener for state tracking
   * 
   * @param {HTMLElement} event - Connected navigation header element
   */
  navHeaderTargetConnected(event) {
    event.addEventListener('click', this.navHeaderClicked.bind(this));
  }

  /**
   * Handle navigation header disconnection from DOM
   * Cleans up click event listener
   * 
   * @param {HTMLElement} event - Disconnected navigation header element
   */
  navHeaderTargetDisconnected(event) {
    event.removeEventListener('click', this.navHeaderClicked.bind(this));
  }

  /**
   * Configure fetch options for AJAX requests
   * Sets up headers for JSON API communication
   * 
   * @returns {Object} Fetch options object
   */
  optionsForFetch() {
    return {
      headers: {
        "X-Requested-With": "XMLHttpRequest",
        "Accept": "application/json"
      }
    };
  }
}
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["nav-bar"] = NavBarController;

/***/ }),

/***/ "./assets/js/controllers/outlet-button-controller.js":
/*!***********************************************************!*\
  !*** ./assets/js/controllers/outlet-button-controller.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * OutletButton Stimulus Controller
 * 
 * Manages inter-controller communication through data passing and event dispatching.
 * Provides a button component that can collect data from other controllers and
 * dispatch custom events for complex workflow coordination.
 * 
 * Features:
 * - Data collection and validation
 * - Conditional button state management
 * - Custom event dispatching for controller communication
 * - Required data validation with automatic button disabling
 * - Event listener management for workflow integration
 * - Outlet-based controller communication patterns
 * 
 * Values:
 * - btnData: Object - Data collected from other controllers
 * - requireData: Boolean - Whether data is required for button activation
 * 
 * Usage:
 * <button data-controller="outlet-btn"
 *         data-outlet-btn-require-data-value="true"
 *         data-action="click->outlet-btn#fireNotice">
 *   Submit
 * </button>
 * 
 * JavaScript integration:
 * controller.addBtnData({memberId: 123, action: 'assign'});
 */
class OutletButton extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static values = {
    btnData: Object,
    requireData: Boolean
  };

  /**
   * Handle button data value changes
   * Updates button state based on data availability and requirements
   */
  btnDataValueChanged() {
    if (this.btnDataValue === null) {
      this.btnDataValue = {};
    }
    if (this.requireDataValue && Object.keys(this.btnDataValue).length === 0) {
      this.element.disabled = true;
    } else {
      this.element.disabled = false;
    }
  }

  /**
   * Add data to button for communication
   * Updates the button's data payload for event dispatching
   * 
   * @param {Object} data - Data object to associate with button
   */
  addBtnData(data) {
    this.btnDataValue = data;
  }

  /**
   * Fire custom event with button data
   * Dispatches outlet-button-clicked event with collected data
   * 
   * @param {Event} event - Click event from button
   */
  fireNotice(event) {
    let btnData = this.btnDataValue;
    this.dispatch("outlet-button-clicked", {
      detail: btnData
    });
  }

  /**
   * Add event listener for outlet button events
   * Registers callback for custom outlet button events
   * 
   * @param {Function} callback - Event handler function
   */
  addListener(callback) {
    this.element.addEventListener("outlet-btn:outlet-button-clicked", callback);
  }

  /**
   * Remove event listener for outlet button events
   * Unregisters callback to prevent memory leaks
   * 
   * @param {Function} callback - Event handler function to remove
   */
  removeListener(callback) {
    this.element.removeEventListener("outlet-btn:outlet-button-clicked", callback);
  }
}
// add to window.Controllers with a name of the controller
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["outlet-btn"] = OutletButton;

/***/ }),

/***/ "./assets/js/controllers/permission-add-role-controller.js":
/*!*****************************************************************!*\
  !*** ./assets/js/controllers/permission-add-role-controller.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * **INTERNAL CODE DOCUMENTATION COMPLETE**
 * 
 * Permission Add Role Controller
 * 
 * A specialized Stimulus controller for managing role assignments to permissions with real-time
 * validation and submit control. Provides seamless role selection validation for RBAC
 * permission configuration workflows.
 * 
 * Key Features:
 * - Role ID validation from autocomplete selection
 * - Real-time form validation with submit control
 * - Focus management for improved user experience
 * - ID parsing from underscore-separated values
 * - Integration with autocomplete role selection
 * - Bootstrap form integration with disabled state management
 * 
 * @class PermissionAddRole
 * @extends Controller
 * 
 * HTML Structure Example:
 * ```html
 * <form data-controller="permission-add-role">
 *   <div class="mb-3">
 *     <label for="role" class="form-label">Select Role</label>
 *     <input type="text" 
 *            data-permission-add-role-target="role"
 *            data-action="change->permission-add-role#checkSubmitEnable"
 *            data-controller="auto-complete"
 *            data-auto-complete-url-value="/roles/autocomplete"
 *            class="form-control"
 *            placeholder="Start typing role name...">
 *   </div>
 *   
 *   <button type="submit" 
 *           data-permission-add-role-target="submitBtn"
 *           class="btn btn-primary">
 *     Add Role to Permission
 *   </button>
 * </form>
 * ```
 */
class PermissionAddRole extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["role", "form", "submitBtn"];

  /**
   * Validate role selection and control submit button state
   * Parses role ID from underscore-separated value format
   * Enables submission only when valid role is selected
   * Provides focus management for improved user workflow
   */
  checkSubmitEnable() {
    let role = this.roleTarget.value;
    let roleId = Number(role.replace(/_/g, ""));
    if (roleId > 0) {
      this.submitBtnTarget.disabled = false;
      this.submitBtnTarget.focus();
    } else {
      this.submitBtnTarget.disabled = true;
    }
  }
}
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["permission-add-role"] = PermissionAddRole;

/***/ }),

/***/ "./assets/js/controllers/permission-import-controller.js":
/*!***************************************************************!*\
  !*** ./assets/js/controllers/permission-import-controller.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/* provided dependency */ var bootstrap = __webpack_require__(/*! bootstrap */ "./node_modules/bootstrap/dist/js/bootstrap.esm.js");


/**
 * Permission Import Controller
 * 
 * Handles permission policy import workflow with preview modal showing
 * what policies will be added and removed during the sync operation.
 * 
 * Features:
 * - File upload handling for JSON import files
 * - Preview analysis showing additions and removals
 * - Confirmation modal before applying changes
 * - Progress feedback during import
 * 
 * @class PermissionImport
 * @extends Controller
 * 
 * HTML Structure Example:
 * ```html
 * <div data-controller="permission-import"
 *      data-permission-import-preview-url-value="/permissions/preview-import"
 *      data-permission-import-import-url-value="/permissions/import-policies">
 *   <input type="file" data-permission-import-target="fileInput" data-action="change->permission-import#handleFileSelect">
 *   <button data-action="click->permission-import#triggerFileSelect">Import</button>
 *   
 *   <!-- Modal for preview -->
 *   <div class="modal" data-permission-import-target="modal">
 *     <div data-permission-import-target="modalContent"></div>
 *     <button data-action="click->permission-import#confirmImport">Confirm</button>
 *     <button data-action="click->permission-import#cancelImport">Cancel</button>
 *   </div>
 * </div>
 * ```
 */
class PermissionImport extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["fileInput", "modal", "modalContent", "addList", "removeList", "confirmBtn", "summary", "loadingOverlay"];
  static values = {
    previewUrl: String,
    importUrl: String,
    buttonContainer: String // Selector for external button container
  };

  /** @type {string|null} Base64 encoded import data for final submission */
  importData = null;

  /** @type {HTMLInputElement|null} External file input reference */
  externalFileInput = null;

  /** @type {HTMLElement|null} External import button reference */
  externalImportButton = null;

  /** @type {Function|null} Bound handleFileSelect reference for cleanup */
  boundHandleFileSelect = null;

  /** @type {Function|null} Bound triggerFileSelect reference for cleanup */
  boundTriggerFileSelect = null;

  /**
   * Initialize controller
   */
  connect() {
    this.importData = null;

    // If buttons are in an external container, wire them up
    if (this.hasButtonContainerValue && this.buttonContainerValue) {
      const container = document.querySelector(this.buttonContainerValue);
      if (container) {
        // Find the file input in the external container
        this.externalFileInput = container.querySelector('input[type="file"]');
        if (this.externalFileInput) {
          this.boundHandleFileSelect = this.handleFileSelect.bind(this);
          this.externalFileInput.addEventListener('change', this.boundHandleFileSelect);
        }

        // Find the import button and wire it up
        const importBtn = container.querySelector('[data-action*="triggerFileSelect"]');
        if (importBtn) {
          this.externalImportButton = importBtn;
          this.boundTriggerFileSelect = this.triggerFileSelect.bind(this);
          importBtn.addEventListener('click', this.boundTriggerFileSelect);
        }
      }
    }
  }

  /**
   * Trigger file input click
   * Called when the import button is clicked
   */
  triggerFileSelect(event) {
    event.preventDefault();
    // Use external file input if available, otherwise use target
    const fileInput = this.externalFileInput || (this.hasFileInputTarget ? this.fileInputTarget : null);
    if (fileInput) {
      fileInput.click();
    }
  }

  /**
   * Handle file selection
   * Validates file type and initiates preview request
   * 
   * @param {Event} event - Change event from file input
   */
  handleFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;

    // Validate file type
    if (!file.name.endsWith('.json')) {
      alert('Please select a JSON file.');
      event.target.value = '';
      return;
    }
    this.showLoadingOverlay();
    this.previewImport(file);
  }

  /**
   * Get the file input element (either external or target)
   * @returns {HTMLInputElement|null}
   */
  getFileInput() {
    return this.externalFileInput || (this.hasFileInputTarget ? this.fileInputTarget : null);
  }

  /**
   * Reset the file input value
   */
  resetFileInput() {
    const fileInput = this.getFileInput();
    if (fileInput) {
      fileInput.value = '';
    }
  }

  /**
   * Send file to server for preview analysis
   * 
   * @param {File} file - The uploaded JSON file
   */
  async previewImport(file) {
    const formData = new FormData();
    formData.append('import_file', file);
    try {
      const response = await fetch(this.previewUrlValue, {
        method: 'POST',
        headers: {
          'X-CSRF-Token': document.querySelector("meta[name='csrf-token']").content
        },
        body: formData
      });
      const data = await response.json();
      if (!response.ok || data.error) {
        this.hideLoadingOverlay();
        alert(data.error || 'Failed to preview import file.');
        this.resetFileInput();
        return;
      }

      // Store import data for final submission
      this.importData = data.import_data;

      // Display preview modal
      this.displayPreview(data.changes);
      this.hideLoadingOverlay();
      this.showModal();
    } catch (error) {
      console.error('Preview error:', error);
      this.hideLoadingOverlay();
      alert('An error occurred while analyzing the import file.');
      this.resetFileInput();
    }
  }

  /**
   * Display preview information in modal
   * 
   * @param {Object} changes - The changes object from preview response
   */
  displayPreview(changes) {
    // Update summary
    if (this.hasSummaryTarget) {
      let summaryContent = `
                <div class="alert alert-info">
                    <strong>Import Summary</strong>
                    ${changes.source_permission ? `<br><small class="text-muted">Source: ${this.escapeHtml(changes.source_permission)}</small>` : ''}
                    <ul class="mb-0 mt-2">
                        <li><span class="badge bg-success">${changes.summary.total_add}</span> policies will be added</li>
                        <li><span class="badge bg-danger">${changes.summary.total_remove}</span> policies will be removed</li>
                    </ul>
                </div>
            `;
      this.summaryTarget.innerHTML = summaryContent;
    }

    // Display policies to add
    if (this.hasAddListTarget) {
      if (changes.policies_to_add.length > 0) {
        let addHtml = '<h6 class="text-success"><i class="bi bi-plus-circle me-1"></i>Policies to Add:</h6>';
        addHtml += '<div class="list-group list-group-flush" style="max-height: 200px; overflow-y: auto;">';
        changes.policies_to_add.forEach(policy => {
          addHtml += `
                        <div class="list-group-item list-group-item-success py-1 px-2">
                            <small><code>${this.formatPolicyName(policy.policy_class)}::${this.escapeHtml(policy.policy_method)}</code></small>
                        </div>
                    `;
        });
        addHtml += '</div>';
        this.addListTarget.innerHTML = addHtml;
      } else {
        this.addListTarget.innerHTML = '<p class="text-muted small">No policies to add.</p>';
      }
    }

    // Display policies to remove
    if (this.hasRemoveListTarget) {
      if (changes.policies_to_remove.length > 0) {
        let removeHtml = '<h6 class="text-danger"><i class="bi bi-dash-circle me-1"></i>Policies to Remove:</h6>';
        removeHtml += '<div class="list-group list-group-flush" style="max-height: 200px; overflow-y: auto;">';
        changes.policies_to_remove.forEach(policy => {
          removeHtml += `
                        <div class="list-group-item list-group-item-danger py-1 px-2">
                            <small><code>${this.formatPolicyName(policy.policy_class)}::${this.escapeHtml(policy.policy_method)}</code></small>
                        </div>
                    `;
        });
        removeHtml += '</div>';
        this.removeListTarget.innerHTML = removeHtml;
      } else {
        this.removeListTarget.innerHTML = '<p class="text-muted small">No policies to remove.</p>';
      }
    }

    // Enable/disable confirm button based on changes
    if (this.hasConfirmBtnTarget) {
      const hasChanges = changes.summary.total_add > 0 || changes.summary.total_remove > 0;
      this.confirmBtnTarget.disabled = !hasChanges;
      if (!hasChanges) {
        this.summaryTarget.innerHTML = `
                    <div class="alert alert-success">
                        <i class="bi bi-check-circle me-2"></i><strong>No changes needed!</strong>
                        The current permission policies match the import file exactly.
                    </div>
                `;
      }
    }
  }

  /**
   * Format policy class name for display
   * Extracts just the class name from full namespace
   * 
   * @param {string} policyClass - Full policy class name
   * @returns {string} Formatted class name
   */
  formatPolicyName(policyClass) {
    const parts = policyClass.split('\\');
    return parts[parts.length - 1];
  }

  /**
   * Escape HTML to prevent XSS
   * 
   * @param {string} text - Text to escape
   * @returns {string} Escaped text
   */
  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  /**
   * Show the preview modal
   */
  showModal() {
    if (this.hasModalTarget) {
      const bsModal = new bootstrap.Modal(this.modalTarget);
      bsModal.show();
    }
  }

  /**
   * Hide the preview modal
   */
  hideModal() {
    if (this.hasModalTarget) {
      const bsModal = bootstrap.Modal.getInstance(this.modalTarget);
      if (bsModal) {
        bsModal.hide();
      }
    }
  }

  /**
   * Show loading overlay during processing
   */
  showLoadingOverlay() {
    if (this.hasLoadingOverlayTarget) {
      this.loadingOverlayTarget.classList.remove('d-none');
    }
  }

  /**
   * Hide loading overlay
   */
  hideLoadingOverlay() {
    if (this.hasLoadingOverlayTarget) {
      this.loadingOverlayTarget.classList.add('d-none');
    }
  }

  /**
   * Cancel import operation
   * Closes modal and resets state
   */
  cancelImport(event) {
    event.preventDefault();
    this.hideModal();
    this.importData = null;
    this.resetFileInput();
    this.resetModalContent();
  }

  /**
   * Reset modal content for next use
   */
  resetModalContent() {
    if (this.hasSummaryTarget) this.summaryTarget.innerHTML = '';
    if (this.hasAddListTarget) this.addListTarget.innerHTML = '';
    if (this.hasRemoveListTarget) this.removeListTarget.innerHTML = '';
  }

  /**
   * Confirm and execute the import
   * Sends the import data to the server for processing
   */
  async confirmImport(event) {
    event.preventDefault();
    if (!this.importData) {
      alert('No import data available.');
      return;
    }
    if (this.hasConfirmBtnTarget) {
      this.confirmBtnTarget.disabled = true;
      this.confirmBtnTarget.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Importing...';
    }
    try {
      const response = await fetch(this.importUrlValue, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'X-CSRF-Token': document.querySelector("meta[name='csrf-token']").content
        },
        body: JSON.stringify({
          import_data: this.importData
        })
      });
      const data = await response.json();
      if (!response.ok || data.error) {
        alert(data.error || 'Import failed.');
        return;
      }

      // Show success message
      const results = data.results;
      let message = `Import completed successfully!\n\nAdded: ${results.added} policies\nRemoved: ${results.removed} policies`;
      if (results.errors && results.errors.length > 0) {
        message += `\n\nWarnings:\n${results.errors.join('\n')}`;
      }
      alert(message);

      // Close modal and refresh page
      this.hideModal();
      window.location.reload();
    } catch (error) {
      console.error('Import error:', error);
      alert('An error occurred during import.');
    } finally {
      if (this.hasConfirmBtnTarget) {
        this.confirmBtnTarget.disabled = false;
        this.confirmBtnTarget.innerHTML = 'Confirm Import';
      }
      this.importData = null;
      this.resetFileInput();
    }
  }

  /**
   * Clean up on disconnect
   */
  disconnect() {
    this.importData = null;
    // Remove event listeners from external elements
    if (this.externalFileInput && this.boundHandleFileSelect) {
      this.externalFileInput.removeEventListener('change', this.boundHandleFileSelect);
    }
    if (this.externalImportButton && this.boundTriggerFileSelect) {
      this.externalImportButton.removeEventListener('click', this.boundTriggerFileSelect);
    }
    this.boundHandleFileSelect = null;
    this.boundTriggerFileSelect = null;
    this.externalFileInput = null;
    this.externalImportButton = null;
  }
}
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["permission-import"] = PermissionImport;

/***/ }),

/***/ "./assets/js/controllers/permission-manage-policies-controller.js":
/*!************************************************************************!*\
  !*** ./assets/js/controllers/permission-manage-policies-controller.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * **INTERNAL CODE DOCUMENTATION COMPLETE**
 * 
 * Permission Manage Policies Controller
 * 
 * A sophisticated Stimulus controller that provides an interactive permission matrix for managing
 * CakePHP authorization policies. Features hierarchical checkbox management with indeterminate
 * states, batch processing for performance, and asynchronous AJAX updates with queue management.
 * 
 * Key Features:
 * - Hierarchical checkbox management (class-level controls method-level checkboxes)
 * - Indeterminate state indicators for partial selections
 * - Batch processing with loading overlay for performance optimization
 * - Asynchronous AJAX queue management for reliable server updates
 * - Dynamic event listener management with cleanup
 * 
 * @class PermissionManagePolicies
 * @extends Controller
 * 
 * HTML Structure Example:
 * ```html
 * <div data-controller="permission-manage-policies" 
 *      data-permission-manage-policies-url-value="/permissions/manage-policies">
 *   <!-- Class-level checkbox (controls all methods in the class) -->
 *   <input type="checkbox" 
 *          data-permission-manage-policies-target="policyClass"
 *          data-class-name="App\\Controller\\MembersController"
 *          data-permission-id="1">
 *   
 *   <!-- Method-level checkboxes (controlled by class checkbox) -->
 *   <input type="checkbox"
 *          data-permission-manage-policies-target="policyMethod" 
 *          data-class-name="App\\Controller\\MembersController"
 *          data-permission-id="1"
 *          data-method-name="index">
 *   
 *   <input type="checkbox"
 *          data-permission-manage-policies-target="policyMethod"
 *          data-class-name="App\\Controller\\MembersController" 
 *          data-permission-id="1"
 *          data-method-name="view">
 * </div>
 * ```
 */
class PermissionManagePolicies extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["policyClass", "policyMethod"];
  static values = {
    url: String
  };

  /** @type {Array} Queue for managing sequential AJAX requests to prevent race conditions */
  changeQueue = [];

  /**
   * Event handler for policy class target connection
   * Sets up click event listeners for class-level checkboxes
   * 
   * @param {HTMLElement} element - The connected policy class checkbox element
   */
  policyClassTargetConnected(element) {
    //add event listener to the element
    element.clickEvent = event => {
      this.classClicked(event);
    };
    element.addEventListener("click", element.clickEvent);
  }

  /**
   * Event handler for policy method target connection
   * Sets up click event listeners for method-level checkboxes
   * 
   * @param {HTMLElement} element - The connected policy method checkbox element
   */
  policyMethodTargetConnected(element) {
    //add event listener to the element
    element.clickEvent = event => {
      this.methodClicked(event);
    };
    element.addEventListener("click", element.clickEvent);
  }

  /**
   * Controller initialization and setup
   * Implements batch processing for performance optimization when dealing with large
   * permission matrices. Shows loading overlay during processing.
   */
  connect() {
    // Show loading overlay
    this.showLoadingOverlay();
    // Batch process checkboxes for performance
    const classes = Array.from(document.querySelectorAll(`input[type='checkbox'][data-class-name][data-permission-id]:not([data-method-name])`));
    const batchSize = 100; // Number of checkboxes to process per batch
    let index = 0;
    const processBatch = () => {
      const end = Math.min(index + batchSize, classes.length);
      for (let i = index; i < end; i++) {
        const element = classes[i];
        const className = element.dataset.className;
        const permissionId = element.dataset.permissionId;
        this.checkClass(className, permissionId);
      }
      index = end;
      if (index < classes.length) {
        setTimeout(processBatch, 0);
      } else {
        this.hideLoadingOverlay();
      }
    };
    processBatch();
  }

  /**
   * Display loading overlay during batch processing
   * Creates a Bootstrap spinner overlay for performance indication
   */
  showLoadingOverlay() {
    // Find the permissions-matrix container
    const container = this.element.closest('.permissions-matrix') || this.element;
    if (!container.querySelector('.loading-overlay')) {
      const overlay = document.createElement('div');
      overlay.className = 'loading-overlay';
      overlay.innerHTML = '<div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading...</span></div>';
      overlay.style.position = 'absolute';
      overlay.style.top = 0;
      overlay.style.left = 0;
      overlay.style.width = '100%';
      overlay.style.height = '100%';
      overlay.style.background = 'rgba(255,255,255,0.7)';
      overlay.style.display = 'flex';
      overlay.style.alignItems = 'center';
      overlay.style.justifyContent = 'center';
      overlay.style.zIndex = 1000;
      container.style.position = 'relative';
      container.appendChild(overlay);
    }
  }

  /**
   * Remove loading overlay after processing completion
   * Cleans up spinner overlay from permissions matrix
   */
  hideLoadingOverlay() {
    const container = this.element.closest('.permissions-matrix') || this.element;
    const overlay = container.querySelector('.loading-overlay');
    if (overlay) {
      overlay.remove();
    }
  }

  /**
   * Update class-level checkbox state based on method selections
   * Implements three-state logic: checked, unchecked, and indeterminate
   * 
   * @param {String} className - The class name to check state for
   * @param {String} permissionId - The permission ID to check state for
   */
  checkClass(className, permissionId) {
    const methods = document.querySelectorAll(`input[type='checkbox'][data-class-name='${className}'][data-permission-id='${permissionId}'][data-method-name]`);
    let checkCount = 0;
    methods.forEach(method => {
      if (method.checked) {
        checkCount++;
      }
    });
    const allChecked = checkCount === methods.length;
    const someChecked = checkCount > 0 && checkCount < methods.length;
    const classCheckbox = document.querySelectorAll(`input[type='checkbox'][data-class-name='${className}'][data-permission-id='${permissionId}']:not([data-method-name])`)[0];
    classCheckbox.checked = allChecked || someChecked;
    if (someChecked) {
      // add the secondary class to the checkbox
      classCheckbox.classList.add("indeterminate-switch");
    } else {
      // remove the secondary class from the checkbox
      classCheckbox.classList.remove("indeterminate-switch");
    }
  }

  /**
   * Handle class-level checkbox clicks
   * Updates all method-level checkboxes and manages indeterminate state
   * 
   * @param {Event} event - The click event from class checkbox
   */
  classClicked(event) {
    const checkbox = event.target;
    const isChecked = checkbox.checked;
    const className = checkbox.dataset.className;
    const permissionId = checkbox.dataset.permissionId;
    const methods = document.querySelectorAll(`input[type='checkbox'][data-class-name='${className}'][data-permission-id='${permissionId}'][data-method-name]`);
    methods.forEach(method => {
      method.checked = isChecked;
      this.changeMethod(method, isChecked);
    });
    checkbox.classList.remove("indeterminate-switch");
  }

  /**
   * Handle method-level checkbox clicks
   * Updates parent class checkbox state and queues server update
   * 
   * @param {Event} event - The click event from method checkbox
   */
  methodClicked(event) {
    // check if the element is checked or not
    const checkbox = event.target;
    const isChecked = checkbox.checked;
    const className = checkbox.dataset.className;
    const permissionId = checkbox.dataset.permissionId;
    this.checkClass(className, permissionId);
    this.changeMethod(checkbox, isChecked);
  }

  /**
   * Queue permission change for server update
   * Adds change to queue and processes if not already processing
   * 
   * @param {HTMLElement} method - The method checkbox element
   * @param {Boolean} isChecked - Whether the checkbox is checked
   */
  changeMethod(method, isChecked) {
    let className = method.dataset.className;
    className = className.replace(/-/g, "\\");
    console.log(className);
    const methodName = method.dataset.methodName;
    const permissionId = method.dataset.permissionId;
    this.changeQueue.push({
      permissionId: permissionId,
      method: methodName,
      className: className,
      action: isChecked ? "add" : "delete"
    });
    // if the queue is empty then start the queue
    if (this.changeQueue.length === 1) {
      this.processQueue();
    }
  }

  /**
   * Process queued permission changes sequentially
   * Handles AJAX communication with server for policy updates
   * Maintains queue integrity and prevents race conditions
   */
  processQueue() {
    if (this.changeQueue.length === 0) {
      return;
    }
    const change = this.changeQueue[0];
    // make a fetch call to the controller url with the change
    fetch(this.urlValue, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json",
        "X-CSRF-Token": document.querySelector("meta[name='csrf-token']").content
      },
      body: JSON.stringify(change)
    }).then(response => response.json()).then(data => {
      // remove the change from the queue
      this.changeQueue.shift();
      // process the next change in the queue
      this.processQueue();
    });
  }

  /**
   * Clean up event listeners on controller disconnect
   * Removes all dynamically added event listeners to prevent memory leaks
   */
  disconnect() {
    // remove event listeners from all elements
    this.policyClassTargets.forEach(element => {
      element.removeEventListener("click", element.clickEvent);
    });
    this.policyMethodTargets.forEach(element => {
      element.removeEventListener("click", element.clickEvent);
    });
  }
}
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["permission-manage-policies"] = PermissionManagePolicies;

/***/ }),

/***/ "./assets/js/controllers/popover-controller.js":
/*!*****************************************************!*\
  !*** ./assets/js/controllers/popover-controller.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/* provided dependency */ var bootstrap = __webpack_require__(/*! bootstrap */ "./node_modules/bootstrap/dist/js/bootstrap.esm.js");


/**
 * Popover Controller
 * 
 * A reusable Stimulus controller for Bootstrap popovers with support for:
 * - HTML content with close buttons
 * - Custom allowList for sanitizer (allows button elements)
 * - Auto-initialization on connect
 * - Proper cleanup on disconnect
 * 
 * Usage:
 * <button type="button" 
 *     data-controller="popover"
 *     data-bs-toggle="popover"
 *     data-bs-trigger="click"
 *     data-bs-html="true"
 *     data-bs-content="<div>Content with <button class='btn-close popover-close-btn'></button></div>">
 *     Open Popover
 * </button>
 */
class PopoverController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static values = {
    placement: {
      type: String,
      default: "auto"
    },
    trigger: {
      type: String,
      default: "click"
    },
    html: {
      type: Boolean,
      default: true
    },
    customClass: {
      type: String,
      default: ""
    }
  };
  connect() {
    this.initializePopover();
    this.setupCloseButtonHandler();
  }
  disconnect() {
    this.removeCloseButtonHandler();
    this.destroyPopover();
  }
  initializePopover() {
    // Custom allowList to permit button elements in popover content
    const allowList = Object.assign({}, bootstrap.Popover.Default.allowList);
    allowList.button = ['type', 'class', 'aria-label'];

    // Get options from data attributes or use defaults
    const options = {
      allowList: allowList,
      placement: this.placementValue,
      trigger: this.triggerValue,
      html: this.htmlValue
    };
    if (this.customClassValue) {
      options.customClass = this.customClassValue;
    }

    // Initialize Bootstrap popover
    this.popover = new bootstrap.Popover(this.element, options);
  }
  destroyPopover() {
    if (this.popover) {
      this.popover.dispose();
      this.popover = null;
    }
  }
  setupCloseButtonHandler() {
    // Use bound method for proper removal later
    this.handleCloseClick = this.handleCloseClick.bind(this);
    document.addEventListener('click', this.handleCloseClick);
  }
  removeCloseButtonHandler() {
    document.removeEventListener('click', this.handleCloseClick);
  }
  handleCloseClick(event) {
    const closeBtn = event.target.closest('.popover .btn-close, .popover .popover-close-btn');
    if (!closeBtn) return;
    const popoverElement = closeBtn.closest('.popover');
    if (!popoverElement) return;

    // Check if this popover belongs to this controller's element
    const popoverId = popoverElement.id;
    if (this.element.getAttribute('aria-describedby') !== popoverId) return;

    // Hide the popover
    if (this.popover) {
      this.popover.hide();
    }
    event.preventDefault();
    event.stopPropagation();
  }

  // Action to programmatically show the popover
  show() {
    if (this.popover) {
      this.popover.show();
    }
  }

  // Action to programmatically hide the popover
  hide() {
    if (this.popover) {
      this.popover.hide();
    }
  }

  // Action to toggle the popover
  toggle() {
    if (this.popover) {
      this.popover.toggle();
    }
  }
}

// Register in global Controllers object
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["popover"] = PopoverController;
/* harmony default export */ __webpack_exports__["default"] = (PopoverController);

/***/ }),

/***/ "./assets/js/controllers/qrcode-controller.js":
/*!****************************************************!*\
  !*** ./assets/js/controllers/qrcode-controller.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/* harmony import */ var qrcode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! qrcode */ "./node_modules/qrcode/lib/browser.js");



/**
 * QR Code Generator Controller
 * 
 * Generates QR codes dynamically using the qrcode library.
 * Generates the QR code when the modal/container is shown to avoid unnecessary generation.
 * 
 * Usage:
 * <div data-controller="qrcode"
 *      data-qrcode-url-value="https://example.com"
 *      data-qrcode-size-value="256"
 *      data-qrcode-modal-id-value="qrCodeModal">
 *   <div data-qrcode-target="canvas"></div>
 * </div>
 * 
 * Or with a modal:
 * <div class="modal" id="qrCodeModal" data-controller="qrcode" 
 *      data-qrcode-url-value="https://example.com">
 *   <div data-qrcode-target="canvas"></div>
 * </div>
 */
class QrcodeController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["canvas"];
  static values = {
    url: String,
    // The URL to encode in QR code
    size: {
      type: Number,
      default: 256
    },
    // QR code size in pixels
    modalId: String,
    // Optional modal ID to detect when to generate
    colorDark: {
      type: String,
      default: '#000000'
    },
    colorLight: {
      type: String,
      default: '#ffffff'
    },
    errorCorrectionLevel: {
      type: String,
      default: 'H'
    } // L, M, Q, H
  };

  // Initialize the generated flag
  generated = false;
  connect() {
    this.generated = false;

    // If modal ID is provided, wait for modal to show
    if (this.hasModalIdValue) {
      const modal = document.getElementById(this.modalIdValue);
      if (modal) {
        // Store the listener as an instance property
        this._onModalShown = () => this.generate();
        modal.addEventListener('shown.bs.modal', this._onModalShown);
      }
    } else {
      // Generate immediately if no modal
      this.generate();
    }
  }
  disconnect() {
    // Remove event listener to prevent memory leak
    if (this.hasModalIdValue && this._onModalShown) {
      const modal = document.getElementById(this.modalIdValue);
      if (modal) {
        modal.removeEventListener('shown.bs.modal', this._onModalShown);
      }
    }
    this.generated = false;
  }

  /**
   * Generate the QR code
   * Returns a Promise that resolves when generation is complete
   */
  generate() {
    // Only generate once
    if (this.generated) {
      return Promise.resolve();
    }
    if (!this.hasUrlValue) {
      throw new Error('QR Code: URL value is required');
    }
    if (!this.hasCanvasTarget) {
      throw new Error('QR Code: Canvas target is required');
    }

    // Clear any existing content
    this.canvasTarget.innerHTML = '';

    // Create canvas element
    const canvas = document.createElement('canvas');
    this.canvasTarget.appendChild(canvas);

    // Return a Promise that resolves when QR code generation is complete
    return new Promise((resolve, reject) => {
      qrcode__WEBPACK_IMPORTED_MODULE_1__.toCanvas(canvas, this.urlValue, {
        width: this.sizeValue,
        margin: 2,
        color: {
          dark: this.colorDarkValue,
          light: this.colorLightValue
        },
        errorCorrectionLevel: this.errorCorrectionLevelValue
      }, error => {
        if (error) {
          this.canvasTarget.innerHTML = '<p class="text-danger">Error generating QR code</p>';
          reject(error);
        } else {
          this.generated = true;
          resolve();
        }
      });
    });
  }

  /**
   * Regenerate the QR code (useful if URL changes)
   */
  regenerate() {
    this.generated = false;
    this.generate();
  }

  /**
   * Download the QR code as PNG
   */
  async download() {
    try {
      // Wait for generation to complete
      await this.generate();
      const canvas = this.canvasTarget.querySelector('canvas');
      if (!canvas) {
        console.error('QR Code Controller: Canvas not found');
        return;
      }

      // Create download link
      const link = document.createElement('a');
      link.download = 'qrcode.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
    } catch (error) {
      console.error('QR Code generation failed:', error);
    }
  }

  /**
   * Copy QR code to clipboard as image
   */
  async copyToClipboard() {
    try {
      // Wait for generation to complete
      await this.generate();
      const canvas = this.canvasTarget.querySelector('canvas');
      if (!canvas) {
        console.error('QR Code Controller: Canvas not found');
        return;
      }

      // Convert canvas to blob using Promise
      const blob = await new Promise((resolve, reject) => {
        canvas.toBlob(blob => {
          if (blob) {
            resolve(blob);
          } else {
            reject(new Error('Failed to create blob from canvas'));
          }
        });
      });

      // Copy to clipboard
      const item = new ClipboardItem({
        'image/png': blob
      });
      await navigator.clipboard.write([item]);
    } catch (error) {
      console.error('Failed to copy QR code:', error);
    }
  }
}

// Register controller globally
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["qrcode"] = QrcodeController;
/* harmony default export */ __webpack_exports__["default"] = (QrcodeController);

/***/ }),

/***/ "./assets/js/controllers/revoke-form-controller.js":
/*!*********************************************************!*\
  !*** ./assets/js/controllers/revoke-form-controller.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * **INTERNAL CODE DOCUMENTATION COMPLETE**
 * 
 * Revoke Form Controller
 * 
 * A specialized Stimulus controller that manages revocation workflows with outlet communication
 * and form validation. Provides seamless integration between trigger elements and revocation
 * forms with real-time validation and submit control.
 * 
 * Key Features:
 * - Inter-controller communication through outlet pattern
 * - Dynamic ID management from external triggers
 * - Real-time form validation with submit control
 * - Automatic event listener management and cleanup
 * - Bootstrap form integration with disabled state management
 * 
 * @class RevokeForm
 * @extends Controller
 * 
 * HTML Structure Example:
 * ```html
 * <!-- Revocation form with outlet communication -->
 * <form data-controller="revoke-form" 
 *       data-revoke-form-url-value="/revoke"
 *       data-revoke-form-outlet-btn-outlet="[data-controller*='outlet-btn']">
 *   <input type="hidden" data-revoke-form-target="id">
 *   
 *   <div class="mb-3">
 *     <label for="reason" class="form-label">Revocation Reason</label>
 *     <textarea data-revoke-form-target="reason" 
 *               data-action="input->revoke-form#checkReadyToSubmit"
 *               class="form-control" 
 *               rows="3" 
 *               required></textarea>
 *   </div>
 *   
 *   <button type="submit" 
 *           data-revoke-form-target="submitBtn"
 *           class="btn btn-danger">
 *     Revoke Access
 *   </button>
 * </form>
 * 
 * <!-- Trigger button with outlet communication -->
 * <button data-controller="outlet-btn" 
 *         data-outlet-btn-id-value="123"
 *         data-action="click->outlet-btn#fireNotice">
 *   Revoke User 123
 * </button>
 * ```
 */
class RevokeForm extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static values = {
    url: String
  };
  static targets = ["submitBtn", "reason", "id"];
  static outlets = ["outlet-btn"];

  /**
   * Handle ID setting from outlet communication
   * Receives ID from outlet button clicks and updates hidden form field
   * 
   * @param {CustomEvent} event - Custom event containing ID details
   * @param {Object} event.detail - Event details object
   * @param {String} event.detail.id - The ID value to set in the form
   */
  setId(event) {
    this.idTarget.value = event.detail.id;
  }

  /**
   * Handle outlet button connection
   * Sets up event listener for ID communication from outlet buttons
   * 
   * @param {Controller} outlet - The connected outlet button controller
   * @param {HTMLElement} element - The outlet button element
   */
  outletBtnOutletConnected(outlet, element) {
    outlet.addListener(this.setId.bind(this));
  }

  /**
   * Handle outlet button disconnection
   * Removes event listener to prevent memory leaks
   * 
   * @param {Controller} outlet - The disconnected outlet button controller
   */
  outletBtnOutletDisconnected(outlet) {
    outlet.removeListener(this.setId.bind(this));
  }

  /**
   * Validate form readiness and control submit button state
   * Enables submit button only when reason field contains valid content
   * Provides real-time feedback for form completion status
   */
  checkReadyToSubmit() {
    let reasonValue = this.reasonTarget.value;
    if (reasonValue.length > 0) {
      this.submitBtnTarget.disabled = false;
    } else {
      this.submitBtnTarget.disabled = true;
    }
  }

  /**
   * Initialize controller state and disable form submission
   * Sets initial form state with disabled submit button until validation passes
   */
  connect() {
    this.submitBtnTarget.disabled = true;
  }
}
// add to window.Controllers with a name of the controller
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["revoke-form"] = RevokeForm;

/***/ }),

/***/ "./assets/js/controllers/role-add-member-controller.js":
/*!*************************************************************!*\
  !*** ./assets/js/controllers/role-add-member-controller.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * **INTERNAL CODE DOCUMENTATION COMPLETE**
 * 
 * Role Add Member Controller
 * 
 * A specialized Stimulus controller for managing role membership assignments with member
 * validation and optional branch requirements. Provides real-time form validation and
 * submit control for RBAC member assignment workflows.
 * 
 * Key Features:
 * - Member ID validation from autocomplete selection
 * - Optional branch requirement validation
 * - Real-time form validation with submit control  
 * - Focus management for improved user experience
 * - Integration with autocomplete member selection
 * - Bootstrap form integration with disabled state management
 * 
 * @class RoleAddMember
 * @extends Controller
 * 
 * HTML Structure Example:
 * ```html
 * <form data-controller="role-add-member">
 *   <div class="mb-3">
 *     <label for="scaMember" class="form-label">Select Member</label>
 *     <input type="text" 
 *            data-role-add-member-target="scaMember"
 *            data-action="change->role-add-member#checkSubmitEnable"
 *            data-controller="auto-complete"
 *            class="form-control">
 *   </div>
 *   
 *   <!-- Optional branch selection (if role requires branch context) -->
 *   <div class="mb-3">
 *     <label for="branch" class="form-label">Branch</label>
 *     <select data-role-add-member-target="branch"
 *             data-action="change->role-add-member#checkSubmitEnable"
 *             class="form-select">
 *       <option value="">Select Branch</option>
 *       <option value="1">Branch 1</option>
 *     </select>
 *   </div>
 *   
 *   <button type="submit" 
 *           data-role-add-member-target="submitBtn"
 *           class="btn btn-primary">
 *     Add Member to Role
 *   </button>
 * </form>
 * ```
 */
class RoleAddMember extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["scaMember", "form", "submitBtn", "branch"];

  /**
   * Validate form submission requirements and control submit button
   * Checks member selection validity and optional branch requirements
   * Provides focus management and real-time validation feedback
   */
  checkSubmitEnable() {
    let scaMember = this.scaMemberTarget.value;
    let memberId = Number(scaMember.replace(/_/g, ""));
    let require_branch = this.hasBranchTarget;
    if (memberId > 0) {
      if (require_branch && this.branchTarget.value == "") {
        this.submitBtnTarget.disabled = true;
        return;
      }
      this.submitBtnTarget.disabled = false;
      this.submitBtnTarget.focus();
    } else {
      this.submitBtnTarget.disabled = true;
    }
  }
}
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["role-add-member"] = RoleAddMember;

/***/ }),

/***/ "./assets/js/controllers/role-add-permission-controller.js":
/*!*****************************************************************!*\
  !*** ./assets/js/controllers/role-add-permission-controller.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * **INTERNAL CODE DOCUMENTATION COMPLETE**
 * 
 * Role Add Permission Controller
 * 
 * A specialized Stimulus controller for managing role permission assignments with real-time
 * validation and submit control. Provides seamless permission selection validation for RBAC
 * role configuration workflows.
 * 
 * Key Features:
 * - Permission ID validation from autocomplete selection
 * - Real-time form validation with submit control
 * - Focus management for improved user experience
 * - ID parsing from underscore-separated values
 * - Integration with autocomplete permission selection
 * - Bootstrap form integration with disabled state management
 * 
 * @class RoleAddPermission
 * @extends Controller
 * 
 * HTML Structure Example:
 * ```html
 * <form data-controller="role-add-permission">
 *   <div class="mb-3">
 *     <label for="permission" class="form-label">Select Permission</label>
 *     <input type="text" 
 *            data-role-add-permission-target="permission"
 *            data-action="change->role-add-permission#checkSubmitEnable"
 *            data-controller="auto-complete"
 *            data-auto-complete-url-value="/permissions/autocomplete"
 *            class="form-control"
 *            placeholder="Start typing permission name...">
 *   </div>
 *   
 *   <button type="submit" 
 *           data-role-add-permission-target="submitBtn"
 *           class="btn btn-primary">
 *     Add Permission to Role
 *   </button>
 * </form>
 * ```
 */
class RoleAddPermission extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["permission", "form", "submitBtn"];

  /**
   * Validate permission selection and control submit button state
   * Parses permission ID from underscore-separated value format
   * Enables submission only when valid permission is selected
   * Provides focus management for improved user workflow
   */
  checkSubmitEnable() {
    let permission = this.permissionTarget.value;
    let permissionId = Number(permission.replace(/_/g, ""));
    if (permissionId > 0) {
      this.submitBtnTarget.disabled = false;
      this.submitBtnTarget.focus();
    } else {
      this.submitBtnTarget.disabled = true;
    }
  }
}
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["role-add-permission"] = RoleAddPermission;

/***/ }),

/***/ "./assets/js/controllers/security-debug-controller.js":
/*!************************************************************!*\
  !*** ./assets/js/controllers/security-debug-controller.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * Security Debug Controller
 * 
 * Handles the display and interaction of security debug information in debug mode.
 * Provides toggle functionality to show/hide detailed security information including
 * user policies and authorization check logs.
 * 
 * Features:
 * - Toggle visibility of security debug panel
 * - Smooth slide animations
 * - Persistent state during page session
 * - AJAX loading of security information on first view
 * 
 * HTML Structure:
 * ```html
 * <div data-controller="security-debug">
 *   <button data-action="click->security-debug#toggle" data-security-debug-target="toggleBtn">
 *     Show Security Info
 *   </button>
 *   <div data-security-debug-target="panel" style="display: none;">
 *     <!-- Security info content -->
 *   </div>
 * </div>
 * ```
 */
class SecurityDebugController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["panel", "toggleBtn"];

  /**
   * Initialize controller
   */
  initialize() {
    this.isVisible = false;
  }

  /**
   * Toggle the visibility of the security debug panel
   */
  toggle(event) {
    event.preventDefault();
    if (this.isVisible) {
      this.hide();
    } else {
      this.show();
    }
  }

  /**
   * Show the security debug panel
   */
  show() {
    this.panelTarget.style.display = 'block';
    this.isVisible = true;
    if (this.hasToggleBtnTarget) {
      this.toggleBtnTarget.textContent = 'Hide Security Info';
    }

    // Smooth scroll to panel
    setTimeout(() => {
      this.panelTarget.scrollIntoView({
        behavior: 'smooth',
        block: 'nearest'
      });
    }, 100);
  }

  /**
   * Hide the security debug panel
   */
  hide() {
    this.panelTarget.style.display = 'none';
    this.isVisible = false;
    if (this.hasToggleBtnTarget) {
      this.toggleBtnTarget.textContent = 'Show Security Info';
    }
  }
}

// Add to global controllers registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["security-debug"] = SecurityDebugController;

/***/ }),

/***/ "./assets/js/controllers/select-all-switch-list-controller.js":
/*!********************************************************************!*\
  !*** ./assets/js/controllers/select-all-switch-list-controller.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * **INTERNAL CODE DOCUMENTATION COMPLETE**
 * 
 * Select All Switch List Controller
 * 
 * A sophisticated Stimulus controller that provides automatic "Select All" functionality for
 * Bootstrap form-switch checkbox lists. Creates and manages a master checkbox that controls
 * all individual checkboxes with bidirectional synchronization.
 * 
 * Key Features:
 * - Automatic "Select All" header checkbox generation
 * - Bidirectional synchronization between master and individual checkboxes
 * - Bootstrap form-switch styling consistency
 * - Dynamic checkbox discovery and event management
 * - Accessibility support with ARIA labels
 * - Automatic state management for partial selections
 * 
 * @class SelectAllListController
 * @extends Controller
 * 
 * HTML Structure Example:
 * ```html
 * <div data-controller="select-all-switch">
 *   <!-- Individual checkboxes (Select All checkbox will be auto-generated) -->
 *   <div class="form-check form-switch">
 *     <input class="form-check-input" type="checkbox" id="item1" name="items[]" value="1">
 *     <label class="form-check-label" for="item1">Item 1</label>
 *   </div>
 *   
 *   <div class="form-check form-switch">
 *     <input class="form-check-input" type="checkbox" id="item2" name="items[]" value="2">
 *     <label class="form-check-label" for="item2">Item 2</label>
 *   </div>
 *   
 *   <div class="form-check form-switch">
 *     <input class="form-check-input" type="checkbox" id="item3" name="items[]" value="3">
 *     <label class="form-check-label" for="item3">Item 3</label>
 *   </div>
 * </div>
 * ```
 */
class SelectAllListController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  /** @type {NodeList} Collection of all checkboxes in the list including the master checkbox */
  allCheckboxes;

  /**
   * Initialize controller and generate Select All functionality
   * Creates master checkbox, sets up event listeners, and establishes synchronization
   */
  connect() {
    //copy the first form-check form-switch checkbox and make it a select all checkbox
    const selectAllCheckbox = this.element.querySelector('.form-check.form-switch').cloneNode(true);
    selectAllCheckbox.querySelector('input[type="checkbox"]').setAttribute('data-select-all', 'true');
    selectAllCheckbox.querySelector('input[type="checkbox"]').setAttribute('aria-label', 'Select All');
    selectAllCheckbox.querySelector('label').innerText = 'Select All';
    // get the first form-check form-switch checkbox and set the id to select-all
    const firstCheckbox = this.element.querySelector('.form-check.form-switch');
    firstCheckbox.parentNode.insertBefore(selectAllCheckbox, firstCheckbox);
    this.allCheckboxes = this.element.querySelectorAll('input[type="checkbox"]');
    this.allCheckboxes.forEach(checkbox => {
      checkbox.addEventListener('change', this.updateSelectAll.bind(this));
    });
  }

  /**
   * Handle checkbox state changes and maintain synchronization
   * Manages bidirectional relationship between master and individual checkboxes
   * Updates master checkbox state based on individual selections
   * 
   * @param {Event} event - The change event from any checkbox in the list
   */
  updateSelectAll(event) {
    const selectAllCheckbox = this.element.querySelector('input[type="checkbox"][data-select-all]');
    if (event.target === selectAllCheckbox) {
      this.allCheckboxes.forEach(checkbox => {
        if (checkbox !== selectAllCheckbox) {
          checkbox.checked = selectAllCheckbox.checked;
        }
      });
    } else {
      const allChecked = Array.from(this.allCheckboxes).every(checkbox => checkbox.checked && checkbox !== selectAllCheckbox);
      selectAllCheckbox.checked = allChecked;
    }
  }
}
// add to window.Controllers with a name of the controller
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["select-all-switch"] = SelectAllListController;

/***/ }),

/***/ "./assets/js/controllers/session-extender-controller.js":
/*!**************************************************************!*\
  !*** ./assets/js/controllers/session-extender-controller.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

const {
  Controller
} = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

/**
 * SessionExtender Stimulus Controller
 * 
 * Manages automatic session extension to prevent timeout during active user sessions.
 * Provides proactive session management with user notification and automatic extension
 * to maintain workflow continuity.
 * 
 * Features:
 * - Automatic session timeout warning after 25 minutes
 * - User notification with extension confirmation
 * - AJAX-based session extension requests
 * - Timer management and cleanup
 * - Configurable session extension endpoint
 * 
 * Values:
 * - url: String - Session extension API endpoint
 * 
 * Usage:
 * <div data-controller="session-extender" 
 *      data-session-extender-url-value="/api/extend-session">
 * </div>
 * 
 * Note: Timer automatically starts when URL value is set or changed
 */
class SessionExtender extends Controller {
  static values = {
    url: String
  };

  /**
   * Handle URL value changes and setup session timer
   * Resets existing timer and starts new countdown for session warning
   */
  urlValueChanged() {
    if (this.timer) {
      clearTimeout(this.timer);
    }
    var me = this;
    this.timer = setTimeout(function () {
      alert('Session Expiring! Click ok to extend session.');
      fetch(me.urlValue).then(res => {
        return res.json();
      }).then(data => {
        me.urlValueChanged();
      });
      //minutes * 60000 miliseconds per minute
    }, 25 * 60000);
  }
}
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["session-extender"] = SessionExtender;

/***/ }),

/***/ "./assets/js/controllers/sortable-list-controller.js":
/*!***********************************************************!*\
  !*** ./assets/js/controllers/sortable-list-controller.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * Sortable List Controller - Drag and Drop Reordering
 * 
 * Provides drag-and-drop reordering functionality for list items.
 * Emits a custom event when items are reordered so parent controllers
 * can respond to changes.
 * 
 * Usage:
 * <ul data-controller="sortable-list" data-action="sortable-list:reordered->parent#handleReorder">
 *   <li data-sortable-list-target="item" data-item-id="1" draggable="true">
 *     <span data-sortable-list-target="handle"></span> Item 1
 *   </li>
 *   <li data-sortable-list-target="item" data-item-id="2" draggable="true">
 *     <span data-sortable-list-target="handle"></span> Item 2
 *   </li>
 * </ul>
 * 
 * Events:
 * - sortable-list:reordered - Dispatched when order changes
 *   detail: { order: ['id1', 'id2', 'id3'], items: [...DOMElements] }
 */
class SortableListController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["item", "handle"];
  initialize() {
    this.draggedElement = null;
    this.draggedOverElement = null;
    this.boundHandlers = {
      dragstart: this.dragStart.bind(this),
      dragover: this.dragOver.bind(this),
      dragenter: this.dragEnter.bind(this),
      dragleave: this.dragLeave.bind(this),
      drop: this.drop.bind(this),
      dragend: this.dragEnd.bind(this)
    };
  }
  connect() {
    // Make items draggable
    this.itemTargets.forEach(item => {
      item.setAttribute('draggable', 'true');
      this.addDragListeners(item);
    });
  }
  disconnect() {
    this.itemTargets.forEach(item => {
      this.removeDragListeners(item);
    });
  }

  /**
   * Handle drag start - store reference to dragged element
   */
  dragStart(event) {
    this.draggedElement = event.currentTarget;
    this.draggedElement.classList.add('dragging');
    event.dataTransfer.effectAllowed = 'move';
  }

  /**
   * Handle drag over - allow drop by preventing default
   */
  dragOver(event) {
    if (event.preventDefault) {
      event.preventDefault();
    }
    event.dataTransfer.dropEffect = 'move';
    const targetItem = event.currentTarget;
    if (targetItem !== this.draggedElement) {
      this.draggedOverElement = targetItem;
      targetItem.classList.add('drag-over');
    }
    return false;
  }

  /**
   * Handle drag enter - visual feedback
   */
  dragEnter(event) {
    const targetItem = event.currentTarget;
    if (targetItem !== this.draggedElement) {
      targetItem.classList.add('drag-over');
    }
  }

  /**
   * Handle drag leave - remove visual feedback
   */
  dragLeave(event) {
    event.currentTarget.classList.remove('drag-over');
  }

  /**
   * Handle drop - reorder items
   */
  drop(event) {
    if (event.stopPropagation) {
      event.stopPropagation();
    }
    const targetItem = event.currentTarget;
    if (this.draggedElement !== targetItem) {
      // Determine if we're dropping above or below
      const rect = targetItem.getBoundingClientRect();
      const midpoint = rect.top + rect.height / 2;
      const dropAbove = event.clientY < midpoint;

      // Reorder in DOM
      if (dropAbove) {
        targetItem.parentNode.insertBefore(this.draggedElement, targetItem);
      } else {
        targetItem.parentNode.insertBefore(this.draggedElement, targetItem.nextSibling);
      }

      // Emit reordered event
      this.emitReorderedEvent();
    }
    return false;
  }

  /**
   * Handle drag end - cleanup
   */
  dragEnd(event) {
    // Remove all drag-related classes
    this.itemTargets.forEach(item => {
      item.classList.remove('dragging', 'drag-over');
    });
    this.draggedElement = null;
    this.draggedOverElement = null;
  }

  /**
   * Emit custom event with new order
   */
  emitReorderedEvent() {
    const order = this.itemTargets.map(item => {
      return item.dataset.itemId || item.dataset.columnKey || item.id;
    });
    const event = new CustomEvent('sortable-list:reordered', {
      detail: {
        order: order,
        items: this.itemTargets
      },
      bubbles: true,
      cancelable: true
    });
    this.element.dispatchEvent(event);
  }

  /**
   * Get current order of items
   */
  getOrder() {
    return this.itemTargets.map(item => {
      return item.dataset.itemId || item.dataset.columnKey || item.id;
    });
  }
  addDragListeners(item) {
    item.addEventListener('dragstart', this.boundHandlers.dragstart);
    item.addEventListener('dragover', this.boundHandlers.dragover);
    item.addEventListener('dragenter', this.boundHandlers.dragenter);
    item.addEventListener('dragleave', this.boundHandlers.dragleave);
    item.addEventListener('drop', this.boundHandlers.drop);
    item.addEventListener('dragend', this.boundHandlers.dragend);
  }
  removeDragListeners(item) {
    item.removeEventListener('dragstart', this.boundHandlers.dragstart);
    item.removeEventListener('dragover', this.boundHandlers.dragover);
    item.removeEventListener('dragenter', this.boundHandlers.dragenter);
    item.removeEventListener('dragleave', this.boundHandlers.dragleave);
    item.removeEventListener('drop', this.boundHandlers.drop);
    item.removeEventListener('dragend', this.boundHandlers.dragend);
  }
}

// Register controller
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["sortable-list"] = SortableListController;

/***/ }),

/***/ "./assets/js/controllers/timezone-input-controller.js":
/*!************************************************************!*\
  !*** ./assets/js/controllers/timezone-input-controller.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * Timezone Input Controller
 *
 * Automatically converts datetime-local inputs between user's local timezone
 * and UTC storage. Converts UTC values to local time on page load, and converts
 * back to UTC before form submission.
 *
 * See /docs/10.3.2-timezone-input-controller.md for complete documentation.
 *
 * @example
 * <form data-controller="timezone-input">
 *   <input type="datetime-local"
 *          name="start_date"
 *          data-timezone-input-target="datetimeInput"
 *          data-utc-value="2025-03-15T14:30:00Z">
 * </form>
 */
class TimezoneInputController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["datetimeInput", "notice"];
  static values = {
    timezone: String,
    showNotice: {
      type: Boolean,
      default: true
    }
  };

  /**
   * Initialize controller - detect timezone and convert UTC to local time
   */
  connect() {
    // Get or detect timezone
    this.timezone = this.hasTimezoneValue ? this.timezoneValue : KMP_Timezone.detectTimezone();

    // Convert all UTC values to local time for display
    this.convertUtcToLocal();

    // Show timezone notice if requested
    if (this.showNoticeValue && this.hasNoticeTarget) {
      this.updateNotice();
    }

    // Cache bound event handlers for proper cleanup
    this._handleSubmit = this.handleSubmit.bind(this);
    this._handleReset = this.handleReset.bind(this);

    // Attach submit handler
    this.element.addEventListener('submit', this._handleSubmit);

    // Attach reset handler
    this.element.addEventListener('reset', this._handleReset);
  }

  /**
   * Convert UTC values to local timezone for input display
   * Stores original and local values in data attributes for reset
   */
  convertUtcToLocal() {
    this.datetimeInputTargets.forEach(input => {
      const utcValue = input.dataset.utcValue;
      if (utcValue) {
        // Convert UTC to local time for input
        const localValue = KMP_Timezone.toLocalInput(utcValue, this.timezone);
        input.value = localValue;

        // Store original UTC value for reference
        input.dataset.originalUtc = utcValue;

        // Store converted local value for reset
        input.dataset.localValue = localValue;
      }
    });
  }

  /**
   * Update timezone notice elements
   */
  updateNotice() {
    const abbr = KMP_Timezone.getAbbreviation(this.timezone);
    const noticeText = `Times shown in ${this.timezone} (${abbr})`;
    this.noticeTargets.forEach(notice => {
      while (notice.firstChild) {
        notice.removeChild(notice.firstChild);
      }
      const icon = document.createElement('i');
      icon.classList.add('bi', 'bi-clock');
      notice.appendChild(icon);
      notice.appendChild(document.createTextNode(` ${noticeText}`));
    });
  }

  /**
   * Handle form submission - convert local times to UTC and create hidden inputs
   * @param {Event} event
   */
  handleSubmit(event) {
    this.datetimeInputTargets.forEach(input => {
      if (input.value) {
        // Convert local time to UTC
        const utcValue = KMP_Timezone.toUTC(input.value, this.timezone);

        // Store original local value for potential reset
        input.dataset.submittedLocal = input.value;
        // Only proceed when conversion succeeds
        if (utcValue) {
          delete input.dataset.timezoneConversionFailed;

          // If the original input is already disabled from a previous submit, skip
          if (input.disabled) {
            return;
          }

          // Remove any prior hidden UTC inputs for this field
          const existingHidden = this.element.querySelectorAll(`input[name="${CSS.escape(input.name)}"][data-timezone-converted="true"]`);
          existingHidden.forEach(el => el.remove());

          // Create hidden input with UTC value
          const hiddenInput = document.createElement('input');
          hiddenInput.type = 'hidden';
          hiddenInput.name = input.name;
          hiddenInput.value = utcValue;
          hiddenInput.dataset.timezoneConverted = 'true';

          // Disable original input so it doesn't submit
          input.disabled = true;

          // Add hidden input to form
          this.element.appendChild(hiddenInput);
        } else {
          input.dataset.timezoneConversionFailed = 'true';
        }
      }
    });
  }

  /**
   * Handle form reset - remove hidden inputs and restore original local values
   * @param {Event} event
   */
  handleReset(event) {
    // Remove any hidden UTC inputs
    const hiddenInputs = this.element.querySelectorAll('input[data-timezone-converted="true"]');
    hiddenInputs.forEach(input => input.remove());

    // Re-enable and restore datetime inputs
    this.datetimeInputTargets.forEach(input => {
      input.disabled = false;
      delete input.dataset.timezoneConversionFailed;

      // Restore to original local value
      if (input.dataset.localValue) {
        setTimeout(() => {
          input.value = input.dataset.localValue;
        }, 0);
      }
    });
  }

  /**
   * Manually update timezone and re-convert all values
   * @param {string} newTimezone - IANA timezone identifier
   */
  updateTimezone(newTimezone) {
    this.timezone = newTimezone;

    // Re-convert all values with new timezone
    this.convertUtcToLocal();

    // Update notice if shown
    if (this.showNoticeValue && this.hasNoticeTarget) {
      this.updateNotice();
    }
  }

  /**
   * Get current timezone being used
   * @returns {string} Current IANA timezone identifier
   */
  getTimezone() {
    return this.timezone;
  }

  /**
   * Cleanup on disconnect - remove event listeners and prevent memory leaks
   */
  disconnect() {
    // Remove event listeners using cached references
    if (this._handleSubmit) {
      this.element.removeEventListener('submit', this._handleSubmit);
      this._handleSubmit = null;
    }
    if (this._handleReset) {
      this.element.removeEventListener('reset', this._handleReset);
      this._handleReset = null;
    }
  }
}

// Add to global controllers registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["timezone-input"] = TimezoneInputController;

/***/ }),

/***/ "./assets/js/controllers/turbo-modal-controller.js":
/*!*********************************************************!*\
  !*** ./assets/js/controllers/turbo-modal-controller.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/* provided dependency */ var bootstrap = __webpack_require__(/*! bootstrap */ "./node_modules/bootstrap/dist/js/bootstrap.esm.js");


/**
 * TurboModal Stimulus Controller
 * 
 * Handles modal closing before form submission to prevent modal being open during
 * Turbo Stream updates. Closes the modal when form is submitted, allowing the
 * background page to update cleanly.
 * 
 * Features:
 * - Modal closing before form submission
 * - Bootstrap modal integration
 * - Turbo Form submission handling
 * - Prevents modal from interfering with page updates
 * 
 * Usage:
 * <form data-controller="turbo-modal" 
 *       data-action="turbo:submit-start->turbo-modal#closeModalBeforeSubmit"
 *       data-turbo="true">
 *   <!-- Form contents -->
 * </form>
 * 
 * The modal will close immediately when the form is submitted.
 */
class TurboModal extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  /**
   * Initialize - log when controller connects
   */
  connect() {
    console.log('TurboModal controller connected');
  }

  /**
   * Close the modal before form submission starts
   * 
   * @param {Event} event - The turbo:submit-start event
   */
  closeModalBeforeSubmit(event) {
    console.log('turbo:submit-start - closing modal before submission');

    // Find the modal element (closest modal parent)
    const modal = this.element.closest('.modal');
    if (modal) {
      const modalInstance = bootstrap.Modal.getInstance(modal);
      if (modalInstance) {
        console.log('Closing modal...');
        modalInstance.hide();
      }
    }
  }
}
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["turbo-modal"] = TurboModal;

/***/ }),

/***/ "./assets/js/controllers/variable-insert-controller.js":
/*!*************************************************************!*\
  !*** ./assets/js/controllers/variable-insert-controller.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * Variable Insert Controller
 * 
 * Provides variable insertion functionality for textarea/input fields.
 * Allows clicking buttons to insert template variables at cursor position.
 * 
 * Usage:
 * <div data-controller="variable-insert">
 *   <textarea data-variable-insert-target="field" id="my-field"></textarea>
 *   <button data-action="variable-insert#insert" 
 *           data-variable-insert-variable-param="email">
 *     Insert {{email}}
 *   </button>
 * </div>
 */
class VariableInsertController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["field"];

  /**
   * Insert a variable at the cursor position in the target field
   * 
   * @param {Event} event - Click event from button
   */
  insert(event) {
    event.preventDefault();
    const variable = event.params.variable;
    if (!variable) {
      console.warn('No variable specified for insertion');
      return;
    }
    if (!this.hasFieldTarget) {
      console.warn('No field target found');
      return;
    }
    const field = this.fieldTarget;

    // Get current cursor position
    const start = field.selectionStart;
    const end = field.selectionEnd;
    const text = field.value;

    // Build variable syntax
    const variableText = `{{${variable}}}`;

    // Insert variable at cursor position
    const before = text.substring(0, start);
    const after = text.substring(end);
    field.value = before + variableText + after;

    // Move cursor after the inserted text
    const newPosition = start + variableText.length;
    field.selectionStart = field.selectionEnd = newPosition;

    // Focus the field
    field.focus();

    // Trigger input event for any listeners
    field.dispatchEvent(new Event('input', {
      bubbles: true
    }));
  }
}

// Add to global controllers registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["variable-insert"] = VariableInsertController;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _defineProperty; }
/* harmony export */ });
/* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toPropertyKey.js */ "./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js");

function _defineProperty(e, r, t) {
  return (r = (0,_toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__["default"])(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/objectSpread2.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _objectSpread2; }
/* harmony export */ });
/* harmony import */ var _defineProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defineProperty.js */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");

function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      (0,_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__["default"])(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toPrimitive.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ toPrimitive; }
/* harmony export */ });
/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");

function toPrimitive(t, r) {
  if ("object" != (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ toPropertyKey; }
/* harmony export */ });
/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toPrimitive.js */ "./node_modules/@babel/runtime/helpers/esm/toPrimitive.js");


function toPropertyKey(t) {
  var i = (0,_toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__["default"])(t, "string");
  return "symbol" == (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(i) ? i : i + "";
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _typeof; }
/* harmony export */ });
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}


/***/ }),

/***/ "./node_modules/@popperjs/core/lib/createPopper.js":
/*!*********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/createPopper.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createPopper: function() { return /* binding */ createPopper; },
/* harmony export */   detectOverflow: function() { return /* reexport safe */ _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_8__["default"]; },
/* harmony export */   popperGenerator: function() { return /* binding */ popperGenerator; }
/* harmony export */ });
/* harmony import */ var _dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dom-utils/getCompositeRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-utils/listScrollParents.js */ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/orderModifiers.js */ "./node_modules/@popperjs/core/lib/utils/orderModifiers.js");
/* harmony import */ var _utils_debounce_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/debounce.js */ "./node_modules/@popperjs/core/lib/utils/debounce.js");
/* harmony import */ var _utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/mergeByName.js */ "./node_modules/@popperjs/core/lib/utils/mergeByName.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");









var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(setOptionsAction) {
        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: (0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(reference) ? (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__["default"])(reference) : reference.contextElement ? (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__["default"])(reference.contextElement) : [],
          popper: (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__["default"])(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = (0,_utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_3__["default"])([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: (0,_dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_4__["default"])(reference, (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_5__["default"])(popper), state.options.strategy === 'fixed'),
          popper: (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__["default"])(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: (0,_utils_debounce_js__WEBPACK_IMPORTED_MODULE_7__["default"])(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {
      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref) {
        var name = _ref.name,
            _ref$options = _ref.options,
            options = _ref$options === void 0 ? {} : _ref$options,
            effect = _ref.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}
var createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/contains.js":
/*!***************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/contains.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ contains; }
/* harmony export */ });
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isShadowRoot)(rootNode)) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe[prop-missing]: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


  return false;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getBoundingClientRect; }
/* harmony export */ });
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isLayoutViewport.js */ "./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js");




function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }

  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }

  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;

  if (includeScale && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {
    scaleX = element.offsetWidth > 0 ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_1__.round)(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_1__.round)(clientRect.height) / element.offsetHeight || 1 : 1;
  }

  var _ref = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element) : window,
      visualViewport = _ref.visualViewport;

  var addVisualOffsets = !(0,_isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_3__["default"])() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x: x,
    y: y
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getClippingRect; }
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _getViewportRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getViewportRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js");
/* harmony import */ var _getDocumentRect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getDocumentRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js");
/* harmony import */ var _listScrollParents_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./listScrollParents.js */ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js");
/* harmony import */ var _getOffsetParent_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./contains.js */ "./node_modules/@popperjs/core/lib/dom-utils/contains.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/rectToClientRect.js */ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");















function getInnerBoundingClientRect(element, strategy) {
  var rect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element, false, strategy === 'fixed');
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}

function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === _enums_js__WEBPACK_IMPORTED_MODULE_1__.viewport ? (0,_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_getViewportRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element, strategy)) : (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : (0,_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_getDocumentRect_js__WEBPACK_IMPORTED_MODULE_5__["default"])((0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_6__["default"])(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = (0,_listScrollParents_js__WEBPACK_IMPORTED_MODULE_7__["default"])((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_8__["default"])(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf((0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_9__["default"])(element).position) >= 0;
  var clipperElement = canEscapeClipping && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(element) ? (0,_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_10__["default"])(element) : element;

  if (!(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(clippingParent) && (0,_contains_js__WEBPACK_IMPORTED_MODULE_11__["default"])(clippingParent, clipperElement) && (0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_12__["default"])(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.max)(rect.top, accRect.top);
    accRect.right = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.min)(rect.right, accRect.right);
    accRect.bottom = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.min)(rect.bottom, accRect.bottom);
    accRect.left = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.max)(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getCompositeRect; }
/* harmony export */ });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getNodeScroll_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getNodeScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");









function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(rect.width) / element.offsetWidth || 1;
  var scaleY = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.


function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var isOffsetParentAnElement = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent);
  var offsetParentIsScaled = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent) && isElementScaled(offsetParent);
  var documentElement = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(offsetParent);
  var rect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__["default"])(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_5__["default"])(documentElement)) {
      scroll = (0,_getNodeScroll_js__WEBPACK_IMPORTED_MODULE_6__["default"])(offsetParent);
    }

    if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent)) {
      offsets = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_7__["default"])(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getComputedStyle; }
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");

function getComputedStyle(element) {
  return (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element).getComputedStyle(element);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getDocumentElement; }
/* harmony export */ });
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return (((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getDocumentRect; }
/* harmony export */ });
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");




 // Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;

  var html = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var winScroll = (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element);
  var y = -winScroll.scrollTop;

  if ((0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__["default"])(body || html).direction === 'rtl') {
    x += (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_2__.max)(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getHTMLElementScroll; }
/* harmony export */ });
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getLayoutRect; }
/* harmony export */ });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
 // Returns the layout rect of an element relative to its offsetParent. Layout
// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;

  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }

  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }

  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getNodeName; }
/* harmony export */ });
function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getNodeScroll; }
/* harmony export */ });
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getHTMLElementScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js");




function getNodeScroll(node) {
  if (node === (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node) || !(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(node)) {
    return (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__["default"])(node);
  } else {
    return (0,_getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node);
  }
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getOffsetParent; }
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _isTableElement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./isTableElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js");
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _utils_userAgent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/userAgent.js */ "./node_modules/@popperjs/core/lib/utils/userAgent.js");








function getTrueOffsetParent(element) {
  if (!(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || // https://github.com/popperjs/popper-core/issues/837
  (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block


function getContainingBlock(element) {
  var isFirefox = /firefox/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_2__["default"])());
  var isIE = /Trident/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_2__["default"])());

  if (isIE && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);

    if (elementCss.position === 'fixed') {
      return null;
    }
  }

  var currentNode = (0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element);

  if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isShadowRoot)(currentNode)) {
    currentNode = currentNode.host;
  }

  while ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(currentNode) && ['html', 'body'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__["default"])(currentNode)) < 0) {
    var css = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  var window = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_5__["default"])(element);
  var offsetParent = getTrueOffsetParent(element);

  while (offsetParent && (0,_isTableElement_js__WEBPACK_IMPORTED_MODULE_6__["default"])(offsetParent) && (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__["default"])(offsetParent) === 'html' || (0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__["default"])(offsetParent) === 'body' && (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent).position === 'static')) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getParentNode; }
/* harmony export */ });
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");



function getParentNode(element) {
  if ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element) === 'html') {
    return element;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || ( // DOM Element detected
    (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isShadowRoot)(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element) // fallback

  );
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getScrollParent; }
/* harmony export */ });
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");




function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }

  if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(node) && (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__["default"])(node)) {
    return node;
  }

  return getScrollParent((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node));
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getViewportRect; }
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");
/* harmony import */ var _isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isLayoutViewport.js */ "./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js");




function getViewportRect(element, strategy) {
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var html = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = (0,_isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_2__["default"])();

    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width: width,
    height: height,
    x: x + (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element),
    y: y
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js":
/*!****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindow.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getWindow; }
/* harmony export */ });
function getWindow(node) {
  if (node == null) {
    return window;
  }

  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getWindowScroll; }
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");

function getWindowScroll(node) {
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getWindowScrollBarX; }
/* harmony export */ });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");



function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)).left + (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element).scrollLeft;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isElement: function() { return /* binding */ isElement; },
/* harmony export */   isHTMLElement: function() { return /* binding */ isHTMLElement; },
/* harmony export */   isShadowRoot: function() { return /* binding */ isShadowRoot; }
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");


function isElement(node) {
  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}

function isHTMLElement(node) {
  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ isLayoutViewport; }
/* harmony export */ });
/* harmony import */ var _utils_userAgent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/userAgent.js */ "./node_modules/@popperjs/core/lib/utils/userAgent.js");

function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_0__["default"])());
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ isScrollParent; }
/* harmony export */ });
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ isTableElement; }
/* harmony export */ });
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element)) >= 0;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js":
/*!************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ listScrollParents; }
/* harmony export */ });
/* harmony import */ var _getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js");
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");




/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;

  if (list === void 0) {
    list = [];
  }

  var scrollParent = (0,_getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__["default"])(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_3__["default"])(target)));
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/enums.js":
/*!**************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/enums.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   afterMain: function() { return /* binding */ afterMain; },
/* harmony export */   afterRead: function() { return /* binding */ afterRead; },
/* harmony export */   afterWrite: function() { return /* binding */ afterWrite; },
/* harmony export */   auto: function() { return /* binding */ auto; },
/* harmony export */   basePlacements: function() { return /* binding */ basePlacements; },
/* harmony export */   beforeMain: function() { return /* binding */ beforeMain; },
/* harmony export */   beforeRead: function() { return /* binding */ beforeRead; },
/* harmony export */   beforeWrite: function() { return /* binding */ beforeWrite; },
/* harmony export */   bottom: function() { return /* binding */ bottom; },
/* harmony export */   clippingParents: function() { return /* binding */ clippingParents; },
/* harmony export */   end: function() { return /* binding */ end; },
/* harmony export */   left: function() { return /* binding */ left; },
/* harmony export */   main: function() { return /* binding */ main; },
/* harmony export */   modifierPhases: function() { return /* binding */ modifierPhases; },
/* harmony export */   placements: function() { return /* binding */ placements; },
/* harmony export */   popper: function() { return /* binding */ popper; },
/* harmony export */   read: function() { return /* binding */ read; },
/* harmony export */   reference: function() { return /* binding */ reference; },
/* harmony export */   right: function() { return /* binding */ right; },
/* harmony export */   start: function() { return /* binding */ start; },
/* harmony export */   top: function() { return /* binding */ top; },
/* harmony export */   variationPlacements: function() { return /* binding */ variationPlacements; },
/* harmony export */   viewport: function() { return /* binding */ viewport; },
/* harmony export */   write: function() { return /* binding */ write; }
/* harmony export */ });
var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   afterMain: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.afterMain; },
/* harmony export */   afterRead: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.afterRead; },
/* harmony export */   afterWrite: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.afterWrite; },
/* harmony export */   applyStyles: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.applyStyles; },
/* harmony export */   arrow: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.arrow; },
/* harmony export */   auto: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.auto; },
/* harmony export */   basePlacements: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements; },
/* harmony export */   beforeMain: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.beforeMain; },
/* harmony export */   beforeRead: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.beforeRead; },
/* harmony export */   beforeWrite: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.beforeWrite; },
/* harmony export */   bottom: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom; },
/* harmony export */   clippingParents: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.clippingParents; },
/* harmony export */   computeStyles: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.computeStyles; },
/* harmony export */   createPopper: function() { return /* reexport safe */ _popper_js__WEBPACK_IMPORTED_MODULE_4__.createPopper; },
/* harmony export */   createPopperBase: function() { return /* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_2__.createPopper; },
/* harmony export */   createPopperLite: function() { return /* reexport safe */ _popper_lite_js__WEBPACK_IMPORTED_MODULE_5__.createPopper; },
/* harmony export */   detectOverflow: function() { return /* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_3__["default"]; },
/* harmony export */   end: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.end; },
/* harmony export */   eventListeners: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.eventListeners; },
/* harmony export */   flip: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.flip; },
/* harmony export */   hide: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.hide; },
/* harmony export */   left: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.left; },
/* harmony export */   main: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.main; },
/* harmony export */   modifierPhases: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.modifierPhases; },
/* harmony export */   offset: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.offset; },
/* harmony export */   placements: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.placements; },
/* harmony export */   popper: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper; },
/* harmony export */   popperGenerator: function() { return /* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_2__.popperGenerator; },
/* harmony export */   popperOffsets: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.popperOffsets; },
/* harmony export */   preventOverflow: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.preventOverflow; },
/* harmony export */   read: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.read; },
/* harmony export */   reference: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.reference; },
/* harmony export */   right: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.right; },
/* harmony export */   start: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.start; },
/* harmony export */   top: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.top; },
/* harmony export */   variationPlacements: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements; },
/* harmony export */   viewport: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.viewport; },
/* harmony export */   write: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.write; }
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/index.js */ "./node_modules/@popperjs/core/lib/modifiers/index.js");
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/createPopper.js");
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _popper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./popper.js */ "./node_modules/@popperjs/core/lib/popper.js");
/* harmony import */ var _popper_lite_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./popper-lite.js */ "./node_modules/@popperjs/core/lib/popper-lite.js");

 // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/applyStyles.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

 // This modifier takes the styles prepared by the `computeStyles` modifier
// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || !(0,_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || !(0,_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)) {
        return;
      }

      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect,
  requires: ['computeStyles']
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/arrow.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/arrow.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../dom-utils/contains.js */ "./node_modules/@popperjs/core/lib/dom-utils/contains.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/within.js */ "./node_modules/@popperjs/core/lib/utils/within.js");
/* harmony import */ var _utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/mergePaddingObject.js */ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js");
/* harmony import */ var _utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/expandToHashMap.js */ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");








 // eslint-disable-next-line import/no-unused-modules

var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return (0,_utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(typeof padding !== 'number' ? padding : (0,_utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_1__["default"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_2__.basePlacements));
};

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name,
      options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(state.placement);
  var axis = (0,_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(basePlacement);
  var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_2__.left, _enums_js__WEBPACK_IMPORTED_MODULE_2__.right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_5__["default"])(arrowElement);
  var minProp = axis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_2__.top : _enums_js__WEBPACK_IMPORTED_MODULE_2__.left;
  var maxProp = axis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_2__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_2__.right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_6__["default"])(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_7__.within)(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function effect(_ref2) {
  var state = _ref2.state,
      options = _ref2.options;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if (!(0,_dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_8__["default"])(state.elements.popper, arrowElement)) {
    return;
  }

  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/computeStyles.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mapToStyles: function() { return /* binding */ mapToStyles; }
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");







 // eslint-disable-next-line import/no-unused-modules

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x,
      y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(x * dpr) / dpr || 0,
    y: (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(y * dpr) / dpr || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      variation = _ref2.variation,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive,
      roundOffsets = _ref2.roundOffsets,
      isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x,
      x = _offsets$x === void 0 ? 0 : _offsets$x,
      _offsets$y = offsets.y,
      y = _offsets$y === void 0 ? 0 : _offsets$y;

  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };

  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = _enums_js__WEBPACK_IMPORTED_MODULE_1__.left;
  var sideY = _enums_js__WEBPACK_IMPORTED_MODULE_1__.top;
  var win = window;

  if (adaptive) {
    var offsetParent = (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_2__["default"])(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';

    if (offsetParent === (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_3__["default"])(popper)) {
      offsetParent = (0,_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(popper);

      if ((0,_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_5__["default"])(offsetParent).position !== 'static' && position === 'absolute') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


    offsetParent = offsetParent;

    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.top || (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.left || placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.right) && variation === _enums_js__WEBPACK_IMPORTED_MODULE_1__.end) {
      sideY = _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
      offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.left || (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.top || placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom) && variation === _enums_js__WEBPACK_IMPORTED_MODULE_1__.end) {
      sideX = _enums_js__WEBPACK_IMPORTED_MODULE_1__.right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
      offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x,
    y: y
  }, (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_3__["default"])(popper)) : {
    x: x,
    y: y
  };

  x = _ref4.x;
  y = _ref4.y;

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref5) {
  var state = _ref5.state,
      options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
      _options$roundOffsets = options.roundOffsets,
      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state.placement),
    variation: (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_7__["default"])(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration,
    isFixed: state.options.strategy === 'fixed'
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }

  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/eventListeners.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
 // eslint-disable-next-line import/no-unused-modules

var passive = {
  passive: true
};

function effect(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/flip.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/flip.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getOppositePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getOppositeVariationPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/computeAutoPlacement.js */ "./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");






 // eslint-disable-next-line import/no-unused-modules

function getExpandedFallbackPlacements(placement) {
  if ((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.auto) {
    return [];
  }

  var oppositePlacement = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(placement);
  return [(0,_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(placement), oppositePlacement, (0,_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [(0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.auto ? (0,_utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);

    var isStartVariation = (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_5__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.start;
    var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_1__.top, _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_1__.right : _enums_js__WEBPACK_IMPORTED_MODULE_1__.left : isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_1__.top;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(mainVariationSide);
    }

    var altVariationSide = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases  research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/hide.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/hide.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");



function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [_enums_js__WEBPACK_IMPORTED_MODULE_0__.top, _enums_js__WEBPACK_IMPORTED_MODULE_0__.right, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom, _enums_js__WEBPACK_IMPORTED_MODULE_0__.left].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyStyles: function() { return /* reexport safe */ _applyStyles_js__WEBPACK_IMPORTED_MODULE_0__["default"]; },
/* harmony export */   arrow: function() { return /* reexport safe */ _arrow_js__WEBPACK_IMPORTED_MODULE_1__["default"]; },
/* harmony export */   computeStyles: function() { return /* reexport safe */ _computeStyles_js__WEBPACK_IMPORTED_MODULE_2__["default"]; },
/* harmony export */   eventListeners: function() { return /* reexport safe */ _eventListeners_js__WEBPACK_IMPORTED_MODULE_3__["default"]; },
/* harmony export */   flip: function() { return /* reexport safe */ _flip_js__WEBPACK_IMPORTED_MODULE_4__["default"]; },
/* harmony export */   hide: function() { return /* reexport safe */ _hide_js__WEBPACK_IMPORTED_MODULE_5__["default"]; },
/* harmony export */   offset: function() { return /* reexport safe */ _offset_js__WEBPACK_IMPORTED_MODULE_6__["default"]; },
/* harmony export */   popperOffsets: function() { return /* reexport safe */ _popperOffsets_js__WEBPACK_IMPORTED_MODULE_7__["default"]; },
/* harmony export */   preventOverflow: function() { return /* reexport safe */ _preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__["default"]; }
/* harmony export */ });
/* harmony import */ var _applyStyles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");
/* harmony import */ var _arrow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./arrow.js */ "./node_modules/@popperjs/core/lib/modifiers/arrow.js");
/* harmony import */ var _computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");
/* harmony import */ var _eventListeners_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");
/* harmony import */ var _flip_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flip.js */ "./node_modules/@popperjs/core/lib/modifiers/flip.js");
/* harmony import */ var _hide_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hide.js */ "./node_modules/@popperjs/core/lib/modifiers/hide.js");
/* harmony import */ var _offset_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./offset.js */ "./node_modules/@popperjs/core/lib/modifiers/offset.js");
/* harmony import */ var _popperOffsets_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");
/* harmony import */ var _preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./preventOverflow.js */ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js");










/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/offset.js":
/*!*************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/offset.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   distanceAndSkiddingToXY: function() { return /* binding */ distanceAndSkiddingToXY; }
/* harmony export */ });
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");

 // eslint-disable-next-line import/no-unused-modules

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);
  var invertDistance = [_enums_js__WEBPACK_IMPORTED_MODULE_1__.left, _enums_js__WEBPACK_IMPORTED_MODULE_1__.top].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [_enums_js__WEBPACK_IMPORTED_MODULE_1__.left, _enums_js__WEBPACK_IMPORTED_MODULE_1__.right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = _enums_js__WEBPACK_IMPORTED_MODULE_1__.placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/computeOffsets.js */ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js");


function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = (0,_utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/getAltAxis.js */ "./node_modules/@popperjs/core/lib/utils/getAltAxis.js");
/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/within.js */ "./node_modules/@popperjs/core/lib/utils/within.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/getFreshSideObject.js */ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");












function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state.placement);
  var variation = (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = (0,_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(basePlacement);
  var altAxis = (0,_utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_4__["default"])(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis) {
    var _offsetModifierState$;

    var mainSide = mainAxis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.top : _enums_js__WEBPACK_IMPORTED_MODULE_5__.left;
    var altSide = mainAxis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_5__.right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min = offset + overflow[mainSide];
    var max = offset - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_5__.start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_5__.start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__["default"])(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : (0,_utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_7__["default"])();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.within)(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_9__["default"])(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset + maxOffset - offsetModifierValue;
    var preventedOffset = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.within)(tether ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_10__.min)(min, tetherMin) : min, offset, tether ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_10__.max)(max, tetherMax) : max);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }

  if (checkAltAxis) {
    var _offsetModifierState$2;

    var _mainSide = mainAxis === 'x' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.top : _enums_js__WEBPACK_IMPORTED_MODULE_5__.left;

    var _altSide = mainAxis === 'x' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_5__.right;

    var _offset = popperOffsets[altAxis];

    var _len = altAxis === 'y' ? 'height' : 'width';

    var _min = _offset + overflow[_mainSide];

    var _max = _offset - overflow[_altSide];

    var isOriginSide = [_enums_js__WEBPACK_IMPORTED_MODULE_5__.top, _enums_js__WEBPACK_IMPORTED_MODULE_5__.left].indexOf(basePlacement) !== -1;

    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

    var _preventedOffset = tether && isOriginSide ? (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.withinMaxClamp)(_tetherMin, _offset, _tetherMax) : (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.within)(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/popper-lite.js":
/*!********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/popper-lite.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createPopper: function() { return /* binding */ createPopper; },
/* harmony export */   defaultModifiers: function() { return /* binding */ defaultModifiers; },
/* harmony export */   detectOverflow: function() { return /* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_5__["default"]; },
/* harmony export */   popperGenerator: function() { return /* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_4__.popperGenerator; }
/* harmony export */ });
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/createPopper.js");
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");
/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");
/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");
/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");





var defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__["default"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__["default"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__["default"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__["default"]];
var createPopper = /*#__PURE__*/(0,_createPopper_js__WEBPACK_IMPORTED_MODULE_4__.popperGenerator)({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/popper.js":
/*!***************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/popper.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyStyles: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.applyStyles; },
/* harmony export */   arrow: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.arrow; },
/* harmony export */   computeStyles: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.computeStyles; },
/* harmony export */   createPopper: function() { return /* binding */ createPopper; },
/* harmony export */   createPopperLite: function() { return /* reexport safe */ _popper_lite_js__WEBPACK_IMPORTED_MODULE_11__.createPopper; },
/* harmony export */   defaultModifiers: function() { return /* binding */ defaultModifiers; },
/* harmony export */   detectOverflow: function() { return /* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_10__["default"]; },
/* harmony export */   eventListeners: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.eventListeners; },
/* harmony export */   flip: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.flip; },
/* harmony export */   hide: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.hide; },
/* harmony export */   offset: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.offset; },
/* harmony export */   popperGenerator: function() { return /* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_9__.popperGenerator; },
/* harmony export */   popperOffsets: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.popperOffsets; },
/* harmony export */   preventOverflow: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.preventOverflow; }
/* harmony export */ });
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/createPopper.js");
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");
/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");
/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");
/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");
/* harmony import */ var _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modifiers/offset.js */ "./node_modules/@popperjs/core/lib/modifiers/offset.js");
/* harmony import */ var _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modifiers/flip.js */ "./node_modules/@popperjs/core/lib/modifiers/flip.js");
/* harmony import */ var _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modifiers/preventOverflow.js */ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js");
/* harmony import */ var _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modifiers/arrow.js */ "./node_modules/@popperjs/core/lib/modifiers/arrow.js");
/* harmony import */ var _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modifiers/hide.js */ "./node_modules/@popperjs/core/lib/modifiers/hide.js");
/* harmony import */ var _popper_lite_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./popper-lite.js */ "./node_modules/@popperjs/core/lib/popper-lite.js");
/* harmony import */ var _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modifiers/index.js */ "./node_modules/@popperjs/core/lib/modifiers/index.js");










var defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__["default"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__["default"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__["default"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__["default"], _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_4__["default"], _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_5__["default"], _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_6__["default"], _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_7__["default"], _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_8__["default"]];
var createPopper = /*#__PURE__*/(0,_createPopper_js__WEBPACK_IMPORTED_MODULE_9__.popperGenerator)({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ computeAutoPlacement; }
/* harmony export */ });
/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");




function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.placements : _options$allowedAutoP;
  var variation = (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement);
  var placements = variation ? flipVariations ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements : _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements.filter(function (placement) {
    return (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) === variation;
  }) : _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements;
  var allowedPlacements = placements.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });

  if (allowedPlacements.length === 0) {
    allowedPlacements = placements;
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = (0,_detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[(0,_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/computeOffsets.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ computeOffsets; }
/* harmony export */ });
/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");




function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? (0,_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) : null;
  var variation = placement ? (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? (0,_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case _enums_js__WEBPACK_IMPORTED_MODULE_2__.start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;

      case _enums_js__WEBPACK_IMPORTED_MODULE_2__.end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;

      default:
    }
  }

  return offsets;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/debounce.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/debounce.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ debounce; }
/* harmony export */ });
function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/detectOverflow.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ detectOverflow; }
/* harmony export */ });
/* harmony import */ var _dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getClippingRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js");
/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _computeOffsets_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./computeOffsets.js */ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js");
/* harmony import */ var _rectToClientRect_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rectToClientRect.js */ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mergePaddingObject.js */ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js");
/* harmony import */ var _expandToHashMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./expandToHashMap.js */ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js");








 // eslint-disable-next-line import/no-unused-modules

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$strategy = _options.strategy,
      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = (0,_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(typeof padding !== 'number' ? padding : (0,_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_2__["default"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements));
  var altContext = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.reference : _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = (0,_dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])((0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(element) ? element : element.contextElement || (0,_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__["default"])(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = (0,_dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state.elements.reference);
  var popperOffsets = (0,_computeOffsets_js__WEBPACK_IMPORTED_MODULE_7__["default"])({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = (0,_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_8__["default"])(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [_enums_js__WEBPACK_IMPORTED_MODULE_0__.right, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [_enums_js__WEBPACK_IMPORTED_MODULE_0__.top, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/expandToHashMap.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ expandToHashMap; }
/* harmony export */ });
function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getAltAxis.js":
/*!*************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getAltAxis.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getAltAxis; }
/* harmony export */ });
function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getBasePlacement.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getBasePlacement; }
/* harmony export */ });

function getBasePlacement(placement) {
  return placement.split('-')[0];
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getFreshSideObject; }
/* harmony export */ });
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getMainAxisFromPlacement; }
/* harmony export */ });
function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getOppositePlacement; }
/* harmony export */ });
var hash = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getOppositeVariationPlacement; }
/* harmony export */ });
var hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getVariation.js":
/*!***************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getVariation.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getVariation; }
/* harmony export */ });
function getVariation(placement) {
  return placement.split('-')[1];
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/math.js":
/*!*******************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/math.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   max: function() { return /* binding */ max; },
/* harmony export */   min: function() { return /* binding */ min; },
/* harmony export */   round: function() { return /* binding */ round; }
/* harmony export */ });
var max = Math.max;
var min = Math.min;
var round = Math.round;

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/mergeByName.js":
/*!**************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/mergeByName.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ mergeByName; }
/* harmony export */ });
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ mergePaddingObject; }
/* harmony export */ });
/* harmony import */ var _getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getFreshSideObject.js */ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js");

function mergePaddingObject(paddingObject) {
  return Object.assign({}, (0,_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(), paddingObject);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/orderModifiers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/orderModifiers.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ orderModifiers; }
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
 // source: https://stackoverflow.com/questions/49875255

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return _enums_js__WEBPACK_IMPORTED_MODULE_0__.modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/rectToClientRect.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ rectToClientRect; }
/* harmony export */ });
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/userAgent.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/userAgent.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getUAString; }
/* harmony export */ });
function getUAString() {
  var uaData = navigator.userAgentData;

  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function (item) {
      return item.brand + "/" + item.version;
    }).join(' ');
  }

  return navigator.userAgent;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/within.js":
/*!*********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/within.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   within: function() { return /* binding */ within; },
/* harmony export */   withinMaxClamp: function() { return /* binding */ withinMaxClamp; }
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");

function within(min, value, max) {
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.max)(min, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(value, max));
}
function withinMaxClamp(min, value, max) {
  var v = within(min, value, max);
  return v > max ? max : v;
}

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = __webpack_require__.g.TYPED_ARRAY_SUPPORT !== undefined
  ? __webpack_require__.g.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}


/***/ }),

/***/ "./node_modules/codemirror-spell-checker/src/js/spell-checker.js":
/*!***********************************************************************!*\
  !*** ./node_modules/codemirror-spell-checker/src/js/spell-checker.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// Use strict mode (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)



// Requires
var Typo = __webpack_require__(/*! typo-js */ "./node_modules/typo-js/typo.js");


// Create function
function CodeMirrorSpellChecker(options) {
	// Initialize
	options = options || {};


	// Verify
	if(typeof options.codeMirrorInstance !== "function" || typeof options.codeMirrorInstance.defineMode !== "function") {
		console.log("CodeMirror Spell Checker: You must provide an instance of CodeMirror via the option `codeMirrorInstance`");
		return;
	}


	// Because some browsers don't support this functionality yet
	if(!String.prototype.includes) {
		String.prototype.includes = function() {
			"use strict";
			return String.prototype.indexOf.apply(this, arguments) !== -1;
		};
	}


	// Define the new mode
	options.codeMirrorInstance.defineMode("spell-checker", function(config) {
		// Load AFF/DIC data
		if(!CodeMirrorSpellChecker.aff_loading) {
			CodeMirrorSpellChecker.aff_loading = true;
			var xhr_aff = new XMLHttpRequest();
			xhr_aff.open("GET", "https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.aff", true);
			xhr_aff.onload = function() {
				if(xhr_aff.readyState === 4 && xhr_aff.status === 200) {
					CodeMirrorSpellChecker.aff_data = xhr_aff.responseText;
					CodeMirrorSpellChecker.num_loaded++;

					if(CodeMirrorSpellChecker.num_loaded == 2) {
						CodeMirrorSpellChecker.typo = new Typo("en_US", CodeMirrorSpellChecker.aff_data, CodeMirrorSpellChecker.dic_data, {
							platform: "any"
						});
					}
				}
			};
			xhr_aff.send(null);
		}

		if(!CodeMirrorSpellChecker.dic_loading) {
			CodeMirrorSpellChecker.dic_loading = true;
			var xhr_dic = new XMLHttpRequest();
			xhr_dic.open("GET", "https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.dic", true);
			xhr_dic.onload = function() {
				if(xhr_dic.readyState === 4 && xhr_dic.status === 200) {
					CodeMirrorSpellChecker.dic_data = xhr_dic.responseText;
					CodeMirrorSpellChecker.num_loaded++;

					if(CodeMirrorSpellChecker.num_loaded == 2) {
						CodeMirrorSpellChecker.typo = new Typo("en_US", CodeMirrorSpellChecker.aff_data, CodeMirrorSpellChecker.dic_data, {
							platform: "any"
						});
					}
				}
			};
			xhr_dic.send(null);
		}


		// Define what separates a word
		var rx_word = "!\"#$%&()*+,-./:;<=>?@[\\]^_`{|}~ ";


		// Create the overlay and such
		var overlay = {
			token: function(stream) {
				var ch = stream.peek();
				var word = "";

				if(rx_word.includes(ch)) {
					stream.next();
					return null;
				}

				while((ch = stream.peek()) != null && !rx_word.includes(ch)) {
					word += ch;
					stream.next();
				}

				if(CodeMirrorSpellChecker.typo && !CodeMirrorSpellChecker.typo.check(word))
					return "spell-error"; // CSS class: cm-spell-error

				return null;
			}
		};

		var mode = options.codeMirrorInstance.getMode(
			config, config.backdrop || "text/plain"
		);

		return options.codeMirrorInstance.overlayMode(mode, overlay, true);
	});
}


// Initialize data globally to reduce memory consumption
CodeMirrorSpellChecker.num_loaded = 0;
CodeMirrorSpellChecker.aff_loading = false;
CodeMirrorSpellChecker.dic_loading = false;
CodeMirrorSpellChecker.aff_data = "";
CodeMirrorSpellChecker.dic_data = "";
CodeMirrorSpellChecker.typo;


// Export
module.exports = CodeMirrorSpellChecker;

/***/ }),

/***/ "./node_modules/codemirror/addon/display/autorefresh.js":
/*!**************************************************************!*\
  !*** ./node_modules/codemirror/addon/display/autorefresh.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/5/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"))
  else // removed by dead control flow
{}
})(function(CodeMirror) {
  "use strict"

  CodeMirror.defineOption("autoRefresh", false, function(cm, val) {
    if (cm.state.autoRefresh) {
      stopListening(cm, cm.state.autoRefresh)
      cm.state.autoRefresh = null
    }
    if (val && cm.display.wrapper.offsetHeight == 0)
      startListening(cm, cm.state.autoRefresh = {delay: val.delay || 250})
  })

  function startListening(cm, state) {
    function check() {
      if (cm.display.wrapper.offsetHeight) {
        stopListening(cm, state)
        if (cm.display.lastWrapHeight != cm.display.wrapper.clientHeight)
          cm.refresh()
      } else {
        state.timeout = setTimeout(check, state.delay)
      }
    }
    state.timeout = setTimeout(check, state.delay)
    state.hurry = function() {
      clearTimeout(state.timeout)
      state.timeout = setTimeout(check, 50)
    }
    CodeMirror.on(window, "mouseup", state.hurry)
    CodeMirror.on(window, "keyup", state.hurry)
  }

  function stopListening(_cm, state) {
    clearTimeout(state.timeout)
    CodeMirror.off(window, "mouseup", state.hurry)
    CodeMirror.off(window, "keyup", state.hurry)
  }
});


/***/ }),

/***/ "./node_modules/codemirror/addon/display/fullscreen.js":
/*!*************************************************************!*\
  !*** ./node_modules/codemirror/addon/display/fullscreen.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/5/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));
  else // removed by dead control flow
{}
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineOption("fullScreen", false, function(cm, val, old) {
    if (old == CodeMirror.Init) old = false;
    if (!old == !val) return;
    if (val) setFullscreen(cm);
    else setNormal(cm);
  });

  function setFullscreen(cm) {
    var wrap = cm.getWrapperElement();
    cm.state.fullScreenRestore = {scrollTop: window.pageYOffset, scrollLeft: window.pageXOffset,
                                  width: wrap.style.width, height: wrap.style.height};
    wrap.style.width = "";
    wrap.style.height = "auto";
    wrap.className += " CodeMirror-fullscreen";
    document.documentElement.style.overflow = "hidden";
    cm.refresh();
  }

  function setNormal(cm) {
    var wrap = cm.getWrapperElement();
    wrap.className = wrap.className.replace(/\s*CodeMirror-fullscreen\b/, "");
    document.documentElement.style.overflow = "";
    var info = cm.state.fullScreenRestore;
    wrap.style.width = info.width; wrap.style.height = info.height;
    window.scrollTo(info.scrollLeft, info.scrollTop);
    cm.refresh();
  }
});


/***/ }),

/***/ "./node_modules/codemirror/addon/display/placeholder.js":
/*!**************************************************************!*\
  !*** ./node_modules/codemirror/addon/display/placeholder.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/5/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));
  else // removed by dead control flow
{}
})(function(CodeMirror) {
  CodeMirror.defineOption("placeholder", "", function(cm, val, old) {
    var prev = old && old != CodeMirror.Init;
    if (val && !prev) {
      cm.on("blur", onBlur);
      cm.on("change", onChange);
      cm.on("swapDoc", onChange);
      CodeMirror.on(cm.getInputField(), "compositionupdate", cm.state.placeholderCompose = function() { onComposition(cm) })
      onChange(cm);
    } else if (!val && prev) {
      cm.off("blur", onBlur);
      cm.off("change", onChange);
      cm.off("swapDoc", onChange);
      CodeMirror.off(cm.getInputField(), "compositionupdate", cm.state.placeholderCompose)
      clearPlaceholder(cm);
      var wrapper = cm.getWrapperElement();
      wrapper.className = wrapper.className.replace(" CodeMirror-empty", "");
    }

    if (val && !cm.hasFocus()) onBlur(cm);
  });

  function clearPlaceholder(cm) {
    if (cm.state.placeholder) {
      cm.state.placeholder.parentNode.removeChild(cm.state.placeholder);
      cm.state.placeholder = null;
    }
  }
  function setPlaceholder(cm) {
    clearPlaceholder(cm);
    var elt = cm.state.placeholder = document.createElement("pre");
    elt.style.cssText = "height: 0; overflow: visible";
    elt.style.direction = cm.getOption("direction");
    elt.className = "CodeMirror-placeholder CodeMirror-line-like";
    var placeHolder = cm.getOption("placeholder")
    if (typeof placeHolder == "string") placeHolder = document.createTextNode(placeHolder)
    elt.appendChild(placeHolder)
    cm.display.lineSpace.insertBefore(elt, cm.display.lineSpace.firstChild);
  }

  function onComposition(cm) {
    setTimeout(function() {
      var empty = false
      if (cm.lineCount() == 1) {
        var input = cm.getInputField()
        empty = input.nodeName == "TEXTAREA" ? !cm.getLine(0).length
          : !/[^\u200b]/.test(input.querySelector(".CodeMirror-line").textContent)
      }
      if (empty) setPlaceholder(cm)
      else clearPlaceholder(cm)
    }, 20)
  }

  function onBlur(cm) {
    if (isEmpty(cm)) setPlaceholder(cm);
  }
  function onChange(cm) {
    var wrapper = cm.getWrapperElement(), empty = isEmpty(cm);
    wrapper.className = wrapper.className.replace(" CodeMirror-empty", "") + (empty ? " CodeMirror-empty" : "");

    if (empty) setPlaceholder(cm);
    else clearPlaceholder(cm);
  }

  function isEmpty(cm) {
    return (cm.lineCount() === 1) && (cm.getLine(0) === "");
  }
});


/***/ }),

/***/ "./node_modules/codemirror/addon/edit/continuelist.js":
/*!************************************************************!*\
  !*** ./node_modules/codemirror/addon/edit/continuelist.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/5/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));
  else // removed by dead control flow
{}
})(function(CodeMirror) {
  "use strict";

  var listRE = /^(\s*)(>[> ]*|[*+-] \[[x ]\]\s|[*+-]\s|(\d+)([.)]))(\s*)/,
      emptyListRE = /^(\s*)(>[> ]*|[*+-] \[[x ]\]|[*+-]|(\d+)[.)])(\s*)$/,
      unorderedListRE = /[*+-]\s/;

  CodeMirror.commands.newlineAndIndentContinueMarkdownList = function(cm) {
    if (cm.getOption("disableInput")) return CodeMirror.Pass;
    var ranges = cm.listSelections(), replacements = [];
    for (var i = 0; i < ranges.length; i++) {
      var pos = ranges[i].head;

      // If we're not in Markdown mode, fall back to normal newlineAndIndent
      var eolState = cm.getStateAfter(pos.line);
      var inner = CodeMirror.innerMode(cm.getMode(), eolState);
      if (inner.mode.name !== "markdown" && inner.mode.helperType !== "markdown") {
        cm.execCommand("newlineAndIndent");
        return;
      } else {
        eolState = inner.state;
      }

      var inList = eolState.list !== false;
      var inQuote = eolState.quote !== 0;

      var line = cm.getLine(pos.line), match = listRE.exec(line);
      var cursorBeforeBullet = /^\s*$/.test(line.slice(0, pos.ch));
      if (!ranges[i].empty() || (!inList && !inQuote) || !match || cursorBeforeBullet) {
        cm.execCommand("newlineAndIndent");
        return;
      }
      if (emptyListRE.test(line)) {
        var endOfQuote = inQuote && />\s*$/.test(line)
        var endOfList = !/>\s*$/.test(line)
        if (endOfQuote || endOfList) cm.replaceRange("", {
          line: pos.line, ch: 0
        }, {
          line: pos.line, ch: pos.ch + 1
        });
        replacements[i] = "\n";
      } else {
        var indent = match[1], after = match[5];
        var numbered = !(unorderedListRE.test(match[2]) || match[2].indexOf(">") >= 0);
        var bullet = numbered ? (parseInt(match[3], 10) + 1) + match[4] : match[2].replace("x", " ");
        replacements[i] = "\n" + indent + bullet + after;

        if (numbered) incrementRemainingMarkdownListNumbers(cm, pos);
      }
    }

    cm.replaceSelections(replacements);
  };

  // Auto-updating Markdown list numbers when a new item is added to the
  // middle of a list
  function incrementRemainingMarkdownListNumbers(cm, pos) {
    var startLine = pos.line, lookAhead = 0, skipCount = 0;
    var startItem = listRE.exec(cm.getLine(startLine)), startIndent = startItem[1];

    do {
      lookAhead += 1;
      var nextLineNumber = startLine + lookAhead;
      var nextLine = cm.getLine(nextLineNumber), nextItem = listRE.exec(nextLine);

      if (nextItem) {
        var nextIndent = nextItem[1];
        var newNumber = (parseInt(startItem[3], 10) + lookAhead - skipCount);
        var nextNumber = (parseInt(nextItem[3], 10)), itemNumber = nextNumber;

        if (startIndent === nextIndent && !isNaN(nextNumber)) {
          if (newNumber === nextNumber) itemNumber = nextNumber + 1;
          if (newNumber > nextNumber) itemNumber = newNumber + 1;
          cm.replaceRange(
            nextLine.replace(listRE, nextIndent + itemNumber + nextItem[4] + nextItem[5]),
          {
            line: nextLineNumber, ch: 0
          }, {
            line: nextLineNumber, ch: nextLine.length
          });
        } else {
          if (startIndent.length > nextIndent.length) return;
          // This doesn't run if the next line immediately indents, as it is
          // not clear of the users intention (new indented item or same level)
          if ((startIndent.length < nextIndent.length) && (lookAhead === 1)) return;
          skipCount += 1;
        }
      }
    } while (nextItem);
  }
});


/***/ }),

/***/ "./node_modules/codemirror/addon/mode/overlay.js":
/*!*******************************************************!*\
  !*** ./node_modules/codemirror/addon/mode/overlay.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/5/LICENSE

// Utility function that allows modes to be combined. The mode given
// as the base argument takes care of most of the normal mode
// functionality, but a second (typically simple) mode is used, which
// can override the style of text. Both modes get to parse all of the
// text, but when both assign a non-null style to a piece of code, the
// overlay wins, unless the combine argument was true and not overridden,
// or state.overlay.combineTokens was true, in which case the styles are
// combined.

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));
  else // removed by dead control flow
{}
})(function(CodeMirror) {
"use strict";

CodeMirror.overlayMode = function(base, overlay, combine) {
  return {
    startState: function() {
      return {
        base: CodeMirror.startState(base),
        overlay: CodeMirror.startState(overlay),
        basePos: 0, baseCur: null,
        overlayPos: 0, overlayCur: null,
        streamSeen: null
      };
    },
    copyState: function(state) {
      return {
        base: CodeMirror.copyState(base, state.base),
        overlay: CodeMirror.copyState(overlay, state.overlay),
        basePos: state.basePos, baseCur: null,
        overlayPos: state.overlayPos, overlayCur: null
      };
    },

    token: function(stream, state) {
      if (stream != state.streamSeen ||
          Math.min(state.basePos, state.overlayPos) < stream.start) {
        state.streamSeen = stream;
        state.basePos = state.overlayPos = stream.start;
      }

      if (stream.start == state.basePos) {
        state.baseCur = base.token(stream, state.base);
        state.basePos = stream.pos;
      }
      if (stream.start == state.overlayPos) {
        stream.pos = stream.start;
        state.overlayCur = overlay.token(stream, state.overlay);
        state.overlayPos = stream.pos;
      }
      stream.pos = Math.min(state.basePos, state.overlayPos);

      // state.overlay.combineTokens always takes precedence over combine,
      // unless set to null
      if (state.overlayCur == null) return state.baseCur;
      else if (state.baseCur != null &&
               state.overlay.combineTokens ||
               combine && state.overlay.combineTokens == null)
        return state.baseCur + " " + state.overlayCur;
      else return state.overlayCur;
    },

    indent: base.indent && function(state, textAfter, line) {
      return base.indent(state.base, textAfter, line);
    },
    electricChars: base.electricChars,

    innerMode: function(state) { return {state: state.base, mode: base}; },

    blankLine: function(state) {
      var baseToken, overlayToken;
      if (base.blankLine) baseToken = base.blankLine(state.base);
      if (overlay.blankLine) overlayToken = overlay.blankLine(state.overlay);

      return overlayToken == null ?
        baseToken :
        (combine && baseToken != null ? baseToken + " " + overlayToken : overlayToken);
    }
  };
};

});


/***/ }),

/***/ "./node_modules/codemirror/addon/search/searchcursor.js":
/*!**************************************************************!*\
  !*** ./node_modules/codemirror/addon/search/searchcursor.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/5/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"))
  else // removed by dead control flow
{}
})(function(CodeMirror) {
  "use strict"
  var Pos = CodeMirror.Pos

  function regexpFlags(regexp) {
    var flags = regexp.flags
    return flags != null ? flags : (regexp.ignoreCase ? "i" : "")
      + (regexp.global ? "g" : "")
      + (regexp.multiline ? "m" : "")
  }

  function ensureFlags(regexp, flags) {
    var current = regexpFlags(regexp), target = current
    for (var i = 0; i < flags.length; i++) if (target.indexOf(flags.charAt(i)) == -1)
      target += flags.charAt(i)
    return current == target ? regexp : new RegExp(regexp.source, target)
  }

  function maybeMultiline(regexp) {
    return /\\s|\\n|\n|\\W|\\D|\[\^/.test(regexp.source)
  }

  function searchRegexpForward(doc, regexp, start) {
    regexp = ensureFlags(regexp, "g")
    for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {
      regexp.lastIndex = ch
      var string = doc.getLine(line), match = regexp.exec(string)
      if (match)
        return {from: Pos(line, match.index),
                to: Pos(line, match.index + match[0].length),
                match: match}
    }
  }

  function searchRegexpForwardMultiline(doc, regexp, start) {
    if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start)

    regexp = ensureFlags(regexp, "gm")
    var string, chunk = 1
    for (var line = start.line, last = doc.lastLine(); line <= last;) {
      // This grows the search buffer in exponentially-sized chunks
      // between matches, so that nearby matches are fast and don't
      // require concatenating the whole document (in case we're
      // searching for something that has tons of matches), but at the
      // same time, the amount of retries is limited.
      for (var i = 0; i < chunk; i++) {
        if (line > last) break
        var curLine = doc.getLine(line++)
        string = string == null ? curLine : string + "\n" + curLine
      }
      chunk = chunk * 2
      regexp.lastIndex = start.ch
      var match = regexp.exec(string)
      if (match) {
        var before = string.slice(0, match.index).split("\n"), inside = match[0].split("\n")
        var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length
        return {from: Pos(startLine, startCh),
                to: Pos(startLine + inside.length - 1,
                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),
                match: match}
      }
    }
  }

  function lastMatchIn(string, regexp, endMargin) {
    var match, from = 0
    while (from <= string.length) {
      regexp.lastIndex = from
      var newMatch = regexp.exec(string)
      if (!newMatch) break
      var end = newMatch.index + newMatch[0].length
      if (end > string.length - endMargin) break
      if (!match || end > match.index + match[0].length)
        match = newMatch
      from = newMatch.index + 1
    }
    return match
  }

  function searchRegexpBackward(doc, regexp, start) {
    regexp = ensureFlags(regexp, "g")
    for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {
      var string = doc.getLine(line)
      var match = lastMatchIn(string, regexp, ch < 0 ? 0 : string.length - ch)
      if (match)
        return {from: Pos(line, match.index),
                to: Pos(line, match.index + match[0].length),
                match: match}
    }
  }

  function searchRegexpBackwardMultiline(doc, regexp, start) {
    if (!maybeMultiline(regexp)) return searchRegexpBackward(doc, regexp, start)
    regexp = ensureFlags(regexp, "gm")
    var string, chunkSize = 1, endMargin = doc.getLine(start.line).length - start.ch
    for (var line = start.line, first = doc.firstLine(); line >= first;) {
      for (var i = 0; i < chunkSize && line >= first; i++) {
        var curLine = doc.getLine(line--)
        string = string == null ? curLine : curLine + "\n" + string
      }
      chunkSize *= 2

      var match = lastMatchIn(string, regexp, endMargin)
      if (match) {
        var before = string.slice(0, match.index).split("\n"), inside = match[0].split("\n")
        var startLine = line + before.length, startCh = before[before.length - 1].length
        return {from: Pos(startLine, startCh),
                to: Pos(startLine + inside.length - 1,
                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),
                match: match}
      }
    }
  }

  var doFold, noFold
  if (String.prototype.normalize) {
    doFold = function(str) { return str.normalize("NFD").toLowerCase() }
    noFold = function(str) { return str.normalize("NFD") }
  } else {
    doFold = function(str) { return str.toLowerCase() }
    noFold = function(str) { return str }
  }

  // Maps a position in a case-folded line back to a position in the original line
  // (compensating for codepoints increasing in number during folding)
  function adjustPos(orig, folded, pos, foldFunc) {
    if (orig.length == folded.length) return pos
    for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {
      if (min == max) return min
      var mid = (min + max) >> 1
      var len = foldFunc(orig.slice(0, mid)).length
      if (len == pos) return mid
      else if (len > pos) max = mid
      else min = mid + 1
    }
  }

  function searchStringForward(doc, query, start, caseFold) {
    // Empty string would match anything and never progress, so we
    // define it to match nothing instead.
    if (!query.length) return null
    var fold = caseFold ? doFold : noFold
    var lines = fold(query).split(/\r|\n\r?/)

    search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {
      var orig = doc.getLine(line).slice(ch), string = fold(orig)
      if (lines.length == 1) {
        var found = string.indexOf(lines[0])
        if (found == -1) continue search
        var start = adjustPos(orig, string, found, fold) + ch
        return {from: Pos(line, adjustPos(orig, string, found, fold) + ch),
                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)}
      } else {
        var cutFrom = string.length - lines[0].length
        if (string.slice(cutFrom) != lines[0]) continue search
        for (var i = 1; i < lines.length - 1; i++)
          if (fold(doc.getLine(line + i)) != lines[i]) continue search
        var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1]
        if (endString.slice(0, lastLine.length) != lastLine) continue search
        return {from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),
                to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))}
      }
    }
  }

  function searchStringBackward(doc, query, start, caseFold) {
    if (!query.length) return null
    var fold = caseFold ? doFold : noFold
    var lines = fold(query).split(/\r|\n\r?/)

    search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {
      var orig = doc.getLine(line)
      if (ch > -1) orig = orig.slice(0, ch)
      var string = fold(orig)
      if (lines.length == 1) {
        var found = string.lastIndexOf(lines[0])
        if (found == -1) continue search
        return {from: Pos(line, adjustPos(orig, string, found, fold)),
                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))}
      } else {
        var lastLine = lines[lines.length - 1]
        if (string.slice(0, lastLine.length) != lastLine) continue search
        for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)
          if (fold(doc.getLine(start + i)) != lines[i]) continue search
        var top = doc.getLine(line + 1 - lines.length), topString = fold(top)
        if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search
        return {from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),
                to: Pos(line, adjustPos(orig, string, lastLine.length, fold))}
      }
    }
  }

  function SearchCursor(doc, query, pos, options) {
    this.atOccurrence = false
    this.afterEmptyMatch = false
    this.doc = doc
    pos = pos ? doc.clipPos(pos) : Pos(0, 0)
    this.pos = {from: pos, to: pos}

    var caseFold
    if (typeof options == "object") {
      caseFold = options.caseFold
    } else { // Backwards compat for when caseFold was the 4th argument
      caseFold = options
      options = null
    }

    if (typeof query == "string") {
      if (caseFold == null) caseFold = false
      this.matches = function(reverse, pos) {
        return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold)
      }
    } else {
      query = ensureFlags(query, "gm")
      if (!options || options.multiline !== false)
        this.matches = function(reverse, pos) {
          return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos)
        }
      else
        this.matches = function(reverse, pos) {
          return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos)
        }
    }
  }

  SearchCursor.prototype = {
    findNext: function() {return this.find(false)},
    findPrevious: function() {return this.find(true)},

    find: function(reverse) {
      var head = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);
      if (this.afterEmptyMatch && this.atOccurrence) {
        // do not return the same 0 width match twice
        head = Pos(head.line, head.ch)
        if (reverse) {
          head.ch--;
          if (head.ch < 0) {
            head.line--;
            head.ch = (this.doc.getLine(head.line) || "").length;
          }
        } else {
          head.ch++;
          if (head.ch > (this.doc.getLine(head.line) || "").length) {
            head.ch = 0;
            head.line++;
          }
        }
        if (CodeMirror.cmpPos(head, this.doc.clipPos(head)) != 0) {
           return this.atOccurrence = false
        }
      }
      var result = this.matches(reverse, head)
      this.afterEmptyMatch = result && CodeMirror.cmpPos(result.from, result.to) == 0

      if (result) {
        this.pos = result
        this.atOccurrence = true
        return this.pos.match || true
      } else {
        var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0)
        this.pos = {from: end, to: end}
        return this.atOccurrence = false
      }
    },

    from: function() {if (this.atOccurrence) return this.pos.from},
    to: function() {if (this.atOccurrence) return this.pos.to},

    replace: function(newText, origin) {
      if (!this.atOccurrence) return
      var lines = CodeMirror.splitLines(newText)
      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin)
      this.pos.to = Pos(this.pos.from.line + lines.length - 1,
                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0))
    }
  }

  CodeMirror.defineExtension("getSearchCursor", function(query, pos, caseFold) {
    return new SearchCursor(this.doc, query, pos, caseFold)
  })
  CodeMirror.defineDocExtension("getSearchCursor", function(query, pos, caseFold) {
    return new SearchCursor(this, query, pos, caseFold)
  })

  CodeMirror.defineExtension("selectMatches", function(query, caseFold) {
    var ranges = []
    var cur = this.getSearchCursor(query, this.getCursor("from"), caseFold)
    while (cur.findNext()) {
      if (CodeMirror.cmpPos(cur.to(), this.getCursor("to")) > 0) break
      ranges.push({anchor: cur.from(), head: cur.to()})
    }
    if (ranges.length)
      this.setSelections(ranges, 0)
  })
});


/***/ }),

/***/ "./node_modules/codemirror/addon/selection/mark-selection.js":
/*!*******************************************************************!*\
  !*** ./node_modules/codemirror/addon/selection/mark-selection.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/5/LICENSE

// Because sometimes you need to mark the selected *text*.
//
// Adds an option 'styleSelectedText' which, when enabled, gives
// selected text the CSS class given as option value, or
// "CodeMirror-selectedtext" when the value is not a string.

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));
  else // removed by dead control flow
{}
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineOption("styleSelectedText", false, function(cm, val, old) {
    var prev = old && old != CodeMirror.Init;
    if (val && !prev) {
      cm.state.markedSelection = [];
      cm.state.markedSelectionStyle = typeof val == "string" ? val : "CodeMirror-selectedtext";
      reset(cm);
      cm.on("cursorActivity", onCursorActivity);
      cm.on("change", onChange);
    } else if (!val && prev) {
      cm.off("cursorActivity", onCursorActivity);
      cm.off("change", onChange);
      clear(cm);
      cm.state.markedSelection = cm.state.markedSelectionStyle = null;
    }
  });

  function onCursorActivity(cm) {
    if (cm.state.markedSelection)
      cm.operation(function() { update(cm); });
  }

  function onChange(cm) {
    if (cm.state.markedSelection && cm.state.markedSelection.length)
      cm.operation(function() { clear(cm); });
  }

  var CHUNK_SIZE = 8;
  var Pos = CodeMirror.Pos;
  var cmp = CodeMirror.cmpPos;

  function coverRange(cm, from, to, addAt) {
    if (cmp(from, to) == 0) return;
    var array = cm.state.markedSelection;
    var cls = cm.state.markedSelectionStyle;
    for (var line = from.line;;) {
      var start = line == from.line ? from : Pos(line, 0);
      var endLine = line + CHUNK_SIZE, atEnd = endLine >= to.line;
      var end = atEnd ? to : Pos(endLine, 0);
      var mark = cm.markText(start, end, {className: cls});
      if (addAt == null) array.push(mark);
      else array.splice(addAt++, 0, mark);
      if (atEnd) break;
      line = endLine;
    }
  }

  function clear(cm) {
    var array = cm.state.markedSelection;
    for (var i = 0; i < array.length; ++i) array[i].clear();
    array.length = 0;
  }

  function reset(cm) {
    clear(cm);
    var ranges = cm.listSelections();
    for (var i = 0; i < ranges.length; i++)
      coverRange(cm, ranges[i].from(), ranges[i].to());
  }

  function update(cm) {
    if (!cm.somethingSelected()) return clear(cm);
    if (cm.listSelections().length > 1) return reset(cm);

    var from = cm.getCursor("start"), to = cm.getCursor("end");

    var array = cm.state.markedSelection;
    if (!array.length) return coverRange(cm, from, to);

    var coverStart = array[0].find(), coverEnd = array[array.length - 1].find();
    if (!coverStart || !coverEnd || to.line - from.line <= CHUNK_SIZE ||
        cmp(from, coverEnd.to) >= 0 || cmp(to, coverStart.from) <= 0)
      return reset(cm);

    while (cmp(from, coverStart.from) > 0) {
      array.shift().clear();
      coverStart = array[0].find();
    }
    if (cmp(from, coverStart.from) < 0) {
      if (coverStart.to.line - from.line < CHUNK_SIZE) {
        array.shift().clear();
        coverRange(cm, from, coverStart.to, 0);
      } else {
        coverRange(cm, from, coverStart.from, 0);
      }
    }

    while (cmp(to, coverEnd.to) < 0) {
      array.pop().clear();
      coverEnd = array[array.length - 1].find();
    }
    if (cmp(to, coverEnd.to) > 0) {
      if (to.line - coverEnd.from.line < CHUNK_SIZE) {
        array.pop().clear();
        coverRange(cm, coverEnd.from, to);
      } else {
        coverRange(cm, coverEnd.to, to);
      }
    }
  }
});


/***/ }),

/***/ "./node_modules/codemirror/lib/codemirror.js":
/*!***************************************************!*\
  !*** ./node_modules/codemirror/lib/codemirror.js ***!
  \***************************************************/
/***/ (function(module) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/5/LICENSE

// This is CodeMirror (https://codemirror.net/5), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function (global, factory) {
   true ? module.exports = factory() :
  0;
}(this, (function () { 'use strict';

  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.
  var userAgent = navigator.userAgent;
  var platform = navigator.platform;

  var gecko = /gecko\/\d/i.test(userAgent);
  var ie_upto10 = /MSIE \d/.test(userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
  var edge = /Edge\/(\d+)/.exec(userAgent);
  var ie = ie_upto10 || ie_11up || edge;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
  var webkit = !edge && /WebKit\//.test(userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
  var chrome = !edge && /Chrome\/(\d+)/.exec(userAgent);
  var chrome_version = chrome && +chrome[1];
  var presto = /Opera\//.test(userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
  var phantom = /PhantomJS/.test(userAgent);

  var ios = safari && (/Mobile\/\w+/.test(userAgent) || navigator.maxTouchPoints > 2);
  var android = /Android/.test(userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
  var mac = ios || /Mac/.test(platform);
  var chromeOS = /\bCrOS\b/.test(userAgent);
  var windows = /win/i.test(platform);

  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) { presto_version = Number(presto_version[1]); }
  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || (ie && ie_version >= 9);

  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }

  var rmClass = function(node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);
    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      { e.removeChild(e.firstChild); }
    return e
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e)
  }

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) { e.className = className; }
    if (style) { e.style.cssText = style; }
    if (typeof content == "string") { e.appendChild(document.createTextNode(content)); }
    else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }
    return e
  }
  // wrapper for elt, which removes the elt from the accessibility tree
  function eltP(tag, content, className, style) {
    var e = elt(tag, content, className, style);
    e.setAttribute("role", "presentation");
    return e
  }

  var range;
  if (document.createRange) { range = function(node, start, end, endNode) {
    var r = document.createRange();
    r.setEnd(endNode || node, end);
    r.setStart(node, start);
    return r
  }; }
  else { range = function(node, start, end) {
    var r = document.body.createTextRange();
    try { r.moveToElementText(node.parentNode); }
    catch(e) { return r }
    r.collapse(true);
    r.moveEnd("character", end);
    r.moveStart("character", start);
    return r
  }; }

  function contains(parent, child) {
    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
      { child = child.parentNode; }
    if (parent.contains)
      { return parent.contains(child) }
    do {
      if (child.nodeType == 11) { child = child.host; }
      if (child == parent) { return true }
    } while (child = child.parentNode)
  }

  function activeElt(rootNode) {
    // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
    // IE < 10 will throw when accessed while the page is loading or in an iframe.
    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
    var doc = rootNode.ownerDocument || rootNode;
    var activeElement;
    try {
      activeElement = rootNode.activeElement;
    } catch(e) {
      activeElement = doc.body || null;
    }
    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
      { activeElement = activeElement.shadowRoot.activeElement; }
    return activeElement
  }

  function addClass(node, cls) {
    var current = node.className;
    if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls; }
  }
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++)
      { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i]; } }
    return b
  }

  var selectInput = function(node) { node.select(); };
  if (ios) // Mobile Safari apparently has a bug where select() is broken.
    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }
  else if (ie) // Suppress mysterious IE10 errors
    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }

  function doc(cm) { return cm.display.wrapper.ownerDocument }

  function root(cm) {
    return rootNode(cm.display.wrapper)
  }

  function rootNode(element) {
    // Detect modern browsers (2017+).
    return element.getRootNode ? element.getRootNode() : element.ownerDocument
  }

  function win(cm) { return doc(cm).defaultView }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){return f.apply(null, args)}
  }

  function copyObj(obj, target, overwrite) {
    if (!target) { target = {}; }
    for (var prop in obj)
      { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
        { target[prop] = obj[prop]; } }
    return target
  }

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) { end = string.length; }
    }
    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end)
        { return n + (end - i) }
      n += nextTab - i;
      n += tabSize - (n % tabSize);
      i = nextTab + 1;
    }
  }

  var Delayed = function() {
    this.id = null;
    this.f = null;
    this.time = 0;
    this.handler = bind(this.onTimeout, this);
  };
  Delayed.prototype.onTimeout = function (self) {
    self.id = 0;
    if (self.time <= +new Date) {
      self.f();
    } else {
      setTimeout(self.handler, self.time - +new Date);
    }
  };
  Delayed.prototype.set = function (ms, f) {
    this.f = f;
    var time = +new Date + ms;
    if (!this.id || time < this.time) {
      clearTimeout(this.id);
      this.id = setTimeout(this.handler, ms);
      this.time = time;
    }
  };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i)
      { if (array[i] == elt) { return i } }
    return -1
  }

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerGap = 50;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = {toString: function(){return "CodeMirror.Pass"}};

  // Reused option objects for setSelection & friends
  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) { nextTab = string.length; }
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal)
        { return pos + Math.min(skipped, goal - col) }
      col += nextTab - pos;
      col += tabSize - (col % tabSize);
      pos = nextTab + 1;
      if (col >= goal) { return pos }
    }
  }

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      { spaceStrs.push(lst(spaceStrs) + " "); }
    return spaceStrs[n]
  }

  function lst(arr) { return arr[arr.length-1] }

  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }
    return out
  }

  function insertSorted(array, value, score) {
    var pos = 0, priority = score(value);
    while (pos < array.length && score(array[pos]) <= priority) { pos++; }
    array.splice(pos, 0, value);
  }

  function nothing() {}

  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }
    if (props) { copyObj(props, inst); }
    return inst
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  function isWordCharBasic(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
  }
  function isWordChar(ch, helper) {
    if (!helper) { return isWordCharBasic(ch) }
    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
    return helper.test(ch)
  }

  function isEmpty(obj) {
    for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
    return true
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }

  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
  function skipExtendingChars(str, pos, dir) {
    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }
    return pos
  }

  // Returns the value from the range [`from`; `to`] that satisfies
  // `pred` and is closest to `from`. Assumes that at least `to`
  // satisfies `pred`. Supports `from` being greater than `to`.
  function findFirst(pred, from, to) {
    // At any point we are certain `to` satisfies `pred`, don't know
    // whether `from` does.
    var dir = from > to ? -1 : 1;
    for (;;) {
      if (from == to) { return from }
      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
      if (mid == from) { return pred(mid) ? from : to }
      if (pred(mid)) { to = mid; }
      else { from = mid + dir; }
    }
  }

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) { return f(from, to, "ltr", 0) }
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
        found = true;
      }
    }
    if (!found) { f(from, to, "ltr"); }
  }

  var bidiOther = null;
  function getBidiPartAt(order, ch, sticky) {
    var found;
    bidiOther = null;
    for (var i = 0; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < ch && cur.to > ch) { return i }
      if (cur.to == ch) {
        if (cur.from != cur.to && sticky == "before") { found = i; }
        else { bidiOther = i; }
      }
      if (cur.from == ch) {
        if (cur.from != cur.to && sticky != "before") { found = i; }
        else { bidiOther = i; }
      }
    }
    return found != null ? found : bidiOther
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function() {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6f9
    var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
    function charType(code) {
      if (code <= 0xf7) { return lowTypes.charAt(code) }
      else if (0x590 <= code && code <= 0x5f4) { return "R" }
      else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
      else if (0x6ee <= code && code <= 0x8ac) { return "r" }
      else if (0x2000 <= code && code <= 0x200b) { return "w" }
      else if (code == 0x200c) { return "b" }
      else { return "L" }
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from; this.to = to;
    }

    return function(str, direction) {
      var outerType = direction == "ltr" ? "L" : "R";

      if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) { return false }
      var len = str.length, types = [];
      for (var i = 0; i < len; ++i)
        { types.push(charType(str.charCodeAt(i))); }

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
        var type = types[i$1];
        if (type == "m") { types[i$1] = prev; }
        else { prev = type; }
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
        var type$1 = types[i$2];
        if (type$1 == "1" && cur == "r") { types[i$2] = "n"; }
        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R"; } }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
        var type$2 = types[i$3];
        if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1"; }
        else if (type$2 == "," && prev$1 == types[i$3+1] &&
                 (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1; }
        prev$1 = type$2;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i$4 = 0; i$4 < len; ++i$4) {
        var type$3 = types[i$4];
        if (type$3 == ",") { types[i$4] = "N"; }
        else if (type$3 == "%") {
          var end = (void 0);
          for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
          var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
          for (var j = i$4; j < end; ++j) { types[j] = replace; }
          i$4 = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
        var type$4 = types[i$5];
        if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L"; }
        else if (isStrong.test(type$4)) { cur$1 = type$4; }
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i$6 = 0; i$6 < len; ++i$6) {
        if (isNeutral.test(types[i$6])) {
          var end$1 = (void 0);
          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
          var before = (i$6 ? types[i$6-1] : outerType) == "L";
          var after = (end$1 < len ? types[end$1] : outerType) == "L";
          var replace$1 = before == after ? (before ? "L" : "R") : outerType;
          for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }
          i$6 = end$1 - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i$7 = 0; i$7 < len;) {
        if (countsAsLeft.test(types[i$7])) {
          var start = i$7;
          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
          order.push(new BidiSpan(0, start, i$7));
        } else {
          var pos = i$7, at = order.length, isRTL = direction == "rtl" ? 1 : 0;
          for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
          for (var j$2 = pos; j$2 < i$7;) {
            if (countsAsNum.test(types[j$2])) {
              if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); at += isRTL; }
              var nstart = j$2;
              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
              order.splice(at, 0, new BidiSpan(2, nstart, j$2));
              at += isRTL;
              pos = j$2;
            } else { ++j$2; }
          }
          if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }
        }
      }
      if (direction == "ltr") {
        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
          order[0].from = m[0].length;
          order.unshift(new BidiSpan(0, 0, m[0].length));
        }
        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
          lst(order).to -= m[0].length;
          order.push(new BidiSpan(0, len - m[0].length, len));
        }
      }

      return direction == "rtl" ? order.reverse() : order
    }
  })();

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line, direction) {
    var order = line.order;
    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }
    return order
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var noHandlers = [];

  var on = function(emitter, type, f) {
    if (emitter.addEventListener) {
      emitter.addEventListener(type, f, false);
    } else if (emitter.attachEvent) {
      emitter.attachEvent("on" + type, f);
    } else {
      var map = emitter._handlers || (emitter._handlers = {});
      map[type] = (map[type] || noHandlers).concat(f);
    }
  };

  function getHandlers(emitter, type) {
    return emitter._handlers && emitter._handlers[type] || noHandlers
  }

  function off(emitter, type, f) {
    if (emitter.removeEventListener) {
      emitter.removeEventListener(type, f, false);
    } else if (emitter.detachEvent) {
      emitter.detachEvent("on" + type, f);
    } else {
      var map = emitter._handlers, arr = map && map[type];
      if (arr) {
        var index = indexOf(arr, f);
        if (index > -1)
          { map[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }
      }
    }
  }

  function signal(emitter, type /*, values...*/) {
    var handlers = getHandlers(emitter, type);
    if (!handlers.length) { return }
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string")
      { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) { return }
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
      { set.push(arr[i]); } }
  }

  function hasHandler(emitter, type) {
    return getHandlers(emitter, type).length > 0
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function(type, f) {on(this, type, f);};
    ctor.prototype.off = function(type, f) {off(this, type, f);};
  }

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  function e_preventDefault(e) {
    if (e.preventDefault) { e.preventDefault(); }
    else { e.returnValue = false; }
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation) { e.stopPropagation(); }
    else { e.cancelBubble = true; }
  }
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
  }
  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}

  function e_target(e) {return e.target || e.srcElement}
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) { b = 1; }
      else if (e.button & 2) { b = 3; }
      else if (e.button & 4) { b = 2; }
    }
    if (mac && e.ctrlKey && b == 1) { b = 3; }
    return b
  }

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie && ie_version < 9) { return false }
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div
  }();

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0)
        { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }
    }
    var node = zwspSupported ? elt("span", "\u200b") :
      elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) { return badBidiRects }
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    removeChildren(measure);
    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
    return badBidiRects = (r1.right - r0.right < 3)
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) { nl = string.length; }
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result
  } : function (string) { return string.split(/\r\n?|\n/); };

  var hasSelection = window.getSelection ? function (te) {
    try { return te.selectionStart != te.selectionEnd }
    catch(e) { return false }
  } : function (te) {
    var range;
    try {range = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range || range.parentElement() != te) { return false }
    return range.compareEndPoints("StartToEnd", range) != 0
  };

  var hasCopyEvent = (function () {
    var e = elt("div");
    if ("oncopy" in e) { return true }
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function"
  })();

  var badZoomedRects = null;
  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) { return badZoomedRects }
    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
  }

  // Known modes, by name and by MIME
  var modes = {}, mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  function defineMode(name, mode) {
    if (arguments.length > 2)
      { mode.dependencies = Array.prototype.slice.call(arguments, 2); }
    modes[name] = mode;
  }

  function defineMIME(mime, spec) {
    mimeModes[mime] = spec;
  }

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  function resolveMode(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") { found = {name: found}; }
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return resolveMode("application/xml")
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
      return resolveMode("application/json")
    }
    if (typeof spec == "string") { return {name: spec} }
    else { return spec || {name: "null"} }
  }

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  function getMode(options, spec) {
    spec = resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) { return getMode(options, "text/plain") }
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) { continue }
        if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) { modeObj.helperType = spec.helperType; }
    if (spec.modeProps) { for (var prop$1 in spec.modeProps)
      { modeObj[prop$1] = spec.modeProps[prop$1]; } }

    return modeObj
  }

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = {};
  function extendMode(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  }

  function copyState(mode, state) {
    if (state === true) { return state }
    if (mode.copyState) { return mode.copyState(state) }
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) { val = val.concat([]); }
      nstate[n] = val;
    }
    return nstate
  }

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  function innerMode(mode, state) {
    var info;
    while (mode.innerMode) {
      info = mode.innerMode(state);
      if (!info || info.mode == mode) { break }
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state}
  }

  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true
  }

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = function(string, tabSize, lineOracle) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
    this.lineOracle = lineOracle;
  };

  StringStream.prototype.eol = function () {return this.pos >= this.string.length};
  StringStream.prototype.sol = function () {return this.pos == this.lineStart};
  StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
  StringStream.prototype.next = function () {
    if (this.pos < this.string.length)
      { return this.string.charAt(this.pos++) }
  };
  StringStream.prototype.eat = function (match) {
    var ch = this.string.charAt(this.pos);
    var ok;
    if (typeof match == "string") { ok = ch == match; }
    else { ok = ch && (match.test ? match.test(ch) : match(ch)); }
    if (ok) {++this.pos; return ch}
  };
  StringStream.prototype.eatWhile = function (match) {
    var start = this.pos;
    while (this.eat(match)){}
    return this.pos > start
  };
  StringStream.prototype.eatSpace = function () {
    var start = this.pos;
    while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this.pos; }
    return this.pos > start
  };
  StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};
  StringStream.prototype.skipTo = function (ch) {
    var found = this.string.indexOf(ch, this.pos);
    if (found > -1) {this.pos = found; return true}
  };
  StringStream.prototype.backUp = function (n) {this.pos -= n;};
  StringStream.prototype.column = function () {
    if (this.lastColumnPos < this.start) {
      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
      this.lastColumnPos = this.start;
    }
    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
  };
  StringStream.prototype.indentation = function () {
    return countColumn(this.string, null, this.tabSize) -
      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
  };
  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
    if (typeof pattern == "string") {
      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
      var substr = this.string.substr(this.pos, pattern.length);
      if (cased(substr) == cased(pattern)) {
        if (consume !== false) { this.pos += pattern.length; }
        return true
      }
    } else {
      var match = this.string.slice(this.pos).match(pattern);
      if (match && match.index > 0) { return null }
      if (match && consume !== false) { this.pos += match[0].length; }
      return match
    }
  };
  StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
  StringStream.prototype.hideFirstChars = function (n, inner) {
    this.lineStart += n;
    try { return inner() }
    finally { this.lineStart -= n; }
  };
  StringStream.prototype.lookAhead = function (n) {
    var oracle = this.lineOracle;
    return oracle && oracle.lookAhead(n)
  };
  StringStream.prototype.baseToken = function () {
    var oracle = this.lineOracle;
    return oracle && oracle.baseToken(this.pos)
  };

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
    var chunk = doc;
    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break }
        n -= sz;
      }
    }
    return chunk.lines[n]
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function (line) {
      var text = line.text;
      if (n == end.line) { text = text.slice(0, end.ch); }
      if (n == start.line) { text = text.slice(start.ch); }
      out.push(text);
      ++n;
    });
    return out
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value
    return out
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) { return null }
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) { break }
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
        var child = chunk.children[i$1], ch = child.height;
        if (h < ch) { chunk = child; continue outer }
        h -= ch;
        n += child.chunkSize();
      }
      return n
    } while (!chunk.lines)
    var i = 0;
    for (; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) { break }
      h -= lh;
    }
    return n + i
  }

  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber))
  }

  // A Pos instance represents a position within the text.
  function Pos(line, ch, sticky) {
    if ( sticky === void 0 ) sticky = null;

    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }
    this.line = line;
    this.ch = ch;
    this.sticky = sticky;
  }

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }

  function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }

  function copyPos(x) {return Pos(x.line, x.ch)}
  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
  function minPos(a, b) { return cmp(a, b) < 0 ? a : b }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
  function clipPos(doc, pos) {
    if (pos.line < doc.first) { return Pos(doc.first, 0) }
    var last = doc.first + doc.size - 1;
    if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
    return clipToLen(pos, getLine(doc, pos.line).text.length)
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
    else if (ch < 0) { return Pos(pos.line, 0) }
    else { return pos }
  }
  function clipPosArray(doc, array) {
    var out = [];
    for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }
    return out
  }

  var SavedContext = function(state, lookAhead) {
    this.state = state;
    this.lookAhead = lookAhead;
  };

  var Context = function(doc, state, line, lookAhead) {
    this.state = state;
    this.doc = doc;
    this.line = line;
    this.maxLookAhead = lookAhead || 0;
    this.baseTokens = null;
    this.baseTokenPos = 1;
  };

  Context.prototype.lookAhead = function (n) {
    var line = this.doc.getLine(this.line + n);
    if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }
    return line
  };

  Context.prototype.baseToken = function (n) {
    if (!this.baseTokens) { return null }
    while (this.baseTokens[this.baseTokenPos] <= n)
      { this.baseTokenPos += 2; }
    var type = this.baseTokens[this.baseTokenPos + 1];
    return {type: type && type.replace(/( |^)overlay .*/, ""),
            size: this.baseTokens[this.baseTokenPos] - n}
  };

  Context.prototype.nextLine = function () {
    this.line++;
    if (this.maxLookAhead > 0) { this.maxLookAhead--; }
  };

  Context.fromSaved = function (doc, saved, line) {
    if (saved instanceof SavedContext)
      { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }
    else
      { return new Context(doc, copyState(doc.mode, saved), line) }
  };

  Context.prototype.save = function (copy) {
    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state
  };


  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, context, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen], lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },
            lineClasses, forceToEnd);
    var state = context.state;

    // Run overlays, adjust style array.
    var loop = function ( o ) {
      context.baseTokens = st;
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      context.state = true;
      runMode(cm, line.text, overlay.mode, context, function (end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            { st.splice(i, 1, end, st[i+1], i_end); }
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) { return }
        if (overlay.opaque) {
          st.splice(start, i - start, end, "overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = (cur ? cur + " " : "") + "overlay " + style;
          }
        }
      }, lineClasses);
      context.state = state;
      context.baseTokens = null;
      context.baseTokenPos = 1;
    };

    for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );

    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
  }

  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var context = getContextBefore(cm, lineNo(line));
      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
      var result = highlightLine(cm, line, context);
      if (resetState) { context.state = resetState; }
      line.stateAfter = context.save(!resetState);
      line.styles = result.styles;
      if (result.classes) { line.styleClasses = result.classes; }
      else if (line.styleClasses) { line.styleClasses = null; }
      if (updateFrontier === cm.doc.highlightFrontier)
        { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }
    }
    return line.styles
  }

  function getContextBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState) { return new Context(doc, true, n) }
    var start = findStartLine(cm, n, precise);
    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);

    doc.iter(start, n, function (line) {
      processLine(cm, line.text, context);
      var pos = context.line;
      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
      context.nextLine();
    });
    if (precise) { doc.modeFrontier = context.line; }
    return context
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, context, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize, context);
    stream.start = stream.pos = startAt || 0;
    if (text == "") { callBlankLine(mode, context.state); }
    while (!stream.eol()) {
      readToken(mode, stream, context.state);
      stream.start = stream.pos;
    }
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) { return mode.blankLine(state) }
    if (!mode.innerMode) { return }
    var inner = innerMode(mode, state);
    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
  }

  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) { inner[0] = innerMode(mode, state).mode; }
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) { return style }
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.")
  }

  var Token = function(stream, type, state) {
    this.start = stream.start; this.end = stream.pos;
    this.string = stream.current();
    this.type = type || null;
    this.state = state;
  };

  // Utility for getTokenAt and getLineTokens
  function takeToken(cm, pos, precise, asArray) {
    var doc = cm.doc, mode = doc.mode, style;
    pos = clipPos(doc, pos);
    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
    if (asArray) { tokens = []; }
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, context.state);
      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }
    }
    return asArray ? tokens : new Token(stream, style, context.state)
  }

  function extractLineClasses(type, output) {
    if (type) { for (;;) {
      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
      if (!lineClass) { break }
      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
      var prop = lineClass[1] ? "bgClass" : "textClass";
      if (output[prop] == null)
        { output[prop] = lineClass[2]; }
      else if (!(new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)")).test(output[prop]))
        { output[prop] += " " + lineClass[2]; }
    } }
    return type
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize, context), style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) { processLine(cm, text, context, stream.pos); }
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) { style = "m-" + (style ? mName + " " + style : mName); }
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 5000);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444
      // characters, and returns inaccurate measurements in nodes
      // starting around 5000 chars.
      var pos = Math.min(stream.pos, curStart + 5000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) { return doc.first }
      var line = getLine(doc, search - 1), after = line.stateAfter;
      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))
        { return search }
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline
  }

  function retreatFrontier(doc, n) {
    doc.modeFrontier = Math.min(doc.modeFrontier, n);
    if (doc.highlightFrontier < n - 10) { return }
    var start = doc.first;
    for (var line = n - 1; line > start; line--) {
      var saved = getLine(doc, line).stateAfter;
      // change is on 3
      // state on line 1 looked ahead 2 -- so saw 3
      // test 1 + 2 < 3 should cover this
      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
        start = line + 1;
        break
      }
    }
    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
  }

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  function seeReadOnlySpans() {
    sawReadOnlySpans = true;
  }

  function seeCollapsedSpans() {
    sawCollapsedSpans = true;
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from; this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) { for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) { return span }
    } }
  }

  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    var r;
    for (var i = 0; i < spans.length; ++i)
      { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }
    return r
  }

  // Add a span to a line.
  function addMarkedSpan(line, span, op) {
    var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = new WeakSet));
    if (inThisOp && line.markedSpans && inThisOp.has(line.markedSpans)) {
      line.markedSpans.push(span);
    } else {
      line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
      if (inThisOp) { inThisOp.add(line.markedSpans); }
    }
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    var nw;
    if (old) { for (var i = 0; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)
        ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
      }
    } }
    return nw
  }
  function markedSpansAfter(old, endCh, isInsert) {
    var nw;
    if (old) { for (var i = 0; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)
        ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                              span.to == null ? null : span.to - endCh));
      }
    } }
    return nw
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    if (change.full) { return null }
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) { return null }

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) { span.to = startCh; }
          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i$1 = 0; i$1 < last.length; ++i$1) {
        var span$1 = last[i$1];
        if (span$1.to != null) { span$1.to += offset; }
        if (span$1.from == null) {
          var found$1 = getMarkedSpanFor(first, span$1.marker);
          if (!found$1) {
            span$1.from = offset;
            if (sameLine) { (first || (first = [])).push(span$1); }
          }
        } else {
          span$1.from += offset;
          if (sameLine) { (first || (first = [])).push(span$1); }
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) { first = clearEmptySpans(first); }
    if (last && last != first) { last = clearEmptySpans(last); }

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        { for (var i$2 = 0; i$2 < first.length; ++i$2)
          { if (first[i$2].to == null)
            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }
      for (var i$3 = 0; i$3 < gap; ++i$3)
        { newMarkers.push(gapMarkers); }
      newMarkers.push(last);
    }
    return newMarkers
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
        { spans.splice(i--, 1); }
    }
    if (!spans.length) { return null }
    return spans
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function (line) {
      if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          { (markers || (markers = [])).push(mark); }
      } }
    });
    if (!markers) { return null }
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
          { newParts.push({from: p.from, to: m.from}); }
        if (dto > 0 || !mk.inclusiveRight && !dto)
          { newParts.push({from: m.to, to: p.to}); }
        parts.splice.apply(parts, newParts);
        j += newParts.length - 3;
      }
    }
    return parts
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) { return }
    for (var i = 0; i < spans.length; ++i)
      { spans[i].marker.detachLine(line); }
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) { return }
    for (var i = 0; i < spans.length; ++i)
      { spans[i].marker.attachLine(line); }
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) { return lenDiff }
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) { return -fromCmp }
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) { return toCmp }
    return b.id - a.id
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
        { found = sp.marker; }
    } }
    return found
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }

  function collapsedSpanAround(line, ch) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) { for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }
    } }
    return found
  }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
    var line = getLine(doc, lineNo);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) { for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (!sp.marker.collapsed) { continue }
      var found = sp.marker.find(0);
      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
        { return true }
    } }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      { line = merged.find(-1, true).line; }
    return line
  }

  function visualLineEnd(line) {
    var merged;
    while (merged = collapsedSpanAtEnd(line))
      { line = merged.find(1, true).line; }
    return line
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line
      ;(lines || (lines = [])).push(line);
    }
    return lines
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN), vis = visualLine(line);
    if (line == vis) { return lineN }
    return lineNo(vis)
  }

  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) { return lineN }
    var line = getLine(doc, lineN), merged;
    if (!lineIsHidden(doc, line)) { return lineN }
    while (merged = collapsedSpanAtEnd(line))
      { line = merged.find(1, true).line; }
    return lineNo(line) + 1
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) { continue }
      if (sp.from == null) { return true }
      if (sp.marker.widgetNode) { continue }
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        { return true }
    } }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      { return true }
    for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
          (sp.to == null || sp.to != span.from) &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) { return true }
    }
  }

  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) { break }
      else { h += line.height; }
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
        var cur = p.children[i$1];
        if (cur == chunk) { break }
        else { h += cur.height; }
      }
    }
    return h
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) { return 0 }
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found$1 = merged.find(0, true);
      len -= cur.text.length - found$1.from.ch;
      cur = found$1.to.line;
      len += cur.text.length - found$1.to.ch;
    }
    return len
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function (line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = function(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };

  Line.prototype.lineNo = function () { return lineNo(this) };
  eventMixin(Line);

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) { line.stateAfter = null; }
    if (line.styles) { line.styles = null; }
    if (line.order != null) { line.order = null; }
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) { updateLineHeight(line, estHeight); }
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) { return null }
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] ||
      (cache[style] = style.replace(/\S+/g, "cm-$&"))
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {pre: eltP("pre", [content], "CodeMirror-line"), content: content,
                   col: 0, pos: 0, cm: cm,
                   trailingSpace: false,
                   splitSpaces: cm.getOption("lineWrapping")};
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))
        { builder.addToken = buildTokenBadBidi(builder.addToken, order); }
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass)
          { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || ""); }
        if (line.styleClasses.textClass)
          { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""); }
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0)
        { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
  (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
        ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    // See issue #2901
    if (webkit) {
      var last = builder.content.lastChild;
      if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
        { builder.content.className = "cm-tab-wrap-hack"; }
    }

    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className)
      { builder.textClass = joinClasses(builder.pre.className, builder.textClass || ""); }

    return builder
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
    if (!text) { return }
    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
    var special = builder.cm.state.specialChars, mustWrap = false;
    var content;
    if (!special.test(text)) {
      builder.col += text.length;
      content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) { mustWrap = true; }
      builder.pos += text.length;
    } else {
      content = document.createDocumentFragment();
      var pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])); }
          else { content.appendChild(txt); }
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) { break }
        pos += skipped + 1;
        var txt$1 = (void 0);
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt$1.setAttribute("role", "presentation");
          txt$1.setAttribute("cm-text", "\t");
          builder.col += tabWidth;
        } else if (m[0] == "\r" || m[0] == "\n") {
          txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
          txt$1.setAttribute("cm-text", m[0]);
          builder.col += 1;
        } else {
          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
          txt$1.setAttribute("cm-text", m[0]);
          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])); }
          else { content.appendChild(txt$1); }
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt$1);
        builder.pos++;
      }
    }
    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
    if (style || startStyle || endStyle || mustWrap || css || attributes) {
      var fullStyle = style || "";
      if (startStyle) { fullStyle += startStyle; }
      if (endStyle) { fullStyle += endStyle; }
      var token = elt("span", [content], fullStyle, css);
      if (attributes) {
        for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class")
          { token.setAttribute(attr, attributes[attr]); } }
      }
      return builder.content.appendChild(token)
    }
    builder.content.appendChild(content);
  }

  // Change some spaces to NBSP to prevent the browser from collapsing
  // trailing spaces at the end of a line when rendering text (issue #1362).
  function splitSpaces(text, trailingBefore) {
    if (text.length > 1 && !/  /.test(text)) { return text }
    var spaceBefore = trailingBefore, result = "";
    for (var i = 0; i < text.length; i++) {
      var ch = text.charAt(i);
      if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
        { ch = "\u00a0"; }
      result += ch;
      spaceBefore = ch == " ";
    }
    return result
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function (builder, text, style, startStyle, endStyle, css, attributes) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos, end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        var part = (void 0);
        for (var i = 0; i < order.length; i++) {
          part = order[i];
          if (part.to > start && part.from <= start) { break }
        }
        if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    }
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }
    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget)
        { widget = builder.content.appendChild(document.createElement("span")); }
      widget.setAttribute("cm-marker", marker.id);
    }
    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
    builder.trailingSpace = false;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i$1 = 1; i$1 < styles.length; i$1+=2)
        { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }
      return
    }

    var len = allText.length, pos = 0, i = 1, text = "", style, css;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = css = "";
        attributes = null;
        collapsed = null; nextChange = Infinity;
        var foundBookmarks = [], endStyles = (void 0);
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
            foundBookmarks.push(m);
          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = "";
            }
            if (m.className) { spanStyle += " " + m.className; }
            if (m.css) { css = (css ? css + ";" : "") + m.css; }
            if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle; }
            if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }
            // support for the old title property
            // https://github.com/codemirror/CodeMirror/pull/5673
            if (m.title) { (attributes || (attributes = {})).title = m.title; }
            if (m.attributes) {
              for (var attr in m.attributes)
                { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }
            }
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
              { collapsed = sp; }
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
        }
        if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
          { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1]; } } }

        if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
          { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                             collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) { return }
          if (collapsed.to == pos) { collapsed = false; }
        }
      }
      if (pos >= len) { break }

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }


  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [], nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array
  }

  var operationGroup = null;

  function pushOperation(op) {
    if (operationGroup) {
      operationGroup.ops.push(op);
    } else {
      op.ownsGroup = operationGroup = {
        ops: [op],
        delayedCallbacks: []
      };
    }
  }

  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks, i = 0;
    do {
      for (; i < callbacks.length; i++)
        { callbacks[i].call(null); }
      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];
        if (op.cursorActivityHandlers)
          { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
            { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }
      }
    } while (i < callbacks.length)
  }

  function finishOperation(op, endCb) {
    var group = op.ownsGroup;
    if (!group) { return }

    try { fireCallbacksForOps(group); }
    finally {
      operationGroup = null;
      endCb(group);
    }
  }

  var orphanDelayedCallbacks = null;

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  function signalLater(emitter, type /*, values...*/) {
    var arr = getHandlers(emitter, type);
    if (!arr.length) { return }
    var args = Array.prototype.slice.call(arguments, 2), list;
    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }
    var loop = function ( i ) {
      list.push(function () { return arr[i].apply(null, args); });
    };

    for (var i = 0; i < arr.length; ++i)
      loop( i );
  }

  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) { delayed[i](); }
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") { updateLineText(cm, lineView); }
      else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims); }
      else if (type == "class") { updateLineClasses(cm, lineView); }
      else if (type == "widget") { updateLineWidgets(cm, lineView, dims); }
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode)
        { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }
      lineView.node.appendChild(lineView.text);
      if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }
    }
    return lineView.node
  }

  function updateLineBackground(cm, lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) { cls += " CodeMirror-linebackground"; }
    if (lineView.background) {
      if (cls) { lineView.background.className = cls; }
      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
      cm.display.input.setUneditable(lineView.background);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built
    }
    return buildLineContent(cm, lineView)
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) { lineView.node = built.pre; }
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(cm, lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(cm, lineView) {
    updateLineBackground(cm, lineView);
    if (lineView.line.wrapClass)
      { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }
    else if (lineView.node != lineView.text)
      { lineView.node.className = ""; }
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    if (lineView.gutterBackground) {
      lineView.node.removeChild(lineView.gutterBackground);
      lineView.gutterBackground = null;
    }
    if (lineView.line.gutterClass) {
      var wrap = ensureLineWrapped(lineView);
      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
                                      ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"));
      cm.display.input.setUneditable(lineView.gutterBackground);
      wrap.insertBefore(lineView.gutterBackground, lineView.text);
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap$1 = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"));
      gutterWrap.setAttribute("aria-hidden", "true");
      cm.display.input.setUneditable(gutterWrap);
      wrap$1.insertBefore(gutterWrap, lineView.text);
      if (lineView.line.gutterClass)
        { gutterWrap.className += " " + lineView.line.gutterClass; }
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
        { lineView.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineN),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))); }
      if (markers) { for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
        var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];
        if (found)
          { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
                                     ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))); }
      } }
    }
  }

  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) { lineView.alignable = null; }
    var isWidget = classTest("CodeMirror-linewidget");
    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
      next = node.nextSibling;
      if (isWidget.test(node.className)) { lineView.node.removeChild(node); }
    }
    insertLineWidgets(cm, lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) { lineView.bgClass = built.bgClass; }
    if (built.textClass) { lineView.textClass = built.textClass; }

    updateLineClasses(cm, lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
      { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }
  }

  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) { return }
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
      if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true"); }
      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);
      if (allowAbove && widget.above)
        { wrap.insertBefore(node, lineView.gutter || lineView.text); }
      else
        { wrap.appendChild(node); }
      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
  (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px"; }
    }
  }

  function widgetHeight(widget) {
    if (widget.height != null) { return widget.height }
    var cm = widget.doc.cm;
    if (!cm) { return 0 }
    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter)
        { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"; }
      if (widget.noHScroll)
        { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"; }
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.parentNode.offsetHeight
  }

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
          (n.parentNode == display.sizer && n != display.mover))
        { return true }
    }
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {return display.lineSpace.offsetTop}
  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
  function paddingH(display) {
    if (display.cachedPaddingH) { return display.cachedPaddingH }
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
    if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }
    return data
  }

  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
  }
  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i], next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2)
            { heights.push((cur.bottom + next.top) / 2 - rect.top); }
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line)
      { return {map: lineView.measure.map, cache: lineView.measure.cache} }
    if (lineView.rest) {
      for (var i = 0; i < lineView.rest.length; i++)
        { if (lineView.rest[i] == line)
          { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
      for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
        { if (lineNo(lineView.rest[i$1]) > lineN)
          { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
    }
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
      { return cm.display.view[findViewIndex(cm, lineN)] }
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
      { return ext }
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text) {
      view = null;
    } else if (view && view.changes) {
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
      cm.curOp.forceUpdate = true;
    }
    if (!view)
      { view = updateExternalMeasurement(cm, line); }

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line, view: view, rect: null,
      map: info.map, cache: info.cache, before: info.before,
      hasHeights: false
    }
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) { ch = -1; }
    var key = ch + (bias || ""), found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect)
        { prepared.rect = prepared.view.text.getBoundingClientRect(); }
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) { prepared.cache[key] = found; }
    }
    return {left: found.left, right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom}
  }

  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

  function nodeAndOffsetInLineMap(map, ch, bias) {
    var node, start, end, collapse, mStart, mEnd;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map.length; i += 3) {
      mStart = map[i];
      mEnd = map[i + 1];
      if (ch < mStart) {
        start = 0; end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) { collapse = "right"; }
      }
      if (start != null) {
        node = map[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
          { collapse = bias; }
        if (bias == "left" && start == 0)
          { while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
            node = map[(i -= 3) + 2];
            collapse = "left";
          } }
        if (bias == "right" && start == mEnd - mStart)
          { while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
            node = map[(i += 3) + 2];
            collapse = "right";
          } }
        break
      }
    }
    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
  }

  function getUsefulRect(rects, bias) {
    var rect = nullRect;
    if (bias == "left") { for (var i = 0; i < rects.length; i++) {
      if ((rect = rects[i]).left != rect.right) { break }
    } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
      if ((rect = rects[i$1]).left != rect.right) { break }
    } }
    return rect
  }

  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

    var rect;
    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
      for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }
        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }
        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
          { rect = node.parentNode.getBoundingClientRect(); }
        else
          { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }
        if (rect.left || rect.right || start == 0) { break }
        end = start;
        start = start - 1;
        collapse = "right";
      }
      if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }
    } else { // If it is a widget, simply get the box for the whole widget.
      if (start > 0) { collapse = bias = "right"; }
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
        { rect = rects[bias == "right" ? rects.length - 1 : 0]; }
      else
        { rect = node.getBoundingClientRect(); }
    }
    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan)
        { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }
      else
        { rect = nullRect; }
    }

    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    var i = 0;
    for (; i < heights.length - 1; i++)
      { if (mid < heights[i]) { break } }
    var top = i ? heights[i - 1] : 0, bot = heights[i];
    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                  top: top, bottom: bot};
    if (!rect.left && !rect.right) { result.bogus = true; }
    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

    return result
  }

  // Work around problem with bounding client rects on ranges being
  // returned incorrectly when zoomed on IE10 and below.
  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null ||
        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
      { return rect }
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return {left: rect.left * scaleX, right: rect.right * scaleX,
            top: rect.top * scaleY, bottom: rect.bottom * scaleY}
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
        { lineView.measure.caches[i] = {}; } }
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++)
      { clearLineMeasurementCacheFor(cm.display.view[i]); }
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }
    cm.display.lineNumChars = null;
  }

  function pageScrollX(doc) {
    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
    // which causes page_Offset and bounding client rects to use
    // different reference viewports and invalidate our calculations.
    if (chrome && android) { return -(doc.body.getBoundingClientRect().left - parseInt(getComputedStyle(doc.body).marginLeft)) }
    return doc.defaultView.pageXOffset || (doc.documentElement || doc.body).scrollLeft
  }
  function pageScrollY(doc) {
    if (chrome && android) { return -(doc.body.getBoundingClientRect().top - parseInt(getComputedStyle(doc.body).marginTop)) }
    return doc.defaultView.pageYOffset || (doc.documentElement || doc.body).scrollTop
  }

  function widgetTopHeight(lineObj) {
    var ref = visualLine(lineObj);
    var widgets = ref.widgets;
    var height = 0;
    if (widgets) { for (var i = 0; i < widgets.length; ++i) { if (widgets[i].above)
      { height += widgetHeight(widgets[i]); } } }
    return height
  }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"./null (editor), "window",
  // or "page".
  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
    if (!includeWidgets) {
      var height = widgetTopHeight(lineObj);
      rect.top += height; rect.bottom += height;
    }
    if (context == "line") { return rect }
    if (!context) { context = "local"; }
    var yOff = heightAtLine(lineObj);
    if (context == "local") { yOff += paddingTop(cm.display); }
    else { yOff -= cm.display.viewOffset; }
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY(doc(cm)));
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX(doc(cm)));
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"./null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") { return coords }
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX(doc(cm));
      top -= pageScrollY(doc(cm));
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
  // and after `char - 1` in writing order of `char - 1`
  // A cursor Pos(line, char, "after") is on the same visual line as `char`
  // and before `char` in writing order of `char`
  // Examples (upper-case letters are RTL, lower-case are LTR):
  //     Pos(0, 1, ...)
  //     before   after
  // ab     a|b     a|b
  // aB     a|B     aB|
  // Ab     |Ab     A|b
  // AB     B|A     B|A
  // Every position after the last character on a line is considered to stick
  // to the last character on the line.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
      if (right) { m.left = m.right; } else { m.right = m.left; }
      return intoCoordSystem(cm, lineObj, m, context)
    }
    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
    if (ch >= lineObj.text.length) {
      ch = lineObj.text.length;
      sticky = "before";
    } else if (ch <= 0) {
      ch = 0;
      sticky = "after";
    }
    if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }

    function getBidi(ch, partPos, invert) {
      var part = order[partPos], right = part.level == 1;
      return get(invert ? ch - 1 : ch, right != invert)
    }
    var partPos = getBidiPartAt(order, ch, sticky);
    var other = bidiOther;
    var val = getBidi(ch, partPos, sticky == "before");
    if (other != null) { val.other = getBidi(ch, other, sticky != "before"); }
    return val
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0;
    pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return {left: left, right: left, top: top, bottom: top + lineObj.height}
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, sticky, outside, xRel) {
    var pos = Pos(line, ch, sticky);
    pos.xRel = xRel;
    if (outside) { pos.outside = outside; }
    return pos
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) { return PosWithInfo(doc.first, 0, null, -1, -1) }
    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineN > last)
      { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1) }
    if (x < 0) { x = 0; }

    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
      if (!collapsed) { return found }
      var rangeEnd = collapsed.find(1);
      if (rangeEnd.line == lineN) { return rangeEnd }
      lineObj = getLine(doc, lineN = rangeEnd.line);
    }
  }

  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
    y -= widgetTopHeight(lineObj);
    var end = lineObj.text.length;
    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);
    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);
    return {begin: begin, end: end}
  }

  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
  }

  // Returns true if the given side of a box is after the given
  // coordinates, in top-to-bottom, left-to-right order.
  function boxIsAfter(box, x, y, left) {
    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x
  }

  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    // Move y into line-local coordinate space
    y -= heightAtLine(lineObj);
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);
    // When directly calling `measureCharPrepared`, we have to adjust
    // for the widgets at this line.
    var widgetHeight = widgetTopHeight(lineObj);
    var begin = 0, end = lineObj.text.length, ltr = true;

    var order = getOrder(lineObj, cm.doc.direction);
    // If the line isn't plain left-to-right text, first figure out
    // which bidi section the coordinates fall into.
    if (order) {
      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)
                   (cm, lineObj, lineNo, preparedMeasure, order, x, y);
      ltr = part.level != 1;
      // The awkward -1 offsets are needed because findFirst (called
      // on these below) will treat its first bound as inclusive,
      // second as exclusive, but we want to actually address the
      // characters in the part's range
      begin = ltr ? part.from : part.to - 1;
      end = ltr ? part.to : part.from - 1;
    }

    // A binary search to find the first character whose bounding box
    // starts after the coordinates. If we run across any whose box wrap
    // the coordinates, store that.
    var chAround = null, boxAround = null;
    var ch = findFirst(function (ch) {
      var box = measureCharPrepared(cm, preparedMeasure, ch);
      box.top += widgetHeight; box.bottom += widgetHeight;
      if (!boxIsAfter(box, x, y, false)) { return false }
      if (box.top <= y && box.left <= x) {
        chAround = ch;
        boxAround = box;
      }
      return true
    }, begin, end);

    var baseX, sticky, outside = false;
    // If a box around the coordinates was found, use that
    if (boxAround) {
      // Distinguish coordinates nearer to the left or right side of the box
      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
      ch = chAround + (atStart ? 0 : 1);
      sticky = atStart ? "after" : "before";
      baseX = atLeft ? boxAround.left : boxAround.right;
    } else {
      // (Adjust for extended bound, if necessary.)
      if (!ltr && (ch == end || ch == begin)) { ch++; }
      // To determine which side to associate with, get the box to the
      // left of the character and compare it's vertical position to the
      // coordinates
      sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" :
        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y) == ltr ?
        "after" : "before";
      // Now get accurate coordinates for this place, in order to get a
      // base X position
      var coords = cursorCoords(cm, Pos(lineNo, ch, sticky), "line", lineObj, preparedMeasure);
      baseX = coords.left;
      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
    }

    ch = skipExtendingChars(lineObj.text, ch, 1);
    return PosWithInfo(lineNo, ch, sticky, outside, x - baseX)
  }

  function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {
    // Bidi parts are sorted left-to-right, and in a non-line-wrapping
    // situation, we can take this ordering to correspond to the visual
    // ordering. This finds the first part whose end is after the given
    // coordinates.
    var index = findFirst(function (i) {
      var part = order[i], ltr = part.level != 1;
      return boxIsAfter(cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? "before" : "after"),
                                     "line", lineObj, preparedMeasure), x, y, true)
    }, 0, order.length - 1);
    var part = order[index];
    // If this isn't the first part, the part's start is also after
    // the coordinates, and the coordinates aren't on the same line as
    // that start, move one part back.
    if (index > 0) {
      var ltr = part.level != 1;
      var start = cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? "after" : "before"),
                               "line", lineObj, preparedMeasure);
      if (boxIsAfter(start, x, y, true) && start.top > y)
        { part = order[index - 1]; }
    }
    return part
  }

  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
    // In a wrapped line, rtl text on wrapping boundaries can do things
    // that don't correspond to the ordering in our `order` array at
    // all, so a binary search doesn't work, and we want to return a
    // part that only spans one line so that the binary search in
    // coordsCharInner is safe. As such, we first find the extent of the
    // wrapped line, and then do a flat search in which we discard any
    // spans that aren't on the line.
    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
    var begin = ref.begin;
    var end = ref.end;
    if (/\s/.test(lineObj.text.charAt(end - 1))) { end--; }
    var part = null, closestDist = null;
    for (var i = 0; i < order.length; i++) {
      var p = order[i];
      if (p.from >= end || p.to <= begin) { continue }
      var ltr = p.level != 1;
      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
      // Weigh against spans ending before this, so that they are only
      // picked if nothing ends after
      var dist = endX < x ? x - endX + 1e9 : endX - x;
      if (!part || closestDist > dist) {
        part = p;
        closestDist = dist;
      }
    }
    if (!part) { part = order[order.length - 1]; }
    // Clip the part to the wrapped line.
    if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }
    if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }
    return part
  }

  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) { return display.cachedTextHeight }
    if (measureText == null) {
      measureText = elt("pre", null, "CodeMirror-line-like");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) { display.cachedTextHeight = height; }
    removeChildren(display.measure);
    return height || 1
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) { return display.cachedCharWidth }
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor], "CodeMirror-line-like");
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2) { display.cachedCharWidth = width; }
    return width || 10
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    var gutterLeft = d.gutters.clientLeft;
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      var id = cm.display.gutterSpecs[i].className;
      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[id] = n.clientWidth;
    }
    return {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth}
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function (line) {
      if (lineIsHidden(cm.doc, line)) { return 0 }

      var widgetsHeight = 0;
      if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {
        if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }
      } }

      if (wrapping)
        { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
      else
        { return widgetsHeight + th }
    }
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function (line) {
      var estHeight = est(line);
      if (estHeight != line.height) { updateLineHeight(line, estHeight); }
    });
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }

    var x, y, space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX - space.left; y = e.clientY - space.top; }
    catch (e$1) { return null }
    var coords = coordsChar(cm, x, y), line;
    if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) { return null }
    n -= cm.display.viewFrom;
    if (n < 0) { return null }
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) { return i }
    }
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) { from = cm.doc.first; }
    if (to == null) { to = cm.doc.first + cm.doc.size; }
    if (!lendiff) { lendiff = 0; }

    var display = cm.display;
    if (lendiff && to < display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers > from))
      { display.updateLineNumbers = from; }

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) { // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
        { resetView(cm); }
    } else if (to <= display.viewFrom) { // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) { // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) { // Bottom overlap
      var cut$1 = viewCuttingPoint(cm, from, from, -1);
      if (cut$1) {
        display.view = display.view.slice(0, cut$1.index);
        display.viewTo = cut$1.lineN;
      } else {
        resetView(cm);
      }
    } else { // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index)
          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
          .concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN)
        { ext.lineN += lendiff; }
      else if (from < ext.lineN + ext.size)
        { display.externalMeasured = null; }
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display, ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
      { display.externalMeasured = null; }

    if (line < display.viewFrom || line >= display.viewTo) { return }
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) { return }
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) { arr.push(type); }
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
      { return {index: index, lineN: newN} }
    var n = cm.display.viewFrom;
    for (var i = 0; i < index; i++)
      { n += view[i].size; }
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) { return null }
        diff = (n + view[index].size) - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff; newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return {index: index, lineN: newN}
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display, view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from)
        { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }
      else if (display.viewFrom < from)
        { display.view = display.view.slice(findViewIndex(cm, from)); }
      display.viewFrom = from;
      if (display.viewTo < to)
        { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }
      else if (display.viewTo > to)
        { display.view = display.view.slice(0, findViewIndex(cm, to)); }
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view, dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }
    }
    return dirty
  }

  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }

  function prepareSelection(cm, primary) {
    if ( primary === void 0 ) primary = true;

    var doc = cm.doc, result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();

    var customCursor = cm.options.$customCursor;
    if (customCursor) { primary = true; }
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      if (!primary && i == doc.sel.primIndex) { continue }
      var range = doc.sel.ranges[i];
      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) { continue }
      var collapsed = range.empty();
      if (customCursor) {
        var head = customCursor(cm, range);
        if (head) { drawSelectionCursor(cm, head, curFragment); }
      } else if (collapsed || cm.options.showCursorWhenSelecting) {
        drawSelectionCursor(cm, range.head, curFragment);
      }
      if (!collapsed)
        { drawSelectionRange(cm, range, selFragment); }
    }
    return result
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, head, output) {
    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (/\bcm-fat-cursor\b/.test(cm.getWrapperElement().className)) {
      var charPos = charCoords(cm, head, "div", null, null);
      var width = charPos.right - charPos.left;
      cursor.style.width = (width > 0 ? width : cm.defaultCharWidth()) + "px";
    }

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range, output) {
    var display = cm.display, doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display), leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
    var docLTR = doc.direction == "ltr";

    function add(left, top, width, bottom) {
      if (top < 0) { top = 0; }
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
      }

      function wrapX(pos, dir, side) {
        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
        var prop = (dir == "ltr") == (side == "after") ? "left" : "right";
        var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
        return coords(ch, prop)[prop]
      }

      var order = getOrder(lineObj, doc.direction);
      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
        var ltr = dir == "ltr";
        var fromPos = coords(from, ltr ? "left" : "right");
        var toPos = coords(to - 1, ltr ? "right" : "left");

        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
        var first = i == 0, last = !order || i == order.length - 1;
        if (toPos.top - fromPos.top <= 3) { // Single line
          var openLeft = (docLTR ? openStart : openEnd) && first;
          var openRight = (docLTR ? openEnd : openStart) && last;
          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
          add(left, fromPos.top, right - left, fromPos.bottom);
        } else { // Multiple lines
          var topLeft, topRight, botLeft, botRight;
          if (ltr) {
            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
            topRight = docLTR ? rightSide : wrapX(from, dir, "before");
            botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
            botRight = docLTR && openEnd && last ? rightSide : toPos.right;
          } else {
            topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
            botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
          }
          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }
          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
        }

        if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }
        if (cmpCoords(toPos, start) < 0) { start = toPos; }
        if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }
        if (cmpCoords(toPos, end) < 0) { end = toPos; }
      });
      return {start: start, end: end}
    }

    var sFrom = range.from(), sTo = range.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        { add(leftSide, leftEnd.bottom, null, rightStart.top); }
    }

    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) { return }
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0)
      { display.blinker = setInterval(function () {
        if (!cm.hasFocus()) { onBlur(cm); }
        display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
      }, cm.options.cursorBlinkRate); }
    else if (cm.options.cursorBlinkRate < 0)
      { display.cursorDiv.style.visibility = "hidden"; }
  }

  function ensureFocus(cm) {
    if (!cm.hasFocus()) {
      cm.display.input.focus();
      if (!cm.state.focused) { onFocus(cm); }
    }
  }

  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function () { if (cm.state.delayingBlurEvent) {
      cm.state.delayingBlurEvent = false;
      if (cm.state.focused) { onBlur(cm); }
    } }, 100);
  }

  function onFocus(cm, e) {
    if (cm.state.delayingBlurEvent && !cm.state.draggingText) { cm.state.delayingBlurEvent = false; }

    if (cm.options.readOnly == "nocursor") { return }
    if (!cm.state.focused) {
      signal(cm, "focus", cm, e);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // This test prevents this from firing when a context
      // menu is closed (since the input reset would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730
      }
      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  function onBlur(cm, e) {
    if (cm.state.delayingBlurEvent) { return }

    if (cm.state.focused) {
      signal(cm, "blur", cm, e);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);
    var oldHeight = display.lineDiv.getBoundingClientRect().top;
    var mustScroll = 0;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i], wrapping = cm.options.lineWrapping;
      var height = (void 0), width = 0;
      if (cur.hidden) { continue }
      oldHeight += cur.line.height;
      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
        // Check that lines don't extend past the right of the current
        // editor width
        if (!wrapping && cur.text.firstChild)
          { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }
      }
      var diff = cur.line.height - height;
      if (diff > .005 || diff < -.005) {
        if (oldHeight < viewTop) { mustScroll -= diff; }
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)
          { updateWidgetHeight(cur.rest[j]); } }
      }
      if (width > cm.display.sizerWidth) {
        var chWidth = Math.ceil(width / charWidth(cm.display));
        if (chWidth > cm.display.maxLineLength) {
          cm.display.maxLineLength = chWidth;
          cm.display.maxLine = cur.line;
          cm.display.maxLineChanged = true;
        }
      }
    }
    if (Math.abs(mustScroll) > 2) { display.scroller.scrollTop += mustScroll; }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {
      var w = line.widgets[i], parent = w.node.parentNode;
      if (parent) { w.height = parent.offsetHeight; }
    } }
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the current scroll position). viewport may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
      if (ensureFrom < from) {
        from = ensureFrom;
        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    return {from: from, to: Math.max(to, from + 1)}
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, rect) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }

    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    var doc = display.wrapper.ownerDocument;
    if (rect.top + box.top < 0) { doScroll = true; }
    else if (rect.bottom + box.top > (doc.defaultView.innerHeight || doc.documentElement.clientHeight)) { doScroll = false; }
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (rect.left) + "px; width: " + (Math.max(2, rect.right - rect.left)) + "px;"));
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) { margin = 0; }
    var rect;
    if (!cm.options.lineWrapping && pos == end) {
      // Set pos and end to the cursor positions around the character pos sticks to
      // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
      // If pos == Pos(_, 0, "before"), pos and end are unchanged
      end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
      pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
    }
    for (var limit = 0; limit < 5; limit++) {
      var changed = false;
      var coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      rect = {left: Math.min(coords.left, endCoords.left),
              top: Math.min(coords.top, endCoords.top) - margin,
              right: Math.max(coords.left, endCoords.left),
              bottom: Math.max(coords.bottom, endCoords.bottom) + margin};
      var scrollPos = calculateScrollPos(cm, rect);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        updateScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }
      }
      if (!changed) { break }
    }
    return rect
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, rect) {
    var scrollPos = calculateScrollPos(cm, rect);
    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }
    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, rect) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (rect.top < 0) { rect.top = 0; }
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm), result = {};
    if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
    if (rect.top < screentop) {
      result.scrollTop = atTop ? 0 : rect.top;
    } else if (rect.bottom > screentop + screen) {
      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
      if (newTop != screentop) { result.scrollTop = newTop; }
    }

    var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
    var screenw = displayWidth(cm) - display.gutters.offsetWidth;
    var tooWide = rect.right - rect.left > screenw;
    if (tooWide) { rect.right = rect.left + screenw; }
    if (rect.left < 10)
      { result.scrollLeft = 0; }
    else if (rect.left < screenleft)
      { result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10)); }
    else if (rect.right > screenw + screenleft - 3)
      { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }
    return result
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollTop(cm, top) {
    if (top == null) { return }
    resolveScrollToPos(cm);
    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor();
    cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};
  }

  function scrollToCoords(cm, x, y) {
    if (x != null || y != null) { resolveScrollToPos(cm); }
    if (x != null) { cm.curOp.scrollLeft = x; }
    if (y != null) { cm.curOp.scrollTop = y; }
  }

  function scrollToRange(cm, range) {
    resolveScrollToPos(cm);
    cm.curOp.scrollToPos = range;
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range = cm.curOp.scrollToPos;
    if (range) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
      scrollToCoordsRange(cm, from, to, range.margin);
    }
  }

  function scrollToCoordsRange(cm, from, to, margin) {
    var sPos = calculateScrollPos(cm, {
      left: Math.min(from.left, to.left),
      top: Math.min(from.top, to.top) - margin,
      right: Math.max(from.right, to.right),
      bottom: Math.max(from.bottom, to.bottom) + margin
    });
    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
  }

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function updateScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
    if (!gecko) { updateDisplaySimple(cm, {top: val}); }
    setScrollTop(cm, val, true);
    if (gecko) { updateDisplaySimple(cm); }
    startWorker(cm, 100);
  }

  function setScrollTop(cm, val, forceScroll) {
    val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
    if (cm.display.scroller.scrollTop == val && !forceScroll) { return }
    cm.doc.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }
  }

  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller, forceScroll) {
    val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }
    cm.display.scrollbars.setScrollLeft(val);
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var d = cm.display, gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    }
  }

  var NativeScrollbars = function(place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    vert.tabIndex = horiz.tabIndex = -1;
    place(vert); place(horiz);

    on(vert, "scroll", function () {
      if (vert.clientHeight) { scroll(vert.scrollTop, "vertical"); }
    });
    on(horiz, "scroll", function () {
      if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal"); }
    });

    this.checkedZeroWidth = false;
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px"; }
  };

  NativeScrollbars.prototype.update = function (measure) {
    var needsH = measure.scrollWidth > measure.clientWidth + 1;
    var needsV = measure.scrollHeight > measure.clientHeight + 1;
    var sWidth = measure.nativeBarWidth;

    if (needsV) {
      this.vert.style.display = "block";
      this.vert.style.bottom = needsH ? sWidth + "px" : "0";
      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
      // A bug in IE8 can cause this value to be negative, so guard it.
      this.vert.firstChild.style.height =
        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
    } else {
      this.vert.scrollTop = 0;
      this.vert.style.display = "";
      this.vert.firstChild.style.height = "0";
    }

    if (needsH) {
      this.horiz.style.display = "block";
      this.horiz.style.right = needsV ? sWidth + "px" : "0";
      this.horiz.style.left = measure.barLeft + "px";
      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
      this.horiz.firstChild.style.width =
        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
    } else {
      this.horiz.style.display = "";
      this.horiz.firstChild.style.width = "0";
    }

    if (!this.checkedZeroWidth && measure.clientHeight > 0) {
      if (sWidth == 0) { this.zeroWidthHack(); }
      this.checkedZeroWidth = true;
    }

    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
  };

  NativeScrollbars.prototype.setScrollLeft = function (pos) {
    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }
    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz"); }
  };

  NativeScrollbars.prototype.setScrollTop = function (pos) {
    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }
    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, "vert"); }
  };

  NativeScrollbars.prototype.zeroWidthHack = function () {
    var w = mac && !mac_geMountainLion ? "12px" : "18px";
    this.horiz.style.height = this.vert.style.width = w;
    this.horiz.style.visibility = this.vert.style.visibility = "hidden";
    this.disableHoriz = new Delayed;
    this.disableVert = new Delayed;
  };

  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
    bar.style.visibility = "";
    function maybeDisable() {
      // To find out whether the scrollbar is still visible, we
      // check whether the element under the pixel in the bottom
      // right corner of the scrollbar box is the scrollbar box
      // itself (when the bar is still visible) or its filler child
      // (when the bar is hidden). If it is still visible, we keep
      // it enabled, if it's hidden, we disable pointer events.
      var box = bar.getBoundingClientRect();
      var elt = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)
          : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
      if (elt != bar) { bar.style.visibility = "hidden"; }
      else { delay.set(1000, maybeDisable); }
    }
    delay.set(1000, maybeDisable);
  };

  NativeScrollbars.prototype.clear = function () {
    var parent = this.horiz.parentNode;
    parent.removeChild(this.horiz);
    parent.removeChild(this.vert);
  };

  var NullScrollbars = function () {};

  NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
  NullScrollbars.prototype.setScrollLeft = function () {};
  NullScrollbars.prototype.setScrollTop = function () {};
  NullScrollbars.prototype.clear = function () {};

  function updateScrollbars(cm, measure) {
    if (!measure) { measure = measureForScrollbars(cm); }
    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
        { updateHeightsInViewport(cm); }
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
    }
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);

    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else { d.scrollbarFiller.style.display = ""; }
    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else { d.gutterFiller.style.display = ""; }
  }

  var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      if (cm.display.scrollbars.addClass)
        { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
    }

    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
      // Prevent clicks in the scrollbars from killing focus
      on(node, "mousedown", function () {
        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }
      });
      node.setAttribute("cm-not-content", "true");
    }, function (pos, axis) {
      if (axis == "horizontal") { setScrollLeft(cm, pos); }
      else { updateScrollTop(cm, pos); }
    }, cm);
    if (cm.display.scrollbars.addClass)
      { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
  }

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height, // Used to detect need to update scrollbar
      forceUpdate: false,      // Used to force a redraw
      updateInput: 0,       // Whether to reset the input textarea
      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,        // Accumulated changes, for firing change events
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
      selectionChanged: false, // Whether the selection needs to be redrawn
      updateMaxLine: false,    // Set when the widest line needs to be determined anew
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,       // Used to scroll to a specific position
      focus: false,
      id: ++nextOpId,          // Unique ID
      markArrays: null         // Used by addMarkedSpan
    };
    pushOperation(cm.curOp);
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp;
    if (op) { finishOperation(op, function (group) {
      for (var i = 0; i < group.ops.length; i++)
        { group.ops[i].cm.curOp = null; }
      endOperations(group);
    }); }
  }

  // The DOM updates done when an operation finishes are batched so
  // that the minimum number of relayouts are required.
  function endOperations(group) {
    var ops = group.ops;
    for (var i = 0; i < ops.length; i++) // Read DOM
      { endOperation_R1(ops[i]); }
    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
      { endOperation_W1(ops[i$1]); }
    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
      { endOperation_R2(ops[i$2]); }
    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
      { endOperation_W2(ops[i$3]); }
    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
      { endOperation_finish(ops[i$4]); }
  }

  function endOperation_R1(op) {
    var cm = op.cm, display = cm.display;
    maybeClipScrollbars(cm);
    if (op.updateMaxLine) { findMaxLine(cm); }

    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                         op.scrollToPos.to.line >= display.viewTo) ||
      display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate &&
      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
  }

  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }

  function endOperation_R2(op) {
    var cm = op.cm, display = cm.display;
    if (op.updatedDisplay) { updateHeightsInViewport(cm); }

    op.barMeasure = measureForScrollbars(cm);

    // If the max line changed since it was last measured, measure it,
    // and ensure the document's width matches it.
    // updateDisplay_W2 will use these properties to do the actual resizing
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth =
        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }

    if (op.updatedDisplay || op.selectionChanged)
      { op.preparedSelection = display.input.prepareSelection(); }
  }

  function endOperation_W2(op) {
    var cm = op.cm;

    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
      if (op.maxScrollLeft < cm.doc.scrollLeft)
        { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }
      cm.display.maxLineChanged = false;
    }

    var takeFocus = op.focus && op.focus == activeElt(root(cm));
    if (op.preparedSelection)
      { cm.display.input.showSelection(op.preparedSelection, takeFocus); }
    if (op.updatedDisplay || op.startHeight != cm.doc.height)
      { updateScrollbars(cm, op.barMeasure); }
    if (op.updatedDisplay)
      { setDocumentHeight(cm, op.barMeasure); }

    if (op.selectionChanged) { restartBlink(cm); }

    if (cm.state.focused && op.updateInput)
      { cm.display.input.reset(op.typing); }
    if (takeFocus) { ensureFocus(op.cm); }
  }

  function endOperation_finish(op) {
    var cm = op.cm, display = cm.display, doc = cm.doc;

    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }

    // Abort mouse wheel delta measurement, when scrolling explicitly
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
      { display.wheelStartX = display.wheelStartY = null; }

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }

    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      maybeScrollWindow(cm, rect);
    }

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) { for (var i = 0; i < hidden.length; ++i)
      { if (!hidden[i].lines.length) { signal(hidden[i], "hide"); } } }
    if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
      { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide"); } } }

    if (display.wrapper.offsetHeight)
      { doc.scrollTop = cm.display.scroller.scrollTop; }

    // Fire change events, and delayed event handlers
    if (op.changeObjs)
      { signal(cm, "changes", cm, op.changeObjs); }
    if (op.update)
      { op.update.finish(); }
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) { return f() }
    startOperation(cm);
    try { return f() }
    finally { endOperation(cm); }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function() {
      if (cm.curOp) { return f.apply(cm, arguments) }
      startOperation(cm);
      try { return f.apply(cm, arguments) }
      finally { endOperation(cm); }
    }
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function() {
      if (this.curOp) { return f.apply(this, arguments) }
      startOperation(this);
      try { return f.apply(this, arguments) }
      finally { endOperation(this); }
    }
  }
  function docMethodOp(f) {
    return function() {
      var cm = this.cm;
      if (!cm || cm.curOp) { return f.apply(this, arguments) }
      startOperation(cm);
      try { return f.apply(this, arguments) }
      finally { endOperation(cm); }
    }
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.highlightFrontier < cm.display.viewTo)
      { cm.state.highlight.set(time, bind(highlightWorker, cm)); }
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.highlightFrontier >= cm.display.viewTo) { return }
    var end = +new Date + cm.options.workTime;
    var context = getContextBefore(cm, doc.highlightFrontier);
    var changedLines = [];

    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
      if (context.line >= cm.display.viewFrom) { // Visible
        var oldStyles = line.styles;
        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
        var highlighted = highlightLine(cm, line, context, true);
        if (resetState) { context.state = resetState; }
        line.styles = highlighted.styles;
        var oldCls = line.styleClasses, newCls = highlighted.classes;
        if (newCls) { line.styleClasses = newCls; }
        else if (oldCls) { line.styleClasses = null; }
        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }
        if (ischange) { changedLines.push(context.line); }
        line.stateAfter = context.save();
        context.nextLine();
      } else {
        if (line.text.length <= cm.options.maxHighlightLength)
          { processLine(cm, line.text, context); }
        line.stateAfter = context.line % 5 == 0 ? context.save() : null;
        context.nextLine();
      }
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true
      }
    });
    doc.highlightFrontier = context.line;
    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
    if (changedLines.length) { runInOp(cm, function () {
      for (var i = 0; i < changedLines.length; i++)
        { regLineChange(cm, changedLines[i], "text"); }
    }); }
  }

  // DISPLAY DRAWING

  var DisplayUpdate = function(cm, viewport, force) {
    var display = cm.display;

    this.viewport = viewport;
    // Store some values that we'll need later (but don't want to force a relayout for)
    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  };

  DisplayUpdate.prototype.signal = function (emitter, type) {
    if (hasHandler(emitter, type))
      { this.events.push(arguments); }
  };
  DisplayUpdate.prototype.finish = function () {
    for (var i = 0; i < this.events.length; i++)
      { signal.apply(null, this.events[i]); }
  };

  function maybeClipScrollbars(cm) {
    var display = cm.display;
    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }

  function selectionSnapshot(cm) {
    if (cm.hasFocus()) { return null }
    var active = activeElt(root(cm));
    if (!active || !contains(cm.display.lineDiv, active)) { return null }
    var result = {activeElt: active};
    if (window.getSelection) {
      var sel = win(cm).getSelection();
      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
        result.anchorNode = sel.anchorNode;
        result.anchorOffset = sel.anchorOffset;
        result.focusNode = sel.focusNode;
        result.focusOffset = sel.focusOffset;
      }
    }
    return result
  }

  function restoreSelection(snapshot) {
    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt(rootNode(snapshot.activeElt))) { return }
    snapshot.activeElt.focus();
    if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) &&
        snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
      var doc = snapshot.activeElt.ownerDocument;
      var sel = doc.defaultView.getSelection(), range = doc.createRange();
      range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
      range.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range);
      sel.extend(snapshot.focusNode, snapshot.focusOffset);
    }
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display, doc = cm.doc;

    if (update.editorIsHidden) {
      resetView(cm);
      return false
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!update.force &&
        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
        display.renderedView == display.view && countDirtyView(cm) == 0)
      { return false }

    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }
    if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo ||
      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);

    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";

    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
      { return false }

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var selSnapshot = selectionSnapshot(cm);
    if (toUpdate > 4) { display.lineDiv.style.display = "none"; }
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    if (toUpdate > 4) { display.lineDiv.style.display = ""; }
    display.renderedView = display.view;
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    restoreSelection(selSnapshot);

    // Prevent selection and cursors from interfering with the scroll
    // width and height.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = display.sizer.style.minHeight = 0;

    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }

    display.updateLineNumbers = null;

    return true
  }

  function postUpdateDisplay(cm, update) {
    var viewport = update.viewport;

    for (var first = true;; first = false) {
      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
        // Clip forced viewport to actual scrollable area.
        if (viewport && viewport.top != null)
          { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }
        // Updated line heights might result in the drawn area not
        // actually covering the viewport. Keep looping until it does.
        update.visible = visibleLines(cm.display, cm.doc, viewport);
        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
          { break }
      } else if (first) {
        update.visible = visibleLines(cm.display, cm.doc, viewport);
      }
      if (!updateDisplayIfNeeded(cm, update)) { break }
      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.force = false;
    }

    update.signal(cm, "update", cm);
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
    }
  }

  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);
    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.finish();
    }
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node)
        { node.style.display = "none"; }
      else
        { node.parentNode.removeChild(node); }
      return next
    }

    var view = display.view, lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else { // Already drawn
        while (cur != lineView.node) { cur = rm(cur); }
        var updateNumber = lineNumbers && updateNumbersFrom != null &&
          updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false; }
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) { cur = rm(cur); }
  }

  function updateGutterSpace(display) {
    var width = display.gutters.offsetWidth;
    display.sizer.style.marginLeft = width + "px";
    // Send an event to consumers responding to changes in gutter width.
    signalLater(display, "gutterChanged", display);
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    cm.display.heightForcer.style.top = measure.docHeight + "px";
    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
  }

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display, view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, left = comp + "px";
    for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {
      if (cm.options.fixedGutter) {
        if (view[i].gutter)
          { view[i].gutter.style.left = left; }
        if (view[i].gutterBackground)
          { view[i].gutterBackground.style.left = left; }
      }
      var align = view[i].alignable;
      if (align) { for (var j = 0; j < align.length; j++)
        { align[j].style.left = left; } }
    } }
    if (cm.options.fixedGutter)
      { display.gutters.style.left = (comp + gutterW) + "px"; }
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) { return false }
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm.display);
      return true
    }
    return false
  }

  function getGutters(gutters, lineNumbers) {
    var result = [], sawLineNumbers = false;
    for (var i = 0; i < gutters.length; i++) {
      var name = gutters[i], style = null;
      if (typeof name != "string") { style = name.style; name = name.className; }
      if (name == "CodeMirror-linenumbers") {
        if (!lineNumbers) { continue }
        else { sawLineNumbers = true; }
      }
      result.push({className: name, style: style});
    }
    if (lineNumbers && !sawLineNumbers) { result.push({className: "CodeMirror-linenumbers", style: null}); }
    return result
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function renderGutters(display) {
    var gutters = display.gutters, specs = display.gutterSpecs;
    removeChildren(gutters);
    display.lineGutter = null;
    for (var i = 0; i < specs.length; ++i) {
      var ref = specs[i];
      var className = ref.className;
      var style = ref.style;
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
      if (style) { gElt.style.cssText = style; }
      if (className == "CodeMirror-linenumbers") {
        display.lineGutter = gElt;
        gElt.style.width = (display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = specs.length ? "" : "none";
    updateGutterSpace(display);
  }

  function updateGutters(cm) {
    renderGutters(cm.display);
    regChange(cm);
    alignHorizontally(cm);
  }

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc, input, options) {
    var d = this;
    this.input = input;

    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = eltP("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                      null, "position: relative; outline: none");
    var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [lines], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null;
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
    // See #6982. FIXME remove when this has been fixed for a while in Chrome
    if (chrome && chrome_version === 105) { d.wrapper.style.clipPath = "inset(0px)"; }

    // This attribute is respected by automatic translation systems such as Google Translate,
    // and may also be respected by tools used by human translators.
    d.wrapper.setAttribute('translate', 'no');

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }

    if (place) {
      if (place.appendChild) { place.appendChild(d.wrapper); }
      else { place(d.wrapper); }
    }

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    d.renderedView = null;
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;

    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;

    // Used to track whether anything happened since the context menu
    // was opened.
    d.selForContextMenu = null;

    d.activeTouch = null;

    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
    renderGutters(d);

    input.init(d);
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) { wheelPixelsPerUnit = -.53; }
  else if (gecko) { wheelPixelsPerUnit = 15; }
  else if (chrome) { wheelPixelsPerUnit = -.7; }
  else if (safari) { wheelPixelsPerUnit = -1/3; }

  function wheelEventDelta(e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }
    else if (dy == null) { dy = e.wheelDelta; }
    return {x: dx, y: dy}
  }
  function wheelEventPixels(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta
  }

  function onScrollWheel(cm, e) {
    // On Chrome 102, viewport updates somehow stop wheel-based
    // scrolling. Turning off pointer events during the scroll seems
    // to avoid the issue.
    if (chrome && chrome_version == 102) {
      if (cm.display.chromeScrollHack == null) { cm.display.sizer.style.pointerEvents = "none"; }
      else { clearTimeout(cm.display.chromeScrollHack); }
      cm.display.chromeScrollHack = setTimeout(function () {
        cm.display.chromeScrollHack = null;
        cm.display.sizer.style.pointerEvents = "";
      }, 100);
    }
    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;
    var pixelsPerUnit = wheelPixelsPerUnit;
    if (e.deltaMode === 0) {
      dx = e.deltaX;
      dy = e.deltaY;
      pixelsPerUnit = 1;
    }

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
    if (!(dx && canScrollX || dy && canScrollY)) { return }

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && pixelsPerUnit != null) {
      if (dy && canScrollY)
        { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit)); }
      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));
      // Only prevent default scrolling if vertical scrolling is
      // actually possible. Otherwise, it causes vertical scroll
      // jitter on OSX trackpads when deltaX is small and deltaY
      // is large (issue #3579)
      if (!dy || (dy && canScrollY))
        { e_preventDefault(e); }
      display.wheelStartX = null; // Abort measurement, if in progress
      return
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && pixelsPerUnit != null) {
      var pixels = dy * pixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) { top = Math.max(0, top + pixels - 50); }
      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }
      updateDisplaySimple(cm, {top: top, bottom: bot});
    }

    if (wheelSamples < 20 && e.deltaMode !== 0) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function () {
          if (display.wheelStartX == null) { return }
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) { return }
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  var Selection = function(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  };

  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };

  Selection.prototype.equals = function (other) {
    if (other == this) { return true }
    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
    for (var i = 0; i < this.ranges.length; i++) {
      var here = this.ranges[i], there = other.ranges[i];
      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }
    }
    return true
  };

  Selection.prototype.deepCopy = function () {
    var out = [];
    for (var i = 0; i < this.ranges.length; i++)
      { out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head)); }
    return new Selection(out, this.primIndex)
  };

  Selection.prototype.somethingSelected = function () {
    for (var i = 0; i < this.ranges.length; i++)
      { if (!this.ranges[i].empty()) { return true } }
    return false
  };

  Selection.prototype.contains = function (pos, end) {
    if (!end) { end = pos; }
    for (var i = 0; i < this.ranges.length; i++) {
      var range = this.ranges[i];
      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
        { return i }
    }
    return -1
  };

  var Range = function(anchor, head) {
    this.anchor = anchor; this.head = head;
  };

  Range.prototype.from = function () { return minPos(this.anchor, this.head) };
  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };
  Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };

  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(cm, ranges, primIndex) {
    var mayTouch = cm && cm.options.selectionsMayTouch;
    var prim = ranges[primIndex];
    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i], prev = ranges[i - 1];
      var diff = cmp(prev.to(), cur.from());
      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) { --primIndex; }
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex)
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0)
  }

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  function changeEnd(change) {
    if (!change.text) { return change.to }
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
  }

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) { return pos }
    if (cmp(pos, change.to) <= 0) { return changeEnd(change) }

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }
    return Pos(line, ch)
  }

  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change),
                         adjustForChange(range.head, change)));
    }
    return normalizeSelection(doc.cm, out, doc.sel.primIndex)
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line)
      { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
    else
      { return Pos(nw.line + (pos.line - old.line), pos.ch) }
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex)
  }

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function (line) {
      if (line.stateAfter) { line.stateAfter = null; }
      if (line.styles) { line.styles = null; }
    });
    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) { regChange(cm); }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null}
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, "change", line, change);
    }
    function linesFor(start, end) {
      var result = [];
      for (var i = start; i < end; ++i)
        { result.push(new Line(text[i], spansFor(i), estimateHeight)); }
      return result
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // Adjust the line structure
    if (change.full) {
      doc.insert(0, linesFor(0, text.length));
      doc.remove(text.length, doc.size - text.length);
    } else if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) { doc.remove(from.line, nlines); }
      if (added.length) { doc.insert(from.line, added); }
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added$1 = linesFor(1, text.length - 1);
        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added$1);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added$2 = linesFor(1, text.length - 1);
      if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }
      doc.insert(from.line + 1, added$2);
    }

    signalLater(doc, "change", doc, change);
  }

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) { continue }
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) { continue }
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      } }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) { throw new Error("This document is already in use.") }
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    setDirectionClass(cm);
    cm.options.direction = doc.direction;
    if (!cm.options.lineWrapping) { findMaxLine(cm); }
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  function setDirectionClass(cm) {
  (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
  }

  function directionChanged(cm) {
    runInOp(cm, function () {
      setDirectionClass(cm);
      regChange(cm);
    });
  }

  function History(prev) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = []; this.undone = [];
    this.undoDepth = prev ? prev.undoDepth : Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);
    return histChange
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) { array.pop(); }
      else { break }
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done)
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done)
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done)
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, or are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur;
    var last;

    if ((hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||
          change.origin.charAt(0) == "*")) &&
        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges)
        { pushSelectionToHistory(doc.sel, hist.done); }
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation};
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) { hist.done.shift(); }
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) { signal(doc, "historyAdded"); }
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" ||
      ch == "+" &&
      prev.ranges.length == sel.ranges.length &&
      prev.somethingSelected() == sel.somethingSelected() &&
      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history, origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastSelOp ||
        (origin && hist.lastSelOrigin == origin &&
         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
      { hist.done[hist.done.length - 1] = sel; }
    else
      { pushSelectionToHistory(sel, hist.done); }

    hist.lastSelTime = +new Date;
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false)
      { clearSelectionEvents(hist.undone); }
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel)))
      { dest.push(sel); }
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
      if (line.markedSpans)
        { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans; }
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) { return null }
    var out;
    for (var i = 0; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }
      else if (out) { out.push(spans[i]); }
    }
    return !out ? spans : out.length ? out : null
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) { return null }
    var nw = [];
    for (var i = 0; i < change.text.length; ++i)
      { nw.push(removeClearedSpans(found[i])); }
    return nw
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) { return stretched }
    if (!stretched) { return old }

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            { if (oldCur[k].marker == span.marker) { continue spans } }
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    var copy = [];
    for (var i = 0; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue
      }
      var changes = event.changes, newChanges = [];
      copy.push({changes: newChanges});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m = (void 0);
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        } } }
      }
    }
    return copy
  }

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(range, head, other, extend) {
    if (extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != (cmp(other, anchor) < 0)) {
          anchor = head;
          head = other;
        } else if (posBefore != (cmp(head, other) < 0)) {
          head = other;
        }
      }
      return new Range(anchor, head)
    } else {
      return new Range(other || head, head)
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options, extend) {
    if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }
    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    var out = [];
    var extend = doc.cm && (doc.cm.display.shift || doc.extend);
    for (var i = 0; i < doc.sel.ranges.length; i++)
      { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }
    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel, options) {
    var obj = {
      ranges: sel.ranges,
      update: function(ranges) {
        this.ranges = [];
        for (var i = 0; i < ranges.length; i++)
          { this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                     clipPos(doc, ranges[i].head)); }
      },
      origin: options && options.origin
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj); }
    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }
    else { return sel }
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done, last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
      { sel = filterSelectionChange(doc, sel, options); }

    var bias = options && options.bias ||
      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm && doc.cm.getOption("readOnly") != "nocursor")
      { ensureCursorVisible(doc.cm); }
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) { return }

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = 1;
      doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
      var newHead = range.head == range.anchor ? newAnchor : skipAtomic(doc, range.head, old && old.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) { out = sel.ranges.slice(0, i); }
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel
  }

  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
    var line = getLine(doc, pos.line);
    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
      var sp = line.markedSpans[i], m = sp.marker;

      // Determine if we should prevent the cursor being placed to the left/right of an atomic marker
      // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it
      // is with selectLeft/Right
      var preventCursorLeft = ("selectLeft" in m) ? !m.selectLeft : m.inclusiveLeft;
      var preventCursorRight = ("selectRight" in m) ? !m.selectRight : m.inclusiveRight;

      if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
          (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
        if (mayClear) {
          signal(m, "beforeCursorEnter");
          if (m.explicitlyCleared) {
            if (!line.markedSpans) { break }
            else {--i; continue}
          }
        }
        if (!m.atomic) { continue }

        if (oldPos) {
          var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);
          if (dir < 0 ? preventCursorRight : preventCursorLeft)
            { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }
          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
            { return skipAtomicInner(doc, near, pos, dir, mayClear) }
        }

        var far = m.find(dir < 0 ? -1 : 1);
        if (dir < 0 ? preventCursorLeft : preventCursorRight)
          { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }
        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
      }
    } }
    return pos
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
    var dir = bias || 1;
    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
    if (!found) {
      doc.cantEdit = true;
      return Pos(doc.first, 0)
    }
    return found
  }

  function movePos(doc, pos, dir, line) {
    if (dir < 0 && pos.ch == 0) {
      if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
      else { return null }
    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
      if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
      else { return null }
    } else {
      return new Pos(pos.line, pos.ch + dir)
    }
  }

  function selectAll(cm) {
    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
  }

  // UPDATING

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function () { return obj.canceled = true; }
    };
    if (update) { obj.update = function (from, to, text, origin) {
      if (from) { obj.from = clipPos(doc, from); }
      if (to) { obj.to = clipPos(doc, to); }
      if (text) { obj.text = text; }
      if (origin !== undefined) { obj.origin = origin; }
    }; }
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj); }

    if (obj.canceled) {
      if (doc.cm) { doc.cm.curOp.updateInput = 2; }
      return null
    }
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
      if (doc.cm.state.suppressEdits) { return }
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) { return }
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i)
        { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text, origin: change.origin}); }
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    var suppress = doc.cm && doc.cm.state.suppressEdits;
    if (suppress && !allowSelectionOnly) { return }

    var hist = doc.history, event, selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    var i = 0;
    for (; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
        { break }
    }
    if (i == source.length) { return }
    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {clearRedo: false});
          return
        }
        selAfter = event;
      } else if (suppress) {
        source.push(event);
        return
      } else { break }
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({changes: antiChanges, generation: hist.generation});
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    var loop = function ( i ) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return {}
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function (doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    };

    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
      var returned = loop( i$1 );

      if ( returned ) return returned.v;
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0) { return }
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
      Pos(range.anchor.line + distance, range.anchor.ch),
      Pos(range.head.line + distance, range.head.ch)
    ); }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
        { regLineChange(doc.cm, l, "gutter"); }
    }
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return
    }
    if (change.from.line > doc.lastLine()) { return }

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }
    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }
    else { updateDoc(doc, change, spans); }
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);

    if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0)))
      { doc.cantEdit = false; }
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function (line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1)
      { signalCursorActivity(cm); }

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }
    }

    retreatFrontier(doc, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (change.full)
      { regChange(cm); }
    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
      { regLineChange(cm, from.line, "text"); }
    else
      { regChange(cm, from.line, to.line + 1, lendiff); }

    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) { signalLater(cm, "change", cm, obj); }
      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }
    }
    cm.display.selForContextMenu = null;
  }

  function replaceRange(doc, code, from, to, origin) {
    var assign;

    if (!to) { to = from; }
    if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }
    if (typeof code == "string") { code = doc.splitLines(code); }
    makeChange(doc, {from: from, to: to, text: code, origin: origin});
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      if (sub.ranges) {
        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue
      }
      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
        var cur = sub.changes[j$1];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(doc, handle, changeType, op) {
    var no = handle, line = handle;
    if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)); }
    else { no = lineNo(handle); }
    if (no == null) { return null }
    if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }
    return line
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    var height = 0;
    for (var i = 0; i < lines.length; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length },

    // Remove the n lines at offset 'at'.
    removeInner: function(at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },

    // Helper used to collapse a small branch into a single leaf.
    collapse: function(lines) {
      lines.push.apply(lines, this.lines);
    },

    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function(at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) { lines[i].parent = this; }
    },

    // Used to iterate over a part of the tree.
    iterN: function(at, n, op) {
      for (var e = at + n; at < e; ++at)
        { if (op(this.lines[at])) { return true } }
    }
  };

  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size },

    removeInner: function(at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) { break }
          at = 0;
        } else { at -= sz; }
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 &&
          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },

    collapse: function(lines) {
      for (var i = 0; i < this.children.length; ++i) { this.children[i].collapse(lines); }
    },

    insertInner: function(at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
            var remaining = child.lines.length % 25 + 25;
            for (var pos = remaining; pos < child.lines.length;) {
              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
              child.height -= leaf.height;
              this.children.splice(++i, 0, leaf);
              leaf.parent = this;
            }
            child.lines = child.lines.slice(0, remaining);
            this.maybeSpill();
          }
          break
        }
        at -= sz;
      }
    },

    // When a node has grown, check whether it should be split.
    maybeSpill: function() {
      if (this.children.length <= 10) { return }
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
       } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10)
      me.parent.maybeSpill();
    },

    iterN: function(at, n, op) {
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) { return true }
          if ((n -= used) == 0) { break }
          at = 0;
        } else { at -= sz; }
      }
    }
  };

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = function(doc, node, options) {
    if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
      { this[opt] = options[opt]; } } }
    this.doc = doc;
    this.node = node;
  };

  LineWidget.prototype.clear = function () {
    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws) { return }
    for (var i = 0; i < ws.length; ++i) { if (ws[i] == this) { ws.splice(i--, 1); } }
    if (!ws.length) { line.widgets = null; }
    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) {
      runInOp(cm, function () {
        adjustScrollWhenAboveVisible(cm, line, -height);
        regLineChange(cm, no, "widget");
      });
      signalLater(cm, "lineWidgetCleared", cm, this, no);
    }
  };

  LineWidget.prototype.changed = function () {
      var this$1 = this;

    var oldH = this.height, cm = this.doc.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) { return }
    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }
    if (cm) {
      runInOp(cm, function () {
        cm.curOp.forceUpdate = true;
        adjustScrollWhenAboveVisible(cm, line, diff);
        signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
      });
    }
  };
  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
      { addToScrollTop(cm, diff); }
  }

  function addLineWidget(doc, handle, node, options) {
    var widget = new LineWidget(doc, node, options);
    var cm = doc.cm;
    if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }
    changeLine(doc, handle, "widget", function (line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) { widgets.push(widget); }
      else { widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget); }
      widget.line = line;
      if (cm && !lineIsHidden(doc, line)) {
        var aboveVisible = heightAtLine(line) < doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) { addToScrollTop(cm, widget.height); }
        cm.curOp.forceUpdate = true;
      }
      return true
    });
    if (cm) { signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle)); }
    return widget
  }

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;

  var TextMarker = function(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
    this.id = ++nextMarkerId;
  };

  // Clear the marker.
  TextMarker.prototype.clear = function () {
    if (this.explicitlyCleared) { return }
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) { startOperation(cm); }
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) { signalLater(this, "clear", found.from, found.to); }
    }
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (cm && !this.collapsed) { regLineChange(cm, lineNo(line), "text"); }
      else if (cm) {
        if (span.to != null) { max = lineNo(line); }
        if (span.from != null) { min = lineNo(line); }
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
        { updateLineHeight(line, textHeight(cm.display)); }
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
      var visual = visualLine(this.lines[i$1]), len = lineLength(visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    } }

    if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) { reCheckSelection(cm.doc); }
    }
    if (cm) { signalLater(cm, "markerCleared", cm, this, min, max); }
    if (withOp) { endOperation(cm); }
    if (this.parent) { this.parent.clear(); }
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function (side, lineObj) {
    if (side == null && this.type == "bookmark") { side = 1; }
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) { return from }
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) { return to }
      }
    }
    return from && {from: from, to: to}
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function () {
      var this$1 = this;

    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm) { return }
    runInOp(cm, function () {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight)
          { updateLineHeight(line, line.height + dHeight); }
      }
      signalLater(cm, "markerChanged", cm, this$1);
    });
  };

  TextMarker.prototype.attachLine = function (line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }
    }
    this.lines.push(line);
  };

  TextMarker.prototype.detachLine = function (line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp
      ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };
  eventMixin(TextMarker);

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }

    var marker = new TextMarker(doc, type), diff = cmp(from, to);
    if (options) { copyObj(options, marker, false); }
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
      { return marker }
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true"); }
      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
        { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
      seeCollapsedSpans();
    }

    if (marker.addToHistory)
      { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN); }

    var curLine = from.line, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function (line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
        { updateMaxLine = true; }
      if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }
      addMarkedSpan(line, new MarkedSpan(marker,
                                         curLine == from.line ? from.ch : null,
                                         curLine == to.line ? to.ch : null), doc.cm && doc.cm.curOp);
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
      if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }
    }); }

    if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }); }

    if (marker.readOnly) {
      seeReadOnlySpans();
      if (doc.history.done.length || doc.history.undone.length)
        { doc.clearHistory(); }
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }
      if (marker.collapsed)
        { regChange(cm, from.line, to.line + 1); }
      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||
               marker.attributes || marker.title)
        { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text"); } }
      if (marker.atomic) { reCheckSelection(cm.doc); }
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = function(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i)
      { markers[i].parent = this; }
  };

  SharedTextMarker.prototype.clear = function () {
    if (this.explicitlyCleared) { return }
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      { this.markers[i].clear(); }
    signalLater(this, "clear");
  };

  SharedTextMarker.prototype.find = function (side, lineObj) {
    return this.primary.find(side, lineObj)
  };
  eventMixin(SharedTextMarker);

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function (doc) {
      if (widget) { options.widgetNode = widget.cloneNode(true); }
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        { if (doc.linked[i].isParent) { return } }
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary)
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], pos = marker.find();
      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    var loop = function ( i ) {
      var marker = markers[i], linked = [marker.primary.doc];
      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    };

    for (var i = 0; i < markers.length; i++) loop( i );
  }

  var nextDocId = 0;
  var Doc = function(text, mode, firstLine, lineSep, direction) {
    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }
    if (firstLine == null) { firstLine = 0; }

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.modeFrontier = this.highlightFrontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;
    this.lineSep = lineSep;
    this.direction = (direction == "rtl") ? "rtl" : "ltr";
    this.extend = false;

    if (typeof text == "string") { text = this.splitLines(text); }
    updateDoc(this, {from: start, to: start, text: text});
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function(from, to, op) {
      if (op) { this.iterN(from - this.first, to - from, op); }
      else { this.iterN(this.first, this.first + this.size, from); }
    },

    // Non-public interface for adding and removing lines.
    insert: function(at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) { return lines }
      return lines.join(lineSep || this.lineSeparator())
    },
    setValue: docMethodOp(function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: this.splitLines(code), origin: "setValue", full: true}, true);
      if (this.cm) { scrollToCoords(this.cm, 0, 0); }
      setSelection(this, simpleSelection(top), sel_dontScroll);
    }),
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) { return lines }
      if (lineSep === '') { return lines.join('') }
      return lines.join(lineSep || this.lineSeparator())
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},

    getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
    getLineNumber: function(line) {return lineNo(line)},

    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") { line = getLine(this, line); }
      return visualLine(line)
    },

    lineCount: function() {return this.size},
    firstLine: function() {return this.first},
    lastLine: function() {return this.first + this.size - 1},

    clipPos: function(pos) {return clipPos(this, pos)},

    getCursor: function(start) {
      var range = this.sel.primary(), pos;
      if (start == null || start == "head") { pos = range.head; }
      else if (start == "anchor") { pos = range.anchor; }
      else if (start == "end" || start == "to" || start === false) { pos = range.to(); }
      else { pos = range.from(); }
      return pos
    },
    listSelections: function() { return this.sel.ranges },
    somethingSelected: function() {return this.sel.somethingSelected()},

    setCursor: docMethodOp(function(line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function(anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function(head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function(heads, options) {
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    extendSelectionsBy: docMethodOp(function(f, options) {
      var heads = map(this.sel.ranges, f);
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    setSelections: docMethodOp(function(ranges, primary, options) {
      if (!ranges.length) { return }
      var out = [];
      for (var i = 0; i < ranges.length; i++)
        { out[i] = new Range(clipPos(this, ranges[i].anchor),
                           clipPos(this, ranges[i].head || ranges[i].anchor)); }
      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }
      setSelection(this, normalizeSelection(this.cm, out, primary), options);
    }),
    addSelection: docMethodOp(function(anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
    }),

    getSelection: function(lineSep) {
      var ranges = this.sel.ranges, lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) { return lines }
      else { return lines.join(lineSep || this.lineSeparator()) }
    },
    getSelections: function(lineSep) {
      var parts = [], ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) { sel = sel.join(lineSep || this.lineSeparator()); }
        parts[i] = sel;
      }
      return parts
    },
    replaceSelection: function(code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++)
        { dup[i] = code; }
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function(code, collapse, origin) {
      var changes = [], sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range = sel.ranges[i];
        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)
        { makeChange(this, changes[i$1]); }
      if (newSel) { setSelectionReplaceHistory(this, newSel); }
      else if (this.cm) { ensureCursorVisible(this.cm); }
    }),
    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

    setExtending: function(val) {this.extend = val;},
    getExtending: function() {return this.extend},

    historySize: function() {
      var hist = this.history, done = 0, undone = 0;
      for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }
      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }
      return {undo: done, redo: undone}
    },
    clearHistory: function() {
      var this$1 = this;

      this.history = new History(this.history);
      linkedDocs(this, function (doc) { return doc.history = this$1.history; }, true);
    },

    markClean: function() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function(forceSplit) {
      if (forceSplit)
        { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }
      return this.history.generation
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration)
    },

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)}
    },
    setHistory: function(histData) {
      var hist = this.history = new History(this.history);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },

    setGutterMarker: docMethodOp(function(line, gutterID, value) {
      return changeLine(this, line, "gutter", function (line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) { line.gutterMarkers = null; }
        return true
      })
    }),

    clearGutter: docMethodOp(function(gutterID) {
      var this$1 = this;

      this.iter(function (line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          changeLine(this$1, line, "gutter", function () {
            line.gutterMarkers[gutterID] = null;
            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }
            return true
          });
        }
      });
    }),

    lineInfo: function(line) {
      var n;
      if (typeof line == "number") {
        if (!isLine(this, line)) { return null }
        n = line;
        line = getLine(this, line);
        if (!line) { return null }
      } else {
        n = lineNo(line);
        if (n == null) { return null }
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets}
    },

    addLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop]) { line[prop] = cls; }
        else if (classTest(cls).test(line[prop])) { return false }
        else { line[prop] += " " + cls; }
        return true
      })
    }),
    removeLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) { return false }
        else if (cls == null) { line[prop] = null; }
        else {
          var found = cur.match(classTest(cls));
          if (!found) { return false }
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true
      })
    }),

    addLineWidget: docMethodOp(function(handle, node, options) {
      return addLineWidget(this, handle, node, options)
    }),
    removeLineWidget: function(widget) { widget.clear(); },

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft,
                      clearWhenEmpty: false, shared: options && options.shared,
                      handleMouseEvents: options && options.handleMouseEvents};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark")
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) { for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          { markers.push(span.marker.parent || span.marker); }
      } }
      return markers
    },
    findMarks: function(from, to, filter) {
      from = clipPos(this, from); to = clipPos(this, to);
      var found = [], lineNo = from.line;
      this.iter(from.line, to.line + 1, function (line) {
        var spans = line.markedSpans;
        if (spans) { for (var i = 0; i < spans.length; i++) {
          var span = spans[i];
          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||
                span.from == null && lineNo != from.line ||
                span.from != null && lineNo == to.line && span.from >= to.ch) &&
              (!filter || filter(span.marker)))
            { found.push(span.marker.parent || span.marker); }
        } }
        ++lineNo;
      });
      return found
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function (line) {
        var sps = line.markedSpans;
        if (sps) { for (var i = 0; i < sps.length; ++i)
          { if (sps[i].from != null) { markers.push(sps[i].marker); } } }
      });
      return markers
    },

    posFromIndex: function(off) {
      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;
      this.iter(function (line) {
        var sz = line.text.length + sepSize;
        if (sz > off) { ch = off; return true }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch))
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) { return 0 }
      var sepSize = this.lineSeparator().length;
      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
        index += line.text.length + sepSize;
      });
      return index
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size),
                        this.modeOption, this.first, this.lineSep, this.direction);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc
    },

    linkedDoc: function(options) {
      if (!options) { options = {}; }
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) { from = options.from; }
      if (options.to != null && options.to < to) { to = options.to; }
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
      if (options.sharedHist) { copy.history = this.history
      ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy
    },
    unlinkDoc: function(other) {
      if (other instanceof CodeMirror) { other = other.doc; }
      if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {
        var link = this.linked[i];
        if (link.doc != other) { continue }
        this.linked.splice(i, 1);
        other.unlinkDoc(this);
        detachSharedMarkers(findSharedMarkers(this));
        break
      } }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode},
    getEditor: function() {return this.cm},

    splitLines: function(str) {
      if (this.lineSep) { return str.split(this.lineSep) }
      return splitLinesAuto(str)
    },
    lineSeparator: function() { return this.lineSep || "\n" },

    setDirection: docMethodOp(function (dir) {
      if (dir != "rtl") { dir = "ltr"; }
      if (dir == this.direction) { return }
      this.direction = dir;
      this.iter(function (line) { return line.order = null; });
      if (this.cm) { directionChanged(this.cm); }
    })
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    clearDragCursor(cm);
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
      { return }
    e_preventDefault(e);
    if (ie) { lastDrop = +new Date; }
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || cm.isReadOnly()) { return }
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var markAsReadAndPasteIfAllFilesAreRead = function () {
        if (++read == n) {
          operation(cm, function () {
            pos = clipPos(cm.doc, pos);
            var change = {from: pos, to: pos,
                          text: cm.doc.splitLines(
                              text.filter(function (t) { return t != null; }).join(cm.doc.lineSeparator())),
                          origin: "paste"};
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
          })();
        }
      };
      var readTextFromFile = function (file, i) {
        if (cm.options.allowDropFileTypes &&
            indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
          markAsReadAndPasteIfAllFilesAreRead();
          return
        }
        var reader = new FileReader;
        reader.onerror = function () { return markAsReadAndPasteIfAllFilesAreRead(); };
        reader.onload = function () {
          var content = reader.result;
          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
            markAsReadAndPasteIfAllFilesAreRead();
            return
          }
          text[i] = content;
          markAsReadAndPasteIfAllFilesAreRead();
        };
        reader.readAsText(file);
      };
      for (var i = 0; i < files.length; i++) { readTextFromFile(files[i], i); }
    } else { // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(function () { return cm.display.input.focus(); }, 20);
        return
      }
      try {
        var text$1 = e.dataTransfer.getData("Text");
        if (text$1) {
          var selected;
          if (cm.state.draggingText && !cm.state.draggingText.copy)
            { selected = cm.listSelections(); }
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)
            { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag"); } }
          cm.replaceSelection(text$1, "around", "paste");
          cm.display.input.focus();
        }
      }
      catch(e$1){}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }

    e.dataTransfer.setData("Text", cm.getSelection());
    e.dataTransfer.effectAllowed = "copyMove";

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) { img.parentNode.removeChild(img); }
    }
  }

  function onDragOver(cm, e) {
    var pos = posFromMouse(cm, e);
    if (!pos) { return }
    var frag = document.createDocumentFragment();
    drawSelectionCursor(cm, pos, frag);
    if (!cm.display.dragCursor) {
      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
    }
    removeChildrenAndAdd(cm.display.dragCursor, frag);
  }

  function clearDragCursor(cm) {
    if (cm.display.dragCursor) {
      cm.display.lineSpace.removeChild(cm.display.dragCursor);
      cm.display.dragCursor = null;
    }
  }

  // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.

  function forEachCodeMirror(f) {
    if (!document.getElementsByClassName) { return }
    var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;
      if (cm) { editors.push(cm); }
    }
    if (editors.length) { editors[0].operation(function () {
      for (var i = 0; i < editors.length; i++) { f(editors[i]); }
    }); }
  }

  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) { return }
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function () {
      if (resizeTimer == null) { resizeTimer = setTimeout(function () {
        resizeTimer = null;
        forEachCodeMirror(onResize);
      }, 100); }
    });
    // When the window loses focus, we want to show the editor as blurred
    on(window, "blur", function () { return forEachCodeMirror(onBlur); });
  }
  // Called when the window resizes
  function onResize(cm) {
    var d = cm.display;
    // Might be a text scaling operation, clear size caches.
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }

  var keyNames = {
    3: "Pause", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
    106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 145: "ScrollLock",
    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
    221: "]", 222: "'", 224: "Mod", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
  };

  // Number keys
  for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }
  // Alphabetic keys
  for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }
  // Function keys
  for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2; }

  var keyMap = {};

  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
    "fallthrough": "basic"
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd", "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp",
    "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine",
    "Ctrl-T": "transposeChars", "Ctrl-O": "openLine"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
    "fallthrough": ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/);
    name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }
      else if (/^a(lt)?$/i.test(mod)) { alt = true; }
      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
      else if (/^s(hift)?$/i.test(mod)) { shift = true; }
      else { throw new Error("Unrecognized modifier name: " + mod) }
    }
    if (alt) { name = "Alt-" + name; }
    if (ctrl) { name = "Ctrl-" + name; }
    if (cmd) { name = "Cmd-" + name; }
    if (shift) { name = "Shift-" + name; }
    return name
  }

  // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.
  function normalizeKeyMap(keymap) {
    var copy = {};
    for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
      var value = keymap[keyname];
      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
      if (value == "...") { delete keymap[keyname]; continue }

      var keys = map(keyname.split(" "), normalizeKeyName);
      for (var i = 0; i < keys.length; i++) {
        var val = (void 0), name = (void 0);
        if (i == keys.length - 1) {
          name = keys.join(" ");
          val = value;
        } else {
          name = keys.slice(0, i + 1).join(" ");
          val = "...";
        }
        var prev = copy[name];
        if (!prev) { copy[name] = val; }
        else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
      }
      delete keymap[keyname];
    } }
    for (var prop in copy) { keymap[prop] = copy[prop]; }
    return keymap
  }

  function lookupKey(key, map, handle, context) {
    map = getKeyMap(map);
    var found = map.call ? map.call(key, context) : map[key];
    if (found === false) { return "nothing" }
    if (found === "...") { return "multi" }
    if (found != null && handle(found)) { return "handled" }

    if (map.fallthrough) {
      if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
        { return lookupKey(key, map.fallthrough, handle, context) }
      for (var i = 0; i < map.fallthrough.length; i++) {
        var result = lookupKey(key, map.fallthrough[i], handle, context);
        if (result) { return result }
      }
    }
  }

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  function isModifierKey(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
  }

  function addModifierNames(name, event, noShift) {
    var base = name;
    if (event.altKey && base != "Alt") { name = "Alt-" + name; }
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name; }
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Mod") { name = "Cmd-" + name; }
    if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name; }
    return name
  }

  // Look up the name of a key as indicated by an event object.
  function keyName(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) { return false }
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey) { return false }
    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)
    if (event.keyCode == 3 && event.code) { name = event.code; }
    return addModifierNames(name, event, noShift)
  }

  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function () {
      for (var i = kill.length - 1; i >= 0; i--)
        { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete"); }
      ensureCursorVisible(cm);
    });
  }

  function moveCharLogically(line, ch, dir) {
    var target = skipExtendingChars(line.text, ch + dir, dir);
    return target < 0 || target > line.text.length ? null : target
  }

  function moveLogically(line, start, dir) {
    var ch = moveCharLogically(line, start.ch, dir);
    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
  }

  function endOfLine(visually, cm, lineObj, lineNo, dir) {
    if (visually) {
      if (cm.doc.direction == "rtl") { dir = -dir; }
      var order = getOrder(lineObj, cm.doc.direction);
      if (order) {
        var part = dir < 0 ? lst(order) : order[0];
        var moveInStorageOrder = (dir < 0) == (part.level == 1);
        var sticky = moveInStorageOrder ? "after" : "before";
        var ch;
        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
        // it could be that the last bidi part is not on the last visual line,
        // since visual lines contain content order-consecutive chunks.
        // Thus, in rtl, we are looking for the first (content-order) character
        // in the rtl chunk that is on the last line (that is, the same line
        // as the last (content-order) character).
        if (part.level > 0 || cm.doc.direction == "rtl") {
          var prep = prepareMeasureForLine(cm, lineObj);
          ch = dir < 0 ? lineObj.text.length - 1 : 0;
          var targetTop = measureCharPrepared(cm, prep, ch).top;
          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);
          if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1); }
        } else { ch = dir < 0 ? part.to : part.from; }
        return new Pos(lineNo, ch, sticky)
      }
    }
    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
  }

  function moveVisually(cm, line, start, dir) {
    var bidi = getOrder(line, cm.doc.direction);
    if (!bidi) { return moveLogically(line, start, dir) }
    if (start.ch >= line.text.length) {
      start.ch = line.text.length;
      start.sticky = "before";
    } else if (start.ch <= 0) {
      start.ch = 0;
      start.sticky = "after";
    }
    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
    if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
      // nothing interesting happens.
      return moveLogically(line, start, dir)
    }

    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };
    var prep;
    var getWrappedLineExtent = function (ch) {
      if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }
      prep = prep || prepareMeasureForLine(cm, line);
      return wrappedLineExtentChar(cm, line, prep, ch)
    };
    var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);

    if (cm.doc.direction == "rtl" || part.level == 1) {
      var moveInStorageOrder = (part.level == 1) == (dir < 0);
      var ch = mv(start, moveInStorageOrder ? 1 : -1);
      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
        // Case 2: We move within an rtl part or in an rtl editor on the same visual line
        var sticky = moveInStorageOrder ? "before" : "after";
        return new Pos(start.line, ch, sticky)
      }
    }

    // Case 3: Could not move within this bidi part in this visual line, so leave
    // the current bidi part

    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
      var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder
        ? new Pos(start.line, mv(ch, 1), "before")
        : new Pos(start.line, ch, "after"); };

      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
        var part = bidi[partPos];
        var moveInStorageOrder = (dir > 0) == (part.level != 1);
        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
        if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }
        ch = moveInStorageOrder ? part.from : mv(part.to, -1);
        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }
      }
    };

    // Case 3a: Look for other bidi parts on the same visual line
    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
    if (res) { return res }

    // Case 3b: Look for other bidi parts on the next visual line
    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
      if (res) { return res }
    }

    // Case 4: Nowhere to move
    return null
  }

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = {
    selectAll: selectAll,
    singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
    killLine: function (cm) { return deleteNearSelection(cm, function (range) {
      if (range.empty()) {
        var len = getLine(cm.doc, range.head.line).text.length;
        if (range.head.ch == len && range.head.line < cm.lastLine())
          { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
        else
          { return {from: range.head, to: Pos(range.head.line, len)} }
      } else {
        return {from: range.from(), to: range.to()}
      }
    }); },
    deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
      from: Pos(range.from().line, 0),
      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
    }); }); },
    delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
      from: Pos(range.from().line, 0), to: range.from()
    }); }); },
    delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
      var top = cm.charCoords(range.head, "div").top + 5;
      var leftPos = cm.coordsChar({left: 0, top: top}, "div");
      return {from: leftPos, to: range.from()}
    }); },
    delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
      var top = cm.charCoords(range.head, "div").top + 5;
      var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
      return {from: range.from(), to: rightPos }
    }); },
    undo: function (cm) { return cm.undo(); },
    redo: function (cm) { return cm.redo(); },
    undoSelection: function (cm) { return cm.undoSelection(); },
    redoSelection: function (cm) { return cm.redoSelection(); },
    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
    goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
      {origin: "+move", bias: 1}
    ); },
    goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
      {origin: "+move", bias: 1}
    ); },
    goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
      {origin: "+move", bias: -1}
    ); },
    goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
    }, sel_move); },
    goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      return cm.coordsChar({left: 0, top: top}, "div")
    }, sel_move); },
    goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      var pos = cm.coordsChar({left: 0, top: top}, "div");
      if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
      return pos
    }, sel_move); },
    goLineUp: function (cm) { return cm.moveV(-1, "line"); },
    goLineDown: function (cm) { return cm.moveV(1, "line"); },
    goPageUp: function (cm) { return cm.moveV(-1, "page"); },
    goPageDown: function (cm) { return cm.moveV(1, "page"); },
    goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
    goCharRight: function (cm) { return cm.moveH(1, "char"); },
    goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
    goColumnRight: function (cm) { return cm.moveH(1, "column"); },
    goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
    goGroupRight: function (cm) { return cm.moveH(1, "group"); },
    goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
    goWordRight: function (cm) { return cm.moveH(1, "word"); },
    delCharBefore: function (cm) { return cm.deleteH(-1, "codepoint"); },
    delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
    delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
    delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
    delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
    delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
    indentAuto: function (cm) { return cm.indentSelection("smart"); },
    indentMore: function (cm) { return cm.indentSelection("add"); },
    indentLess: function (cm) { return cm.indentSelection("subtract"); },
    insertTab: function (cm) { return cm.replaceSelection("\t"); },
    insertSoftTab: function (cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(spaceStr(tabSize - col % tabSize));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function (cm) {
      if (cm.somethingSelected()) { cm.indentSelection("add"); }
      else { cm.execCommand("insertTab"); }
    },
    // Swap the two chars left and right of each selection's head.
    // Move cursor behind the two swapped characters afterwards.
    //
    // Doesn't consider line feeds a character.
    // Doesn't scan more than one line above to find a character.
    // Doesn't do anything on an empty line.
    // Doesn't do anything with non-empty selections.
    transposeChars: function (cm) { return runInOp(cm, function () {
      var ranges = cm.listSelections(), newSel = [];
      for (var i = 0; i < ranges.length; i++) {
        if (!ranges[i].empty()) { continue }
        var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
        if (line) {
          if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }
          if (cur.ch > 0) {
            cur = new Pos(cur.line, cur.ch + 1);
            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                            Pos(cur.line, cur.ch - 2), cur, "+transpose");
          } else if (cur.line > cm.doc.first) {
            var prev = getLine(cm.doc, cur.line - 1).text;
            if (prev) {
              cur = new Pos(cur.line, 1);
              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
                              prev.charAt(prev.length - 1),
                              Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
            }
          }
        }
        newSel.push(new Range(cur, cur));
      }
      cm.setSelections(newSel);
    }); },
    newlineAndIndent: function (cm) { return runInOp(cm, function () {
      var sels = cm.listSelections();
      for (var i = sels.length - 1; i >= 0; i--)
        { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input"); }
      sels = cm.listSelections();
      for (var i$1 = 0; i$1 < sels.length; i$1++)
        { cm.indentLine(sels[i$1].from().line, null, true); }
      ensureCursorVisible(cm);
    }); },
    openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
  };


  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) { lineN = lineNo(visual); }
    return endOfLine(true, cm, visual, lineN, 1)
  }
  function lineEnd(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLineEnd(line);
    if (visual != line) { lineN = lineNo(visual); }
    return endOfLine(true, cm, line, lineN, -1)
  }
  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line, cm.doc.direction);
    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(start.ch, line.text.search(/\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
    }
    return start
  }

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) { return false }
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift, done = false;
    try {
      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
      if (dropShift) { cm.display.shift = false; }
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done
  }

  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
      if (result) { return result }
    }
    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
      || lookupKey(name, cm.options.keyMap, handle, cm)
  }

  // Note that, despite the name, this function is also used to check
  // for bound mouse clicks.

  var stopSeq = new Delayed;

  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) { return "handled" }
      if (/\'$/.test(name))
        { cm.state.keySeq = null; }
      else
        { stopSeq.set(50, function () {
          if (cm.state.keySeq == seq) {
            cm.state.keySeq = null;
            cm.display.input.reset();
          }
        }); }
      if (dispatchKeyInner(cm, seq + " " + name, e, handle)) { return true }
    }
    return dispatchKeyInner(cm, name, e, handle)
  }

  function dispatchKeyInner(cm, name, e, handle) {
    var result = lookupKeyForEditor(cm, name, handle);

    if (result == "multi")
      { cm.state.keySeq = name; }
    if (result == "handled")
      { signalLater(cm, "keyHandled", cm, name, e); }

    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }

    return !!result
  }

  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) { return false }

    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
          || dispatchKey(cm, name, e, function (b) {
               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                 { return doHandleBinding(cm, b) }
             })
    } else {
      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
    }
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    if (e.target && e.target != cm.display.input.getField()) { return }
    cm.curOp.focus = activeElt(root(cm));
    if (signalDOMEvent(cm, e)) { return }
    // IE does strange things with escape.
    if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        { cm.replaceSelection("", null, "cut"); }
    }
    if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand)
      { document.execCommand("cut"); }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
      { showCrossHair(cm); }
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (e.keyCode == 16) { this.doc.sel.shift = false; }
    signalDOMEvent(this, e);
  }

  function onKeyPress(e) {
    var cm = this;
    if (e.target && e.target != cm.display.input.getField()) { return }
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    // Some browsers fire keypress events for backspace
    if (ch == "\x08") { return }
    if (handleCharBinding(cm, e, ch)) { return }
    cm.display.input.onKeyPress(e);
  }

  var DOUBLECLICK_DELAY = 400;

  var PastClick = function(time, pos, button) {
    this.time = time;
    this.pos = pos;
    this.button = button;
  };

  PastClick.prototype.compare = function (time, pos, button) {
    return this.time + DOUBLECLICK_DELAY > time &&
      cmp(pos, this.pos) == 0 && button == this.button
  };

  var lastClick, lastDoubleClick;
  function clickRepeat(pos, button) {
    var now = +new Date;
    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
      lastClick = lastDoubleClick = null;
      return "triple"
    } else if (lastClick && lastClick.compare(now, pos, button)) {
      lastDoubleClick = new PastClick(now, pos, button);
      lastClick = null;
      return "double"
    } else {
      lastClick = new PastClick(now, pos, button);
      lastDoubleClick = null;
      return "single"
    }
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    var cm = this, display = cm.display;
    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
    display.input.ensurePolled();
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function () { return display.scroller.draggable = true; }, 100);
      }
      return
    }
    if (clickInGutter(cm, e)) { return }
    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
    win(cm).focus();

    // #3261: make sure, that we're not starting a second selection
    if (button == 1 && cm.state.selectingText)
      { cm.state.selectingText(e); }

    if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }

    if (button == 1) {
      if (pos) { leftButtonDown(cm, pos, repeat, e); }
      else if (e_target(e) == display.scroller) { e_preventDefault(e); }
    } else if (button == 2) {
      if (pos) { extendSelection(cm.doc, pos); }
      setTimeout(function () { return display.input.focus(); }, 20);
    } else if (button == 3) {
      if (captureRightClick) { cm.display.input.onContextMenu(e); }
      else { delayBlurEvent(cm); }
    }
  }

  function handleMappedButton(cm, button, pos, repeat, event) {
    var name = "Click";
    if (repeat == "double") { name = "Double" + name; }
    else if (repeat == "triple") { name = "Triple" + name; }
    name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;

    return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {
      if (typeof bound == "string") { bound = commands[bound]; }
      if (!bound) { return false }
      var done = false;
      try {
        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
        done = bound(cm, pos) != Pass;
      } finally {
        cm.state.suppressEdits = false;
      }
      return done
    })
  }

  function configureMouse(cm, repeat, event) {
    var option = cm.getOption("configureMouse");
    var value = option ? option(cm, repeat, event) : {};
    if (value.unit == null) {
      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
      value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
    }
    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }
    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }
    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }
    return value
  }

  function leftButtonDown(cm, pos, repeat, event) {
    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }
    else { cm.curOp.focus = activeElt(root(cm)); }

    var behavior = configureMouse(cm, repeat, event);

    var sel = cm.doc.sel, contained;
    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
        repeat == "single" && (contained = sel.contains(pos)) > -1 &&
        (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&
        (cmp(contained.to(), pos) > 0 || pos.xRel < 0))
      { leftButtonStartDrag(cm, event, pos, behavior); }
    else
      { leftButtonSelect(cm, event, pos, behavior); }
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, event, pos, behavior) {
    var display = cm.display, moved = false;
    var dragEnd = operation(cm, function (e) {
      if (webkit) { display.scroller.draggable = false; }
      cm.state.draggingText = false;
      if (cm.state.delayingBlurEvent) {
        if (cm.hasFocus()) { cm.state.delayingBlurEvent = false; }
        else { delayBlurEvent(cm); }
      }
      off(display.wrapper.ownerDocument, "mouseup", dragEnd);
      off(display.wrapper.ownerDocument, "mousemove", mouseMove);
      off(display.scroller, "dragstart", dragStart);
      off(display.scroller, "drop", dragEnd);
      if (!moved) {
        e_preventDefault(e);
        if (!behavior.addNew)
          { extendSelection(cm.doc, pos, null, null, behavior.extend); }
        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
        if ((webkit && !safari) || ie && ie_version == 9)
          { setTimeout(function () {display.wrapper.ownerDocument.body.focus({preventScroll: true}); display.input.focus();}, 20); }
        else
          { display.input.focus(); }
      }
    });
    var mouseMove = function(e2) {
      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
    };
    var dragStart = function () { return moved = true; };
    // Let the drag handler handle this.
    if (webkit) { display.scroller.draggable = true; }
    cm.state.draggingText = dragEnd;
    dragEnd.copy = !behavior.moveOnDrag;
    on(display.wrapper.ownerDocument, "mouseup", dragEnd);
    on(display.wrapper.ownerDocument, "mousemove", mouseMove);
    on(display.scroller, "dragstart", dragStart);
    on(display.scroller, "drop", dragEnd);

    cm.state.delayingBlurEvent = true;
    setTimeout(function () { return display.input.focus(); }, 20);
    // IE's approach to draggable
    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }
  }

  function rangeForUnit(cm, pos, unit) {
    if (unit == "char") { return new Range(pos, pos) }
    if (unit == "word") { return cm.findWordAt(pos) }
    if (unit == "line") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
    var result = unit(cm, pos);
    return new Range(result.from, result.to)
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, event, start, behavior) {
    if (ie) { delayBlurEvent(cm); }
    var display = cm.display, doc = cm.doc;
    e_preventDefault(event);

    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
    if (behavior.addNew && !behavior.extend) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1)
        { ourRange = ranges[ourIndex]; }
      else
        { ourRange = new Range(start, start); }
    } else {
      ourRange = doc.sel.primary();
      ourIndex = doc.sel.primIndex;
    }

    if (behavior.unit == "rectangle") {
      if (!behavior.addNew) { ourRange = new Range(start, start); }
      start = posFromMouse(cm, event, true, true);
      ourIndex = -1;
    } else {
      var range = rangeForUnit(cm, start, behavior.unit);
      if (behavior.extend)
        { ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend); }
      else
        { ourRange = range; }
    }

    if (!behavior.addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),
                   {scroll: false, origin: "*mouse"});
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
                   {scroll: false, origin: "*mouse"});
      startSel = doc.sel;
    } else {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    }

    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) { return }
      lastPos = pos;

      if (behavior.unit == "rectangle") {
        var ranges = [], tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
             line <= end; line++) {
          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
          if (left == right)
            { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }
          else if (text.length > leftPos)
            { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }
        }
        if (!ranges.length) { ranges.push(new Range(start, start)); }
        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                     {origin: "*mouse", scroll: false});
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var range = rangeForUnit(cm, pos, behavior.unit);
        var anchor = oldRange.anchor, head;
        if (cmp(range.anchor, anchor) > 0) {
          head = range.head;
          anchor = minPos(oldRange.from(), range.anchor);
        } else {
          head = range.anchor;
          anchor = maxPos(oldRange.to(), range.head);
        }
        var ranges$1 = startSel.ranges.slice(0);
        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
      if (!cur) { return }
      if (cmp(cur, lastPos) != 0) {
        cm.curOp.focus = activeElt(root(cm));
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) { setTimeout(operation(cm, function () {
          if (counter != curCount) { return }
          display.scroller.scrollTop += outside;
          extend(e);
        }), 50); }
      }
    }

    function done(e) {
      cm.state.selectingText = false;
      counter = Infinity;
      // If e is null or undefined we interpret this as someone trying
      // to explicitly cancel the selection rather than the user
      // letting go of the mouse button.
      if (e) {
        e_preventDefault(e);
        display.input.focus();
      }
      off(display.wrapper.ownerDocument, "mousemove", move);
      off(display.wrapper.ownerDocument, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }

    var move = operation(cm, function (e) {
      if (e.buttons === 0 || !e_button(e)) { done(e); }
      else { extend(e); }
    });
    var up = operation(cm, done);
    cm.state.selectingText = up;
    on(display.wrapper.ownerDocument, "mousemove", move);
    on(display.wrapper.ownerDocument, "mouseup", up);
  }

  // Used when mouse-selecting to adjust the anchor to the proper side
  // of a bidi jump depending on the visual position of the head.
  function bidiSimplify(cm, range) {
    var anchor = range.anchor;
    var head = range.head;
    var anchorLine = getLine(cm.doc, anchor.line);
    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range }
    var order = getOrder(anchorLine);
    if (!order) { return range }
    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
    if (part.from != anchor.ch && part.to != anchor.ch) { return range }
    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);
    if (boundary == 0 || boundary == order.length) { return range }

    // Compute the relative visual position of the head compared to the
    // anchor (<0 is to the left, >0 to the right)
    var leftSide;
    if (head.line != anchor.line) {
      leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
    } else {
      var headIndex = getBidiPartAt(order, head.ch, head.sticky);
      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
      if (headIndex == boundary - 1 || headIndex == boundary)
        { leftSide = dir < 0; }
      else
        { leftSide = dir > 0; }
    }

    var usePart = order[boundary + (leftSide ? -1 : 0)];
    var from = leftSide == (usePart.level == 1);
    var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
    return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head)
  }


  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent) {
    var mX, mY;
    if (e.touches) {
      mX = e.touches[0].clientX;
      mY = e.touches[0].clientY;
    } else {
      try { mX = e.clientX; mY = e.clientY; }
      catch(e$1) { return false }
    }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
    if (prevent) { e_preventDefault(e); }

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.display.gutterSpecs[i];
        signal(cm, type, cm, line, gutter.className, e);
        return e_defaultPrevented(e)
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true)
  }

  // CONTEXT MENU HANDLING

  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
    if (signalDOMEvent(cm, e, "contextmenu")) { return }
    if (!captureRightClick) { cm.display.input.onContextMenu(e); }
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) { return false }
    return gutterEvent(cm, e, "gutterContextMenu", false)
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  var Init = {toString: function(){return "CodeMirror.Init"}};

  var defaults = {};
  var optionHandlers = {};

  function defineOptions(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    function option(name, deflt, handle, notOnInit) {
      CodeMirror.defaults[name] = deflt;
      if (handle) { optionHandlers[name] =
        notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }
    }

    CodeMirror.defineOption = option;

    // Passed to option handlers when there is no old value.
    CodeMirror.Init = Init;

    // These two are, on init, called from the constructor because they
    // have to be initialized before the editor can start at all.
    option("value", "", function (cm, val) { return cm.setValue(val); }, true);
    option("mode", null, function (cm, val) {
      cm.doc.modeOption = val;
      loadMode(cm);
    }, true);

    option("indentUnit", 2, loadMode, true);
    option("indentWithTabs", false);
    option("smartIndent", true);
    option("tabSize", 4, function (cm) {
      resetModeState(cm);
      clearCaches(cm);
      regChange(cm);
    }, true);

    option("lineSeparator", null, function (cm, val) {
      cm.doc.lineSep = val;
      if (!val) { return }
      var newBreaks = [], lineNo = cm.doc.first;
      cm.doc.iter(function (line) {
        for (var pos = 0;;) {
          var found = line.text.indexOf(val, pos);
          if (found == -1) { break }
          pos = found + val.length;
          newBreaks.push(Pos(lineNo, found));
        }
        lineNo++;
      });
      for (var i = newBreaks.length - 1; i >= 0; i--)
        { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }
    });
    option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\u202d\u202e\u2066\u2067\u2069\ufeff\ufff9-\ufffc]/g, function (cm, val, old) {
      cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
      if (old != Init) { cm.refresh(); }
    });
    option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);
    option("electricChars", true);
    option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
      throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
    }, true);
    option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);
    option("autocorrect", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);
    option("autocapitalize", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);
    option("rtlMoveVisually", !windows);
    option("wholeLineUpdateBefore", true);

    option("theme", "default", function (cm) {
      themeChanged(cm);
      updateGutters(cm);
    }, true);
    option("keyMap", "default", function (cm, val, old) {
      var next = getKeyMap(val);
      var prev = old != Init && getKeyMap(old);
      if (prev && prev.detach) { prev.detach(cm, next); }
      if (next.attach) { next.attach(cm, prev || null); }
    });
    option("extraKeys", null);
    option("configureMouse", null);

    option("lineWrapping", false, wrappingChanged, true);
    option("gutters", [], function (cm, val) {
      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
      updateGutters(cm);
    }, true);
    option("fixedGutter", true, function (cm, val) {
      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
      cm.refresh();
    }, true);
    option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true);
    option("scrollbarStyle", "native", function (cm) {
      initScrollbars(cm);
      updateScrollbars(cm);
      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
    }, true);
    option("lineNumbers", false, function (cm, val) {
      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
      updateGutters(cm);
    }, true);
    option("firstLineNumber", 1, updateGutters, true);
    option("lineNumberFormatter", function (integer) { return integer; }, updateGutters, true);
    option("showCursorWhenSelecting", false, updateSelection, true);

    option("resetSelectionOnContextMenu", true);
    option("lineWiseCopyCut", true);
    option("pasteLinesPerSelection", true);
    option("selectionsMayTouch", false);

    option("readOnly", false, function (cm, val) {
      if (val == "nocursor") {
        onBlur(cm);
        cm.display.input.blur();
      }
      cm.display.input.readOnlyChanged(val);
    });

    option("screenReaderLabel", null, function (cm, val) {
      val = (val === '') ? null : val;
      cm.display.input.screenReaderLabelChanged(val);
    });

    option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);
    option("dragDrop", true, dragDropChanged);
    option("allowDropFileTypes", null);

    option("cursorBlinkRate", 530);
    option("cursorScrollMargin", 0);
    option("cursorHeight", 1, updateSelection, true);
    option("singleCursorHeightPerLine", true, updateSelection, true);
    option("workTime", 100);
    option("workDelay", 100);
    option("flattenSpans", true, resetModeState, true);
    option("addModeClass", false, resetModeState, true);
    option("pollInterval", 100);
    option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });
    option("historyEventDelay", 1250);
    option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true);
    option("maxHighlightLength", 10000, resetModeState, true);
    option("moveInputWithCursor", true, function (cm, val) {
      if (!val) { cm.display.input.resetPosition(); }
    });

    option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; });
    option("autofocus", null);
    option("direction", "ltr", function (cm, val) { return cm.doc.setDirection(val); }, true);
    option("phrases", null);
  }

  function dragDropChanged(cm, value, old) {
    var wasOn = old && old != Init;
    if (!value != !wasOn) {
      var funcs = cm.display.dragFunctions;
      var toggle = value ? on : off;
      toggle(cm.display.scroller, "dragstart", funcs.start);
      toggle(cm.display.scroller, "dragenter", funcs.enter);
      toggle(cm.display.scroller, "dragover", funcs.over);
      toggle(cm.display.scroller, "dragleave", funcs.leave);
      toggle(cm.display.scroller, "drop", funcs.drop);
    }
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function () { return updateScrollbars(cm); }, 100);
  }

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror(place, options) {
    var this$1 = this;

    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }

    this.options = options = options ? copyObj(options) : {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);

    var doc = options.value;
    if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }
    else if (options.mode) { doc.modeOption = options.mode; }
    this.doc = doc;

    var input = new CodeMirror.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc, input, options);
    display.wrapper.CodeMirror = this;
    themeChanged(this);
    if (options.lineWrapping)
      { this.display.wrapper.className += " CodeMirror-wrap"; }
    initScrollbars(this);

    this.state = {
      keyMaps: [],  // stores maps added by addKeyMap
      overlays: [], // highlighting overlays, as added by addOverlay
      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll
      selectingText: false,
      draggingText: false,
      highlight: new Delayed(), // stores highlight worker timeout
      keySeq: null,  // Unfinished key sequence
      specialChars: null
    };

    if (options.autofocus && !mobile) { display.input.focus(); }

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }

    registerEventHandlers(this);
    ensureGlobalHandlers();

    startOperation(this);
    this.curOp.forceUpdate = true;
    attachDoc(this, doc);

    if ((options.autofocus && !mobile) || this.hasFocus())
      { setTimeout(function () {
        if (this$1.hasFocus() && !this$1.state.focused) { onFocus(this$1); }
      }, 20); }
    else
      { onBlur(this); }

    for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
      { optionHandlers[opt](this, options[opt], Init); } }
    maybeUpdateLineNumberWidth(this);
    if (options.finishInit) { options.finishInit(this); }
    for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this); }
    endOperation(this);
    // Suppress optimizelegibility in Webkit, since it breaks text
    // measuring on line wrapping boundaries.
    if (webkit && options.lineWrapping &&
        getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
      { display.lineDiv.style.textRendering = "auto"; }
  }

  // The default configuration options.
  CodeMirror.defaults = defaults;
  // Functions to run when options are changed.
  CodeMirror.optionHandlers = optionHandlers;

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie && ie_version < 11)
      { on(d.scroller, "dblclick", operation(cm, function (e) {
        if (signalDOMEvent(cm, e)) { return }
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      })); }
    else
      { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); });
    on(d.input.getField(), "contextmenu", function (e) {
      if (!d.scroller.contains(e.target)) { onContextMenu(cm, e); }
    });

    // Used to suppress mouse event handling when a touch happens
    var touchFinished, prevTouch = {end: 0};
    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);
        prevTouch = d.activeTouch;
        prevTouch.end = +new Date;
      }
    }
    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) { return false }
      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1
    }
    function farAway(touch, other) {
      if (other.left == null) { return true }
      var dx = other.left - touch.left, dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20
    }
    on(d.scroller, "touchstart", function (e) {
      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
        d.input.ensurePolled();
        clearTimeout(touchFinished);
        var now = +new Date;
        d.activeTouch = {start: now, moved: false,
                         prev: now - prevTouch.end <= 300 ? prevTouch : null};
        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function () {
      if (d.activeTouch) { d.activeTouch.moved = true; }
    });
    on(d.scroller, "touchend", function (e) {
      var touch = d.activeTouch;
      if (touch && !eventInWidget(d, e) && touch.left != null &&
          !touch.moved && new Date - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"), range;
        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
          { range = new Range(pos, pos); }
        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
          { range = cm.findWordAt(pos); }
        else // Triple tap
          { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }
        cm.setSelection(range.anchor, range.head);
        cm.focus();
        e_preventDefault(e);
      }
      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch);

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function () {
      if (d.scroller.clientHeight) {
        updateScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); });
    on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); });

    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    d.dragFunctions = {
      enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},
      over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
      start: function (e) { return onDragStart(cm, e); },
      drop: operation(cm, onDrop),
      leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
    };

    var inp = d.input.getField();
    on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", function (e) { return onFocus(cm, e); });
    on(inp, "blur", function (e) { return onBlur(cm, e); });
  }

  var initHooks = [];
  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc, state;
    if (how == null) { how = "add"; }
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) { how = "prev"; }
      else { state = getContextBefore(cm, n).state; }
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) { line.stateAfter = null; }
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) { return }
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }
      else { indentation = 0; }
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";} }
    if (pos < indentation) { indentString += spaceStr(indentation - pos); }

    if (indentString != curSpaceString) {
      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
      line.stateAfter = null;
      return true
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
        var range = doc.sel.ranges[i$1];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos$1 = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
          break
        }
      }
    }
  }

  // This will be set to a {lineWise: bool, text: [string]} object, so
  // that, when pasting, we know what kind of selections the copied
  // text was made out of.
  var lastCopied = null;

  function setLastCopied(newLastCopied) {
    lastCopied = newLastCopied;
  }

  function applyTextInput(cm, inserted, deleted, sel, origin) {
    var doc = cm.doc;
    cm.display.shift = false;
    if (!sel) { sel = doc.sel; }

    var recent = +new Date - 200;
    var paste = origin == "paste" || cm.state.pasteIncoming > recent;
    var textLines = splitLinesAuto(inserted), multiPaste = null;
    // When pasting N lines into N selections, insert one line per selection
    if (paste && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.text.join("\n") == inserted) {
        if (sel.ranges.length % lastCopied.text.length == 0) {
          multiPaste = [];
          for (var i = 0; i < lastCopied.text.length; i++)
            { multiPaste.push(doc.splitLines(lastCopied.text[i])); }
        }
      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
        multiPaste = map(textLines, function (l) { return [l]; });
      }
    }

    var updateInput = cm.curOp.updateInput;
    // Normal behavior is to insert the new text into every selection
    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
      var range = sel.ranges[i$1];
      var from = range.from(), to = range.to();
      if (range.empty()) {
        if (deleted && deleted > 0) // Handle deletion
          { from = Pos(from.line, from.ch - deleted); }
        else if (cm.state.overwrite && !paste) // Handle overwrite
          { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }
        else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n"))
          { from = to = Pos(from.line, 0); }
      }
      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
                         origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")};
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
    }
    if (inserted && !paste)
      { triggerElectric(cm, inserted); }

    ensureCursorVisible(cm);
    if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }
    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = -1;
  }

  function handlePaste(e, cm) {
    var pasted = e.clipboardData && e.clipboardData.getData("Text");
    if (pasted) {
      e.preventDefault();
      if (!cm.isReadOnly() && !cm.options.disableInput && cm.hasFocus())
        { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }); }
      return true
    }
  }

  function triggerElectric(cm, inserted) {
    // When an 'electric' character is inserted, immediately trigger a reindent
    if (!cm.options.electricChars || !cm.options.smartIndent) { return }
    var sel = cm.doc.sel;

    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range = sel.ranges[i];
      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) { continue }
      var mode = cm.getModeAt(range.head);
      var indented = false;
      if (mode.electricChars) {
        for (var j = 0; j < mode.electricChars.length; j++)
          { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
            indented = indentLine(cm, range.head.line, "smart");
            break
          } }
      } else if (mode.electricInput) {
        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))
          { indented = indentLine(cm, range.head.line, "smart"); }
      }
      if (indented) { signalLater(cm, "electricInput", cm, range.head.line); }
    }
  }

  function copyableRanges(cm) {
    var text = [], ranges = [];
    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
      var line = cm.doc.sel.ranges[i].head.line;
      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }
    return {text: text, ranges: ranges}
  }

  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
    field.setAttribute("autocorrect", autocorrect ? "on" : "off");
    field.setAttribute("autocapitalize", autocapitalize ? "on" : "off");
    field.setAttribute("spellcheck", !!spellcheck);
  }

  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) { te.style.width = "1000px"; }
    else { te.setAttribute("wrap", "off"); }
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) { te.style.border = "1px solid black"; }
    return div
  }

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  function addEditorMethods(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    var helpers = CodeMirror.helpers = {};

    CodeMirror.prototype = {
      constructor: CodeMirror,
      focus: function(){win(this).focus(); this.display.input.focus();},

      setOption: function(option, value) {
        var options = this.options, old = options[option];
        if (options[option] == value && option != "mode") { return }
        options[option] = value;
        if (optionHandlers.hasOwnProperty(option))
          { operation(this, optionHandlers[option])(this, value, old); }
        signal(this, "optionChange", this, option);
      },

      getOption: function(option) {return this.options[option]},
      getDoc: function() {return this.doc},

      addKeyMap: function(map, bottom) {
        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
      },
      removeKeyMap: function(map) {
        var maps = this.state.keyMaps;
        for (var i = 0; i < maps.length; ++i)
          { if (maps[i] == map || maps[i].name == map) {
            maps.splice(i, 1);
            return true
          } }
      },

      addOverlay: methodOp(function(spec, options) {
        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
        if (mode.startState) { throw new Error("Overlays may not be stateful.") }
        insertSorted(this.state.overlays,
                     {mode: mode, modeSpec: spec, opaque: options && options.opaque,
                      priority: (options && options.priority) || 0},
                     function (overlay) { return overlay.priority; });
        this.state.modeGen++;
        regChange(this);
      }),
      removeOverlay: methodOp(function(spec) {
        var overlays = this.state.overlays;
        for (var i = 0; i < overlays.length; ++i) {
          var cur = overlays[i].modeSpec;
          if (cur == spec || typeof spec == "string" && cur.name == spec) {
            overlays.splice(i, 1);
            this.state.modeGen++;
            regChange(this);
            return
          }
        }
      }),

      indentLine: methodOp(function(n, dir, aggressive) {
        if (typeof dir != "string" && typeof dir != "number") {
          if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev"; }
          else { dir = dir ? "add" : "subtract"; }
        }
        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }
      }),
      indentSelection: methodOp(function(how) {
        var ranges = this.doc.sel.ranges, end = -1;
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i];
          if (!range.empty()) {
            var from = range.from(), to = range.to();
            var start = Math.max(end, from.line);
            end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
            for (var j = start; j < end; ++j)
              { indentLine(this, j, how); }
            var newRanges = this.doc.sel.ranges;
            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
              { replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }
          } else if (range.head.line > end) {
            indentLine(this, range.head.line, how, true);
            end = range.head.line;
            if (i == this.doc.sel.primIndex) { ensureCursorVisible(this); }
          }
        }
      }),

      // Fetch the parser token for a given character. Useful for hacks
      // that want to inspect the mode state (say, for completion).
      getTokenAt: function(pos, precise) {
        return takeToken(this, pos, precise)
      },

      getLineTokens: function(line, precise) {
        return takeToken(this, Pos(line), precise, true)
      },

      getTokenTypeAt: function(pos) {
        pos = clipPos(this.doc, pos);
        var styles = getLineStyles(this, getLine(this.doc, pos.line));
        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
        var type;
        if (ch == 0) { type = styles[2]; }
        else { for (;;) {
          var mid = (before + after) >> 1;
          if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }
          else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }
          else { type = styles[mid * 2 + 2]; break }
        } }
        var cut = type ? type.indexOf("overlay ") : -1;
        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
      },

      getModeAt: function(pos) {
        var mode = this.doc.mode;
        if (!mode.innerMode) { return mode }
        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
      },

      getHelper: function(pos, type) {
        return this.getHelpers(pos, type)[0]
      },

      getHelpers: function(pos, type) {
        var found = [];
        if (!helpers.hasOwnProperty(type)) { return found }
        var help = helpers[type], mode = this.getModeAt(pos);
        if (typeof mode[type] == "string") {
          if (help[mode[type]]) { found.push(help[mode[type]]); }
        } else if (mode[type]) {
          for (var i = 0; i < mode[type].length; i++) {
            var val = help[mode[type][i]];
            if (val) { found.push(val); }
          }
        } else if (mode.helperType && help[mode.helperType]) {
          found.push(help[mode.helperType]);
        } else if (help[mode.name]) {
          found.push(help[mode.name]);
        }
        for (var i$1 = 0; i$1 < help._global.length; i$1++) {
          var cur = help._global[i$1];
          if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
            { found.push(cur.val); }
        }
        return found
      },

      getStateAfter: function(line, precise) {
        var doc = this.doc;
        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
        return getContextBefore(this, line + 1, precise).state
      },

      cursorCoords: function(start, mode) {
        var pos, range = this.doc.sel.primary();
        if (start == null) { pos = range.head; }
        else if (typeof start == "object") { pos = clipPos(this.doc, start); }
        else { pos = start ? range.from() : range.to(); }
        return cursorCoords(this, pos, mode || "page")
      },

      charCoords: function(pos, mode) {
        return charCoords(this, clipPos(this.doc, pos), mode || "page")
      },

      coordsChar: function(coords, mode) {
        coords = fromCoordSystem(this, coords, mode || "page");
        return coordsChar(this, coords.left, coords.top)
      },

      lineAtHeight: function(height, mode) {
        height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
        return lineAtHeight(this.doc, height + this.display.viewOffset)
      },
      heightAtLine: function(line, mode, includeWidgets) {
        var end = false, lineObj;
        if (typeof line == "number") {
          var last = this.doc.first + this.doc.size - 1;
          if (line < this.doc.first) { line = this.doc.first; }
          else if (line > last) { line = last; end = true; }
          lineObj = getLine(this.doc, line);
        } else {
          lineObj = line;
        }
        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top +
          (end ? this.doc.height - heightAtLine(lineObj) : 0)
      },

      defaultTextHeight: function() { return textHeight(this.display) },
      defaultCharWidth: function() { return charWidth(this.display) },

      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},

      addWidget: function(pos, node, scroll, vert, horiz) {
        var display = this.display;
        pos = cursorCoords(this, clipPos(this.doc, pos));
        var top = pos.bottom, left = pos.left;
        node.style.position = "absolute";
        node.setAttribute("cm-ignore-events", "true");
        this.display.input.setUneditable(node);
        display.sizer.appendChild(node);
        if (vert == "over") {
          top = pos.top;
        } else if (vert == "above" || vert == "near") {
          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
          // Default to positioning above (if specified and possible); otherwise default to positioning below
          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
            { top = pos.top - node.offsetHeight; }
          else if (pos.bottom + node.offsetHeight <= vspace)
            { top = pos.bottom; }
          if (left + node.offsetWidth > hspace)
            { left = hspace - node.offsetWidth; }
        }
        node.style.top = top + "px";
        node.style.left = node.style.right = "";
        if (horiz == "right") {
          left = display.sizer.clientWidth - node.offsetWidth;
          node.style.right = "0px";
        } else {
          if (horiz == "left") { left = 0; }
          else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }
          node.style.left = left + "px";
        }
        if (scroll)
          { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }
      },

      triggerOnKeyDown: methodOp(onKeyDown),
      triggerOnKeyPress: methodOp(onKeyPress),
      triggerOnKeyUp: onKeyUp,
      triggerOnMouseDown: methodOp(onMouseDown),

      execCommand: function(cmd) {
        if (commands.hasOwnProperty(cmd))
          { return commands[cmd].call(null, this) }
      },

      triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

      findPosH: function(from, amount, unit, visually) {
        var dir = 1;
        if (amount < 0) { dir = -1; amount = -amount; }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          cur = findPosH(this.doc, cur, dir, unit, visually);
          if (cur.hitSide) { break }
        }
        return cur
      },

      moveH: methodOp(function(dir, unit) {
        var this$1 = this;

        this.extendSelectionsBy(function (range) {
          if (this$1.display.shift || this$1.doc.extend || range.empty())
            { return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) }
          else
            { return dir < 0 ? range.from() : range.to() }
        }, sel_move);
      }),

      deleteH: methodOp(function(dir, unit) {
        var sel = this.doc.sel, doc = this.doc;
        if (sel.somethingSelected())
          { doc.replaceSelection("", null, "+delete"); }
        else
          { deleteNearSelection(this, function (range) {
            var other = findPosH(doc, range.head, dir, unit, false);
            return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other}
          }); }
      }),

      findPosV: function(from, amount, unit, goalColumn) {
        var dir = 1, x = goalColumn;
        if (amount < 0) { dir = -1; amount = -amount; }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          var coords = cursorCoords(this, cur, "div");
          if (x == null) { x = coords.left; }
          else { coords.left = x; }
          cur = findPosV(this, coords, dir, unit);
          if (cur.hitSide) { break }
        }
        return cur
      },

      moveV: methodOp(function(dir, unit) {
        var this$1 = this;

        var doc = this.doc, goals = [];
        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
        doc.extendSelectionsBy(function (range) {
          if (collapse)
            { return dir < 0 ? range.from() : range.to() }
          var headPos = cursorCoords(this$1, range.head, "div");
          if (range.goalColumn != null) { headPos.left = range.goalColumn; }
          goals.push(headPos.left);
          var pos = findPosV(this$1, headPos, dir, unit);
          if (unit == "page" && range == doc.sel.primary())
            { addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top); }
          return pos
        }, sel_move);
        if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)
          { doc.sel.ranges[i].goalColumn = goals[i]; } }
      }),

      // Find the word at the given position (as returned by coordsChar).
      findWordAt: function(pos) {
        var doc = this.doc, line = getLine(doc, pos.line).text;
        var start = pos.ch, end = pos.ch;
        if (line) {
          var helper = this.getHelper(pos, "wordChars");
          if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end; }
          var startChar = line.charAt(start);
          var check = isWordChar(startChar, helper)
            ? function (ch) { return isWordChar(ch, helper); }
            : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
            : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); };
          while (start > 0 && check(line.charAt(start - 1))) { --start; }
          while (end < line.length && check(line.charAt(end))) { ++end; }
        }
        return new Range(Pos(pos.line, start), Pos(pos.line, end))
      },

      toggleOverwrite: function(value) {
        if (value != null && value == this.state.overwrite) { return }
        if (this.state.overwrite = !this.state.overwrite)
          { addClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
        else
          { rmClass(this.display.cursorDiv, "CodeMirror-overwrite"); }

        signal(this, "overwriteToggle", this, this.state.overwrite);
      },
      hasFocus: function() { return this.display.input.getField() == activeElt(root(this)) },
      isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },

      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),
      getScrollInfo: function() {
        var scroller = this.display.scroller;
        return {left: scroller.scrollLeft, top: scroller.scrollTop,
                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
      },

      scrollIntoView: methodOp(function(range, margin) {
        if (range == null) {
          range = {from: this.doc.sel.primary().head, to: null};
          if (margin == null) { margin = this.options.cursorScrollMargin; }
        } else if (typeof range == "number") {
          range = {from: Pos(range, 0), to: null};
        } else if (range.from == null) {
          range = {from: range, to: null};
        }
        if (!range.to) { range.to = range.from; }
        range.margin = margin || 0;

        if (range.from.line != null) {
          scrollToRange(this, range);
        } else {
          scrollToCoordsRange(this, range.from, range.to, range.margin);
        }
      }),

      setSize: methodOp(function(width, height) {
        var this$1 = this;

        var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; };
        if (width != null) { this.display.wrapper.style.width = interpret(width); }
        if (height != null) { this.display.wrapper.style.height = interpret(height); }
        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }
        var lineNo = this.display.viewFrom;
        this.doc.iter(lineNo, this.display.viewTo, function (line) {
          if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)
            { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo, "widget"); break } } }
          ++lineNo;
        });
        this.curOp.forceUpdate = true;
        signal(this, "refresh", this);
      }),

      operation: function(f){return runInOp(this, f)},
      startOperation: function(){return startOperation(this)},
      endOperation: function(){return endOperation(this)},

      refresh: methodOp(function() {
        var oldHeight = this.display.cachedTextHeight;
        regChange(this);
        this.curOp.forceUpdate = true;
        clearCaches(this);
        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
        updateGutterSpace(this.display);
        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5 || this.options.lineWrapping)
          { estimateLineHeights(this); }
        signal(this, "refresh", this);
      }),

      swapDoc: methodOp(function(doc) {
        var old = this.doc;
        old.cm = null;
        // Cancel the current text selection if any (#5821)
        if (this.state.selectingText) { this.state.selectingText(); }
        attachDoc(this, doc);
        clearCaches(this);
        this.display.input.reset();
        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
        this.curOp.forceScroll = true;
        signalLater(this, "swapDoc", this, old);
        return old
      }),

      phrase: function(phraseText) {
        var phrases = this.options.phrases;
        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText
      },

      getInputField: function(){return this.display.input.getField()},
      getWrapperElement: function(){return this.display.wrapper},
      getScrollerElement: function(){return this.display.scroller},
      getGutterElement: function(){return this.display.gutters}
    };
    eventMixin(CodeMirror);

    CodeMirror.registerHelper = function(type, name, value) {
      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }
      helpers[type][name] = value;
    };
    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
      CodeMirror.registerHelper(type, name, value);
      helpers[type]._global.push({pred: predicate, val: value});
    };
  }

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "codepoint", "char", "column" (like char, but
  // doesn't cross line boundaries), "word" (across next word), or
  // "group" (to the start of next group of word or
  // non-word-non-whitespace chars). The visually param controls
  // whether, in right-to-left text, direction 1 means to move towards
  // the next index in the string, or towards the character to the right
  // of the current position. The resulting position will have a
  // hitSide=true property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var oldPos = pos;
    var origDir = dir;
    var lineObj = getLine(doc, pos.line);
    var lineDir = visually && doc.direction == "rtl" ? -dir : dir;
    function findNextLine() {
      var l = pos.line + lineDir;
      if (l < doc.first || l >= doc.first + doc.size) { return false }
      pos = new Pos(l, pos.ch, pos.sticky);
      return lineObj = getLine(doc, l)
    }
    function moveOnce(boundToLine) {
      var next;
      if (unit == "codepoint") {
        var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));
        if (isNaN(ch)) {
          next = null;
        } else {
          var astral = dir > 0 ? ch >= 0xD800 && ch < 0xDC00 : ch >= 0xDC00 && ch < 0xDFFF;
          next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);
        }
      } else if (visually) {
        next = moveVisually(doc.cm, lineObj, pos, dir);
      } else {
        next = moveLogically(lineObj, pos, dir);
      }
      if (next == null) {
        if (!boundToLine && findNextLine())
          { pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir); }
        else
          { return false }
      } else {
        pos = next;
      }
      return true
    }

    if (unit == "char" || unit == "codepoint") {
      moveOnce();
    } else if (unit == "column") {
      moveOnce(true);
    } else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) { break }
        var cur = lineObj.text.charAt(pos.ch) || "\n";
        var type = isWordChar(cur, helper) ? "w"
          : group && cur == "\n" ? "n"
          : !group || /\s/.test(cur) ? null
          : "p";
        if (group && !first && !type) { type = "s"; }
        if (sawType && sawType != type) {
          if (dir < 0) {dir = 1; moveOnce(); pos.sticky = "after";}
          break
        }

        if (type) { sawType = type; }
        if (dir > 0 && !moveOnce(!first)) { break }
      }
    }
    var result = skipAtomic(doc, pos, oldPos, origDir, true);
    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }
    return result
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, win(cm).innerHeight || doc(cm).documentElement.clientHeight);
      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;

    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    var target;
    for (;;) {
      target = coordsChar(cm, x, y);
      if (!target.outside) { break }
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
      y += dir * 5;
    }
    return target
  }

  // CONTENTEDITABLE INPUT STYLE

  var ContentEditableInput = function(cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.composing = null;
    this.gracePeriod = false;
    this.readDOMTimeout = null;
  };

  ContentEditableInput.prototype.init = function (display) {
      var this$1 = this;

    var input = this, cm = input.cm;
    var div = input.div = display.lineDiv;
    div.contentEditable = true;
    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);

    function belongsToInput(e) {
      for (var t = e.target; t; t = t.parentNode) {
        if (t == div) { return true }
        if (/\bCodeMirror-(?:line)?widget\b/.test(t.className)) { break }
      }
      return false
    }

    on(div, "paste", function (e) {
      if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
      // IE doesn't fire input events, so we schedule a read for the pasted content in this way
      if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }
    });

    on(div, "compositionstart", function (e) {
      this$1.composing = {data: e.data, done: false};
    });
    on(div, "compositionupdate", function (e) {
      if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }
    });
    on(div, "compositionend", function (e) {
      if (this$1.composing) {
        if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }
        this$1.composing.done = true;
      }
    });

    on(div, "touchstart", function () { return input.forceCompositionEnd(); });

    on(div, "input", function () {
      if (!this$1.composing) { this$1.readFromDOMSoon(); }
    });

    function onCopyCut(e) {
      if (!belongsToInput(e) || signalDOMEvent(cm, e)) { return }
      if (cm.somethingSelected()) {
        setLastCopied({lineWise: false, text: cm.getSelections()});
        if (e.type == "cut") { cm.replaceSelection("", null, "cut"); }
      } else if (!cm.options.lineWiseCopyCut) {
        return
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({lineWise: true, text: ranges.text});
        if (e.type == "cut") {
          cm.operation(function () {
            cm.setSelections(ranges.ranges, 0, sel_dontScroll);
            cm.replaceSelection("", null, "cut");
          });
        }
      }
      if (e.clipboardData) {
        e.clipboardData.clearData();
        var content = lastCopied.text.join("\n");
        // iOS exposes the clipboard API, but seems to discard content inserted into it
        e.clipboardData.setData("Text", content);
        if (e.clipboardData.getData("Text") == content) {
          e.preventDefault();
          return
        }
      }
      // Old-fashioned briefly-focus-a-textarea hack
      var kludge = hiddenTextarea(), te = kludge.firstChild;
      disableBrowserMagic(te);
      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
      te.value = lastCopied.text.join("\n");
      var hadFocus = activeElt(rootNode(div));
      selectInput(te);
      setTimeout(function () {
        cm.display.lineSpace.removeChild(kludge);
        hadFocus.focus();
        if (hadFocus == div) { input.showPrimarySelection(); }
      }, 50);
    }
    on(div, "copy", onCopyCut);
    on(div, "cut", onCopyCut);
  };

  ContentEditableInput.prototype.screenReaderLabelChanged = function (label) {
    // Label for screenreaders, accessibility
    if(label) {
      this.div.setAttribute('aria-label', label);
    } else {
      this.div.removeAttribute('aria-label');
    }
  };

  ContentEditableInput.prototype.prepareSelection = function () {
    var result = prepareSelection(this.cm, false);
    result.focus = activeElt(rootNode(this.div)) == this.div;
    return result
  };

  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
    if (!info || !this.cm.display.view.length) { return }
    if (info.focus || takeFocus) { this.showPrimarySelection(); }
    this.showMultipleSelections(info);
  };

  ContentEditableInput.prototype.getSelection = function () {
    return this.cm.display.wrapper.ownerDocument.getSelection()
  };

  ContentEditableInput.prototype.showPrimarySelection = function () {
    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
    var from = prim.from(), to = prim.to();

    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
      sel.removeAllRanges();
      return
    }

    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
        cmp(minPos(curAnchor, curFocus), from) == 0 &&
        cmp(maxPos(curAnchor, curFocus), to) == 0)
      { return }

    var view = cm.display.view;
    var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||
        {node: view[0].measure.map[2], offset: 0};
    var end = to.line < cm.display.viewTo && posToDOM(cm, to);
    if (!end) {
      var measure = view[view.length - 1].measure;
      var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
      end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};
    }

    if (!start || !end) {
      sel.removeAllRanges();
      return
    }

    var old = sel.rangeCount && sel.getRangeAt(0), rng;
    try { rng = range(start.node, start.offset, end.offset, end.node); }
    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
    if (rng) {
      if (!gecko && cm.state.focused) {
        sel.collapse(start.node, start.offset);
        if (!rng.collapsed) {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
      } else {
        sel.removeAllRanges();
        sel.addRange(rng);
      }
      if (old && sel.anchorNode == null) { sel.addRange(old); }
      else if (gecko) { this.startGracePeriod(); }
    }
    this.rememberSelection();
  };

  ContentEditableInput.prototype.startGracePeriod = function () {
      var this$1 = this;

    clearTimeout(this.gracePeriod);
    this.gracePeriod = setTimeout(function () {
      this$1.gracePeriod = false;
      if (this$1.selectionChanged())
        { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }
    }, 20);
  };

  ContentEditableInput.prototype.showMultipleSelections = function (info) {
    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
  };

  ContentEditableInput.prototype.rememberSelection = function () {
    var sel = this.getSelection();
    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
  };

  ContentEditableInput.prototype.selectionInEditor = function () {
    var sel = this.getSelection();
    if (!sel.rangeCount) { return false }
    var node = sel.getRangeAt(0).commonAncestorContainer;
    return contains(this.div, node)
  };

  ContentEditableInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor") {
      if (!this.selectionInEditor() || activeElt(rootNode(this.div)) != this.div)
        { this.showSelection(this.prepareSelection(), true); }
      this.div.focus();
    }
  };
  ContentEditableInput.prototype.blur = function () { this.div.blur(); };
  ContentEditableInput.prototype.getField = function () { return this.div };

  ContentEditableInput.prototype.supportsTouch = function () { return true };

  ContentEditableInput.prototype.receivedFocus = function () {
      var this$1 = this;

    var input = this;
    if (this.selectionInEditor())
      { setTimeout(function () { return this$1.pollSelection(); }, 20); }
    else
      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }

    function poll() {
      if (input.cm.state.focused) {
        input.pollSelection();
        input.polling.set(input.cm.options.pollInterval, poll);
      }
    }
    this.polling.set(this.cm.options.pollInterval, poll);
  };

  ContentEditableInput.prototype.selectionChanged = function () {
    var sel = this.getSelection();
    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
  };

  ContentEditableInput.prototype.pollSelection = function () {
    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }
    var sel = this.getSelection(), cm = this.cm;
    // On Android Chrome (version 56, at least), backspacing into an
    // uneditable block element will put the cursor in that element,
    // and then, because it's not editable, hide the virtual keyboard.
    // Because Android doesn't allow us to actually detect backspace
    // presses in a sane way, this code checks for when that happens
    // and simulates a backspace press in this case.
    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
      this.cm.triggerOnKeyDown({type: "keydown", keyCode: 8, preventDefault: Math.abs});
      this.blur();
      this.focus();
      return
    }
    if (this.composing) { return }
    this.rememberSelection();
    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var head = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (anchor && head) { runInOp(cm, function () {
      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }
    }); }
  };

  ContentEditableInput.prototype.pollContent = function () {
    if (this.readDOMTimeout != null) {
      clearTimeout(this.readDOMTimeout);
      this.readDOMTimeout = null;
    }

    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
    var from = sel.from(), to = sel.to();
    if (from.ch == 0 && from.line > cm.firstLine())
      { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }
    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
      { to = Pos(to.line + 1, 0); }
    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }

    var fromIndex, fromLine, fromNode;
    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
      fromLine = lineNo(display.view[0].line);
      fromNode = display.view[0].node;
    } else {
      fromLine = lineNo(display.view[fromIndex].line);
      fromNode = display.view[fromIndex - 1].node.nextSibling;
    }
    var toIndex = findViewIndex(cm, to.line);
    var toLine, toNode;
    if (toIndex == display.view.length - 1) {
      toLine = display.viewTo - 1;
      toNode = display.lineDiv.lastChild;
    } else {
      toLine = lineNo(display.view[toIndex + 1].line) - 1;
      toNode = display.view[toIndex + 1].node.previousSibling;
    }

    if (!fromNode) { return false }
    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
    while (newText.length > 1 && oldText.length > 1) {
      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
      else { break }
    }

    var cutFront = 0, cutEnd = 0;
    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
      { ++cutFront; }
    var newBot = lst(newText), oldBot = lst(oldText);
    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
                             oldBot.length - (oldText.length == 1 ? cutFront : 0));
    while (cutEnd < maxCutEnd &&
           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
      { ++cutEnd; }
    // Try to move start of change to start of selection if ambiguous
    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
      while (cutFront && cutFront > from.ch &&
             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        cutFront--;
        cutEnd++;
      }
    }

    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
    newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");

    var chFrom = Pos(fromLine, cutFront);
    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
      replaceRange(cm.doc, newText, chFrom, chTo, "+input");
      return true
    }
  };

  ContentEditableInput.prototype.ensurePolled = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.reset = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.forceCompositionEnd = function () {
    if (!this.composing) { return }
    clearTimeout(this.readDOMTimeout);
    this.composing = null;
    this.updateFromDOM();
    this.div.blur();
    this.div.focus();
  };
  ContentEditableInput.prototype.readFromDOMSoon = function () {
      var this$1 = this;

    if (this.readDOMTimeout != null) { return }
    this.readDOMTimeout = setTimeout(function () {
      this$1.readDOMTimeout = null;
      if (this$1.composing) {
        if (this$1.composing.done) { this$1.composing = null; }
        else { return }
      }
      this$1.updateFromDOM();
    }, 80);
  };

  ContentEditableInput.prototype.updateFromDOM = function () {
      var this$1 = this;

    if (this.cm.isReadOnly() || !this.pollContent())
      { runInOp(this.cm, function () { return regChange(this$1.cm); }); }
  };

  ContentEditableInput.prototype.setUneditable = function (node) {
    node.contentEditable = "false";
  };

  ContentEditableInput.prototype.onKeyPress = function (e) {
    if (e.charCode == 0 || this.composing) { return }
    e.preventDefault();
    if (!this.cm.isReadOnly())
      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }
  };

  ContentEditableInput.prototype.readOnlyChanged = function (val) {
    this.div.contentEditable = String(val != "nocursor");
  };

  ContentEditableInput.prototype.onContextMenu = function () {};
  ContentEditableInput.prototype.resetPosition = function () {};

  ContentEditableInput.prototype.needsContentAttribute = true;

  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);
    if (!view || view.hidden) { return null }
    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);

    var order = getOrder(line, cm.doc.direction), side = "left";
    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }
    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result
  }

  function isInGutter(node) {
    for (var scan = node; scan; scan = scan.parentNode)
      { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }
    return false
  }

  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }

  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
    function close() {
      if (closing) {
        text += lineSep;
        if (extraLinebreak) { text += lineSep; }
        closing = extraLinebreak = false;
      }
    }
    function addText(str) {
      if (str) {
        close();
        text += str;
      }
    }
    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");
        if (cmText) {
          addText(cmText);
          return
        }
        var markerID = node.getAttribute("cm-marker"), range;
        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
          if (found.length && (range = found[0].find(0)))
            { addText(getBetween(cm.doc, range.from, range.to).join(lineSep)); }
          return
        }
        if (node.getAttribute("contenteditable") == "false") { return }
        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }

        if (isBlock) { close(); }
        for (var i = 0; i < node.childNodes.length; i++)
          { walk(node.childNodes[i]); }

        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }
        if (isBlock) { closing = true; }
      } else if (node.nodeType == 3) {
        addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
      }
    }
    for (;;) {
      walk(from);
      if (from == to) { break }
      from = from.nextSibling;
      extraLinebreak = false;
    }
    return text
  }

  function domToPos(cm, node, offset) {
    var lineNode;
    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];
      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
      node = null; offset = 0;
    } else {
      for (lineNode = node;; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) { return null }
        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
      }
    }
    for (var i = 0; i < cm.display.view.length; i++) {
      var lineView = cm.display.view[i];
      if (lineView.node == lineNode)
        { return locateNodeInLineView(lineView, node, offset) }
    }
  }

  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild, bad = false;
    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;
      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad)
      }
    }

    var textNode = node.nodeType == 3 ? node : null, topNode = node;
    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;
      if (offset) { offset = textNode.nodeValue.length; }
    }
    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }
    var measure = lineView.measure, maps = measure.maps;

    function find(textNode, topNode, offset) {
      for (var i = -1; i < (maps ? maps.length : 0); i++) {
        var map = i < 0 ? measure.map : maps[i];
        for (var j = 0; j < map.length; j += 3) {
          var curNode = map[j + 2];
          if (curNode == textNode || curNode == topNode) {
            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
            var ch = map[j] + offset;
            if (offset < 0 || curNode != textNode) { ch = map[j + (offset ? 1 : 0)]; }
            return Pos(line, ch)
          }
        }
      }
    }
    var found = find(textNode, topNode, offset);
    if (found) { return badPos(found, bad) }

    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);
      if (found)
        { return badPos(Pos(found.line, found.ch - dist), bad) }
      else
        { dist += after.textContent.length; }
    }
    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);
      if (found)
        { return badPos(Pos(found.line, found.ch + dist$1), bad) }
      else
        { dist$1 += before.textContent.length; }
    }
  }

  // TEXTAREA INPUT STYLE

  var TextareaInput = function(cm) {
    this.cm = cm;
    // See input.poll and input.reset
    this.prevInput = "";

    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    this.pollingFast = false;
    // Self-resetting timeout for the poller
    this.polling = new Delayed();
    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
    this.hasSelection = false;
    this.composing = null;
    this.resetting = false;
  };

  TextareaInput.prototype.init = function (display) {
      var this$1 = this;

    var input = this, cm = this.cm;
    this.createField(display);
    var te = this.textarea;

    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);

    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
    if (ios) { te.style.width = "0px"; }

    on(te, "input", function () {
      if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }
      input.poll();
    });

    on(te, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }

      cm.state.pasteIncoming = +new Date;
      input.fastPoll();
    });

    function prepareCopyCut(e) {
      if (signalDOMEvent(cm, e)) { return }
      if (cm.somethingSelected()) {
        setLastCopied({lineWise: false, text: cm.getSelections()});
      } else if (!cm.options.lineWiseCopyCut) {
        return
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({lineWise: true, text: ranges.text});
        if (e.type == "cut") {
          cm.setSelections(ranges.ranges, null, sel_dontScroll);
        } else {
          input.prevInput = "";
          te.value = ranges.text.join("\n");
          selectInput(te);
        }
      }
      if (e.type == "cut") { cm.state.cutIncoming = +new Date; }
    }
    on(te, "cut", prepareCopyCut);
    on(te, "copy", prepareCopyCut);

    on(display.scroller, "paste", function (e) {
      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
      if (!te.dispatchEvent) {
        cm.state.pasteIncoming = +new Date;
        input.focus();
        return
      }

      // Pass the `paste` event to the textarea so it's handled by its event listener.
      var event = new Event("paste");
      event.clipboardData = e.clipboardData;
      te.dispatchEvent(event);
    });

    // Prevent normal selection in the editor (we handle our own)
    on(display.lineSpace, "selectstart", function (e) {
      if (!eventInWidget(display, e)) { e_preventDefault(e); }
    });

    on(te, "compositionstart", function () {
      var start = cm.getCursor("from");
      if (input.composing) { input.composing.range.clear(); }
      input.composing = {
        start: start,
        range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
      };
    });
    on(te, "compositionend", function () {
      if (input.composing) {
        input.poll();
        input.composing.range.clear();
        input.composing = null;
      }
    });
  };

  TextareaInput.prototype.createField = function (_display) {
    // Wraps and hides input textarea
    this.wrapper = hiddenTextarea();
    // The semihidden textarea that is focused when the editor is
    // focused, and receives input.
    this.textarea = this.wrapper.firstChild;
    var opts = this.cm.options;
    disableBrowserMagic(this.textarea, opts.spellcheck, opts.autocorrect, opts.autocapitalize);
  };

  TextareaInput.prototype.screenReaderLabelChanged = function (label) {
    // Label for screenreaders, accessibility
    if(label) {
      this.textarea.setAttribute('aria-label', label);
    } else {
      this.textarea.removeAttribute('aria-label');
    }
  };

  TextareaInput.prototype.prepareSelection = function () {
    // Redraw the selection and/or cursor
    var cm = this.cm, display = cm.display, doc = cm.doc;
    var result = prepareSelection(cm);

    // Move the hidden textarea near the cursor to prevent scrolling artifacts
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                          headPos.top + lineOff.top - wrapOff.top));
      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                           headPos.left + lineOff.left - wrapOff.left));
    }

    return result
  };

  TextareaInput.prototype.showSelection = function (drawn) {
    var cm = this.cm, display = cm.display;
    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
    removeChildrenAndAdd(display.selectionDiv, drawn.selection);
    if (drawn.teTop != null) {
      this.wrapper.style.top = drawn.teTop + "px";
      this.wrapper.style.left = drawn.teLeft + "px";
    }
  };

  // Reset the input to correspond to the selection (or to be empty,
  // when not typing and nothing is selected)
  TextareaInput.prototype.reset = function (typing) {
    if (this.contextMenuPending || this.composing && typing) { return }
    var cm = this.cm;
    this.resetting = true;
    if (cm.somethingSelected()) {
      this.prevInput = "";
      var content = cm.getSelection();
      this.textarea.value = content;
      if (cm.state.focused) { selectInput(this.textarea); }
      if (ie && ie_version >= 9) { this.hasSelection = content; }
    } else if (!typing) {
      this.prevInput = this.textarea.value = "";
      if (ie && ie_version >= 9) { this.hasSelection = null; }
    }
    this.resetting = false;
  };

  TextareaInput.prototype.getField = function () { return this.textarea };

  TextareaInput.prototype.supportsTouch = function () { return false };

  TextareaInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt(rootNode(this.textarea)) != this.textarea)) {
      try { this.textarea.focus(); }
      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
    }
  };

  TextareaInput.prototype.blur = function () { this.textarea.blur(); };

  TextareaInput.prototype.resetPosition = function () {
    this.wrapper.style.top = this.wrapper.style.left = 0;
  };

  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };

  // Poll for input changes, using the normal rate of polling. This
  // runs as long as the editor is focused.
  TextareaInput.prototype.slowPoll = function () {
      var this$1 = this;

    if (this.pollingFast) { return }
    this.polling.set(this.cm.options.pollInterval, function () {
      this$1.poll();
      if (this$1.cm.state.focused) { this$1.slowPoll(); }
    });
  };

  // When an event has just come in that is likely to add or change
  // something in the input textarea, we poll faster, to ensure that
  // the change appears on the screen quickly.
  TextareaInput.prototype.fastPoll = function () {
    var missed = false, input = this;
    input.pollingFast = true;
    function p() {
      var changed = input.poll();
      if (!changed && !missed) {missed = true; input.polling.set(60, p);}
      else {input.pollingFast = false; input.slowPoll();}
    }
    input.polling.set(20, p);
  };

  // Read input from the textarea, and update the document to match.
  // When something is selected, it is present in the textarea, and
  // selected (unless it is huge, in which case a placeholder is
  // used). When nothing is selected, the cursor sits after previously
  // seen text (can be empty), which is stored in prevInput (we must
  // not reset the textarea when typing, because that breaks IME).
  TextareaInput.prototype.poll = function () {
      var this$1 = this;

    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
    // Since this is called a *lot*, try to bail out as cheaply as
    // possible when it is clear that nothing happened. hasSelection
    // will be the case when there is a lot of text in the textarea,
    // in which case reading its value would be expensive.
    if (this.contextMenuPending || this.resetting || !cm.state.focused ||
        (hasSelection(input) && !prevInput && !this.composing) ||
        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
      { return false }

    var text = input.value;
    // If nothing changed, bail.
    if (text == prevInput && !cm.somethingSelected()) { return false }
    // Work around nonsensical selection resetting in IE9/10, and
    // inexplicable appearance of private area unicode characters on
    // some key combos in Mac (#2689).
    if (ie && ie_version >= 9 && this.hasSelection === text ||
        mac && /[\uf700-\uf7ff]/.test(text)) {
      cm.display.input.reset();
      return false
    }

    if (cm.doc.sel == cm.display.selForContextMenu) {
      var first = text.charCodeAt(0);
      if (first == 0x200b && !prevInput) { prevInput = "\u200b"; }
      if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
    }
    // Find the part of the input that is actually new
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }

    runInOp(cm, function () {
      applyTextInput(cm, text.slice(same), prevInput.length - same,
                     null, this$1.composing ? "*compose" : null);

      // Don't leave long text in the textarea, since it makes further polling slow
      if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = ""; }
      else { this$1.prevInput = text; }

      if (this$1.composing) {
        this$1.composing.range.clear();
        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
                                           {className: "CodeMirror-composing"});
      }
    });
    return true
  };

  TextareaInput.prototype.ensurePolled = function () {
    if (this.pollingFast && this.poll()) { this.pollingFast = false; }
  };

  TextareaInput.prototype.onKeyPress = function () {
    if (ie && ie_version >= 9) { this.hasSelection = null; }
    this.fastPoll();
  };

  TextareaInput.prototype.onContextMenu = function (e) {
    var input = this, cm = input.cm, display = cm.display, te = input.textarea;
    if (input.contextMenuPending) { input.contextMenuPending(); }
    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || presto) { return } // Opera is difficult.

    // Reset the current text selection only if the click is done outside of the selection
    // and 'resetSelectionOnContextMenu' option is true.
    var reset = cm.options.resetSelectionOnContextMenu;
    if (reset && cm.doc.sel.contains(pos) == -1)
      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }

    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
    input.wrapper.style.cssText = "position: static";
    te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
    var oldScrollY;
    if (webkit) { oldScrollY = te.ownerDocument.defaultView.scrollY; } // Work around Chrome issue (#2712)
    display.input.focus();
    if (webkit) { te.ownerDocument.defaultView.scrollTo(null, oldScrollY); }
    display.input.reset();
    // Adds "Select all" to context menu in FF
    if (!cm.somethingSelected()) { te.value = input.prevInput = " "; }
    input.contextMenuPending = rehide;
    display.selForContextMenu = cm.doc.sel;
    clearTimeout(display.detectingSelectAll);

    // Select-all will be greyed out if there's nothing to select, so
    // this adds a zero-width space so that we can later check whether
    // it got selected.
    function prepareSelectAllHack() {
      if (te.selectionStart != null) {
        var selected = cm.somethingSelected();
        var extval = "\u200b" + (selected ? te.value : "");
        te.value = "\u21da"; // Used to catch context-menu undo
        te.value = extval;
        input.prevInput = selected ? "" : "\u200b";
        te.selectionStart = 1; te.selectionEnd = extval.length;
        // Re-set this, in case some other handler touched the
        // selection in the meantime.
        display.selForContextMenu = cm.doc.sel;
      }
    }
    function rehide() {
      if (input.contextMenuPending != rehide) { return }
      input.contextMenuPending = false;
      input.wrapper.style.cssText = oldWrapperCSS;
      te.style.cssText = oldCSS;
      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }

      // Try to detect the user choosing select-all
      if (te.selectionStart != null) {
        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }
        var i = 0, poll = function () {
          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
              te.selectionEnd > 0 && input.prevInput == "\u200b") {
            operation(cm, selectAll)(cm);
          } else if (i++ < 10) {
            display.detectingSelectAll = setTimeout(poll, 500);
          } else {
            display.selForContextMenu = null;
            display.input.reset();
          }
        };
        display.detectingSelectAll = setTimeout(poll, 200);
      }
    }

    if (ie && ie_version >= 9) { prepareSelectAllHack(); }
    if (captureRightClick) {
      e_stop(e);
      var mouseup = function () {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };
      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  };

  TextareaInput.prototype.readOnlyChanged = function (val) {
    if (!val) { this.reset(); }
    this.textarea.disabled = val == "nocursor";
    this.textarea.readOnly = !!val;
  };

  TextareaInput.prototype.setUneditable = function () {};

  TextareaInput.prototype.needsContentAttribute = false;

  function fromTextArea(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabIndex)
      { options.tabindex = textarea.tabIndex; }
    if (!options.placeholder && textarea.placeholder)
      { options.placeholder = textarea.placeholder; }
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt(rootNode(textarea));
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}

    var realSubmit;
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form;
        realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function () {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch(e) {}
      }
    }

    options.finishInit = function (cm) {
      cm.save = save;
      cm.getTextArea = function () { return textarea; };
      cm.toTextArea = function () {
        cm.toTextArea = isNaN; // Prevent this from being ran twice
        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function")
            { textarea.form.submit = realSubmit; }
        }
      };
    };

    textarea.style.display = "none";
    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
      options);
    return cm
  }

  function addLegacyProps(CodeMirror) {
    CodeMirror.off = off;
    CodeMirror.on = on;
    CodeMirror.wheelEventPixels = wheelEventPixels;
    CodeMirror.Doc = Doc;
    CodeMirror.splitLines = splitLinesAuto;
    CodeMirror.countColumn = countColumn;
    CodeMirror.findColumn = findColumn;
    CodeMirror.isWordChar = isWordCharBasic;
    CodeMirror.Pass = Pass;
    CodeMirror.signal = signal;
    CodeMirror.Line = Line;
    CodeMirror.changeEnd = changeEnd;
    CodeMirror.scrollbarModel = scrollbarModel;
    CodeMirror.Pos = Pos;
    CodeMirror.cmpPos = cmp;
    CodeMirror.modes = modes;
    CodeMirror.mimeModes = mimeModes;
    CodeMirror.resolveMode = resolveMode;
    CodeMirror.getMode = getMode;
    CodeMirror.modeExtensions = modeExtensions;
    CodeMirror.extendMode = extendMode;
    CodeMirror.copyState = copyState;
    CodeMirror.startState = startState;
    CodeMirror.innerMode = innerMode;
    CodeMirror.commands = commands;
    CodeMirror.keyMap = keyMap;
    CodeMirror.keyName = keyName;
    CodeMirror.isModifierKey = isModifierKey;
    CodeMirror.lookupKey = lookupKey;
    CodeMirror.normalizeKeyMap = normalizeKeyMap;
    CodeMirror.StringStream = StringStream;
    CodeMirror.SharedTextMarker = SharedTextMarker;
    CodeMirror.TextMarker = TextMarker;
    CodeMirror.LineWidget = LineWidget;
    CodeMirror.e_preventDefault = e_preventDefault;
    CodeMirror.e_stopPropagation = e_stopPropagation;
    CodeMirror.e_stop = e_stop;
    CodeMirror.addClass = addClass;
    CodeMirror.contains = contains;
    CodeMirror.rmClass = rmClass;
    CodeMirror.keyNames = keyNames;
  }

  // EDITOR CONSTRUCTOR

  defineOptions(CodeMirror);

  addEditorMethods(CodeMirror);

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
  for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    { CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments)}
    })(Doc.prototype[prop]); } }

  eventMixin(Doc);
  CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror.defineMode = function(name/*, mode, */) {
    if (!CodeMirror.defaults.mode && name != "null") { CodeMirror.defaults.mode = name; }
    defineMode.apply(this, arguments);
  };

  CodeMirror.defineMIME = defineMIME;

  // Minimal default mode.
  CodeMirror.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
  CodeMirror.defineMIME("text/plain", "null");

  // EXTENSIONS

  CodeMirror.defineExtension = function (name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function (name, func) {
    Doc.prototype[name] = func;
  };

  CodeMirror.fromTextArea = fromTextArea;

  addLegacyProps(CodeMirror);

  CodeMirror.version = "5.65.20";

  return CodeMirror;

})));


/***/ }),

/***/ "./node_modules/codemirror/mode/gfm/gfm.js":
/*!*************************************************!*\
  !*** ./node_modules/codemirror/mode/gfm/gfm.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/5/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"), __webpack_require__(/*! ../markdown/markdown */ "./node_modules/codemirror/mode/markdown/markdown.js"), __webpack_require__(/*! ../../addon/mode/overlay */ "./node_modules/codemirror/addon/mode/overlay.js"));
  else // removed by dead control flow
{}
})(function(CodeMirror) {
"use strict";

var urlRE = /^((?:(?:aaas?|about|acap|adiumxtra|af[ps]|aim|apt|attachment|aw|beshare|bitcoin|bolo|callto|cap|chrome(?:-extension)?|cid|coap|com-eventbrite-attendee|content|crid|cvs|data|dav|dict|dlna-(?:playcontainer|playsingle)|dns|doi|dtn|dvb|ed2k|facetime|feed|file|finger|fish|ftp|geo|gg|git|gizmoproject|go|gopher|gtalk|h323|hcp|https?|iax|icap|icon|im|imap|info|ipn|ipp|irc[6s]?|iris(?:\.beep|\.lwz|\.xpc|\.xpcs)?|itms|jar|javascript|jms|keyparc|lastfm|ldaps?|magnet|mailto|maps|market|message|mid|mms|ms-help|msnim|msrps?|mtqp|mumble|mupdate|mvn|news|nfs|nih?|nntp|notes|oid|opaquelocktoken|palm|paparazzi|platform|pop|pres|proxy|psyc|query|res(?:ource)?|rmi|rsync|rtmp|rtsp|secondlife|service|session|sftp|sgn|shttp|sieve|sips?|skype|sm[bs]|snmp|soap\.beeps?|soldat|spotify|ssh|steam|svn|tag|teamspeak|tel(?:net)?|tftp|things|thismessage|tip|tn3270|tv|udp|unreal|urn|ut2004|vemmi|ventrilo|view-source|webcal|wss?|wtai|wyciwyg|xcon(?:-userid)?|xfire|xmlrpc\.beeps?|xmpp|xri|ymsgr|z39\.50[rs]?):(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]|\([^\s()<>]*\))+(?:\([^\s()<>]*\)|[^\s`*!()\[\]{};:'".,<>?]))/i

CodeMirror.defineMode("gfm", function(config, modeConfig) {
  var codeDepth = 0;
  function blankLine(state) {
    state.code = false;
    return null;
  }
  var gfmOverlay = {
    startState: function() {
      return {
        code: false,
        codeBlock: false,
        ateSpace: false
      };
    },
    copyState: function(s) {
      return {
        code: s.code,
        codeBlock: s.codeBlock,
        ateSpace: s.ateSpace
      };
    },
    token: function(stream, state) {
      state.combineTokens = null;

      // Hack to prevent formatting override inside code blocks (block and inline)
      if (state.codeBlock) {
        if (stream.match(/^```+/)) {
          state.codeBlock = false;
          return null;
        }
        stream.skipToEnd();
        return null;
      }
      if (stream.sol()) {
        state.code = false;
      }
      if (stream.sol() && stream.match(/^```+/)) {
        stream.skipToEnd();
        state.codeBlock = true;
        return null;
      }
      // If this block is changed, it may need to be updated in Markdown mode
      if (stream.peek() === '`') {
        stream.next();
        var before = stream.pos;
        stream.eatWhile('`');
        var difference = 1 + stream.pos - before;
        if (!state.code) {
          codeDepth = difference;
          state.code = true;
        } else {
          if (difference === codeDepth) { // Must be exact
            state.code = false;
          }
        }
        return null;
      } else if (state.code) {
        stream.next();
        return null;
      }
      // Check if space. If so, links can be formatted later on
      if (stream.eatSpace()) {
        state.ateSpace = true;
        return null;
      }
      if (stream.sol() || state.ateSpace) {
        state.ateSpace = false;
        if (modeConfig.gitHubSpice !== false) {
          if(stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+@)?(?=.{0,6}\d)(?:[a-f0-9]{7,40}\b)/)) {
            // User/Project@SHA
            // User@SHA
            // SHA
            state.combineTokens = true;
            return "link";
          } else if (stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+)?#[0-9]+\b/)) {
            // User/Project#Num
            // User#Num
            // #Num
            state.combineTokens = true;
            return "link";
          }
        }
      }
      if (stream.match(urlRE) &&
          stream.string.slice(stream.start - 2, stream.start) != "](" &&
          (stream.start == 0 || /\W/.test(stream.string.charAt(stream.start - 1)))) {
        // URLs
        // Taken from http://daringfireball.net/2010/07/improved_regex_for_matching_urls
        // And then (issue #1160) simplified to make it not crash the Chrome Regexp engine
        // And then limited url schemes to the CommonMark list, so foo:bar isn't matched as a URL
        state.combineTokens = true;
        return "link";
      }
      stream.next();
      return null;
    },
    blankLine: blankLine
  };

  var markdownConfig = {
    taskLists: true,
    strikethrough: true,
    emoji: true
  };
  for (var attr in modeConfig) {
    markdownConfig[attr] = modeConfig[attr];
  }
  markdownConfig.name = "markdown";
  return CodeMirror.overlayMode(CodeMirror.getMode(config, markdownConfig), gfmOverlay);

}, "markdown");

  CodeMirror.defineMIME("text/x-gfm", "gfm");
});


/***/ }),

/***/ "./node_modules/codemirror/mode/markdown/markdown.js":
/*!***********************************************************!*\
  !*** ./node_modules/codemirror/mode/markdown/markdown.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/5/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"), __webpack_require__(/*! ../xml/xml */ "./node_modules/codemirror/mode/xml/xml.js"), __webpack_require__(/*! ../meta */ "./node_modules/codemirror/mode/meta.js"));
  else // removed by dead control flow
{}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("markdown", function(cmCfg, modeCfg) {

  var htmlMode = CodeMirror.getMode(cmCfg, "text/html");
  var htmlModeMissing = htmlMode.name == "null"

  function getMode(name) {
    if (CodeMirror.findModeByName) {
      var found = CodeMirror.findModeByName(name);
      if (found) name = found.mime || found.mimes[0];
    }
    var mode = CodeMirror.getMode(cmCfg, name);
    return mode.name == "null" ? null : mode;
  }

  // Should characters that affect highlighting be highlighted separate?
  // Does not include characters that will be output (such as `1.` and `-` for lists)
  if (modeCfg.highlightFormatting === undefined)
    modeCfg.highlightFormatting = false;

  // Maximum number of nested blockquotes. Set to 0 for infinite nesting.
  // Excess `>` will emit `error` token.
  if (modeCfg.maxBlockquoteDepth === undefined)
    modeCfg.maxBlockquoteDepth = 0;

  // Turn on task lists? ("- [ ] " and "- [x] ")
  if (modeCfg.taskLists === undefined) modeCfg.taskLists = false;

  // Turn on strikethrough syntax
  if (modeCfg.strikethrough === undefined)
    modeCfg.strikethrough = false;

  if (modeCfg.emoji === undefined)
    modeCfg.emoji = false;

  if (modeCfg.fencedCodeBlockHighlighting === undefined)
    modeCfg.fencedCodeBlockHighlighting = true;

  if (modeCfg.fencedCodeBlockDefaultMode === undefined)
    modeCfg.fencedCodeBlockDefaultMode = 'text/plain';

  if (modeCfg.xml === undefined)
    modeCfg.xml = true;

  // Allow token types to be overridden by user-provided token types.
  if (modeCfg.tokenTypeOverrides === undefined)
    modeCfg.tokenTypeOverrides = {};

  var tokenTypes = {
    header: "header",
    code: "comment",
    quote: "quote",
    list1: "variable-2",
    list2: "variable-3",
    list3: "keyword",
    hr: "hr",
    image: "image",
    imageAltText: "image-alt-text",
    imageMarker: "image-marker",
    formatting: "formatting",
    linkInline: "link",
    linkEmail: "link",
    linkText: "link",
    linkHref: "string",
    em: "em",
    strong: "strong",
    strikethrough: "strikethrough",
    emoji: "builtin"
  };

  for (var tokenType in tokenTypes) {
    if (tokenTypes.hasOwnProperty(tokenType) && modeCfg.tokenTypeOverrides[tokenType]) {
      tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType];
    }
  }

  var hrRE = /^([*\-_])(?:\s*\1){2,}\s*$/
  ,   listRE = /^(?:[*\-+]|^[0-9]+([.)]))\s+/
  ,   taskListRE = /^\[(x| )\](?=\s)/i // Must follow listRE
  ,   atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/
  ,   setextHeaderRE = /^ {0,3}(?:\={1,}|-{2,})\s*$/
  ,   textRE = /^[^#!\[\]*_\\<>` "'(~:]+/
  ,   fencedCodeRE = /^(~~~+|```+)[ \t]*([\w\/+#-]*)[^\n`]*$/
  ,   linkDefRE = /^\s*\[[^\]]+?\]:.*$/ // naive link-definition
  ,   punctuation = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/
  ,   expandedTab = "    " // CommonMark specifies tab as 4 spaces

  function switchInline(stream, state, f) {
    state.f = state.inline = f;
    return f(stream, state);
  }

  function switchBlock(stream, state, f) {
    state.f = state.block = f;
    return f(stream, state);
  }

  function lineIsEmpty(line) {
    return !line || !/\S/.test(line.string)
  }

  // Blocks

  function blankLine(state) {
    // Reset linkTitle state
    state.linkTitle = false;
    state.linkHref = false;
    state.linkText = false;
    // Reset EM state
    state.em = false;
    // Reset STRONG state
    state.strong = false;
    // Reset strikethrough state
    state.strikethrough = false;
    // Reset state.quote
    state.quote = 0;
    // Reset state.indentedCode
    state.indentedCode = false;
    if (state.f == htmlBlock) {
      var exit = htmlModeMissing
      if (!exit) {
        var inner = CodeMirror.innerMode(htmlMode, state.htmlState)
        exit = inner.mode.name == "xml" && inner.state.tagStart === null &&
          (!inner.state.context && inner.state.tokenize.isInText)
      }
      if (exit) {
        state.f = inlineNormal;
        state.block = blockNormal;
        state.htmlState = null;
      }
    }
    // Reset state.trailingSpace
    state.trailingSpace = 0;
    state.trailingSpaceNewLine = false;
    // Mark this line as blank
    state.prevLine = state.thisLine
    state.thisLine = {stream: null}
    return null;
  }

  function blockNormal(stream, state) {
    var firstTokenOnLine = stream.column() === state.indentation;
    var prevLineLineIsEmpty = lineIsEmpty(state.prevLine.stream);
    var prevLineIsIndentedCode = state.indentedCode;
    var prevLineIsHr = state.prevLine.hr;
    var prevLineIsList = state.list !== false;
    var maxNonCodeIndentation = (state.listStack[state.listStack.length - 1] || 0) + 3;

    state.indentedCode = false;

    var lineIndentation = state.indentation;
    // compute once per line (on first token)
    if (state.indentationDiff === null) {
      state.indentationDiff = state.indentation;
      if (prevLineIsList) {
        state.list = null;
        // While this list item's marker's indentation is less than the deepest
        //  list item's content's indentation,pop the deepest list item
        //  indentation off the stack, and update block indentation state
        while (lineIndentation < state.listStack[state.listStack.length - 1]) {
          state.listStack.pop();
          if (state.listStack.length) {
            state.indentation = state.listStack[state.listStack.length - 1];
          // less than the first list's indent -> the line is no longer a list
          } else {
            state.list = false;
          }
        }
        if (state.list !== false) {
          state.indentationDiff = lineIndentation - state.listStack[state.listStack.length - 1]
        }
      }
    }

    // not comprehensive (currently only for setext detection purposes)
    var allowsInlineContinuation = (
        !prevLineLineIsEmpty && !prevLineIsHr && !state.prevLine.header &&
        (!prevLineIsList || !prevLineIsIndentedCode) &&
        !state.prevLine.fencedCodeEnd
    );

    var isHr = (state.list === false || prevLineIsHr || prevLineLineIsEmpty) &&
      state.indentation <= maxNonCodeIndentation && stream.match(hrRE);

    var match = null;
    if (state.indentationDiff >= 4 && (prevLineIsIndentedCode || state.prevLine.fencedCodeEnd ||
         state.prevLine.header || prevLineLineIsEmpty)) {
      stream.skipToEnd();
      state.indentedCode = true;
      return tokenTypes.code;
    } else if (stream.eatSpace()) {
      return null;
    } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(atxHeaderRE)) && match[1].length <= 6) {
      state.quote = 0;
      state.header = match[1].length;
      state.thisLine.header = true;
      if (modeCfg.highlightFormatting) state.formatting = "header";
      state.f = state.inline;
      return getType(state);
    } else if (state.indentation <= maxNonCodeIndentation && stream.eat('>')) {
      state.quote = firstTokenOnLine ? 1 : state.quote + 1;
      if (modeCfg.highlightFormatting) state.formatting = "quote";
      stream.eatSpace();
      return getType(state);
    } else if (!isHr && !state.setext && firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(listRE))) {
      var listType = match[1] ? "ol" : "ul";

      state.indentation = lineIndentation + stream.current().length;
      state.list = true;
      state.quote = 0;

      // Add this list item's content's indentation to the stack
      state.listStack.push(state.indentation);
      // Reset inline styles which shouldn't propagate across list items
      state.em = false;
      state.strong = false;
      state.code = false;
      state.strikethrough = false;

      if (modeCfg.taskLists && stream.match(taskListRE, false)) {
        state.taskList = true;
      }
      state.f = state.inline;
      if (modeCfg.highlightFormatting) state.formatting = ["list", "list-" + listType];
      return getType(state);
    } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(fencedCodeRE, true))) {
      state.quote = 0;
      state.fencedEndRE = new RegExp(match[1] + "+ *$");
      // try switching mode
      state.localMode = modeCfg.fencedCodeBlockHighlighting && getMode(match[2] || modeCfg.fencedCodeBlockDefaultMode );
      if (state.localMode) state.localState = CodeMirror.startState(state.localMode);
      state.f = state.block = local;
      if (modeCfg.highlightFormatting) state.formatting = "code-block";
      state.code = -1
      return getType(state);
    // SETEXT has lowest block-scope precedence after HR, so check it after
    //  the others (code, blockquote, list...)
    } else if (
      // if setext set, indicates line after ---/===
      state.setext || (
        // line before ---/===
        (!allowsInlineContinuation || !prevLineIsList) && !state.quote && state.list === false &&
        !state.code && !isHr && !linkDefRE.test(stream.string) &&
        (match = stream.lookAhead(1)) && (match = match.match(setextHeaderRE))
      )
    ) {
      if ( !state.setext ) {
        state.header = match[0].charAt(0) == '=' ? 1 : 2;
        state.setext = state.header;
      } else {
        state.header = state.setext;
        // has no effect on type so we can reset it now
        state.setext = 0;
        stream.skipToEnd();
        if (modeCfg.highlightFormatting) state.formatting = "header";
      }
      state.thisLine.header = true;
      state.f = state.inline;
      return getType(state);
    } else if (isHr) {
      stream.skipToEnd();
      state.hr = true;
      state.thisLine.hr = true;
      return tokenTypes.hr;
    } else if (stream.peek() === '[') {
      return switchInline(stream, state, footnoteLink);
    }

    return switchInline(stream, state, state.inline);
  }

  function htmlBlock(stream, state) {
    var style = htmlMode.token(stream, state.htmlState);
    if (!htmlModeMissing) {
      var inner = CodeMirror.innerMode(htmlMode, state.htmlState)
      if ((inner.mode.name == "xml" && inner.state.tagStart === null &&
           (!inner.state.context && inner.state.tokenize.isInText)) ||
          (state.md_inside && stream.current().indexOf(">") > -1)) {
        state.f = inlineNormal;
        state.block = blockNormal;
        state.htmlState = null;
      }
    }
    return style;
  }

  function local(stream, state) {
    var currListInd = state.listStack[state.listStack.length - 1] || 0;
    var hasExitedList = state.indentation < currListInd;
    var maxFencedEndInd = currListInd + 3;
    if (state.fencedEndRE && state.indentation <= maxFencedEndInd && (hasExitedList || stream.match(state.fencedEndRE))) {
      if (modeCfg.highlightFormatting) state.formatting = "code-block";
      var returnType;
      if (!hasExitedList) returnType = getType(state)
      state.localMode = state.localState = null;
      state.block = blockNormal;
      state.f = inlineNormal;
      state.fencedEndRE = null;
      state.code = 0
      state.thisLine.fencedCodeEnd = true;
      if (hasExitedList) return switchBlock(stream, state, state.block);
      return returnType;
    } else if (state.localMode) {
      return state.localMode.token(stream, state.localState);
    } else {
      stream.skipToEnd();
      return tokenTypes.code;
    }
  }

  // Inline
  function getType(state) {
    var styles = [];

    if (state.formatting) {
      styles.push(tokenTypes.formatting);

      if (typeof state.formatting === "string") state.formatting = [state.formatting];

      for (var i = 0; i < state.formatting.length; i++) {
        styles.push(tokenTypes.formatting + "-" + state.formatting[i]);

        if (state.formatting[i] === "header") {
          styles.push(tokenTypes.formatting + "-" + state.formatting[i] + "-" + state.header);
        }

        // Add `formatting-quote` and `formatting-quote-#` for blockquotes
        // Add `error` instead if the maximum blockquote nesting depth is passed
        if (state.formatting[i] === "quote") {
          if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
            styles.push(tokenTypes.formatting + "-" + state.formatting[i] + "-" + state.quote);
          } else {
            styles.push("error");
          }
        }
      }
    }

    if (state.taskOpen) {
      styles.push("meta");
      return styles.length ? styles.join(' ') : null;
    }
    if (state.taskClosed) {
      styles.push("property");
      return styles.length ? styles.join(' ') : null;
    }

    if (state.linkHref) {
      styles.push(tokenTypes.linkHref, "url");
    } else { // Only apply inline styles to non-url text
      if (state.strong) { styles.push(tokenTypes.strong); }
      if (state.em) { styles.push(tokenTypes.em); }
      if (state.strikethrough) { styles.push(tokenTypes.strikethrough); }
      if (state.emoji) { styles.push(tokenTypes.emoji); }
      if (state.linkText) { styles.push(tokenTypes.linkText); }
      if (state.code) { styles.push(tokenTypes.code); }
      if (state.image) { styles.push(tokenTypes.image); }
      if (state.imageAltText) { styles.push(tokenTypes.imageAltText, "link"); }
      if (state.imageMarker) { styles.push(tokenTypes.imageMarker); }
    }

    if (state.header) { styles.push(tokenTypes.header, tokenTypes.header + "-" + state.header); }

    if (state.quote) {
      styles.push(tokenTypes.quote);

      // Add `quote-#` where the maximum for `#` is modeCfg.maxBlockquoteDepth
      if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
        styles.push(tokenTypes.quote + "-" + state.quote);
      } else {
        styles.push(tokenTypes.quote + "-" + modeCfg.maxBlockquoteDepth);
      }
    }

    if (state.list !== false) {
      var listMod = (state.listStack.length - 1) % 3;
      if (!listMod) {
        styles.push(tokenTypes.list1);
      } else if (listMod === 1) {
        styles.push(tokenTypes.list2);
      } else {
        styles.push(tokenTypes.list3);
      }
    }

    if (state.trailingSpaceNewLine) {
      styles.push("trailing-space-new-line");
    } else if (state.trailingSpace) {
      styles.push("trailing-space-" + (state.trailingSpace % 2 ? "a" : "b"));
    }

    return styles.length ? styles.join(' ') : null;
  }

  function handleText(stream, state) {
    if (stream.match(textRE, true)) {
      return getType(state);
    }
    return undefined;
  }

  function inlineNormal(stream, state) {
    var style = state.text(stream, state);
    if (typeof style !== 'undefined')
      return style;

    if (state.list) { // List marker (*, +, -, 1., etc)
      state.list = null;
      return getType(state);
    }

    if (state.taskList) {
      var taskOpen = stream.match(taskListRE, true)[1] === " ";
      if (taskOpen) state.taskOpen = true;
      else state.taskClosed = true;
      if (modeCfg.highlightFormatting) state.formatting = "task";
      state.taskList = false;
      return getType(state);
    }

    state.taskOpen = false;
    state.taskClosed = false;

    if (state.header && stream.match(/^#+$/, true)) {
      if (modeCfg.highlightFormatting) state.formatting = "header";
      return getType(state);
    }

    var ch = stream.next();

    // Matches link titles present on next line
    if (state.linkTitle) {
      state.linkTitle = false;
      var matchCh = ch;
      if (ch === '(') {
        matchCh = ')';
      }
      matchCh = (matchCh+'').replace(/([.?*+^\[\]\\(){}|-])/g, "\\$1");
      var regex = '^\\s*(?:[^' + matchCh + '\\\\]+|\\\\\\\\|\\\\.)' + matchCh;
      if (stream.match(new RegExp(regex), true)) {
        return tokenTypes.linkHref;
      }
    }

    // If this block is changed, it may need to be updated in GFM mode
    if (ch === '`') {
      var previousFormatting = state.formatting;
      if (modeCfg.highlightFormatting) state.formatting = "code";
      stream.eatWhile('`');
      var count = stream.current().length
      if (state.code == 0 && (!state.quote || count == 1)) {
        state.code = count
        return getType(state)
      } else if (count == state.code) { // Must be exact
        var t = getType(state)
        state.code = 0
        return t
      } else {
        state.formatting = previousFormatting
        return getType(state)
      }
    } else if (state.code) {
      return getType(state);
    }

    if (ch === '\\') {
      stream.next();
      if (modeCfg.highlightFormatting) {
        var type = getType(state);
        var formattingEscape = tokenTypes.formatting + "-escape";
        return type ? type + " " + formattingEscape : formattingEscape;
      }
    }

    if (ch === '!' && stream.match(/\[[^\]]*\] ?(?:\(|\[)/, false)) {
      state.imageMarker = true;
      state.image = true;
      if (modeCfg.highlightFormatting) state.formatting = "image";
      return getType(state);
    }

    if (ch === '[' && state.imageMarker && stream.match(/[^\]]*\](\(.*?\)| ?\[.*?\])/, false)) {
      state.imageMarker = false;
      state.imageAltText = true
      if (modeCfg.highlightFormatting) state.formatting = "image";
      return getType(state);
    }

    if (ch === ']' && state.imageAltText) {
      if (modeCfg.highlightFormatting) state.formatting = "image";
      var type = getType(state);
      state.imageAltText = false;
      state.image = false;
      state.inline = state.f = linkHref;
      return type;
    }

    if (ch === '[' && !state.image) {
      if (state.linkText && stream.match(/^.*?\]/)) return getType(state)
      state.linkText = true;
      if (modeCfg.highlightFormatting) state.formatting = "link";
      return getType(state);
    }

    if (ch === ']' && state.linkText) {
      if (modeCfg.highlightFormatting) state.formatting = "link";
      var type = getType(state);
      state.linkText = false;
      state.inline = state.f = stream.match(/\(.*?\)| ?\[.*?\]/, false) ? linkHref : inlineNormal
      return type;
    }

    if (ch === '<' && stream.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, false)) {
      state.f = state.inline = linkInline;
      if (modeCfg.highlightFormatting) state.formatting = "link";
      var type = getType(state);
      if (type){
        type += " ";
      } else {
        type = "";
      }
      return type + tokenTypes.linkInline;
    }

    if (ch === '<' && stream.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, false)) {
      state.f = state.inline = linkInline;
      if (modeCfg.highlightFormatting) state.formatting = "link";
      var type = getType(state);
      if (type){
        type += " ";
      } else {
        type = "";
      }
      return type + tokenTypes.linkEmail;
    }

    if (modeCfg.xml && ch === '<' && stream.match(/^(!--|\?|!\[CDATA\[|[a-z][a-z0-9-]*(?:\s+[a-z_:.\-]+(?:\s*=\s*[^>]+)?)*\s*(?:>|$))/i, false)) {
      var end = stream.string.indexOf(">", stream.pos);
      if (end != -1) {
        var atts = stream.string.substring(stream.start, end);
        if (/markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(atts)) state.md_inside = true;
      }
      stream.backUp(1);
      state.htmlState = CodeMirror.startState(htmlMode);
      return switchBlock(stream, state, htmlBlock);
    }

    if (modeCfg.xml && ch === '<' && stream.match(/^\/\w*?>/)) {
      state.md_inside = false;
      return "tag";
    } else if (ch === "*" || ch === "_") {
      var len = 1, before = stream.pos == 1 ? " " : stream.string.charAt(stream.pos - 2)
      while (len < 3 && stream.eat(ch)) len++
      var after = stream.peek() || " "
      // See http://spec.commonmark.org/0.27/#emphasis-and-strong-emphasis
      var leftFlanking = !/\s/.test(after) && (!punctuation.test(after) || /\s/.test(before) || punctuation.test(before))
      var rightFlanking = !/\s/.test(before) && (!punctuation.test(before) || /\s/.test(after) || punctuation.test(after))
      var setEm = null, setStrong = null
      if (len % 2) { // Em
        if (!state.em && leftFlanking && (ch === "*" || !rightFlanking || punctuation.test(before)))
          setEm = true
        else if (state.em == ch && rightFlanking && (ch === "*" || !leftFlanking || punctuation.test(after)))
          setEm = false
      }
      if (len > 1) { // Strong
        if (!state.strong && leftFlanking && (ch === "*" || !rightFlanking || punctuation.test(before)))
          setStrong = true
        else if (state.strong == ch && rightFlanking && (ch === "*" || !leftFlanking || punctuation.test(after)))
          setStrong = false
      }
      if (setStrong != null || setEm != null) {
        if (modeCfg.highlightFormatting) state.formatting = setEm == null ? "strong" : setStrong == null ? "em" : "strong em"
        if (setEm === true) state.em = ch
        if (setStrong === true) state.strong = ch
        var t = getType(state)
        if (setEm === false) state.em = false
        if (setStrong === false) state.strong = false
        return t
      }
    } else if (ch === ' ') {
      if (stream.eat('*') || stream.eat('_')) { // Probably surrounded by spaces
        if (stream.peek() === ' ') { // Surrounded by spaces, ignore
          return getType(state);
        } else { // Not surrounded by spaces, back up pointer
          stream.backUp(1);
        }
      }
    }

    if (modeCfg.strikethrough) {
      if (ch === '~' && stream.eatWhile(ch)) {
        if (state.strikethrough) {// Remove strikethrough
          if (modeCfg.highlightFormatting) state.formatting = "strikethrough";
          var t = getType(state);
          state.strikethrough = false;
          return t;
        } else if (stream.match(/^[^\s]/, false)) {// Add strikethrough
          state.strikethrough = true;
          if (modeCfg.highlightFormatting) state.formatting = "strikethrough";
          return getType(state);
        }
      } else if (ch === ' ') {
        if (stream.match('~~', true)) { // Probably surrounded by space
          if (stream.peek() === ' ') { // Surrounded by spaces, ignore
            return getType(state);
          } else { // Not surrounded by spaces, back up pointer
            stream.backUp(2);
          }
        }
      }
    }

    if (modeCfg.emoji && ch === ":" && stream.match(/^(?:[a-z_\d+][a-z_\d+-]*|\-[a-z_\d+][a-z_\d+-]*):/)) {
      state.emoji = true;
      if (modeCfg.highlightFormatting) state.formatting = "emoji";
      var retType = getType(state);
      state.emoji = false;
      return retType;
    }

    if (ch === ' ') {
      if (stream.match(/^ +$/, false)) {
        state.trailingSpace++;
      } else if (state.trailingSpace) {
        state.trailingSpaceNewLine = true;
      }
    }

    return getType(state);
  }

  function linkInline(stream, state) {
    var ch = stream.next();

    if (ch === ">") {
      state.f = state.inline = inlineNormal;
      if (modeCfg.highlightFormatting) state.formatting = "link";
      var type = getType(state);
      if (type){
        type += " ";
      } else {
        type = "";
      }
      return type + tokenTypes.linkInline;
    }

    stream.match(/^[^>]+/, true);

    return tokenTypes.linkInline;
  }

  function linkHref(stream, state) {
    // Check if space, and return NULL if so (to avoid marking the space)
    if(stream.eatSpace()){
      return null;
    }
    var ch = stream.next();
    if (ch === '(' || ch === '[') {
      state.f = state.inline = getLinkHrefInside(ch === "(" ? ")" : "]");
      if (modeCfg.highlightFormatting) state.formatting = "link-string";
      state.linkHref = true;
      return getType(state);
    }
    return 'error';
  }

  var linkRE = {
    ")": /^(?:[^\\\(\)]|\\.|\((?:[^\\\(\)]|\\.)*\))*?(?=\))/,
    "]": /^(?:[^\\\[\]]|\\.|\[(?:[^\\\[\]]|\\.)*\])*?(?=\])/
  }

  function getLinkHrefInside(endChar) {
    return function(stream, state) {
      var ch = stream.next();

      if (ch === endChar) {
        state.f = state.inline = inlineNormal;
        if (modeCfg.highlightFormatting) state.formatting = "link-string";
        var returnState = getType(state);
        state.linkHref = false;
        return returnState;
      }

      stream.match(linkRE[endChar])
      state.linkHref = true;
      return getType(state);
    };
  }

  function footnoteLink(stream, state) {
    if (stream.match(/^([^\]\\]|\\.)*\]:/, false)) {
      state.f = footnoteLinkInside;
      stream.next(); // Consume [
      if (modeCfg.highlightFormatting) state.formatting = "link";
      state.linkText = true;
      return getType(state);
    }
    return switchInline(stream, state, inlineNormal);
  }

  function footnoteLinkInside(stream, state) {
    if (stream.match(']:', true)) {
      state.f = state.inline = footnoteUrl;
      if (modeCfg.highlightFormatting) state.formatting = "link";
      var returnType = getType(state);
      state.linkText = false;
      return returnType;
    }

    stream.match(/^([^\]\\]|\\.)+/, true);

    return tokenTypes.linkText;
  }

  function footnoteUrl(stream, state) {
    // Check if space, and return NULL if so (to avoid marking the space)
    if(stream.eatSpace()){
      return null;
    }
    // Match URL
    stream.match(/^[^\s]+/, true);
    // Check for link title
    if (stream.peek() === undefined) { // End of line, set flag to check next line
      state.linkTitle = true;
    } else { // More content on line, check if link title
      stream.match(/^(?:\s+(?:"(?:[^"\\]|\\.)+"|'(?:[^'\\]|\\.)+'|\((?:[^)\\]|\\.)+\)))?/, true);
    }
    state.f = state.inline = inlineNormal;
    return tokenTypes.linkHref + " url";
  }

  var mode = {
    startState: function() {
      return {
        f: blockNormal,

        prevLine: {stream: null},
        thisLine: {stream: null},

        block: blockNormal,
        htmlState: null,
        indentation: 0,

        inline: inlineNormal,
        text: handleText,

        formatting: false,
        linkText: false,
        linkHref: false,
        linkTitle: false,
        code: 0,
        em: false,
        strong: false,
        header: 0,
        setext: 0,
        hr: false,
        taskList: false,
        list: false,
        listStack: [],
        quote: 0,
        trailingSpace: 0,
        trailingSpaceNewLine: false,
        strikethrough: false,
        emoji: false,
        fencedEndRE: null
      };
    },

    copyState: function(s) {
      return {
        f: s.f,

        prevLine: s.prevLine,
        thisLine: s.thisLine,

        block: s.block,
        htmlState: s.htmlState && CodeMirror.copyState(htmlMode, s.htmlState),
        indentation: s.indentation,

        localMode: s.localMode,
        localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,

        inline: s.inline,
        text: s.text,
        formatting: false,
        linkText: s.linkText,
        linkTitle: s.linkTitle,
        linkHref: s.linkHref,
        code: s.code,
        em: s.em,
        strong: s.strong,
        strikethrough: s.strikethrough,
        emoji: s.emoji,
        header: s.header,
        setext: s.setext,
        hr: s.hr,
        taskList: s.taskList,
        list: s.list,
        listStack: s.listStack.slice(0),
        quote: s.quote,
        indentedCode: s.indentedCode,
        trailingSpace: s.trailingSpace,
        trailingSpaceNewLine: s.trailingSpaceNewLine,
        md_inside: s.md_inside,
        fencedEndRE: s.fencedEndRE
      };
    },

    token: function(stream, state) {

      // Reset state.formatting
      state.formatting = false;

      if (stream != state.thisLine.stream) {
        state.header = 0;
        state.hr = false;

        if (stream.match(/^\s*$/, true)) {
          blankLine(state);
          return null;
        }

        state.prevLine = state.thisLine
        state.thisLine = {stream: stream}

        // Reset state.taskList
        state.taskList = false;

        // Reset state.trailingSpace
        state.trailingSpace = 0;
        state.trailingSpaceNewLine = false;

        if (!state.localState) {
          state.f = state.block;
          if (state.f != htmlBlock) {
            var indentation = stream.match(/^\s*/, true)[0].replace(/\t/g, expandedTab).length;
            state.indentation = indentation;
            state.indentationDiff = null;
            if (indentation > 0) return null;
          }
        }
      }
      return state.f(stream, state);
    },

    innerMode: function(state) {
      if (state.block == htmlBlock) return {state: state.htmlState, mode: htmlMode};
      if (state.localState) return {state: state.localState, mode: state.localMode};
      return {state: state, mode: mode};
    },

    indent: function(state, textAfter, line) {
      if (state.block == htmlBlock && htmlMode.indent) return htmlMode.indent(state.htmlState, textAfter, line)
      if (state.localState && state.localMode.indent) return state.localMode.indent(state.localState, textAfter, line)
      return CodeMirror.Pass
    },

    blankLine: blankLine,

    getType: getType,

    blockCommentStart: "<!--",
    blockCommentEnd: "-->",
    closeBrackets: "()[]{}''\"\"``",
    fold: "markdown"
  };
  return mode;
}, "xml");

CodeMirror.defineMIME("text/markdown", "markdown");

CodeMirror.defineMIME("text/x-markdown", "markdown");

});


/***/ }),

/***/ "./node_modules/codemirror/mode/meta.js":
/*!**********************************************!*\
  !*** ./node_modules/codemirror/mode/meta.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/5/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__(/*! ../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));
  else // removed by dead control flow
{}
})(function(CodeMirror) {
  "use strict";

  CodeMirror.modeInfo = [
    {name: "APL", mime: "text/apl", mode: "apl", ext: ["dyalog", "apl"]},
    {name: "PGP", mimes: ["application/pgp", "application/pgp-encrypted", "application/pgp-keys", "application/pgp-signature"], mode: "asciiarmor", ext: ["asc", "pgp", "sig"]},
    {name: "ASN.1", mime: "text/x-ttcn-asn", mode: "asn.1", ext: ["asn", "asn1"]},
    {name: "Asterisk", mime: "text/x-asterisk", mode: "asterisk", file: /^extensions\.conf$/i},
    {name: "Brainfuck", mime: "text/x-brainfuck", mode: "brainfuck", ext: ["b", "bf"]},
    {name: "C", mime: "text/x-csrc", mode: "clike", ext: ["c", "h", "ino"]},
    {name: "C++", mime: "text/x-c++src", mode: "clike", ext: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"], alias: ["cpp"]},
    {name: "Cobol", mime: "text/x-cobol", mode: "cobol", ext: ["cob", "cpy", "cbl"]},
    {name: "C#", mime: "text/x-csharp", mode: "clike", ext: ["cs"], alias: ["csharp", "cs"]},
    {name: "Clojure", mime: "text/x-clojure", mode: "clojure", ext: ["clj", "cljc", "cljx"]},
    {name: "ClojureScript", mime: "text/x-clojurescript", mode: "clojure", ext: ["cljs"]},
    {name: "Closure Stylesheets (GSS)", mime: "text/x-gss", mode: "css", ext: ["gss"]},
    {name: "CMake", mime: "text/x-cmake", mode: "cmake", ext: ["cmake", "cmake.in"], file: /^CMakeLists\.txt$/},
    {name: "CoffeeScript", mimes: ["application/vnd.coffeescript", "text/coffeescript", "text/x-coffeescript"], mode: "coffeescript", ext: ["coffee"], alias: ["coffee", "coffee-script"]},
    {name: "Common Lisp", mime: "text/x-common-lisp", mode: "commonlisp", ext: ["cl", "lisp", "el"], alias: ["lisp"]},
    {name: "Cypher", mime: "application/x-cypher-query", mode: "cypher", ext: ["cyp", "cypher"]},
    {name: "Cython", mime: "text/x-cython", mode: "python", ext: ["pyx", "pxd", "pxi"]},
    {name: "Crystal", mime: "text/x-crystal", mode: "crystal", ext: ["cr"]},
    {name: "CSS", mime: "text/css", mode: "css", ext: ["css"]},
    {name: "CQL", mime: "text/x-cassandra", mode: "sql", ext: ["cql"]},
    {name: "D", mime: "text/x-d", mode: "d", ext: ["d"]},
    {name: "Dart", mimes: ["application/dart", "text/x-dart"], mode: "dart", ext: ["dart"]},
    {name: "diff", mime: "text/x-diff", mode: "diff", ext: ["diff", "patch"]},
    {name: "Django", mime: "text/x-django", mode: "django"},
    {name: "Dockerfile", mime: "text/x-dockerfile", mode: "dockerfile", file: /^Dockerfile$/},
    {name: "DTD", mime: "application/xml-dtd", mode: "dtd", ext: ["dtd"]},
    {name: "Dylan", mime: "text/x-dylan", mode: "dylan", ext: ["dylan", "dyl", "intr"]},
    {name: "EBNF", mime: "text/x-ebnf", mode: "ebnf"},
    {name: "ECL", mime: "text/x-ecl", mode: "ecl", ext: ["ecl"]},
    {name: "edn", mime: "application/edn", mode: "clojure", ext: ["edn"]},
    {name: "Eiffel", mime: "text/x-eiffel", mode: "eiffel", ext: ["e"]},
    {name: "Elm", mime: "text/x-elm", mode: "elm", ext: ["elm"]},
    {name: "Embedded JavaScript", mime: "application/x-ejs", mode: "htmlembedded", ext: ["ejs"]},
    {name: "Embedded Ruby", mime: "application/x-erb", mode: "htmlembedded", ext: ["erb"]},
    {name: "Erlang", mime: "text/x-erlang", mode: "erlang", ext: ["erl"]},
    {name: "Esper", mime: "text/x-esper", mode: "sql"},
    {name: "Factor", mime: "text/x-factor", mode: "factor", ext: ["factor"]},
    {name: "FCL", mime: "text/x-fcl", mode: "fcl"},
    {name: "Forth", mime: "text/x-forth", mode: "forth", ext: ["forth", "fth", "4th"]},
    {name: "Fortran", mime: "text/x-fortran", mode: "fortran", ext: ["f", "for", "f77", "f90", "f95"]},
    {name: "F#", mime: "text/x-fsharp", mode: "mllike", ext: ["fs"], alias: ["fsharp"]},
    {name: "Gas", mime: "text/x-gas", mode: "gas", ext: ["s"]},
    {name: "Gherkin", mime: "text/x-feature", mode: "gherkin", ext: ["feature"]},
    {name: "GitHub Flavored Markdown", mime: "text/x-gfm", mode: "gfm", file: /^(readme|contributing|history)\.md$/i},
    {name: "Go", mime: "text/x-go", mode: "go", ext: ["go"]},
    {name: "Groovy", mime: "text/x-groovy", mode: "groovy", ext: ["groovy", "gradle"], file: /^Jenkinsfile$/},
    {name: "HAML", mime: "text/x-haml", mode: "haml", ext: ["haml"]},
    {name: "Haskell", mime: "text/x-haskell", mode: "haskell", ext: ["hs"]},
    {name: "Haskell (Literate)", mime: "text/x-literate-haskell", mode: "haskell-literate", ext: ["lhs"]},
    {name: "Haxe", mime: "text/x-haxe", mode: "haxe", ext: ["hx"]},
    {name: "HXML", mime: "text/x-hxml", mode: "haxe", ext: ["hxml"]},
    {name: "ASP.NET", mime: "application/x-aspx", mode: "htmlembedded", ext: ["aspx"], alias: ["asp", "aspx"]},
    {name: "HTML", mime: "text/html", mode: "htmlmixed", ext: ["html", "htm", "handlebars", "hbs"], alias: ["xhtml"]},
    {name: "HTTP", mime: "message/http", mode: "http"},
    {name: "IDL", mime: "text/x-idl", mode: "idl", ext: ["pro"]},
    {name: "Pug", mime: "text/x-pug", mode: "pug", ext: ["jade", "pug"], alias: ["jade"]},
    {name: "Java", mime: "text/x-java", mode: "clike", ext: ["java"]},
    {name: "Java Server Pages", mime: "application/x-jsp", mode: "htmlembedded", ext: ["jsp"], alias: ["jsp"]},
    {name: "JavaScript", mimes: ["text/javascript", "text/ecmascript", "application/javascript", "application/x-javascript", "application/ecmascript"],
     mode: "javascript", ext: ["js"], alias: ["ecmascript", "js", "node"]},
    {name: "JSON", mimes: ["application/json", "application/x-json"], mode: "javascript", ext: ["json", "map"], alias: ["json5"]},
    {name: "JSON-LD", mime: "application/ld+json", mode: "javascript", ext: ["jsonld"], alias: ["jsonld"]},
    {name: "JSX", mime: "text/jsx", mode: "jsx", ext: ["jsx"]},
    {name: "Jinja2", mime: "text/jinja2", mode: "jinja2", ext: ["j2", "jinja", "jinja2"]},
    {name: "Julia", mime: "text/x-julia", mode: "julia", ext: ["jl"], alias: ["jl"]},
    {name: "Kotlin", mime: "text/x-kotlin", mode: "clike", ext: ["kt"]},
    {name: "LESS", mime: "text/x-less", mode: "css", ext: ["less"]},
    {name: "LiveScript", mime: "text/x-livescript", mode: "livescript", ext: ["ls"], alias: ["ls"]},
    {name: "Lua", mime: "text/x-lua", mode: "lua", ext: ["lua"]},
    {name: "Markdown", mime: "text/x-markdown", mode: "markdown", ext: ["markdown", "md", "mkd"]},
    {name: "mIRC", mime: "text/mirc", mode: "mirc"},
    {name: "MariaDB SQL", mime: "text/x-mariadb", mode: "sql"},
    {name: "Mathematica", mime: "text/x-mathematica", mode: "mathematica", ext: ["m", "nb", "wl", "wls"]},
    {name: "Modelica", mime: "text/x-modelica", mode: "modelica", ext: ["mo"]},
    {name: "MUMPS", mime: "text/x-mumps", mode: "mumps", ext: ["mps"]},
    {name: "MS SQL", mime: "text/x-mssql", mode: "sql"},
    {name: "mbox", mime: "application/mbox", mode: "mbox", ext: ["mbox"]},
    {name: "MySQL", mime: "text/x-mysql", mode: "sql"},
    {name: "Nginx", mime: "text/x-nginx-conf", mode: "nginx", file: /nginx.*\.conf$/i},
    {name: "NSIS", mime: "text/x-nsis", mode: "nsis", ext: ["nsh", "nsi"]},
    {name: "NTriples", mimes: ["application/n-triples", "application/n-quads", "text/n-triples"],
     mode: "ntriples", ext: ["nt", "nq"]},
    {name: "Objective-C", mime: "text/x-objectivec", mode: "clike", ext: ["m"], alias: ["objective-c", "objc"]},
    {name: "Objective-C++", mime: "text/x-objectivec++", mode: "clike", ext: ["mm"], alias: ["objective-c++", "objc++"]},
    {name: "OCaml", mime: "text/x-ocaml", mode: "mllike", ext: ["ml", "mli", "mll", "mly"]},
    {name: "Octave", mime: "text/x-octave", mode: "octave", ext: ["m"]},
    {name: "Oz", mime: "text/x-oz", mode: "oz", ext: ["oz"]},
    {name: "Pascal", mime: "text/x-pascal", mode: "pascal", ext: ["p", "pas"]},
    {name: "PEG.js", mime: "null", mode: "pegjs", ext: ["jsonld"]},
    {name: "Perl", mime: "text/x-perl", mode: "perl", ext: ["pl", "pm"]},
    {name: "PHP", mimes: ["text/x-php", "application/x-httpd-php", "application/x-httpd-php-open"], mode: "php", ext: ["php", "php3", "php4", "php5", "php7", "phtml"]},
    {name: "Pig", mime: "text/x-pig", mode: "pig", ext: ["pig"]},
    {name: "Plain Text", mime: "text/plain", mode: "null", ext: ["txt", "text", "conf", "def", "list", "log"]},
    {name: "PLSQL", mime: "text/x-plsql", mode: "sql", ext: ["pls"]},
    {name: "PostgreSQL", mime: "text/x-pgsql", mode: "sql"},
    {name: "PowerShell", mime: "application/x-powershell", mode: "powershell", ext: ["ps1", "psd1", "psm1"]},
    {name: "Properties files", mime: "text/x-properties", mode: "properties", ext: ["properties", "ini", "in"], alias: ["ini", "properties"]},
    {name: "ProtoBuf", mime: "text/x-protobuf", mode: "protobuf", ext: ["proto"]},
    {name: "Python", mime: "text/x-python", mode: "python", ext: ["BUILD", "bzl", "py", "pyw"], file: /^(BUCK|BUILD)$/},
    {name: "Puppet", mime: "text/x-puppet", mode: "puppet", ext: ["pp"]},
    {name: "Q", mime: "text/x-q", mode: "q", ext: ["q"]},
    {name: "R", mime: "text/x-rsrc", mode: "r", ext: ["r", "R"], alias: ["rscript"]},
    {name: "reStructuredText", mime: "text/x-rst", mode: "rst", ext: ["rst"], alias: ["rst"]},
    {name: "RPM Changes", mime: "text/x-rpm-changes", mode: "rpm"},
    {name: "RPM Spec", mime: "text/x-rpm-spec", mode: "rpm", ext: ["spec"]},
    {name: "Ruby", mime: "text/x-ruby", mode: "ruby", ext: ["rb"], alias: ["jruby", "macruby", "rake", "rb", "rbx"]},
    {name: "Rust", mime: "text/x-rustsrc", mode: "rust", ext: ["rs"]},
    {name: "SAS", mime: "text/x-sas", mode: "sas", ext: ["sas"]},
    {name: "Sass", mime: "text/x-sass", mode: "sass", ext: ["sass"]},
    {name: "Scala", mime: "text/x-scala", mode: "clike", ext: ["scala"]},
    {name: "Scheme", mime: "text/x-scheme", mode: "scheme", ext: ["scm", "ss"]},
    {name: "SCSS", mime: "text/x-scss", mode: "css", ext: ["scss"]},
    {name: "Shell", mimes: ["text/x-sh", "application/x-sh"], mode: "shell", ext: ["sh", "ksh", "bash"], alias: ["bash", "sh", "zsh"], file: /^PKGBUILD$/},
    {name: "Sieve", mime: "application/sieve", mode: "sieve", ext: ["siv", "sieve"]},
    {name: "Slim", mimes: ["text/x-slim", "application/x-slim"], mode: "slim", ext: ["slim"]},
    {name: "Smalltalk", mime: "text/x-stsrc", mode: "smalltalk", ext: ["st"]},
    {name: "Smarty", mime: "text/x-smarty", mode: "smarty", ext: ["tpl"]},
    {name: "Solr", mime: "text/x-solr", mode: "solr"},
    {name: "SML", mime: "text/x-sml", mode: "mllike", ext: ["sml", "sig", "fun", "smackspec"]},
    {name: "Soy", mime: "text/x-soy", mode: "soy", ext: ["soy"], alias: ["closure template"]},
    {name: "SPARQL", mime: "application/sparql-query", mode: "sparql", ext: ["rq", "sparql"], alias: ["sparul"]},
    {name: "Spreadsheet", mime: "text/x-spreadsheet", mode: "spreadsheet", alias: ["excel", "formula"]},
    {name: "SQL", mime: "text/x-sql", mode: "sql", ext: ["sql"]},
    {name: "SQLite", mime: "text/x-sqlite", mode: "sql"},
    {name: "Squirrel", mime: "text/x-squirrel", mode: "clike", ext: ["nut"]},
    {name: "Stylus", mime: "text/x-styl", mode: "stylus", ext: ["styl"]},
    {name: "Swift", mime: "text/x-swift", mode: "swift", ext: ["swift"]},
    {name: "sTeX", mime: "text/x-stex", mode: "stex"},
    {name: "LaTeX", mime: "text/x-latex", mode: "stex", ext: ["text", "ltx", "tex"], alias: ["tex"]},
    {name: "SystemVerilog", mime: "text/x-systemverilog", mode: "verilog", ext: ["v", "sv", "svh"]},
    {name: "Tcl", mime: "text/x-tcl", mode: "tcl", ext: ["tcl"]},
    {name: "Textile", mime: "text/x-textile", mode: "textile", ext: ["textile"]},
    {name: "TiddlyWiki", mime: "text/x-tiddlywiki", mode: "tiddlywiki"},
    {name: "Tiki wiki", mime: "text/tiki", mode: "tiki"},
    {name: "TOML", mime: "text/x-toml", mode: "toml", ext: ["toml"]},
    {name: "Tornado", mime: "text/x-tornado", mode: "tornado"},
    {name: "troff", mime: "text/troff", mode: "troff", ext: ["1", "2", "3", "4", "5", "6", "7", "8", "9"]},
    {name: "TTCN", mime: "text/x-ttcn", mode: "ttcn", ext: ["ttcn", "ttcn3", "ttcnpp"]},
    {name: "TTCN_CFG", mime: "text/x-ttcn-cfg", mode: "ttcn-cfg", ext: ["cfg"]},
    {name: "Turtle", mime: "text/turtle", mode: "turtle", ext: ["ttl"]},
    {name: "TypeScript", mime: "application/typescript", mode: "javascript", ext: ["ts"], alias: ["ts"]},
    {name: "TypeScript-JSX", mime: "text/typescript-jsx", mode: "jsx", ext: ["tsx"], alias: ["tsx"]},
    {name: "Twig", mime: "text/x-twig", mode: "twig"},
    {name: "Web IDL", mime: "text/x-webidl", mode: "webidl", ext: ["webidl"]},
    {name: "VB.NET", mime: "text/x-vb", mode: "vb", ext: ["vb"]},
    {name: "VBScript", mime: "text/vbscript", mode: "vbscript", ext: ["vbs"]},
    {name: "Velocity", mime: "text/velocity", mode: "velocity", ext: ["vtl"]},
    {name: "Verilog", mime: "text/x-verilog", mode: "verilog", ext: ["v"]},
    {name: "VHDL", mime: "text/x-vhdl", mode: "vhdl", ext: ["vhd", "vhdl"]},
    {name: "Vue.js Component", mimes: ["script/x-vue", "text/x-vue"], mode: "vue", ext: ["vue"]},
    {name: "XML", mimes: ["application/xml", "text/xml"], mode: "xml", ext: ["xml", "xsl", "xsd", "svg"], alias: ["rss", "wsdl", "xsd"]},
    {name: "XQuery", mime: "application/xquery", mode: "xquery", ext: ["xy", "xquery"]},
    {name: "Yacas", mime: "text/x-yacas", mode: "yacas", ext: ["ys"]},
    {name: "YAML", mimes: ["text/x-yaml", "text/yaml"], mode: "yaml", ext: ["yaml", "yml"], alias: ["yml"]},
    {name: "Z80", mime: "text/x-z80", mode: "z80", ext: ["z80"]},
    {name: "mscgen", mime: "text/x-mscgen", mode: "mscgen", ext: ["mscgen", "mscin", "msc"]},
    {name: "xu", mime: "text/x-xu", mode: "mscgen", ext: ["xu"]},
    {name: "msgenny", mime: "text/x-msgenny", mode: "mscgen", ext: ["msgenny"]},
    {name: "WebAssembly", mime: "text/webassembly", mode: "wast", ext: ["wat", "wast"]},
  ];
  // Ensure all modes have a mime property for backwards compatibility
  for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
    var info = CodeMirror.modeInfo[i];
    if (info.mimes) info.mime = info.mimes[0];
  }

  CodeMirror.findModeByMIME = function(mime) {
    mime = mime.toLowerCase();
    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
      var info = CodeMirror.modeInfo[i];
      if (info.mime == mime) return info;
      if (info.mimes) for (var j = 0; j < info.mimes.length; j++)
        if (info.mimes[j] == mime) return info;
    }
    if (/\+xml$/.test(mime)) return CodeMirror.findModeByMIME("application/xml")
    if (/\+json$/.test(mime)) return CodeMirror.findModeByMIME("application/json")
  };

  CodeMirror.findModeByExtension = function(ext) {
    ext = ext.toLowerCase();
    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
      var info = CodeMirror.modeInfo[i];
      if (info.ext) for (var j = 0; j < info.ext.length; j++)
        if (info.ext[j] == ext) return info;
    }
  };

  CodeMirror.findModeByFileName = function(filename) {
    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
      var info = CodeMirror.modeInfo[i];
      if (info.file && info.file.test(filename)) return info;
    }
    var dot = filename.lastIndexOf(".");
    var ext = dot > -1 && filename.substring(dot + 1, filename.length);
    if (ext) return CodeMirror.findModeByExtension(ext);
  };

  CodeMirror.findModeByName = function(name) {
    name = name.toLowerCase();
    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
      var info = CodeMirror.modeInfo[i];
      if (info.name.toLowerCase() == name) return info;
      if (info.alias) for (var j = 0; j < info.alias.length; j++)
        if (info.alias[j].toLowerCase() == name) return info;
    }
  };
});


/***/ }),

/***/ "./node_modules/codemirror/mode/xml/xml.js":
/*!*************************************************!*\
  !*** ./node_modules/codemirror/mode/xml/xml.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/5/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));
  else // removed by dead control flow
{}
})(function(CodeMirror) {
"use strict";

var htmlConfig = {
  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,
                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,
                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,
                    'track': true, 'wbr': true, 'menuitem': true},
  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,
                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,
                     'th': true, 'tr': true},
  contextGrabbers: {
    'dd': {'dd': true, 'dt': true},
    'dt': {'dd': true, 'dt': true},
    'li': {'li': true},
    'option': {'option': true, 'optgroup': true},
    'optgroup': {'optgroup': true},
    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,
          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,
          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,
          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,
          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},
    'rp': {'rp': true, 'rt': true},
    'rt': {'rp': true, 'rt': true},
    'tbody': {'tbody': true, 'tfoot': true},
    'td': {'td': true, 'th': true},
    'tfoot': {'tbody': true},
    'th': {'td': true, 'th': true},
    'thead': {'tbody': true, 'tfoot': true},
    'tr': {'tr': true}
  },
  doNotIndent: {"pre": true},
  allowUnquoted: true,
  allowMissing: true,
  caseFold: true
}

var xmlConfig = {
  autoSelfClosers: {},
  implicitlyClosed: {},
  contextGrabbers: {},
  doNotIndent: {},
  allowUnquoted: false,
  allowMissing: false,
  allowMissingTagName: false,
  caseFold: false
}

CodeMirror.defineMode("xml", function(editorConf, config_) {
  var indentUnit = editorConf.indentUnit
  var config = {}
  var defaults = config_.htmlMode ? htmlConfig : xmlConfig
  for (var prop in defaults) config[prop] = defaults[prop]
  for (var prop in config_) config[prop] = config_[prop]

  // Return variables for tokenizers
  var type, setStyle;

  function inText(stream, state) {
    function chain(parser) {
      state.tokenize = parser;
      return parser(stream, state);
    }

    var ch = stream.next();
    if (ch == "<") {
      if (stream.eat("!")) {
        if (stream.eat("[")) {
          if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));
          else return null;
        } else if (stream.match("--")) {
          return chain(inBlock("comment", "-->"));
        } else if (stream.match("DOCTYPE", true, true)) {
          stream.eatWhile(/[\w\._\-]/);
          return chain(doctype(1));
        } else {
          return null;
        }
      } else if (stream.eat("?")) {
        stream.eatWhile(/[\w\._\-]/);
        state.tokenize = inBlock("meta", "?>");
        return "meta";
      } else {
        type = stream.eat("/") ? "closeTag" : "openTag";
        state.tokenize = inTag;
        return "tag bracket";
      }
    } else if (ch == "&") {
      var ok;
      if (stream.eat("#")) {
        if (stream.eat("x")) {
          ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
        } else {
          ok = stream.eatWhile(/[\d]/) && stream.eat(";");
        }
      } else {
        ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
      }
      return ok ? "atom" : "error";
    } else {
      stream.eatWhile(/[^&<]/);
      return null;
    }
  }
  inText.isInText = true;

  function inTag(stream, state) {
    var ch = stream.next();
    if (ch == ">" || (ch == "/" && stream.eat(">"))) {
      state.tokenize = inText;
      type = ch == ">" ? "endTag" : "selfcloseTag";
      return "tag bracket";
    } else if (ch == "=") {
      type = "equals";
      return null;
    } else if (ch == "<") {
      state.tokenize = inText;
      state.state = baseState;
      state.tagName = state.tagStart = null;
      var next = state.tokenize(stream, state);
      return next ? next + " tag error" : "tag error";
    } else if (/[\'\"]/.test(ch)) {
      state.tokenize = inAttribute(ch);
      state.stringStartCol = stream.column();
      return state.tokenize(stream, state);
    } else {
      stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
      return "word";
    }
  }

  function inAttribute(quote) {
    var closure = function(stream, state) {
      while (!stream.eol()) {
        if (stream.next() == quote) {
          state.tokenize = inTag;
          break;
        }
      }
      return "string";
    };
    closure.isInAttribute = true;
    return closure;
  }

  function inBlock(style, terminator) {
    return function(stream, state) {
      while (!stream.eol()) {
        if (stream.match(terminator)) {
          state.tokenize = inText;
          break;
        }
        stream.next();
      }
      return style;
    }
  }

  function doctype(depth) {
    return function(stream, state) {
      var ch;
      while ((ch = stream.next()) != null) {
        if (ch == "<") {
          state.tokenize = doctype(depth + 1);
          return state.tokenize(stream, state);
        } else if (ch == ">") {
          if (depth == 1) {
            state.tokenize = inText;
            break;
          } else {
            state.tokenize = doctype(depth - 1);
            return state.tokenize(stream, state);
          }
        }
      }
      return "meta";
    };
  }

  function lower(tagName) {
    return tagName && tagName.toLowerCase();
  }

  function Context(state, tagName, startOfLine) {
    this.prev = state.context;
    this.tagName = tagName || "";
    this.indent = state.indented;
    this.startOfLine = startOfLine;
    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))
      this.noIndent = true;
  }
  function popContext(state) {
    if (state.context) state.context = state.context.prev;
  }
  function maybePopContext(state, nextTagName) {
    var parentTagName;
    while (true) {
      if (!state.context) {
        return;
      }
      parentTagName = state.context.tagName;
      if (!config.contextGrabbers.hasOwnProperty(lower(parentTagName)) ||
          !config.contextGrabbers[lower(parentTagName)].hasOwnProperty(lower(nextTagName))) {
        return;
      }
      popContext(state);
    }
  }

  function baseState(type, stream, state) {
    if (type == "openTag") {
      state.tagStart = stream.column();
      return tagNameState;
    } else if (type == "closeTag") {
      return closeTagNameState;
    } else {
      return baseState;
    }
  }
  function tagNameState(type, stream, state) {
    if (type == "word") {
      state.tagName = stream.current();
      setStyle = "tag";
      return attrState;
    } else if (config.allowMissingTagName && type == "endTag") {
      setStyle = "tag bracket";
      return attrState(type, stream, state);
    } else {
      setStyle = "error";
      return tagNameState;
    }
  }
  function closeTagNameState(type, stream, state) {
    if (type == "word") {
      var tagName = stream.current();
      if (state.context && state.context.tagName != tagName &&
          config.implicitlyClosed.hasOwnProperty(lower(state.context.tagName)))
        popContext(state);
      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {
        setStyle = "tag";
        return closeState;
      } else {
        setStyle = "tag error";
        return closeStateErr;
      }
    } else if (config.allowMissingTagName && type == "endTag") {
      setStyle = "tag bracket";
      return closeState(type, stream, state);
    } else {
      setStyle = "error";
      return closeStateErr;
    }
  }

  function closeState(type, _stream, state) {
    if (type != "endTag") {
      setStyle = "error";
      return closeState;
    }
    popContext(state);
    return baseState;
  }
  function closeStateErr(type, stream, state) {
    setStyle = "error";
    return closeState(type, stream, state);
  }

  function attrState(type, _stream, state) {
    if (type == "word") {
      setStyle = "attribute";
      return attrEqState;
    } else if (type == "endTag" || type == "selfcloseTag") {
      var tagName = state.tagName, tagStart = state.tagStart;
      state.tagName = state.tagStart = null;
      if (type == "selfcloseTag" ||
          config.autoSelfClosers.hasOwnProperty(lower(tagName))) {
        maybePopContext(state, tagName);
      } else {
        maybePopContext(state, tagName);
        state.context = new Context(state, tagName, tagStart == state.indented);
      }
      return baseState;
    }
    setStyle = "error";
    return attrState;
  }
  function attrEqState(type, stream, state) {
    if (type == "equals") return attrValueState;
    if (!config.allowMissing) setStyle = "error";
    return attrState(type, stream, state);
  }
  function attrValueState(type, stream, state) {
    if (type == "string") return attrContinuedState;
    if (type == "word" && config.allowUnquoted) {setStyle = "string"; return attrState;}
    setStyle = "error";
    return attrState(type, stream, state);
  }
  function attrContinuedState(type, stream, state) {
    if (type == "string") return attrContinuedState;
    return attrState(type, stream, state);
  }

  return {
    startState: function(baseIndent) {
      var state = {tokenize: inText,
                   state: baseState,
                   indented: baseIndent || 0,
                   tagName: null, tagStart: null,
                   context: null}
      if (baseIndent != null) state.baseIndent = baseIndent
      return state
    },

    token: function(stream, state) {
      if (!state.tagName && stream.sol())
        state.indented = stream.indentation();

      if (stream.eatSpace()) return null;
      type = null;
      var style = state.tokenize(stream, state);
      if ((style || type) && style != "comment") {
        setStyle = null;
        state.state = state.state(type || style, stream, state);
        if (setStyle)
          style = setStyle == "error" ? style + " error" : setStyle;
      }
      return style;
    },

    indent: function(state, textAfter, fullLine) {
      var context = state.context;
      // Indent multi-line strings (e.g. css).
      if (state.tokenize.isInAttribute) {
        if (state.tagStart == state.indented)
          return state.stringStartCol + 1;
        else
          return state.indented + indentUnit;
      }
      if (context && context.noIndent) return CodeMirror.Pass;
      if (state.tokenize != inTag && state.tokenize != inText)
        return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
      // Indent the starts of attribute names.
      if (state.tagName) {
        if (config.multilineTagIndentPastTag !== false)
          return state.tagStart + state.tagName.length + 2;
        else
          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
      }
      if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
      var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
      if (tagAfter && tagAfter[1]) { // Closing tag spotted
        while (context) {
          if (context.tagName == tagAfter[2]) {
            context = context.prev;
            break;
          } else if (config.implicitlyClosed.hasOwnProperty(lower(context.tagName))) {
            context = context.prev;
          } else {
            break;
          }
        }
      } else if (tagAfter) { // Opening tag spotted
        while (context) {
          var grabbers = config.contextGrabbers[lower(context.tagName)];
          if (grabbers && grabbers.hasOwnProperty(lower(tagAfter[2])))
            context = context.prev;
          else
            break;
        }
      }
      while (context && context.prev && !context.startOfLine)
        context = context.prev;
      if (context) return context.indent + indentUnit;
      else return state.baseIndent || 0;
    },

    electricInput: /<\/[\s\w:]+>$/,
    blockCommentStart: "<!--",
    blockCommentEnd: "-->",

    configuration: config.htmlMode ? "html" : "xml",
    helperType: config.htmlMode ? "html" : "xml",

    skipAttribute: function(state) {
      if (state.state == attrValueState)
        state.state = attrState
    },

    xmlCurrentTag: function(state) {
      return state.tagName ? {name: state.tagName, close: state.type == "closeTag"} : null
    },

    xmlCurrentContext: function(state) {
      var context = []
      for (var cx = state.context; cx; cx = cx.prev)
        context.push(cx.tagName)
      return context.reverse()
    }
  };
});

CodeMirror.defineMIME("text/xml", "xml");
CodeMirror.defineMIME("application/xml", "xml");
if (!CodeMirror.mimeModes.hasOwnProperty("text/html"))
  CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});

});


/***/ }),

/***/ "./node_modules/dijkstrajs/dijkstra.js":
/*!*********************************************!*\
  !*** ./node_modules/dijkstrajs/dijkstra.js ***!
  \*********************************************/
/***/ (function(module) {

"use strict";


/******************************************************************************
 * Created 2008-08-19.
 *
 * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.
 *
 * Copyright (C) 2008
 *   Wyatt Baldwin <self@wyattbaldwin.com>
 *   All rights reserved
 *
 * Licensed under the MIT license.
 *
 *   http://www.opensource.org/licenses/mit-license.php
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *****************************************************************************/
var dijkstra = {
  single_source_shortest_paths: function(graph, s, d) {
    // Predecessor map for each node that has been encountered.
    // node ID => predecessor node ID
    var predecessors = {};

    // Costs of shortest paths from s to all nodes encountered.
    // node ID => cost
    var costs = {};
    costs[s] = 0;

    // Costs of shortest paths from s to all nodes encountered; differs from
    // `costs` in that it provides easy access to the node that currently has
    // the known shortest path from s.
    // XXX: Do we actually need both `costs` and `open`?
    var open = dijkstra.PriorityQueue.make();
    open.push(s, 0);

    var closest,
        u, v,
        cost_of_s_to_u,
        adjacent_nodes,
        cost_of_e,
        cost_of_s_to_u_plus_cost_of_e,
        cost_of_s_to_v,
        first_visit;
    while (!open.empty()) {
      // In the nodes remaining in graph that have a known cost from s,
      // find the node, u, that currently has the shortest path from s.
      closest = open.pop();
      u = closest.value;
      cost_of_s_to_u = closest.cost;

      // Get nodes adjacent to u...
      adjacent_nodes = graph[u] || {};

      // ...and explore the edges that connect u to those nodes, updating
      // the cost of the shortest paths to any or all of those nodes as
      // necessary. v is the node across the current edge from u.
      for (v in adjacent_nodes) {
        if (adjacent_nodes.hasOwnProperty(v)) {
          // Get the cost of the edge running from u to v.
          cost_of_e = adjacent_nodes[v];

          // Cost of s to u plus the cost of u to v across e--this is *a*
          // cost from s to v that may or may not be less than the current
          // known cost to v.
          cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;

          // If we haven't visited v yet OR if the current known cost from s to
          // v is greater than the new cost we just found (cost of s to u plus
          // cost of u to v across e), update v's cost in the cost list and
          // update v's predecessor in the predecessor list (it's now u).
          cost_of_s_to_v = costs[v];
          first_visit = (typeof costs[v] === 'undefined');
          if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
            costs[v] = cost_of_s_to_u_plus_cost_of_e;
            open.push(v, cost_of_s_to_u_plus_cost_of_e);
            predecessors[v] = u;
          }
        }
      }
    }

    if (typeof d !== 'undefined' && typeof costs[d] === 'undefined') {
      var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');
      throw new Error(msg);
    }

    return predecessors;
  },

  extract_shortest_path_from_predecessor_list: function(predecessors, d) {
    var nodes = [];
    var u = d;
    var predecessor;
    while (u) {
      nodes.push(u);
      predecessor = predecessors[u];
      u = predecessors[u];
    }
    nodes.reverse();
    return nodes;
  },

  find_path: function(graph, s, d) {
    var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);
    return dijkstra.extract_shortest_path_from_predecessor_list(
      predecessors, d);
  },

  /**
   * A very naive priority queue implementation.
   */
  PriorityQueue: {
    make: function (opts) {
      var T = dijkstra.PriorityQueue,
          t = {},
          key;
      opts = opts || {};
      for (key in T) {
        if (T.hasOwnProperty(key)) {
          t[key] = T[key];
        }
      }
      t.queue = [];
      t.sorter = opts.sorter || T.default_sorter;
      return t;
    },

    default_sorter: function (a, b) {
      return a.cost - b.cost;
    },

    /**
     * Add a new item to the queue and ensure the highest priority element
     * is at the front of the queue.
     */
    push: function (value, cost) {
      var item = {value: value, cost: cost};
      this.queue.push(item);
      this.queue.sort(this.sorter);
    },

    /**
     * Return the highest priority element in the queue.
     */
    pop: function () {
      return this.queue.shift();
    },

    empty: function () {
      return this.queue.length === 0;
    }
  }
};


// node.js module exports
if (true) {
  module.exports = dijkstra;
}


/***/ }),

/***/ "./node_modules/easymde/src/js/codemirror/tablist.js":
/*!***********************************************************!*\
  !*** ./node_modules/easymde/src/js/codemirror/tablist.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

var CodeMirror = __webpack_require__(/*! codemirror */ "./node_modules/codemirror/lib/codemirror.js");

CodeMirror.commands.tabAndIndentMarkdownList = function (cm) {
    var ranges = cm.listSelections();
    var pos = ranges[0].head;
    var eolState = cm.getStateAfter(pos.line);
    var inList = eolState.list !== false;

    if (inList) {
        cm.execCommand('indentMore');
        return;
    }

    if (cm.options.indentWithTabs) {
        cm.execCommand('insertTab');
    } else {
        var spaces = Array(cm.options.tabSize + 1).join(' ');
        cm.replaceSelection(spaces);
    }
};

CodeMirror.commands.shiftTabAndUnindentMarkdownList = function (cm) {
    var ranges = cm.listSelections();
    var pos = ranges[0].head;
    var eolState = cm.getStateAfter(pos.line);
    var inList = eolState.list !== false;

    if (inList) {
        cm.execCommand('indentLess');
        return;
    }

    if (cm.options.indentWithTabs) {
        cm.execCommand('insertTab');
    } else {
        var spaces = Array(cm.options.tabSize + 1).join(' ');
        cm.replaceSelection(spaces);
    }
};


/***/ }),

/***/ "./node_modules/easymde/src/js/easymde.js":
/*!************************************************!*\
  !*** ./node_modules/easymde/src/js/easymde.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var CodeMirror = __webpack_require__(/*! codemirror */ "./node_modules/codemirror/lib/codemirror.js");
__webpack_require__(/*! codemirror/addon/edit/continuelist.js */ "./node_modules/codemirror/addon/edit/continuelist.js");
__webpack_require__(/*! ./codemirror/tablist */ "./node_modules/easymde/src/js/codemirror/tablist.js");
__webpack_require__(/*! codemirror/addon/display/fullscreen.js */ "./node_modules/codemirror/addon/display/fullscreen.js");
__webpack_require__(/*! codemirror/mode/markdown/markdown.js */ "./node_modules/codemirror/mode/markdown/markdown.js");
__webpack_require__(/*! codemirror/addon/mode/overlay.js */ "./node_modules/codemirror/addon/mode/overlay.js");
__webpack_require__(/*! codemirror/addon/display/placeholder.js */ "./node_modules/codemirror/addon/display/placeholder.js");
__webpack_require__(/*! codemirror/addon/display/autorefresh.js */ "./node_modules/codemirror/addon/display/autorefresh.js");
__webpack_require__(/*! codemirror/addon/selection/mark-selection.js */ "./node_modules/codemirror/addon/selection/mark-selection.js");
__webpack_require__(/*! codemirror/addon/search/searchcursor.js */ "./node_modules/codemirror/addon/search/searchcursor.js");
__webpack_require__(/*! codemirror/mode/gfm/gfm.js */ "./node_modules/codemirror/mode/gfm/gfm.js");
__webpack_require__(/*! codemirror/mode/xml/xml.js */ "./node_modules/codemirror/mode/xml/xml.js");
var CodeMirrorSpellChecker = __webpack_require__(/*! codemirror-spell-checker */ "./node_modules/codemirror-spell-checker/src/js/spell-checker.js");
var marked = (__webpack_require__(/*! marked */ "./node_modules/marked/lib/marked.cjs").marked);


// Some variables
var isMac = /Mac/.test(navigator.platform);
var anchorToExternalRegex = new RegExp(/(<a.*?https?:\/\/.*?[^a]>)+?/g);

// Mapping of actions that can be bound to keyboard shortcuts or toolbar buttons
var bindings = {
    'toggleBold': toggleBold,
    'toggleItalic': toggleItalic,
    'drawLink': drawLink,
    'toggleHeadingSmaller': toggleHeadingSmaller,
    'toggleHeadingBigger': toggleHeadingBigger,
    'drawImage': drawImage,
    'toggleBlockquote': toggleBlockquote,
    'toggleOrderedList': toggleOrderedList,
    'toggleUnorderedList': toggleUnorderedList,
    'toggleCodeBlock': toggleCodeBlock,
    'togglePreview': togglePreview,
    'toggleStrikethrough': toggleStrikethrough,
    'toggleHeading1': toggleHeading1,
    'toggleHeading2': toggleHeading2,
    'toggleHeading3': toggleHeading3,
    'toggleHeading4': toggleHeading4,
    'toggleHeading5': toggleHeading5,
    'toggleHeading6': toggleHeading6,
    'cleanBlock': cleanBlock,
    'drawTable': drawTable,
    'drawHorizontalRule': drawHorizontalRule,
    'undo': undo,
    'redo': redo,
    'toggleSideBySide': toggleSideBySide,
    'toggleFullScreen': toggleFullScreen,
};

var shortcuts = {
    'toggleBold': 'Cmd-B',
    'toggleItalic': 'Cmd-I',
    'drawLink': 'Cmd-K',
    'toggleHeadingSmaller': 'Cmd-H',
    'toggleHeadingBigger': 'Shift-Cmd-H',
    'toggleHeading1': 'Ctrl+Alt+1',
    'toggleHeading2': 'Ctrl+Alt+2',
    'toggleHeading3': 'Ctrl+Alt+3',
    'toggleHeading4': 'Ctrl+Alt+4',
    'toggleHeading5': 'Ctrl+Alt+5',
    'toggleHeading6': 'Ctrl+Alt+6',
    'cleanBlock': 'Cmd-E',
    'drawImage': 'Cmd-Alt-I',
    'toggleBlockquote': 'Cmd-\'',
    'toggleOrderedList': 'Cmd-Alt-L',
    'toggleUnorderedList': 'Cmd-L',
    'toggleCodeBlock': 'Cmd-Alt-C',
    'togglePreview': 'Cmd-P',
    'toggleSideBySide': 'F9',
    'toggleFullScreen': 'F11',
};

var getBindingName = function (f) {
    for (var key in bindings) {
        if (bindings[key] === f) {
            return key;
        }
    }
    return null;
};

var isMobile = function () {
    var check = false;
    (function (a) {
        if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(a.substr(0, 4))) check = true;
    })(navigator.userAgent || navigator.vendor || window.opera);
    return check;
};

/**
 * Modify HTML to add 'target="_blank"' to links so they open in new tabs by default.
 * @param {string} htmlText - HTML to be modified.
 * @return {string} The modified HTML text.
 */
function addAnchorTargetBlank(htmlText) {
    var match;
    while ((match = anchorToExternalRegex.exec(htmlText)) !== null) {
        // With only one capture group in the RegExp, we can safely take the first index from the match.
        var linkString = match[0];

        if (linkString.indexOf('target=') === -1) {
            var fixedLinkString = linkString.replace(/>$/, ' target="_blank">');
            htmlText = htmlText.replace(linkString, fixedLinkString);
        }
    }
    return htmlText;
}

/**
 * Modify HTML to remove the list-style when rendering checkboxes.
 * @param {string} htmlText - HTML to be modified.
 * @return {string} The modified HTML text.
 */
function removeListStyleWhenCheckbox(htmlText) {

    var parser = new DOMParser();
    var htmlDoc = parser.parseFromString(htmlText, 'text/html');
    var listItems = htmlDoc.getElementsByTagName('li');

    for (var i = 0; i < listItems.length; i++) {
        var listItem = listItems[i];

        for (var j = 0; j < listItem.children.length; j++) {
            var listItemChild = listItem.children[j];

            if (listItemChild instanceof HTMLInputElement && listItemChild.type === 'checkbox') {
                // From Github: margin: 0 .2em .25em -1.6em;
                listItem.style.marginLeft = '-1.5em';
                listItem.style.listStyleType = 'none';
            }
        }
    }

    return htmlDoc.documentElement.innerHTML;
}

/**
 * Fix shortcut. Mac use Command, others use Ctrl.
 */
function fixShortcut(name) {
    if (isMac) {
        name = name.replace('Ctrl', 'Cmd');
    } else {
        name = name.replace('Cmd', 'Ctrl');
    }
    return name;
}

/**
 * Create dropdown block
 */
function createToolbarDropdown(options, enableTooltips, shortcuts, parent) {
    var el = createToolbarButton(options, false, enableTooltips, shortcuts, 'button', parent);
    el.classList.add('easymde-dropdown');

    el.onclick = function () {
        el.focus();
    };

    var content = document.createElement('div');
    content.className = 'easymde-dropdown-content';
    for (var childrenIndex = 0; childrenIndex < options.children.length; childrenIndex++) {

        var child = options.children[childrenIndex];
        var childElement;

        if (typeof child === 'string' && child in toolbarBuiltInButtons) {
            childElement = createToolbarButton(toolbarBuiltInButtons[child], true, enableTooltips, shortcuts, 'button', parent);
        } else {
            childElement = createToolbarButton(child, true, enableTooltips, shortcuts, 'button', parent);
        }

        childElement.addEventListener('click', function (e) { e.stopPropagation(); }, false);
        content.appendChild(childElement);
    }
    el.appendChild(content);
    return el;
}

/**
 * Create button element for toolbar.
 */
function createToolbarButton(options, enableActions, enableTooltips, shortcuts, markup, parent) {
    options = options || {};
    var el = document.createElement(markup);

    // Add 'custom' attributes as early as possible, so that 'official' attributes will never be overwritten.
    if (options.attributes) {
        for (var attribute in options.attributes) {
            if (Object.prototype.hasOwnProperty.call(options.attributes, attribute)) {
                el.setAttribute(attribute, options.attributes[attribute]);
            }
        }
    }

    var classNamePrefix = parent.options.toolbarButtonClassPrefix ? parent.options.toolbarButtonClassPrefix + '-' : '';
    el.className = classNamePrefix + options.name;
    el.setAttribute('type', markup);
    enableTooltips = (enableTooltips == undefined) ? true : enableTooltips;

    if (options.text) {
        el.innerText = options.text;
    }

    // Properly handle custom shortcuts
    if (options.name && options.name in shortcuts) {
        bindings[options.name] = options.action;
    }

    if (options.title && enableTooltips) {
        el.title = createTooltip(options.title, options.action, shortcuts);

        if (isMac) {
            el.title = el.title.replace('Ctrl', '');
            el.title = el.title.replace('Alt', '');
        }
    }

    if (options.title) {
        el.setAttribute('aria-label', options.title);
    }

    if (options.noDisable) {
        el.classList.add('no-disable');
    }

    if (options.noMobile) {
        el.classList.add('no-mobile');
    }

    // Prevent errors if there is no class name in custom options
    var classNameParts = [];
    if (typeof options.className !== 'undefined') {
        classNameParts = options.className.split(' ');
    }

    // Provide backwards compatibility with simple-markdown-editor by adding custom classes to the button.
    var iconClasses = [];
    for (var classNameIndex = 0; classNameIndex < classNameParts.length; classNameIndex++) {
        var classNamePart = classNameParts[classNameIndex];
        // Split icon classes from the button.
        // Regex will detect "fa", "fas", "fa-something" and "fa-some-icon-1", but not "fanfare".
        if (classNamePart.match(/^fa([srlb]|(-[\w-]*)|$)/)) {
            iconClasses.push(classNamePart);
        } else {
            el.classList.add(classNamePart);
        }
    }

    el.tabIndex = -1;

    if (iconClasses.length > 0) {
        // Create icon element and append as a child to the button
        var icon = document.createElement('i');
        for (var iconClassIndex = 0; iconClassIndex < iconClasses.length; iconClassIndex++) {
            var iconClass = iconClasses[iconClassIndex];
            icon.classList.add(iconClass);
        }
        el.appendChild(icon);
    }

    // If there is a custom icon markup set, use that
    if (typeof options.icon !== 'undefined') {
        el.innerHTML = options.icon;
    }

    if (options.action && enableActions) {
        if (typeof options.action === 'function') {
            el.onclick = function (e) {
                e.preventDefault();
                options.action(parent);
            };
        } else if (typeof options.action === 'string') {
            el.onclick = function (e) {
                e.preventDefault();
                window.open(options.action, '_blank');
            };
        }
    }

    return el;
}

function createSep() {
    var el = document.createElement('i');
    el.className = 'separator';
    el.innerHTML = '|';
    return el;
}

function createTooltip(title, action, shortcuts) {
    var actionName;
    var tooltip = title;

    if (action) {
        actionName = getBindingName(action);
        if (shortcuts[actionName]) {
            tooltip += ' (' + fixShortcut(shortcuts[actionName]) + ')';
        }
    }

    return tooltip;
}

/**
 * The state of CodeMirror at the given position.
 */
function getState(cm, pos) {
    pos = pos || cm.getCursor('start');
    var stat = cm.getTokenAt(pos);
    if (!stat.type) return {};

    var types = stat.type.split(' ');

    var ret = {},
        data, text;
    for (var i = 0; i < types.length; i++) {
        data = types[i];
        if (data === 'strong') {
            ret.bold = true;
        } else if (data === 'variable-2') {
            text = cm.getLine(pos.line);
            if (/^\s*\d+\.\s/.test(text)) {
                ret['ordered-list'] = true;
            } else {
                ret['unordered-list'] = true;
            }
        } else if (data === 'atom') {
            ret.quote = true;
        } else if (data === 'em') {
            ret.italic = true;
        } else if (data === 'quote') {
            ret.quote = true;
        } else if (data === 'strikethrough') {
            ret.strikethrough = true;
        } else if (data === 'comment') {
            ret.code = true;
        } else if (data === 'link' && !ret.image) {
            ret.link = true;
        } else if (data === 'image') {
            ret.image = true;
        } else if (data.match(/^header(-[1-6])?$/)) {
            ret[data.replace('header', 'heading')] = true;
        }
    }
    return ret;
}


// Saved overflow setting
var saved_overflow = '';

/**
 * Toggle full screen of the editor.
 * @param {EasyMDE} editor
 */
function toggleFullScreen(editor) {
    // Set fullscreen
    var cm = editor.codemirror;
    cm.setOption('fullScreen', !cm.getOption('fullScreen'));


    // Prevent scrolling on body during fullscreen active
    if (cm.getOption('fullScreen')) {
        saved_overflow = document.body.style.overflow;
        document.body.style.overflow = 'hidden';
    } else {
        document.body.style.overflow = saved_overflow;
    }

    var wrapper = cm.getWrapperElement();
    var sidebyside = wrapper.nextSibling;

    if (sidebyside.classList.contains('editor-preview-active-side')) {
        if (editor.options.sideBySideFullscreen === false) {
            // if side-by-side not-fullscreen ok, apply classes as needed
            var easyMDEContainer = wrapper.parentNode;
            if (cm.getOption('fullScreen')) {
                easyMDEContainer.classList.remove('sided--no-fullscreen');
            } else {
                easyMDEContainer.classList.add('sided--no-fullscreen');
            }
        } else {
            toggleSideBySide(editor);
        }
    }

    if (editor.options.onToggleFullScreen) {
        editor.options.onToggleFullScreen(cm.getOption('fullScreen') || false);
    }

    // Remove or set maxHeight
    if (typeof editor.options.maxHeight !== 'undefined') {
        if (cm.getOption('fullScreen')) {
            cm.getScrollerElement().style.removeProperty('height');
            sidebyside.style.removeProperty('height');
        } else {
            cm.getScrollerElement().style.height = editor.options.maxHeight;
            editor.setPreviewMaxHeight();
        }
    }

    // Update toolbar class
    editor.toolbar_div.classList.toggle('fullscreen');

    // Update toolbar button
    if (editor.toolbarElements && editor.toolbarElements.fullscreen) {
        var toolbarButton = editor.toolbarElements.fullscreen;
        toolbarButton.classList.toggle('active');
    }
}


/**
 * Action for toggling bold.
 * @param {EasyMDE} editor
 */
function toggleBold(editor) {
    _toggleBlock(editor, 'bold', editor.options.blockStyles.bold);
}


/**
 * Action for toggling italic.
 * @param {EasyMDE} editor
 */
function toggleItalic(editor) {
    _toggleBlock(editor, 'italic', editor.options.blockStyles.italic);
}


/**
 * Action for toggling strikethrough.
 * @param {EasyMDE} editor
 */
function toggleStrikethrough(editor) {
    _toggleBlock(editor, 'strikethrough', '~~');
}

/**
 * Action for toggling code block.
 * @param {EasyMDE} editor
 */
function toggleCodeBlock(editor) {
    var fenceCharsToInsert = editor.options.blockStyles.code;

    function fencing_line(line) {
        /* return true, if this is a ``` or ~~~ line */
        if (typeof line !== 'object') {
            throw 'fencing_line() takes a \'line\' object (not a line number, or line text).  Got: ' + typeof line + ': ' + line;
        }
        return line.styles && line.styles[2] && line.styles[2].indexOf('formatting-code-block') !== -1;
    }

    function token_state(token) {
        // base goes an extra level deep when mode backdrops are used, e.g. spellchecker on
        return token.state.base.base || token.state.base;
    }

    function code_type(cm, line_num, line, firstTok, lastTok) {
        /*
         * Return "single", "indented", "fenced" or false
         *
         * cm and line_num are required.  Others are optional for efficiency
         *   To check in the middle of a line, pass in firstTok yourself.
         */
        line = line || cm.getLineHandle(line_num);
        firstTok = firstTok || cm.getTokenAt({
            line: line_num,
            ch: 1,
        });
        lastTok = lastTok || (!!line.text && cm.getTokenAt({
            line: line_num,
            ch: line.text.length - 1,
        }));
        var types = firstTok.type ? firstTok.type.split(' ') : [];
        if (lastTok && token_state(lastTok).indentedCode) {
            // have to check last char, since first chars of first line aren"t marked as indented
            return 'indented';
        } else if (types.indexOf('comment') === -1) {
            // has to be after "indented" check, since first chars of first indented line aren"t marked as such
            return false;
        } else if (token_state(firstTok).fencedChars || token_state(lastTok).fencedChars || fencing_line(line)) {
            return 'fenced';
        } else {
            return 'single';
        }
    }

    function insertFencingAtSelection(cm, cur_start, cur_end, fenceCharsToInsert) {
        var start_line_sel = cur_start.line + 1,
            end_line_sel = cur_end.line + 1,
            sel_multi = cur_start.line !== cur_end.line,
            repl_start = fenceCharsToInsert + '\n',
            repl_end = '\n' + fenceCharsToInsert;
        if (sel_multi) {
            end_line_sel++;
        }
        // handle last char including \n or not
        if (sel_multi && cur_end.ch === 0) {
            repl_end = fenceCharsToInsert + '\n';
            end_line_sel--;
        }
        _replaceSelection(cm, false, [repl_start, repl_end]);
        cm.setSelection({
            line: start_line_sel,
            ch: 0,
        }, {
            line: end_line_sel,
            ch: 0,
        });
    }

    var cm = editor.codemirror,
        cur_start = cm.getCursor('start'),
        cur_end = cm.getCursor('end'),
        tok = cm.getTokenAt({
            line: cur_start.line,
            ch: cur_start.ch || 1,
        }), // avoid ch 0 which is a cursor pos but not token
        line = cm.getLineHandle(cur_start.line),
        is_code = code_type(cm, cur_start.line, line, tok);
    var block_start, block_end, lineCount;

    if (is_code === 'single') {
        // similar to some EasyMDE _toggleBlock logic
        var start = line.text.slice(0, cur_start.ch).replace('`', ''),
            end = line.text.slice(cur_start.ch).replace('`', '');
        cm.replaceRange(start + end, {
            line: cur_start.line,
            ch: 0,
        }, {
            line: cur_start.line,
            ch: 99999999999999,
        });
        cur_start.ch--;
        if (cur_start !== cur_end) {
            cur_end.ch--;
        }
        cm.setSelection(cur_start, cur_end);
        cm.focus();
    } else if (is_code === 'fenced') {
        if (cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {
            // use selection

            // find the fenced line so we know what type it is (tilde, backticks, number of them)
            for (block_start = cur_start.line; block_start >= 0; block_start--) {
                line = cm.getLineHandle(block_start);
                if (fencing_line(line)) {
                    break;
                }
            }
            var fencedTok = cm.getTokenAt({
                line: block_start,
                ch: 1,
            });
            var fence_chars = token_state(fencedTok).fencedChars;
            var start_text, start_line;
            var end_text, end_line;
            // check for selection going up against fenced lines, in which case we don't want to add more fencing
            if (fencing_line(cm.getLineHandle(cur_start.line))) {
                start_text = '';
                start_line = cur_start.line;
            } else if (fencing_line(cm.getLineHandle(cur_start.line - 1))) {
                start_text = '';
                start_line = cur_start.line - 1;
            } else {
                start_text = fence_chars + '\n';
                start_line = cur_start.line;
            }
            if (fencing_line(cm.getLineHandle(cur_end.line))) {
                end_text = '';
                end_line = cur_end.line;
                if (cur_end.ch === 0) {
                    end_line += 1;
                }
            } else if (cur_end.ch !== 0 && fencing_line(cm.getLineHandle(cur_end.line + 1))) {
                end_text = '';
                end_line = cur_end.line + 1;
            } else {
                end_text = fence_chars + '\n';
                end_line = cur_end.line + 1;
            }
            if (cur_end.ch === 0) {
                // full last line selected, putting cursor at beginning of next
                end_line -= 1;
            }
            cm.operation(function () {
                // end line first, so that line numbers don't change
                cm.replaceRange(end_text, {
                    line: end_line,
                    ch: 0,
                }, {
                    line: end_line + (end_text ? 0 : 1),
                    ch: 0,
                });
                cm.replaceRange(start_text, {
                    line: start_line,
                    ch: 0,
                }, {
                    line: start_line + (start_text ? 0 : 1),
                    ch: 0,
                });
            });
            cm.setSelection({
                line: start_line + (start_text ? 1 : 0),
                ch: 0,
            }, {
                line: end_line + (start_text ? 1 : -1),
                ch: 0,
            });
            cm.focus();
        } else {
            // no selection, search for ends of this fenced block
            var search_from = cur_start.line;
            if (fencing_line(cm.getLineHandle(cur_start.line))) { // gets a little tricky if cursor is right on a fenced line
                if (code_type(cm, cur_start.line + 1) === 'fenced') {
                    block_start = cur_start.line;
                    search_from = cur_start.line + 1; // for searching for "end"
                } else {
                    block_end = cur_start.line;
                    search_from = cur_start.line - 1; // for searching for "start"
                }
            }
            if (block_start === undefined) {
                for (block_start = search_from; block_start >= 0; block_start--) {
                    line = cm.getLineHandle(block_start);
                    if (fencing_line(line)) {
                        break;
                    }
                }
            }
            if (block_end === undefined) {
                lineCount = cm.lineCount();
                for (block_end = search_from; block_end < lineCount; block_end++) {
                    line = cm.getLineHandle(block_end);
                    if (fencing_line(line)) {
                        break;
                    }
                }
            }
            cm.operation(function () {
                cm.replaceRange('', {
                    line: block_start,
                    ch: 0,
                }, {
                    line: block_start + 1,
                    ch: 0,
                });
                cm.replaceRange('', {
                    line: block_end - 1,
                    ch: 0,
                }, {
                    line: block_end,
                    ch: 0,
                });
            });
            cm.focus();
        }
    } else if (is_code === 'indented') {
        if (cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {
            // use selection
            block_start = cur_start.line;
            block_end = cur_end.line;
            if (cur_end.ch === 0) {
                block_end--;
            }
        } else {
            // no selection, search for ends of this indented block
            for (block_start = cur_start.line; block_start >= 0; block_start--) {
                line = cm.getLineHandle(block_start);
                if (line.text.match(/^\s*$/)) {
                    // empty or all whitespace - keep going
                    continue;
                } else {
                    if (code_type(cm, block_start, line) !== 'indented') {
                        block_start += 1;
                        break;
                    }
                }
            }
            lineCount = cm.lineCount();
            for (block_end = cur_start.line; block_end < lineCount; block_end++) {
                line = cm.getLineHandle(block_end);
                if (line.text.match(/^\s*$/)) {
                    // empty or all whitespace - keep going
                    continue;
                } else {
                    if (code_type(cm, block_end, line) !== 'indented') {
                        block_end -= 1;
                        break;
                    }
                }
            }
        }
        // if we are going to un-indent based on a selected set of lines, and the next line is indented too, we need to
        // insert a blank line so that the next line(s) continue to be indented code
        var next_line = cm.getLineHandle(block_end + 1),
            next_line_last_tok = next_line && cm.getTokenAt({
                line: block_end + 1,
                ch: next_line.text.length - 1,
            }),
            next_line_indented = next_line_last_tok && token_state(next_line_last_tok).indentedCode;
        if (next_line_indented) {
            cm.replaceRange('\n', {
                line: block_end + 1,
                ch: 0,
            });
        }

        for (var i = block_start; i <= block_end; i++) {
            cm.indentLine(i, 'subtract'); // TODO: this doesn't get tracked in the history, so can't be undone :(
        }
        cm.focus();
    } else {
        // insert code formatting
        var no_sel_and_starting_of_line = (cur_start.line === cur_end.line && cur_start.ch === cur_end.ch && cur_start.ch === 0);
        var sel_multi = cur_start.line !== cur_end.line;
        if (no_sel_and_starting_of_line || sel_multi) {
            insertFencingAtSelection(cm, cur_start, cur_end, fenceCharsToInsert);
        } else {
            _replaceSelection(cm, false, ['`', '`']);
        }
    }
}

/**
 * Action for toggling blockquote.
 */
function toggleBlockquote(editor) {
    _toggleLine(editor.codemirror, 'quote');
}

/**
 * Action for toggling heading size: normal -> h1 -> h2 -> h3 -> h4 -> h5 -> h6 -> normal
 */
function toggleHeadingSmaller(editor) {
    _toggleHeading(editor.codemirror, 'smaller');
}

/**
 * Action for toggling heading size: normal -> h6 -> h5 -> h4 -> h3 -> h2 -> h1 -> normal
 */
function toggleHeadingBigger(editor) {
    _toggleHeading(editor.codemirror, 'bigger');
}

/**
 * Action for toggling heading size 1
 */
function toggleHeading1(editor) {
    _toggleHeading(editor.codemirror, undefined, 1);
}

/**
 * Action for toggling heading size 2
 */
function toggleHeading2(editor) {
    _toggleHeading(editor.codemirror, undefined, 2);
}

/**
 * Action for toggling heading size 3
 */
function toggleHeading3(editor) {
    _toggleHeading(editor.codemirror, undefined, 3);
}

/**
 * Action for toggling heading size 4
 */
function toggleHeading4(editor) {
    _toggleHeading(editor.codemirror, undefined, 4);
}

/**
 * Action for toggling heading size 5
 */
function toggleHeading5(editor) {
    _toggleHeading(editor.codemirror, undefined, 5);
}

/**
 * Action for toggling heading size 6
 */
function toggleHeading6(editor) {
    _toggleHeading(editor.codemirror, undefined, 6);
}


/**
 * Action for toggling ul.
 */
function toggleUnorderedList(editor) {
    var cm = editor.codemirror;

    var listStyle = '*'; // Default
    if (['-', '+', '*'].includes(editor.options.unorderedListStyle)) {
        listStyle = editor.options.unorderedListStyle;
    }

    _toggleLine(cm, 'unordered-list', listStyle);
}


/**
 * Action for toggling ol.
 */
function toggleOrderedList(editor) {
    _toggleLine(editor.codemirror, 'ordered-list');
}

/**
 * Action for clean block (remove headline, list, blockquote code, markers)
 */
function cleanBlock(editor) {
    _cleanBlock(editor.codemirror);
}

/**
 * Action for drawing a link.
 * @param {EasyMDE} editor
 */
function drawLink(editor) {
    var options = editor.options;
    var url = 'https://';
    if (options.promptURLs) {
        var result = prompt(options.promptTexts.link, url);
        if (!result) {
            return false;
        }
        url = escapePromptURL(result);
    }
    _toggleLink(editor, 'link', options.insertTexts.link, url);
}

/**
 * Action for drawing an img.
 * @param {EasyMDE} editor
 */
function drawImage(editor) {
    var options = editor.options;
    var url = 'https://';
    if (options.promptURLs) {
        var result = prompt(options.promptTexts.image, url);
        if (!result) {
            return false;
        }
        url = escapePromptURL(result);
    }
    _toggleLink(editor, 'image', options.insertTexts.image, url);
}

/**
 * Encode and escape URLs to prevent breaking up rendered Markdown links.
 * @param {string} url The url of the link or image
 */
function escapePromptURL(url) {
    return encodeURI(url).replace(/([\\()])/g, '\\$1');
}

/**
 * Action for opening the browse-file window to upload an image to a server.
 * @param {EasyMDE} editor The EasyMDE object
 */
function drawUploadedImage(editor) {
    // TODO: Draw the image template with a fake url? ie: '![](importing foo.png...)'
    editor.openBrowseFileWindow();
}

/**
 * Action executed after an image have been successfully imported on the server.
 * @param {EasyMDE} editor The EasyMDE object
 * @param {string} url The url of the uploaded image
 */
function afterImageUploaded(editor, url) {
    var cm = editor.codemirror;
    var stat = getState(cm);
    var options = editor.options;
    var imageName = url.substr(url.lastIndexOf('/') + 1);
    var ext = imageName.substring(imageName.lastIndexOf('.') + 1).replace(/\?.*$/, '').toLowerCase();

    // Check if media is an image
    if (['png', 'jpg', 'jpeg', 'gif', 'svg', 'apng', 'avif', 'webp'].includes(ext)) {
        _replaceSelection(cm, stat.image, options.insertTexts.uploadedImage, url);
    } else {
        var text_link = options.insertTexts.link;
        text_link[0] = '[' + imageName;
        _replaceSelection(cm, stat.link, text_link, url);
    }

    // show uploaded image filename for 1000ms
    editor.updateStatusBar('upload-image', editor.options.imageTexts.sbOnUploaded.replace('#image_name#', imageName));
    setTimeout(function () {
        editor.updateStatusBar('upload-image', editor.options.imageTexts.sbInit);
    }, 1000);
}

/**
 * Action for drawing a table.
 * @param {EasyMDE} editor
 */
function drawTable(editor) {
    var cm = editor.codemirror;
    var stat = getState(cm);
    var options = editor.options;
    _replaceSelection(cm, stat.table, options.insertTexts.table);
}

/**
 * Action for drawing a horizontal rule.
 * @param {EasyMDE} editor
 */
function drawHorizontalRule(editor) {
    var cm = editor.codemirror;
    var stat = getState(cm);
    var options = editor.options;
    _replaceSelection(cm, stat.image, options.insertTexts.horizontalRule);
}


/**
 * Undo action.
 * @param {EasyMDE} editor
 */
function undo(editor) {
    var cm = editor.codemirror;
    cm.undo();
    cm.focus();
}


/**
 * Redo action.
 * @param {EasyMDE} editor
 */
function redo(editor) {
    var cm = editor.codemirror;
    cm.redo();
    cm.focus();
}


/**
 * Toggle side by side preview
 * @param {EasyMDE} editor
 */
function toggleSideBySide(editor) {
    var cm = editor.codemirror;
    var wrapper = cm.getWrapperElement();
    var preview = wrapper.nextSibling;
    var toolbarButton = editor.toolbarElements && editor.toolbarElements['side-by-side'];
    var useSideBySideListener = false;

    var easyMDEContainer = wrapper.parentNode;

    if (preview.classList.contains('editor-preview-active-side')) {
        if (editor.options.sideBySideFullscreen === false) {
            // if side-by-side not-fullscreen ok, remove classes when hiding side
            easyMDEContainer.classList.remove('sided--no-fullscreen');
        }
        preview.classList.remove('editor-preview-active-side');
        if (toolbarButton) toolbarButton.classList.remove('active');
        wrapper.classList.remove('CodeMirror-sided');
    } else {
        // When the preview button is clicked for the first time,
        // give some time for the transition from editor.css to fire and the view to slide from right to left,
        // instead of just appearing.
        setTimeout(function () {
            if (!cm.getOption('fullScreen')) {
                if (editor.options.sideBySideFullscreen === false) {
                    // if side-by-side not-fullscreen ok, add classes when not fullscreen and showing side
                    easyMDEContainer.classList.add('sided--no-fullscreen');
                } else {
                    toggleFullScreen(editor);
                }
            }
            preview.classList.add('editor-preview-active-side');
        }, 1);
        if (toolbarButton) toolbarButton.classList.add('active');
        wrapper.classList.add('CodeMirror-sided');
        useSideBySideListener = true;
    }

    // Hide normal preview if active
    var previewNormal = wrapper.lastChild;
    if (previewNormal.classList.contains('editor-preview-active')) {
        previewNormal.classList.remove('editor-preview-active');
        var toolbar = editor.toolbarElements.preview;
        var toolbar_div = editor.toolbar_div;
        toolbar.classList.remove('active');
        toolbar_div.classList.remove('disabled-for-preview');
    }

    var sideBySideRenderingFunction = function () {
        var newValue = editor.options.previewRender(editor.value(), preview);
        if (newValue != null) {
            preview.innerHTML = newValue;
        }
    };

    if (!cm.sideBySideRenderingFunction) {
        cm.sideBySideRenderingFunction = sideBySideRenderingFunction;
    }

    if (useSideBySideListener) {
        var newValue = editor.options.previewRender(editor.value(), preview);
        if (newValue != null) {
            preview.innerHTML = newValue;
        }
        cm.on('update', cm.sideBySideRenderingFunction);
    } else {
        cm.off('update', cm.sideBySideRenderingFunction);
    }

    // Refresh to fix selection being off (#309)
    cm.refresh();
}


/**
 * Preview action.
 * @param {EasyMDE} editor
 */
function togglePreview(editor) {
    var cm = editor.codemirror;
    var wrapper = cm.getWrapperElement();
    var toolbar_div = editor.toolbar_div;
    var toolbar = editor.options.toolbar ? editor.toolbarElements.preview : false;
    var preview = wrapper.lastChild;

    // Turn off side by side if needed
    var sidebyside = cm.getWrapperElement().nextSibling;
    if (sidebyside.classList.contains('editor-preview-active-side'))
        toggleSideBySide(editor);

    if (!preview || !preview.classList.contains('editor-preview-full')) {

        preview = document.createElement('div');
        preview.className = 'editor-preview-full';

        if (editor.options.previewClass) {

            if (Array.isArray(editor.options.previewClass)) {
                for (var i = 0; i < editor.options.previewClass.length; i++) {
                    preview.classList.add(editor.options.previewClass[i]);
                }

            } else if (typeof editor.options.previewClass === 'string') {
                preview.classList.add(editor.options.previewClass);
            }
        }

        wrapper.appendChild(preview);
    }

    if (preview.classList.contains('editor-preview-active')) {
        preview.classList.remove('editor-preview-active');
        if (toolbar) {
            toolbar.classList.remove('active');
            toolbar_div.classList.remove('disabled-for-preview');
        }
    } else {
        // When the preview button is clicked for the first time,
        // give some time for the transition from editor.css to fire and the view to slide from right to left,
        // instead of just appearing.
        setTimeout(function () {
            preview.classList.add('editor-preview-active');
        }, 1);
        if (toolbar) {
            toolbar.classList.add('active');
            toolbar_div.classList.add('disabled-for-preview');
        }
    }

    var preview_result = editor.options.previewRender(editor.value(), preview);
    if (preview_result !== null) {
        preview.innerHTML = preview_result;
    }

}

function _replaceSelection(cm, active, startEnd, url) {
    if (cm.getWrapperElement().lastChild.classList.contains('editor-preview-active'))
        return;

    var text;
    var start = startEnd[0];
    var end = startEnd[1];
    var startPoint = {},
        endPoint = {};
    Object.assign(startPoint, cm.getCursor('start'));
    Object.assign(endPoint, cm.getCursor('end'));
    if (url) {
        start = start.replace('#url#', url);  // url is in start for upload-image
        end = end.replace('#url#', url);
    }
    if (active) {
        text = cm.getLine(startPoint.line);
        start = text.slice(0, startPoint.ch);
        end = text.slice(startPoint.ch);
        cm.replaceRange(start + end, {
            line: startPoint.line,
            ch: 0,
        });
    } else {
        text = cm.getSelection();
        cm.replaceSelection(start + text + end);

        startPoint.ch += start.length;
        if (startPoint !== endPoint) {
            endPoint.ch += start.length;
        }
    }
    cm.setSelection(startPoint, endPoint);
    cm.focus();
}


function _toggleHeading(cm, direction, size) {
    if (cm.getWrapperElement().lastChild.classList.contains('editor-preview-active'))
        return;

    var startPoint = cm.getCursor('start');
    var endPoint = cm.getCursor('end');
    for (var i = startPoint.line; i <= endPoint.line; i++) {
        (function (i) {
            var text = cm.getLine(i);
            var currHeadingLevel = text.search(/[^#]/);

            if (direction !== undefined) {
                if (currHeadingLevel <= 0) {
                    if (direction == 'bigger') {
                        text = '###### ' + text;
                    } else {
                        text = '# ' + text;
                    }
                } else if (currHeadingLevel == 6 && direction == 'smaller') {
                    text = text.substr(7);
                } else if (currHeadingLevel == 1 && direction == 'bigger') {
                    text = text.substr(2);
                } else {
                    if (direction == 'bigger') {
                        text = text.substr(1);
                    } else {
                        text = '#' + text;
                    }
                }
            } else {
                if (currHeadingLevel <= 0) {
                    text = '#'.repeat(size) + ' ' + text;
                } else if (currHeadingLevel == size) {
                    text = text.substr(currHeadingLevel + 1);
                } else {
                    text = '#'.repeat(size) + ' ' + text.substr(currHeadingLevel + 1);
                }
            }

            cm.replaceRange(text, {
                line: i,
                ch: 0,
            }, {
                line: i,
                ch: 99999999999999,
            });
        })(i);
    }
    cm.focus();
}


function _toggleLine(cm, name, liststyle) {
    if (cm.getWrapperElement().lastChild.classList.contains('editor-preview-active'))
        return;

    var listRegexp = /^(\s*)(\*|-|\+|\d*\.)(\s+)/;
    var whitespacesRegexp = /^\s*/;

    var stat = getState(cm);
    var startPoint = cm.getCursor('start');
    var endPoint = cm.getCursor('end');
    var repl = {
        'quote': /^(\s*)>\s+/,
        'unordered-list': listRegexp,
        'ordered-list': listRegexp,
    };

    var _getChar = function (name, i) {
        var map = {
            'quote': '>',
            'unordered-list': liststyle,
            'ordered-list': '%%i.',
        };

        return map[name].replace('%%i', i);
    };

    var _checkChar = function (name, char) {
        var map = {
            'quote': '>',
            'unordered-list': '\\' + liststyle,
            'ordered-list': '\\d+.',
        };
        var rt = new RegExp(map[name]);

        return char && rt.test(char);
    };

    var _toggle = function (name, text, untoggleOnly) {
        var arr = listRegexp.exec(text);
        var char = _getChar(name, line);
        if (arr !== null) {
            if (_checkChar(name, arr[2])) {
                char = '';
            }
            text = arr[1] + char + arr[3] + text.replace(whitespacesRegexp, '').replace(repl[name], '$1');
        } else if (untoggleOnly == false) {
            text = char + ' ' + text;
        }
        return text;
    };

    var line = 1;
    for (var i = startPoint.line; i <= endPoint.line; i++) {
        (function (i) {
            var text = cm.getLine(i);
            if (stat[name]) {
                text = text.replace(repl[name], '$1');
            } else {
                // If we're toggling unordered-list formatting, check if the current line
                // is part of an ordered-list, and if so, untoggle that first.
                // Workaround for https://github.com/Ionaru/easy-markdown-editor/issues/92
                if (name == 'unordered-list') {
                    text = _toggle('ordered-list', text, true);
                }
                text = _toggle(name, text, false);
                line += 1;
            }
            cm.replaceRange(text, {
                line: i,
                ch: 0,
            }, {
                line: i,
                ch: 99999999999999,
            });
        })(i);
    }
    cm.focus();
}

/**
 * @param {EasyMDE} editor
 * @param {'link' | 'image'} type
 * @param {string} startEnd
 * @param {string} url
 */
function _toggleLink(editor, type, startEnd, url) {
    if (!editor.codemirror || editor.isPreviewActive()) {
        return;
    }

    var cm = editor.codemirror;
    var stat = getState(cm);
    var active = stat[type];
    if (!active) {
        _replaceSelection(cm, active, startEnd, url);
        return;
    }

    var startPoint = cm.getCursor('start');
    var endPoint = cm.getCursor('end');
    var text = cm.getLine(startPoint.line);
    var start = text.slice(0, startPoint.ch);
    var end = text.slice(startPoint.ch);

    if (type == 'link') {
        start = start.replace(/(.*)[^!]\[/, '$1');
    } else if (type == 'image') {
        start = start.replace(/(.*)!\[$/, '$1');
    }
    end = end.replace(/]\(.*?\)/, '');

    cm.replaceRange(start + end, {
        line: startPoint.line,
        ch: 0,
    }, {
        line: startPoint.line,
        ch: 99999999999999,
    });

    startPoint.ch -= startEnd[0].length;
    if (startPoint !== endPoint) {
        endPoint.ch -= startEnd[0].length;
    }
    cm.setSelection(startPoint, endPoint);
    cm.focus();
}

/**
 * @param {EasyMDE} editor
 */
function _toggleBlock(editor, type, start_chars, end_chars) {
    if (!editor.codemirror || editor.isPreviewActive()) {
        return;
    }

    end_chars = (typeof end_chars === 'undefined') ? start_chars : end_chars;
    var cm = editor.codemirror;
    var stat = getState(cm);

    var text;
    var start = start_chars;
    var end = end_chars;

    var startPoint = cm.getCursor('start');
    var endPoint = cm.getCursor('end');

    if (stat[type]) {
        text = cm.getLine(startPoint.line);
        start = text.slice(0, startPoint.ch);
        end = text.slice(startPoint.ch);
        if (type == 'bold') {
            start = start.replace(/(\*\*|__)(?![\s\S]*(\*\*|__))/, '');
            end = end.replace(/(\*\*|__)/, '');
        } else if (type == 'italic') {
            start = start.replace(/(\*|_)(?![\s\S]*(\*|_))/, '');
            end = end.replace(/(\*|_)/, '');
        } else if (type == 'strikethrough') {
            start = start.replace(/(\*\*|~~)(?![\s\S]*(\*\*|~~))/, '');
            end = end.replace(/(\*\*|~~)/, '');
        }
        cm.replaceRange(start + end, {
            line: startPoint.line,
            ch: 0,
        }, {
            line: startPoint.line,
            ch: 99999999999999,
        });

        if (type == 'bold' || type == 'strikethrough') {
            startPoint.ch -= 2;
            if (startPoint !== endPoint) {
                endPoint.ch -= 2;
            }
        } else if (type == 'italic') {
            startPoint.ch -= 1;
            if (startPoint !== endPoint) {
                endPoint.ch -= 1;
            }
        }
    } else {
        text = cm.getSelection();
        if (type == 'bold') {
            text = text.split('**').join('');
            text = text.split('__').join('');
        } else if (type == 'italic') {
            text = text.split('*').join('');
            text = text.split('_').join('');
        } else if (type == 'strikethrough') {
            text = text.split('~~').join('');
        }
        cm.replaceSelection(start + text + end);

        startPoint.ch += start_chars.length;
        endPoint.ch = startPoint.ch + text.length;
    }

    cm.setSelection(startPoint, endPoint);
    cm.focus();
}

function _cleanBlock(cm) {
    if (cm.getWrapperElement().lastChild.classList.contains('editor-preview-active'))
        return;

    var startPoint = cm.getCursor('start');
    var endPoint = cm.getCursor('end');
    var text;

    for (var line = startPoint.line; line <= endPoint.line; line++) {
        text = cm.getLine(line);
        text = text.replace(/^[ ]*([# ]+|\*|-|[> ]+|[0-9]+(.|\)))[ ]*/, '');

        cm.replaceRange(text, {
            line: line,
            ch: 0,
        }, {
            line: line,
            ch: 99999999999999,
        });
    }
}

/**
 * Convert a number of bytes to a human-readable file size. If you desire
 * to add a space between the value and the unit, you need to add this space
 * to the given units.
 * @param bytes {number} A number of bytes, as integer. Ex: 421137
 * @param units {number[]} An array of human-readable units, ie. [' B', ' K', ' MB']
 * @returns string A human-readable file size. Ex: '412 KB'
 */
function humanFileSize(bytes, units) {
    if (Math.abs(bytes) < 1024) {
        return '' + bytes + units[0];
    }
    var u = 0;
    do {
        bytes /= 1024;
        ++u;
    } while (Math.abs(bytes) >= 1024 && u < units.length);
    return '' + bytes.toFixed(1) + units[u];
}

// Merge the properties of one object into another.
function _mergeProperties(target, source) {
    for (var property in source) {
        if (Object.prototype.hasOwnProperty.call(source, property)) {
            if (source[property] instanceof Array) {
                target[property] = source[property].concat(target[property] instanceof Array ? target[property] : []);
            } else if (
                source[property] !== null &&
                typeof source[property] === 'object' &&
                source[property].constructor === Object
            ) {
                target[property] = _mergeProperties(target[property] || {}, source[property]);
            } else {
                target[property] = source[property];
            }
        }
    }

    return target;
}

// Merge an arbitrary number of objects into one.
function extend(target) {
    for (var i = 1; i < arguments.length; i++) {
        target = _mergeProperties(target, arguments[i]);
    }

    return target;
}

/* The right word count in respect for CJK. */
function wordCount(data) {
    var pattern = /[a-zA-Z0-9_\u00A0-\u02AF\u0392-\u03c9\u0410-\u04F9]+|[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af]+/g;
    var m = data.match(pattern);
    var count = 0;
    if (m === null) return count;
    for (var i = 0; i < m.length; i++) {
        if (m[i].charCodeAt(0) >= 0x4E00) {
            count += m[i].length;
        } else {
            count += 1;
        }
    }
    return count;
}

var iconClassMap = {
    'bold': 'fa fa-bold',
    'italic': 'fa fa-italic',
    'strikethrough': 'fa fa-strikethrough',
    'heading': 'fa fa-header fa-heading',
    'heading-smaller': 'fa fa-header fa-heading header-smaller',
    'heading-bigger': 'fa fa-header fa-heading header-bigger',
    'heading-1': 'fa fa-header fa-heading header-1',
    'heading-2': 'fa fa-header fa-heading header-2',
    'heading-3': 'fa fa-header fa-heading header-3',
    'code': 'fa fa-code',
    'quote': 'fa fa-quote-left',
    'ordered-list': 'fa fa-list-ol',
    'unordered-list': 'fa fa-list-ul',
    'clean-block': 'fa fa-eraser',
    'link': 'fa fa-link',
    'image': 'fa fa-image',
    'upload-image': 'fa fa-image',
    'table': 'fa fa-table',
    'horizontal-rule': 'fa fa-minus',
    'preview': 'fa fa-eye',
    'side-by-side': 'fa fa-columns',
    'fullscreen': 'fa fa-arrows-alt',
    'guide': 'fa fa-question-circle',
    'undo': 'fa fa-undo',
    'redo': 'fa fa-repeat fa-redo',
};

var toolbarBuiltInButtons = {
    'bold': {
        name: 'bold',
        action: toggleBold,
        className: iconClassMap['bold'],
        title: 'Bold',
        default: true,
    },
    'italic': {
        name: 'italic',
        action: toggleItalic,
        className: iconClassMap['italic'],
        title: 'Italic',
        default: true,
    },
    'strikethrough': {
        name: 'strikethrough',
        action: toggleStrikethrough,
        className: iconClassMap['strikethrough'],
        title: 'Strikethrough',
    },
    'heading': {
        name: 'heading',
        action: toggleHeadingSmaller,
        className: iconClassMap['heading'],
        title: 'Heading',
        default: true,
    },
    'heading-smaller': {
        name: 'heading-smaller',
        action: toggleHeadingSmaller,
        className: iconClassMap['heading-smaller'],
        title: 'Smaller Heading',
    },
    'heading-bigger': {
        name: 'heading-bigger',
        action: toggleHeadingBigger,
        className: iconClassMap['heading-bigger'],
        title: 'Bigger Heading',
    },
    'heading-1': {
        name: 'heading-1',
        action: toggleHeading1,
        className: iconClassMap['heading-1'],
        title: 'Big Heading',
    },
    'heading-2': {
        name: 'heading-2',
        action: toggleHeading2,
        className: iconClassMap['heading-2'],
        title: 'Medium Heading',
    },
    'heading-3': {
        name: 'heading-3',
        action: toggleHeading3,
        className: iconClassMap['heading-3'],
        title: 'Small Heading',
    },
    'separator-1': {
        name: 'separator-1',
    },
    'code': {
        name: 'code',
        action: toggleCodeBlock,
        className: iconClassMap['code'],
        title: 'Code',
    },
    'quote': {
        name: 'quote',
        action: toggleBlockquote,
        className: iconClassMap['quote'],
        title: 'Quote',
        default: true,
    },
    'unordered-list': {
        name: 'unordered-list',
        action: toggleUnorderedList,
        className: iconClassMap['unordered-list'],
        title: 'Generic List',
        default: true,
    },
    'ordered-list': {
        name: 'ordered-list',
        action: toggleOrderedList,
        className: iconClassMap['ordered-list'],
        title: 'Numbered List',
        default: true,
    },
    'clean-block': {
        name: 'clean-block',
        action: cleanBlock,
        className: iconClassMap['clean-block'],
        title: 'Clean block',
    },
    'separator-2': {
        name: 'separator-2',
    },
    'link': {
        name: 'link',
        action: drawLink,
        className: iconClassMap['link'],
        title: 'Create Link',
        default: true,
    },
    'image': {
        name: 'image',
        action: drawImage,
        className: iconClassMap['image'],
        title: 'Insert Image',
        default: true,
    },
    'upload-image': {
        name: 'upload-image',
        action: drawUploadedImage,
        className: iconClassMap['upload-image'],
        title: 'Import an image',
    },
    'table': {
        name: 'table',
        action: drawTable,
        className: iconClassMap['table'],
        title: 'Insert Table',
    },
    'horizontal-rule': {
        name: 'horizontal-rule',
        action: drawHorizontalRule,
        className: iconClassMap['horizontal-rule'],
        title: 'Insert Horizontal Line',
    },
    'separator-3': {
        name: 'separator-3',
    },
    'preview': {
        name: 'preview',
        action: togglePreview,
        className: iconClassMap['preview'],
        noDisable: true,
        title: 'Toggle Preview',
        default: true,
    },
    'side-by-side': {
        name: 'side-by-side',
        action: toggleSideBySide,
        className: iconClassMap['side-by-side'],
        noDisable: true,
        noMobile: true,
        title: 'Toggle Side by Side',
        default: true,
    },
    'fullscreen': {
        name: 'fullscreen',
        action: toggleFullScreen,
        className: iconClassMap['fullscreen'],
        noDisable: true,
        noMobile: true,
        title: 'Toggle Fullscreen',
        default: true,
    },
    'separator-4': {
        name: 'separator-4',
    },
    'guide': {
        name: 'guide',
        action: 'https://www.markdownguide.org/basic-syntax/',
        className: iconClassMap['guide'],
        noDisable: true,
        title: 'Markdown Guide',
        default: true,
    },
    'separator-5': {
        name: 'separator-5',
    },
    'undo': {
        name: 'undo',
        action: undo,
        className: iconClassMap['undo'],
        noDisable: true,
        title: 'Undo',
    },
    'redo': {
        name: 'redo',
        action: redo,
        className: iconClassMap['redo'],
        noDisable: true,
        title: 'Redo',
    },
};

var insertTexts = {
    link: ['[', '](#url#)'],
    image: ['![', '](#url#)'],
    uploadedImage: ['![](#url#)', ''],
    // uploadedImage: ['![](#url#)\n', ''], // TODO: New line insertion doesn't work here.
    table: ['', '\n\n| Column 1 | Column 2 | Column 3 |\n| -------- | -------- | -------- |\n| Text     | Text     | Text     |\n\n'],
    horizontalRule: ['', '\n\n-----\n\n'],
};

var promptTexts = {
    link: 'URL for the link:',
    image: 'URL of the image:',
};

var timeFormat = {
    locale: 'en-US',
    format: {
        hour: '2-digit',
        minute: '2-digit',
    },
};

var blockStyles = {
    'bold': '**',
    'code': '```',
    'italic': '*',
};

/**
 * Texts displayed to the user (mainly on the status bar) for the import image
 * feature. Can be used for customization or internationalization.
 */
var imageTexts = {
    sbInit: 'Attach files by drag and dropping or pasting from clipboard.',
    sbOnDragEnter: 'Drop image to upload it.',
    sbOnDrop: 'Uploading image #images_names#...',
    sbProgress: 'Uploading #file_name#: #progress#%',
    sbOnUploaded: 'Uploaded #image_name#',
    sizeUnits: ' B, KB, MB',
};

/**
 * Errors displayed to the user, using the `errorCallback` option. Can be used for
 * customization or internationalization.
 */
var errorMessages = {
    noFileGiven: 'You must select a file.',
    typeNotAllowed: 'This image type is not allowed.',
    fileTooLarge: 'Image #image_name# is too big (#image_size#).\n' +
        'Maximum file size is #image_max_size#.',
    importError: 'Something went wrong when uploading the image #image_name#.',
};

/**
 * Interface of EasyMDE.
 */
function EasyMDE(options) {
    // Handle options parameter
    options = options || {};

    // Used later to refer to it"s parent
    options.parent = this;

    // Check if Font Awesome needs to be auto downloaded
    var autoDownloadFA = true;

    if (options.autoDownloadFontAwesome === false) {
        autoDownloadFA = false;
    }

    if (options.autoDownloadFontAwesome !== true) {
        var styleSheets = document.styleSheets;
        for (var i = 0; i < styleSheets.length; i++) {
            if (!styleSheets[i].href)
                continue;

            if (styleSheets[i].href.indexOf('//maxcdn.bootstrapcdn.com/font-awesome/') > -1) {
                autoDownloadFA = false;
            }
        }
    }

    if (autoDownloadFA) {
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = 'https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    }


    // Find the textarea to use
    if (options.element) {
        this.element = options.element;
    } else if (options.element === null) {
        // This means that the element option was specified, but no element was found
        console.log('EasyMDE: Error. No element was found.');
        return;
    }


    // Handle toolbar
    if (options.toolbar === undefined) {
        // Initialize
        options.toolbar = [];


        // Loop over the built in buttons, to get the preferred order
        for (var key in toolbarBuiltInButtons) {
            if (Object.prototype.hasOwnProperty.call(toolbarBuiltInButtons, key)) {
                if (key.indexOf('separator-') != -1) {
                    options.toolbar.push('|');
                }

                if (toolbarBuiltInButtons[key].default === true || (options.showIcons && options.showIcons.constructor === Array && options.showIcons.indexOf(key) != -1)) {
                    options.toolbar.push(key);
                }
            }
        }
    }

    // Editor preview styling class.
    if (!Object.prototype.hasOwnProperty.call(options, 'previewClass')) {
        options.previewClass = 'editor-preview';
    }

    // Handle status bar
    if (!Object.prototype.hasOwnProperty.call(options, 'status')) {
        options.status = ['autosave', 'lines', 'words', 'cursor'];

        if (options.uploadImage) {
            options.status.unshift('upload-image');
        }
    }


    // Add default preview rendering function
    if (!options.previewRender) {
        options.previewRender = function (plainText) {
            // Note: "this" refers to the options object
            return this.parent.markdown(plainText);
        };
    }


    // Set default options for parsing config
    options.parsingConfig = extend({
        highlightFormatting: true, // needed for toggleCodeBlock to detect types of code
    }, options.parsingConfig || {});


    // Merging the insertTexts, with the given options
    options.insertTexts = extend({}, insertTexts, options.insertTexts || {});


    // Merging the promptTexts, with the given options
    options.promptTexts = extend({}, promptTexts, options.promptTexts || {});


    // Merging the blockStyles, with the given options
    options.blockStyles = extend({}, blockStyles, options.blockStyles || {});


    if (options.autosave != undefined) {
        // Merging the Autosave timeFormat, with the given options
        options.autosave.timeFormat = extend({}, timeFormat, options.autosave.timeFormat || {});
    }

    options.iconClassMap = extend({}, iconClassMap, options.iconClassMap || {});

    // Merging the shortcuts, with the given options
    options.shortcuts = extend({}, shortcuts, options.shortcuts || {});

    options.maxHeight = options.maxHeight || undefined;

    options.direction = options.direction || 'ltr';

    if (typeof options.maxHeight !== 'undefined') {
        // Min and max height are equal if maxHeight is set
        options.minHeight = options.maxHeight;
    } else {
        options.minHeight = options.minHeight || '300px';
    }

    options.errorCallback = options.errorCallback || function (errorMessage) {
        alert(errorMessage);
    };

    // Import-image default configuration
    options.uploadImage = options.uploadImage || false;
    options.imageMaxSize = options.imageMaxSize || 2097152; // 1024 * 1024 * 2
    options.imageAccept = options.imageAccept || 'image/png, image/jpeg, image/gif, image/avif';
    options.imageTexts = extend({}, imageTexts, options.imageTexts || {});
    options.errorMessages = extend({}, errorMessages, options.errorMessages || {});
    options.imagePathAbsolute = options.imagePathAbsolute || false;
    options.imageCSRFName = options.imageCSRFName || 'csrfmiddlewaretoken';
    options.imageCSRFHeader = options.imageCSRFHeader || false;
    options.imageInputName = options.imageInputName || 'image';


    // Change unique_id to uniqueId for backwards compatibility
    if (options.autosave != undefined && options.autosave.unique_id != undefined && options.autosave.unique_id != '')
        options.autosave.uniqueId = options.autosave.unique_id;

    // If overlay mode is specified and combine is not provided, default it to true
    if (options.overlayMode && options.overlayMode.combine === undefined) {
        options.overlayMode.combine = true;
    }

    // Update this options
    this.options = options;


    // Auto render
    this.render();


    // The codemirror component is only available after rendering
    // so, the setter for the initialValue can only run after
    // the element has been rendered
    if (options.initialValue && (!this.options.autosave || this.options.autosave.foundSavedValue !== true)) {
        this.value(options.initialValue);
    }

    if (options.uploadImage) {
        var self = this;

        this.codemirror.on('dragenter', function (cm, event) {
            self.updateStatusBar('upload-image', self.options.imageTexts.sbOnDragEnter);
            event.stopPropagation();
            event.preventDefault();
        });
        this.codemirror.on('dragend', function (cm, event) {
            self.updateStatusBar('upload-image', self.options.imageTexts.sbInit);
            event.stopPropagation();
            event.preventDefault();
        });
        this.codemirror.on('dragleave', function (cm, event) {
            self.updateStatusBar('upload-image', self.options.imageTexts.sbInit);
            event.stopPropagation();
            event.preventDefault();
        });

        this.codemirror.on('dragover', function (cm, event) {
            self.updateStatusBar('upload-image', self.options.imageTexts.sbOnDragEnter);
            event.stopPropagation();
            event.preventDefault();
        });

        this.codemirror.on('drop', function (cm, event) {
            event.stopPropagation();
            event.preventDefault();
            if (options.imageUploadFunction) {
                self.uploadImagesUsingCustomFunction(options.imageUploadFunction, event.dataTransfer.files);
            } else {
                self.uploadImages(event.dataTransfer.files);
            }
        });

        this.codemirror.on('paste', function (cm, event) {
            if (options.imageUploadFunction) {
                self.uploadImagesUsingCustomFunction(options.imageUploadFunction, event.clipboardData.files);
            } else {
                self.uploadImages(event.clipboardData.files);
            }
        });
    }
}

/**
 * Upload asynchronously a list of images to a server.
 *
 * Can be triggered by:
 * - drag&drop;
 * - copy-paste;
 * - the browse-file window (opened when the user clicks on the *upload-image* icon).
 * @param {FileList} files The files to upload the the server.
 * @param [onSuccess] {function} see EasyMDE.prototype.uploadImage
 * @param [onError] {function} see EasyMDE.prototype.uploadImage
 */
EasyMDE.prototype.uploadImages = function (files, onSuccess, onError) {
    if (files.length === 0) {
        return;
    }
    var names = [];
    for (var i = 0; i < files.length; i++) {
        names.push(files[i].name);
        this.uploadImage(files[i], onSuccess, onError);
    }
    this.updateStatusBar('upload-image', this.options.imageTexts.sbOnDrop.replace('#images_names#', names.join(', ')));
};

/**
 * Upload asynchronously a list of images to a server.
 *
 * Can be triggered by:
 * - drag&drop;
 * - copy-paste;
 * - the browse-file window (opened when the user clicks on the *upload-image* icon).
 * @param imageUploadFunction {Function} The custom function to upload the image passed in options.
 * @param {FileList} files The files to upload the the server.
 */
EasyMDE.prototype.uploadImagesUsingCustomFunction = function (imageUploadFunction, files) {
    if (files.length === 0) {
        return;
    }
    var names = [];
    for (var i = 0; i < files.length; i++) {
        names.push(files[i].name);
        this.uploadImageUsingCustomFunction(imageUploadFunction, files[i]);
    }
    this.updateStatusBar('upload-image', this.options.imageTexts.sbOnDrop.replace('#images_names#', names.join(', ')));
};

/**
 * Update an item in the status bar.
 * @param itemName {string} The name of the item to update (ie. 'upload-image', 'autosave', etc.).
 * @param content {string} the new content of the item to write in the status bar.
 */
EasyMDE.prototype.updateStatusBar = function (itemName, content) {
    if (!this.gui.statusbar) {
        return;
    }

    var matchingClasses = this.gui.statusbar.getElementsByClassName(itemName);
    if (matchingClasses.length === 1) {
        this.gui.statusbar.getElementsByClassName(itemName)[0].textContent = content;
    } else if (matchingClasses.length === 0) {
        console.log('EasyMDE: status bar item ' + itemName + ' was not found.');
    } else {
        console.log('EasyMDE: Several status bar items named ' + itemName + ' was found.');
    }
};

/**
 * Default markdown render.
 */
EasyMDE.prototype.markdown = function (text) {
    if (marked) {
        // Initialize
        var markedOptions;
        if (this.options && this.options.renderingConfig && this.options.renderingConfig.markedOptions) {
            markedOptions = this.options.renderingConfig.markedOptions;
        } else {
            markedOptions = {};
        }

        // Update options
        if (this.options && this.options.renderingConfig && this.options.renderingConfig.singleLineBreaks === false) {
            markedOptions.breaks = false;
        } else {
            markedOptions.breaks = true;
        }

        if (this.options && this.options.renderingConfig && this.options.renderingConfig.codeSyntaxHighlighting === true) {

            /* Get HLJS from config or window */
            var hljs = this.options.renderingConfig.hljs || window.hljs;

            /* Check if HLJS loaded */
            if (hljs) {
                markedOptions.highlight = function (code, language) {
                    if (language && hljs.getLanguage(language)) {
                        return hljs.highlight(language, code).value;
                    } else {
                        return hljs.highlightAuto(code).value;
                    }
                };
            }
        }

        // Set options
        marked.use(markedOptions);

        // Convert the markdown to HTML
        var htmlText = marked.parse(text);

        // Sanitize HTML
        if (this.options.renderingConfig && typeof this.options.renderingConfig.sanitizerFunction === 'function') {
            htmlText = this.options.renderingConfig.sanitizerFunction.call(this, htmlText);
        }

        // Edit the HTML anchors to add 'target="_blank"' by default.
        htmlText = addAnchorTargetBlank(htmlText);

        // Remove list-style when rendering checkboxes
        htmlText = removeListStyleWhenCheckbox(htmlText);

        return htmlText;
    }
};

/**
 * Render editor to the given element.
 */
EasyMDE.prototype.render = function (el) {
    if (!el) {
        el = this.element || document.getElementsByTagName('textarea')[0];
    }

    if (this._rendered && this._rendered === el) {
        // Already rendered.
        return;
    }

    this.element = el;
    var options = this.options;

    var self = this;
    var keyMaps = {};

    for (var key in options.shortcuts) {
        // null stands for "do not bind this command"
        if (options.shortcuts[key] !== null && bindings[key] !== null) {
            (function (key) {
                keyMaps[fixShortcut(options.shortcuts[key])] = function () {
                    var action = bindings[key];
                    if (typeof action === 'function') {
                        action(self);
                    } else if (typeof action === 'string') {
                        window.open(action, '_blank');
                    }
                };
            })(key);
        }
    }

    keyMaps['Enter'] = 'newlineAndIndentContinueMarkdownList';
    keyMaps['Tab'] = 'tabAndIndentMarkdownList';
    keyMaps['Shift-Tab'] = 'shiftTabAndUnindentMarkdownList';
    keyMaps['Esc'] = function (cm) {
        if (cm.getOption('fullScreen')) toggleFullScreen(self);
    };

    this.documentOnKeyDown = function (e) {
        e = e || window.event;

        if (e.keyCode == 27) {
            if (self.codemirror.getOption('fullScreen')) toggleFullScreen(self);
        }
    };
    document.addEventListener('keydown', this.documentOnKeyDown, false);

    var mode, backdrop;

    // CodeMirror overlay mode
    if (options.overlayMode) {
        CodeMirror.defineMode('overlay-mode', function (config) {
            return CodeMirror.overlayMode(CodeMirror.getMode(config, options.spellChecker !== false ? 'spell-checker' : 'gfm'), options.overlayMode.mode, options.overlayMode.combine);
        });

        mode = 'overlay-mode';
        backdrop = options.parsingConfig;
        backdrop.gitHubSpice = false;
    } else {
        mode = options.parsingConfig;
        mode.name = 'gfm';
        mode.gitHubSpice = false;
    }
    if (options.spellChecker !== false) {
        mode = 'spell-checker';
        backdrop = options.parsingConfig;
        backdrop.name = 'gfm';
        backdrop.gitHubSpice = false;

        if (typeof options.spellChecker === 'function') {
            options.spellChecker({
                codeMirrorInstance: CodeMirror,
            });
        } else {
            CodeMirrorSpellChecker({
                codeMirrorInstance: CodeMirror,
            });
        }
    }

    // eslint-disable-next-line no-unused-vars
    function configureMouse(cm, repeat, event) {
        return {
            addNew: false,
        };
    }

    this.codemirror = CodeMirror.fromTextArea(el, {
        mode: mode,
        backdrop: backdrop,
        theme: (options.theme != undefined) ? options.theme : 'easymde',
        tabSize: (options.tabSize != undefined) ? options.tabSize : 2,
        indentUnit: (options.tabSize != undefined) ? options.tabSize : 2,
        indentWithTabs: (options.indentWithTabs === false) ? false : true,
        lineNumbers: (options.lineNumbers === true) ? true : false,
        autofocus: (options.autofocus === true) ? true : false,
        extraKeys: keyMaps,
        direction: options.direction,
        lineWrapping: (options.lineWrapping === false) ? false : true,
        allowDropFileTypes: ['text/plain'],
        placeholder: options.placeholder || el.getAttribute('placeholder') || '',
        styleSelectedText: (options.styleSelectedText != undefined) ? options.styleSelectedText : !isMobile(),
        scrollbarStyle: (options.scrollbarStyle != undefined) ? options.scrollbarStyle : 'native',
        configureMouse: configureMouse,
        inputStyle: (options.inputStyle != undefined) ? options.inputStyle : isMobile() ? 'contenteditable' : 'textarea',
        spellcheck: (options.nativeSpellcheck != undefined) ? options.nativeSpellcheck : true,
        autoRefresh: (options.autoRefresh != undefined) ? options.autoRefresh : false,
    });

    this.codemirror.getScrollerElement().style.minHeight = options.minHeight;

    if (typeof options.maxHeight !== 'undefined') {
        this.codemirror.getScrollerElement().style.height = options.maxHeight;
    }

    if (options.forceSync === true) {
        var cm = this.codemirror;
        cm.on('change', function () {
            cm.save();
        });
    }

    this.gui = {};

    // Wrap Codemirror with container before create toolbar, etc,
    // to use with sideBySideFullscreen option.
    var easyMDEContainer = document.createElement('div');
    easyMDEContainer.classList.add('EasyMDEContainer');
    easyMDEContainer.setAttribute('role', 'application');
    var cmWrapper = this.codemirror.getWrapperElement();
    cmWrapper.parentNode.insertBefore(easyMDEContainer, cmWrapper);
    easyMDEContainer.appendChild(cmWrapper);

    if (options.toolbar !== false) {
        this.gui.toolbar = this.createToolbar();
    }
    if (options.status !== false) {
        this.gui.statusbar = this.createStatusbar();
    }
    if (options.autosave != undefined && options.autosave.enabled === true) {
        this.autosave(); // use to load localstorage content
        this.codemirror.on('change', function () {
            clearTimeout(self._autosave_timeout);
            self._autosave_timeout = setTimeout(function () {
                self.autosave();
            }, self.options.autosave.submit_delay || self.options.autosave.delay || 1000);
        });
    }

    function calcHeight(naturalWidth, naturalHeight) {
        var height;
        var viewportWidth = window.getComputedStyle(document.querySelector('.CodeMirror-sizer')).width.replace('px', '');
        if (naturalWidth < viewportWidth) {
            height = naturalHeight + 'px';
        } else {
            height = (naturalHeight / naturalWidth * 100) + '%';
        }
        return height;
    }

    var _vm = this;


    function assignImageBlockAttributes(parentEl, img) {
        var url = (new URL(img.url, document.baseURI)).href;
        parentEl.setAttribute('data-img-src', url);
        parentEl.setAttribute('style', '--bg-image:url(' + url + ');--width:' + img.naturalWidth + 'px;--height:' + calcHeight(img.naturalWidth, img.naturalHeight));
        _vm.codemirror.setSize();
    }

    function handleImages() {
        if (!options.previewImagesInEditor) {
            return;
        }

        easyMDEContainer.querySelectorAll('.cm-image-marker').forEach(function (e) {
            var parentEl = e.parentElement;
            if (!parentEl.innerText.match(/^!\[.*?\]\(.*\)/g)) {
                // if img pasted on the same line with other text, don't preview, preview only images on separate line
                return;
            }
            if (!parentEl.hasAttribute('data-img-src')) {
                var srcAttr = parentEl.innerText.match(/!\[.*?\]\((.*?)\)/); // might require better parsing according to markdown spec
                if (!window.EMDEimagesCache) {
                    window.EMDEimagesCache = {};
                }

                if (srcAttr && srcAttr.length >= 2) {
                    var keySrc = srcAttr[1];

                    if (options.imagesPreviewHandler) {
                        var newSrc = options.imagesPreviewHandler(srcAttr[1]);
                        // defensive check making sure the handler provided by the user returns a string
                        if (typeof newSrc === 'string') {
                            keySrc = newSrc;
                        }
                    }

                    if (!window.EMDEimagesCache[keySrc]) {
                        window.EMDEimagesCache[keySrc] = {};
                        var img = document.createElement('img');
                        img.onload = function () {
                            window.EMDEimagesCache[keySrc] = {
                                naturalWidth: img.naturalWidth,
                                naturalHeight: img.naturalHeight,
                                url: keySrc,
                            };
                            assignImageBlockAttributes(parentEl, window.EMDEimagesCache[keySrc]);
                        };
                        img.src = keySrc;
                    } else {
                        assignImageBlockAttributes(parentEl, window.EMDEimagesCache[keySrc]);
                    }
                }
            }
        });
    }

    this.codemirror.on('update', function () {
        handleImages();
    });

    this.gui.sideBySide = this.createSideBySide();
    this._rendered = this.element;

    if (options.autofocus === true || el.autofocus) {
        this.codemirror.focus();
    }

    // Fixes CodeMirror bug (#344)
    var temp_cm = this.codemirror;
    setTimeout(function () {
        temp_cm.refresh();
    }.bind(temp_cm), 0);
};

EasyMDE.prototype.cleanup = function () {
    document.removeEventListener('keydown', this.documentOnKeyDown);
};

// Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem throw QuotaExceededError. We're going to detect this and set a variable accordingly.
function isLocalStorageAvailable() {
    if (typeof localStorage === 'object') {
        try {
            localStorage.setItem('smde_localStorage', 1);
            localStorage.removeItem('smde_localStorage');
        } catch (e) {
            return false;
        }
    } else {
        return false;
    }

    return true;
}

EasyMDE.prototype.autosave = function () {
    if (isLocalStorageAvailable()) {
        var easyMDE = this;

        if (this.options.autosave.uniqueId == undefined || this.options.autosave.uniqueId == '') {
            console.log('EasyMDE: You must set a uniqueId to use the autosave feature');
            return;
        }

        if (this.options.autosave.binded !== true) {
            if (easyMDE.element.form != null && easyMDE.element.form != undefined) {
                easyMDE.element.form.addEventListener('submit', function () {
                    clearTimeout(easyMDE.autosaveTimeoutId);
                    easyMDE.autosaveTimeoutId = undefined;

                    localStorage.removeItem('smde_' + easyMDE.options.autosave.uniqueId);
                });
            }

            this.options.autosave.binded = true;
        }

        if (this.options.autosave.loaded !== true) {
            if (typeof localStorage.getItem('smde_' + this.options.autosave.uniqueId) == 'string' && localStorage.getItem('smde_' + this.options.autosave.uniqueId) != '') {
                this.codemirror.setValue(localStorage.getItem('smde_' + this.options.autosave.uniqueId));
                this.options.autosave.foundSavedValue = true;
            }

            this.options.autosave.loaded = true;
        }

        var value = easyMDE.value();
        if (value !== '') {
            localStorage.setItem('smde_' + this.options.autosave.uniqueId, value);
        } else {
            localStorage.removeItem('smde_' + this.options.autosave.uniqueId);
        }

        var el = document.getElementById('autosaved');
        if (el != null && el != undefined && el != '') {
            var d = new Date();
            var dd = new Intl.DateTimeFormat([this.options.autosave.timeFormat.locale, 'en-US'], this.options.autosave.timeFormat.format).format(d);
            var save = this.options.autosave.text == undefined ? 'Autosaved: ' : this.options.autosave.text;

            el.innerHTML = save + dd;
        }
    } else {
        console.log('EasyMDE: localStorage not available, cannot autosave');
    }
};

EasyMDE.prototype.clearAutosavedValue = function () {
    if (isLocalStorageAvailable()) {
        if (this.options.autosave == undefined || this.options.autosave.uniqueId == undefined || this.options.autosave.uniqueId == '') {
            console.log('EasyMDE: You must set a uniqueId to clear the autosave value');
            return;
        }

        localStorage.removeItem('smde_' + this.options.autosave.uniqueId);
    } else {
        console.log('EasyMDE: localStorage not available, cannot autosave');
    }
};

/**
 * Open the browse-file window to upload an image to a server.
 * @param [onSuccess] {function} see EasyMDE.prototype.uploadImage
 * @param [onError] {function} see EasyMDE.prototype.uploadImage
 */
EasyMDE.prototype.openBrowseFileWindow = function (onSuccess, onError) {
    var self = this;
    var imageInput = this.gui.toolbar.getElementsByClassName('imageInput')[0];
    imageInput.click(); //dispatchEvent(new MouseEvent('click'));  // replaced with click() for IE11 compatibility.
    function onChange(event) {
        if (self.options.imageUploadFunction) {
            self.uploadImagesUsingCustomFunction(self.options.imageUploadFunction, event.target.files);
        } else {
            self.uploadImages(event.target.files, onSuccess, onError);
        }
        imageInput.removeEventListener('change', onChange);
    }

    imageInput.addEventListener('change', onChange);
};

/**
 * Upload an image to the server.
 *
 * @param file {File} The image to upload, as a HTML5 File object (https://developer.mozilla.org/en-US/docs/Web/API/File)
 * @param [onSuccess] {function} A callback function to execute after the image has been successfully uploaded, with one parameter:
 * - url (string): The URL of the uploaded image.
 * @param [onError] {function} A callback function to execute when the image upload fails, with one parameter:
 * - error (string): the detailed error to display to the user (based on messages from options.errorMessages).
 */
EasyMDE.prototype.uploadImage = function (file, onSuccess, onError) {
    var self = this;
    onSuccess = onSuccess || function onSuccess(imageUrl) {
        afterImageUploaded(self, imageUrl);
    };

    function onErrorSup(errorMessage) {
        // show error on status bar and reset after 10000ms
        self.updateStatusBar('upload-image', errorMessage);

        setTimeout(function () {
            self.updateStatusBar('upload-image', self.options.imageTexts.sbInit);
        }, 10000);

        // run custom error handler
        if (onError && typeof onError === 'function') {
            onError(errorMessage);
        }
        // run error handler from options, this alerts the message.
        self.options.errorCallback(errorMessage);
    }

    function fillErrorMessage(errorMessage) {
        var units = self.options.imageTexts.sizeUnits.split(',');
        return errorMessage
            .replace('#image_name#', file.name)
            .replace('#image_size#', humanFileSize(file.size, units))
            .replace('#image_max_size#', humanFileSize(self.options.imageMaxSize, units));
    }

    if (file.size > this.options.imageMaxSize) {
        onErrorSup(fillErrorMessage(this.options.errorMessages.fileTooLarge));
        return;
    }

    var formData = new FormData();
    formData.append('image', file);

    // insert CSRF body token if provided in config.
    if (self.options.imageCSRFToken && !self.options.imageCSRFHeader) {
        formData.append(self.options.imageCSRFName, self.options.imageCSRFToken);
    }

    var request = new XMLHttpRequest();
    request.upload.onprogress = function (event) {
        if (event.lengthComputable) {
            var progress = '' + Math.round((event.loaded * 100) / event.total);
            self.updateStatusBar('upload-image', self.options.imageTexts.sbProgress.replace('#file_name#', file.name).replace('#progress#', progress));
        }
    };
    request.open('POST', this.options.imageUploadEndpoint);

    // insert CSRF header token if provided in config.
    if (self.options.imageCSRFToken && self.options.imageCSRFHeader) {
        request.setRequestHeader(self.options.imageCSRFName, self.options.imageCSRFToken);
    }

    request.onload = function () {
        try {
            var response = JSON.parse(this.responseText);
        } catch (error) {
            console.error('EasyMDE: The server did not return a valid json.');
            onErrorSup(fillErrorMessage(self.options.errorMessages.importError));
            return;
        }
        if (this.status === 200 && response && !response.error && response.data && response.data.filePath) {
            onSuccess((self.options.imagePathAbsolute ? '' : (window.location.origin + '/')) + response.data.filePath);
        } else {
            if (response.error && response.error in self.options.errorMessages) {  // preformatted error message
                onErrorSup(fillErrorMessage(self.options.errorMessages[response.error]));
            } else if (response.error) {  // server side generated error message
                onErrorSup(fillErrorMessage(response.error));
            } else {  //unknown error
                console.error('EasyMDE: Received an unexpected response after uploading the image.'
                    + this.status + ' (' + this.statusText + ')');
                onErrorSup(fillErrorMessage(self.options.errorMessages.importError));
            }
        }
    };

    request.onerror = function (event) {
        console.error('EasyMDE: An unexpected error occurred when trying to upload the image.'
            + event.target.status + ' (' + event.target.statusText + ')');
        onErrorSup(self.options.errorMessages.importError);
    };

    request.send(formData);

};

/**
 * Upload an image to the server using a custom upload function.
 *
 * @param imageUploadFunction {Function} The custom function to upload the image passed in options
 * @param file {File} The image to upload, as a HTML5 File object (https://developer.mozilla.org/en-US/docs/Web/API/File).
 */
EasyMDE.prototype.uploadImageUsingCustomFunction = function (imageUploadFunction, file) {
    var self = this;

    function onSuccess(imageUrl) {
        afterImageUploaded(self, imageUrl);
    }

    function onError(errorMessage) {
        var filledErrorMessage = fillErrorMessage(errorMessage);
        // show error on status bar and reset after 10000ms
        self.updateStatusBar('upload-image', filledErrorMessage);

        setTimeout(function () {
            self.updateStatusBar('upload-image', self.options.imageTexts.sbInit);
        }, 10000);

        // run error handler from options, this alerts the message.
        self.options.errorCallback(filledErrorMessage);
    }

    function fillErrorMessage(errorMessage) {
        var units = self.options.imageTexts.sizeUnits.split(',');
        return errorMessage
            .replace('#image_name#', file.name)
            .replace('#image_size#', humanFileSize(file.size, units))
            .replace('#image_max_size#', humanFileSize(self.options.imageMaxSize, units));
    }

    imageUploadFunction.apply(this, [file, onSuccess, onError]);
};

EasyMDE.prototype.setPreviewMaxHeight = function () {
    var cm = this.codemirror;
    var wrapper = cm.getWrapperElement();
    var preview = wrapper.nextSibling;

    // Calc preview max height
    var paddingTop = parseInt(window.getComputedStyle(wrapper).paddingTop);
    var borderTopWidth = parseInt(window.getComputedStyle(wrapper).borderTopWidth);
    var optionsMaxHeight = parseInt(this.options.maxHeight);
    var wrapperMaxHeight = optionsMaxHeight + paddingTop * 2 + borderTopWidth * 2;
    var previewMaxHeight = wrapperMaxHeight.toString() + 'px';

    preview.style.height = previewMaxHeight;
};

EasyMDE.prototype.createSideBySide = function () {
    var cm = this.codemirror;
    var wrapper = cm.getWrapperElement();
    var preview = wrapper.nextSibling;

    if (!preview || !preview.classList.contains('editor-preview-side')) {
        preview = document.createElement('div');
        preview.className = 'editor-preview-side';

        if (this.options.previewClass) {

            if (Array.isArray(this.options.previewClass)) {
                for (var i = 0; i < this.options.previewClass.length; i++) {
                    preview.classList.add(this.options.previewClass[i]);
                }

            } else if (typeof this.options.previewClass === 'string') {
                preview.classList.add(this.options.previewClass);
            }
        }

        wrapper.parentNode.insertBefore(preview, wrapper.nextSibling);
    }

    if (typeof this.options.maxHeight !== 'undefined') {
        this.setPreviewMaxHeight();
    }

    if (this.options.syncSideBySidePreviewScroll === false) return preview;
    // Syncs scroll  editor -> preview
    var cScroll = false;
    var pScroll = false;
    cm.on('scroll', function (v) {
        if (cScroll) {
            cScroll = false;
            return;
        }
        pScroll = true;
        var height = v.getScrollInfo().height - v.getScrollInfo().clientHeight;
        var ratio = parseFloat(v.getScrollInfo().top) / height;
        var move = (preview.scrollHeight - preview.clientHeight) * ratio;
        preview.scrollTop = move;
    });

    // Syncs scroll  preview -> editor
    preview.onscroll = function () {
        if (pScroll) {
            pScroll = false;
            return;
        }
        cScroll = true;
        var height = preview.scrollHeight - preview.clientHeight;
        var ratio = parseFloat(preview.scrollTop) / height;
        var move = (cm.getScrollInfo().height - cm.getScrollInfo().clientHeight) * ratio;
        cm.scrollTo(0, move);
    };
    return preview;
};

EasyMDE.prototype.createToolbar = function (items) {
    items = items || this.options.toolbar;

    if (!items || items.length === 0) {
        return;
    }
    var i;
    for (i = 0; i < items.length; i++) {
        if (toolbarBuiltInButtons[items[i]] != undefined) {
            items[i] = toolbarBuiltInButtons[items[i]];
        }
    }

    var bar = document.createElement('div');
    bar.className = 'editor-toolbar';
    bar.setAttribute('role', 'toolbar');

    var self = this;

    var toolbarData = {};
    self.toolbar = items;

    for (i = 0; i < items.length; i++) {
        if (items[i].name == 'guide' && self.options.toolbarGuideIcon === false)
            continue;

        if (self.options.hideIcons && self.options.hideIcons.indexOf(items[i].name) != -1)
            continue;

        // Fullscreen does not work well on mobile devices (even tablets)
        // In the future, hopefully this can be resolved
        if ((items[i].name == 'fullscreen' || items[i].name == 'side-by-side') && isMobile())
            continue;


        // Don't include trailing separators
        if (items[i] === '|') {
            var nonSeparatorIconsFollow = false;

            for (var x = (i + 1); x < items.length; x++) {
                if (items[x] !== '|' && (!self.options.hideIcons || self.options.hideIcons.indexOf(items[x].name) == -1)) {
                    nonSeparatorIconsFollow = true;
                }
            }

            if (!nonSeparatorIconsFollow)
                continue;
        }


        // Create the icon and append to the toolbar
        (function (item) {
            var el;
            if (item === '|') {
                el = createSep();
            } else if (item.children) {
                el = createToolbarDropdown(item, self.options.toolbarTips, self.options.shortcuts, self);
            } else {
                el = createToolbarButton(item, true, self.options.toolbarTips, self.options.shortcuts, 'button', self);
            }


            toolbarData[item.name || item] = el;
            bar.appendChild(el);

            // Create the input element (ie. <input type='file'>), used among
            // with the 'import-image' icon to open the browse-file window.
            if (item.name === 'upload-image') {
                var imageInput = document.createElement('input');
                imageInput.className = 'imageInput';
                imageInput.type = 'file';
                imageInput.multiple = true;
                imageInput.name = self.options.imageInputName;
                imageInput.accept = self.options.imageAccept;
                imageInput.style.display = 'none';
                imageInput.style.opacity = 0;
                bar.appendChild(imageInput);
            }
        })(items[i]);
    }

    self.toolbar_div = bar;
    self.toolbarElements = toolbarData;

    var cm = this.codemirror;
    cm.on('cursorActivity', function () {
        var stat = getState(cm);

        for (var key in toolbarData) {
            (function (key) {
                var el = toolbarData[key];
                if (stat[key]) {
                    el.classList.add('active');
                } else if (key != 'fullscreen' && key != 'side-by-side') {
                    el.classList.remove('active');
                }
            })(key);
        }
    });

    var cmWrapper = cm.getWrapperElement();
    cmWrapper.parentNode.insertBefore(bar, cmWrapper);
    return bar;
};

EasyMDE.prototype.createStatusbar = function (status) {
    // Initialize
    status = status || this.options.status;
    var options = this.options;
    var cm = this.codemirror;

    // Make sure the status variable is valid
    if (!status || status.length === 0) {
        return;
    }

    // Set up the built-in items
    var items = [];
    var i, onUpdate, onActivity, defaultValue;

    for (i = 0; i < status.length; i++) {
        // Reset some values
        onUpdate = undefined;
        onActivity = undefined;
        defaultValue = undefined;


        // Handle if custom or not
        if (typeof status[i] === 'object') {
            items.push({
                className: status[i].className,
                defaultValue: status[i].defaultValue,
                onUpdate: status[i].onUpdate,
                onActivity: status[i].onActivity,
            });
        } else {
            var name = status[i];

            if (name === 'words') {
                defaultValue = function (el) {
                    el.innerHTML = wordCount(cm.getValue());
                };
                onUpdate = function (el) {
                    el.innerHTML = wordCount(cm.getValue());
                };
            } else if (name === 'lines') {
                defaultValue = function (el) {
                    el.innerHTML = cm.lineCount();
                };
                onUpdate = function (el) {
                    el.innerHTML = cm.lineCount();
                };
            } else if (name === 'cursor') {
                defaultValue = function (el) {
                    el.innerHTML = '1:1';
                };
                onActivity = function (el) {
                    var pos = cm.getCursor();
                    var posLine = pos.line + 1;
                    var posColumn = pos.ch + 1;
                    el.innerHTML = posLine + ':' + posColumn;
                };
            } else if (name === 'autosave') {
                defaultValue = function (el) {
                    if (options.autosave != undefined && options.autosave.enabled === true) {
                        el.setAttribute('id', 'autosaved');
                    }
                };
            } else if (name === 'upload-image') {
                defaultValue = function (el) {
                    el.innerHTML = options.imageTexts.sbInit;
                };
            }

            items.push({
                className: name,
                defaultValue: defaultValue,
                onUpdate: onUpdate,
                onActivity: onActivity,
            });
        }
    }


    // Create element for the status bar
    var bar = document.createElement('div');
    bar.className = 'editor-statusbar';


    // Create a new span for each item
    for (i = 0; i < items.length; i++) {
        // Store in temporary variable
        var item = items[i];


        // Create span element
        var el = document.createElement('span');
        el.className = item.className;


        // Ensure the defaultValue is a function
        if (typeof item.defaultValue === 'function') {
            item.defaultValue(el);
        }


        // Ensure the onUpdate is a function
        if (typeof item.onUpdate === 'function') {
            // Create a closure around the span of the current action, then execute the onUpdate handler
            this.codemirror.on('update', (function (el, item) {
                return function () {
                    item.onUpdate(el);
                };
            }(el, item)));
        }
        if (typeof item.onActivity === 'function') {
            // Create a closure around the span of the current action, then execute the onActivity handler
            this.codemirror.on('cursorActivity', (function (el, item) {
                return function () {
                    item.onActivity(el);
                };
            }(el, item)));
        }


        // Append the item to the status bar
        bar.appendChild(el);
    }


    // Insert the status bar into the DOM
    var cmWrapper = this.codemirror.getWrapperElement();
    cmWrapper.parentNode.insertBefore(bar, cmWrapper.nextSibling);
    return bar;
};

/**
 * Get or set the text content.
 */
EasyMDE.prototype.value = function (val) {
    var cm = this.codemirror;
    if (val === undefined) {
        return cm.getValue();
    } else {
        cm.getDoc().setValue(val);
        if (this.isPreviewActive()) {
            var wrapper = cm.getWrapperElement();
            var preview = wrapper.lastChild;
            var preview_result = this.options.previewRender(val, preview);
            if (preview_result !== null) {
                preview.innerHTML = preview_result;
            }

        }
        return this;
    }
};


/**
 * Bind static methods for exports.
 */
EasyMDE.toggleBold = toggleBold;
EasyMDE.toggleItalic = toggleItalic;
EasyMDE.toggleStrikethrough = toggleStrikethrough;
EasyMDE.toggleBlockquote = toggleBlockquote;
EasyMDE.toggleHeadingSmaller = toggleHeadingSmaller;
EasyMDE.toggleHeadingBigger = toggleHeadingBigger;
EasyMDE.toggleHeading1 = toggleHeading1;
EasyMDE.toggleHeading2 = toggleHeading2;
EasyMDE.toggleHeading3 = toggleHeading3;
EasyMDE.toggleHeading4 = toggleHeading4;
EasyMDE.toggleHeading5 = toggleHeading5;
EasyMDE.toggleHeading6 = toggleHeading6;
EasyMDE.toggleCodeBlock = toggleCodeBlock;
EasyMDE.toggleUnorderedList = toggleUnorderedList;
EasyMDE.toggleOrderedList = toggleOrderedList;
EasyMDE.cleanBlock = cleanBlock;
EasyMDE.drawLink = drawLink;
EasyMDE.drawImage = drawImage;
EasyMDE.drawUploadedImage = drawUploadedImage;
EasyMDE.drawTable = drawTable;
EasyMDE.drawHorizontalRule = drawHorizontalRule;
EasyMDE.undo = undo;
EasyMDE.redo = redo;
EasyMDE.togglePreview = togglePreview;
EasyMDE.toggleSideBySide = toggleSideBySide;
EasyMDE.toggleFullScreen = toggleFullScreen;

/**
 * Bind instance methods for exports.
 */
EasyMDE.prototype.toggleBold = function () {
    toggleBold(this);
};
EasyMDE.prototype.toggleItalic = function () {
    toggleItalic(this);
};
EasyMDE.prototype.toggleStrikethrough = function () {
    toggleStrikethrough(this);
};
EasyMDE.prototype.toggleBlockquote = function () {
    toggleBlockquote(this);
};
EasyMDE.prototype.toggleHeadingSmaller = function () {
    toggleHeadingSmaller(this);
};
EasyMDE.prototype.toggleHeadingBigger = function () {
    toggleHeadingBigger(this);
};
EasyMDE.prototype.toggleHeading1 = function () {
    toggleHeading1(this);
};
EasyMDE.prototype.toggleHeading2 = function () {
    toggleHeading2(this);
};
EasyMDE.prototype.toggleHeading3 = function () {
    toggleHeading3(this);
};
EasyMDE.prototype.toggleHeading4 = function () {
    toggleHeading4(this);
};
EasyMDE.prototype.toggleHeading5 = function () {
    toggleHeading5(this);
};
EasyMDE.prototype.toggleHeading6 = function () {
    toggleHeading6(this);
};
EasyMDE.prototype.toggleCodeBlock = function () {
    toggleCodeBlock(this);
};
EasyMDE.prototype.toggleUnorderedList = function () {
    toggleUnorderedList(this);
};
EasyMDE.prototype.toggleOrderedList = function () {
    toggleOrderedList(this);
};
EasyMDE.prototype.cleanBlock = function () {
    cleanBlock(this);
};
EasyMDE.prototype.drawLink = function () {
    drawLink(this);
};
EasyMDE.prototype.drawImage = function () {
    drawImage(this);
};
EasyMDE.prototype.drawUploadedImage = function () {
    drawUploadedImage(this);
};
EasyMDE.prototype.drawTable = function () {
    drawTable(this);
};
EasyMDE.prototype.drawHorizontalRule = function () {
    drawHorizontalRule(this);
};
EasyMDE.prototype.undo = function () {
    undo(this);
};
EasyMDE.prototype.redo = function () {
    redo(this);
};
EasyMDE.prototype.togglePreview = function () {
    togglePreview(this);
};
EasyMDE.prototype.toggleSideBySide = function () {
    toggleSideBySide(this);
};
EasyMDE.prototype.toggleFullScreen = function () {
    toggleFullScreen(this);
};

EasyMDE.prototype.isPreviewActive = function () {
    var cm = this.codemirror;
    var wrapper = cm.getWrapperElement();
    var preview = wrapper.lastChild;

    return preview.classList.contains('editor-preview-active');
};

EasyMDE.prototype.isSideBySideActive = function () {
    var cm = this.codemirror;
    var wrapper = cm.getWrapperElement();
    var preview = wrapper.nextSibling;

    return preview.classList.contains('editor-preview-active-side');
};

EasyMDE.prototype.isFullscreenActive = function () {
    var cm = this.codemirror;

    return cm.getOption('fullScreen');
};

EasyMDE.prototype.getState = function () {
    var cm = this.codemirror;

    return getState(cm);
};

EasyMDE.prototype.toTextArea = function () {
    var cm = this.codemirror;
    var wrapper = cm.getWrapperElement();
    var easyMDEContainer = wrapper.parentNode;

    if (easyMDEContainer) {
        if (this.gui.toolbar) {
            easyMDEContainer.removeChild(this.gui.toolbar);
        }
        if (this.gui.statusbar) {
            easyMDEContainer.removeChild(this.gui.statusbar);
        }
        if (this.gui.sideBySide) {
            easyMDEContainer.removeChild(this.gui.sideBySide);
        }
    }

    // Unwrap easyMDEcontainer before codemirror toTextArea() call
    easyMDEContainer.parentNode.insertBefore(wrapper, easyMDEContainer);
    easyMDEContainer.remove();

    cm.toTextArea();

    if (this.autosaveTimeoutId) {
        clearTimeout(this.autosaveTimeoutId);
        this.autosaveTimeoutId = undefined;
        this.clearAutosavedValue();
    }
};

module.exports = EasyMDE;


/***/ }),

/***/ "./node_modules/guifier/dist/Guifier.js":
/*!**********************************************!*\
  !*** ./node_modules/guifier/dist/Guifier.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ bE; }
/* harmony export */ });
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
(function(){"use strict";try{if(typeof document<"u"){var e=document.createElement("style");e.appendChild(document.createTextNode('@font-face{font-family:Material Icons Outlined;font-style:normal;font-weight:400;font-display:block;src:url(data:font/woff2;base64,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) format("woff2"),url(data:font/woff;base64,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) format("woff")}.material-icons-outlined{font-family:Material Icons Outlined;font-weight:400;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;text-rendering:optimizeLegibility;font-feature-settings:"liga"}.guifierObjectContainerbody{display:grid;grid-template-columns:1fr 1fr;grid-gap:var(--primary-grid-gap);padding:var(--primary-padding)}.guifierObjectLabelContainer{display:flex}.guifierObjectFieldContainer{position:relative}.guifierObjectLabelTextPart{display:flex;justify-content:flex-start;align-items:center;gap:5px;transition:.3s;transform-origin:left bottom;transform:translateY(0);font-weight:700}.guifierDescriptionSymbol{display:flex;justify-content:center;align-items:center;border-radius:100%;border:var(--second-border);width:20px;height:20px;font-size:small;font-weight:bolder;color:var(--second-color);cursor:pointer}.descriptionTooltipRefrence{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none}.guifierObjectLabelContainer:hover~.guifierDescriptionTooltip{opacity:1}.guifierObjectFieldContainer:hover>.guifierObjectLabelContainer>.guifierObjectLabelTextPart{transform:translateY(-7px)}.guifierObjectLabelButtonsPart{position:relative}.fieldButtons{position:absolute;display:flex;z-index:1;gap:5px;bottom:0px;left:0;padding-bottom:3px;padding-left:10px;pointer-events:none}.fieldButtons>*{color:var(--third-color);border:var(--second-border);padding:5px;border-radius:100%;opacity:0;transform:translateY(75%);transition:.2s ease;cursor:pointer;font-size:large}.guifierMainWrapper{position:relative;height:100%}.guifierContainer{display:flex;flex-direction:column;height:100%;border:var(--primary-border);border-radius:var(--primary-border-radius)}.guifierContainerHeader{position:relative;display:flex;justify-content:space-between;font-size:larger;color:var(--third-color);padding:var(--header-horizontal-padding) var(--primary-grid-gap);padding-right:15px}.guifierContainerHeader .guifierDescriptionTooltip{width:95%}.guifierContainerHeader:hover .guifierDescriptionTooltip{opacity:1}.guifierContainerHeaderButtons{display:flex;align-items:center;font-size:xx-large;gap:10px}.guifierContainerHeaderButtons>*{font-size:25px;cursor:pointer;opacity:0;transform:translateY(75%);transition:.2s ease}.guifierContainerCollapseButton{opacity:1;transform:translateY(0)}.guifierContainerHeaderKeyName{display:flex;align-items:center;gap:5px;font-weight:700}.guifierEmptyContentContianer{display:flex;flex-direction:row;grid-column:span 2;height:175px}.emptyContentContianerWrapper{display:flex;flex-direction:column;justify-content:center;align-items:center;flex:1;padding:0px var(--primary-padding);grid-column:span 2}.guifierArrayContainerbody .emptyContentContianerWrapper{padding:var(--primary-padding)}.guifierEmptyTitle{margin:0;color:var(--third-color);font-size:large}.guifierEmptyParagraph{text-align:center;max-width:375px;margin-top:7.5px;margin-bottom:7.5px;color:#00000080;font-size:medium}.guifierEmptyButton{display:flex;align-items:center;gap:5px;background-color:var(--primary-color);padding:5px 10px 5px 19px;border-radius:var(--primary-border-radius);color:#fff;cursor:pointer;font-weight:700;font-size:small;margin-top:15px}.guifierEmptyButton:hover{background-color:#1d5dffec;background:linear-gradient(rgba(255,255,255,.1),rgba(255,255,255,.1)),linear-gradient(var(--primary-color),var(--primary-color))}.guifierObjectLabelContainer{color:var(--third-color);font-size:medium;margin:3px}.guifierDialogBackgroundContainer{position:absolute;display:flex;justify-content:center;align-items:center;background-color:#ffffff80;top:0;bottom:0;width:100%;height:100%;z-index:1000;transition:.15s;opacity:1;backdrop-filter:blur(2px);border-radius:var(--primary-border-radius);padding:20px}.guifierDialogContainer{display:flex;flex-direction:column;justify-content:space-between;width:100%;height:100%;max-width:450px;max-height:550px;background-color:#fff;box-shadow:#fff 0 0 100px;border:var(--primary-border);border-radius:var(--primary-border-radius)}.guifierDialogContainerTitle{position:relative;display:flex;justify-content:center;align-items:center;font-size:larger;border-bottom:var(--primary-border);padding:15px;gap:5px}.guifierDialogContainerBody{overflow:auto;flex:1}.guifierDialogFooter{display:flex;justify-content:space-evenly;gap:20px;padding:15px;border-top:var(--primary-border)}.guifierDialogButton{display:flex;justify-content:center;align-items:center;padding:12.5px 35px;border-radius:var(--primary-border-radius);cursor:pointer;font-size:15px;font-weight:700}.guifierDialogCancelButton{border:var(--primary-border);background-color:var(--fourth-color);color:var(--third-color)}.guifierDialogCancelButton:hover{background-color:#eeeff3}.guifierDialogConfirmButton{background-color:var(--primary-color);color:#fff}.guifierDialogConfirmButton:hover{background-color:#366fff}.guifierArrayContainerbody{display:flex;flex-direction:column;flex:1;overflow-x:hidden}.guifierArrayFieldContainer{display:flex;align-items:stretch;transition:.15s;border-bottom:1px solid rgba(0,0,0,.075);padding-right:var(--primary-padding);opacity:1;height:100%}.guifierArrayfieldInnerContainer{display:flex;align-items:center;flex:1;width:100%;margin-bottom:var(--second-padding);margin-top:var(--second-padding)}.guifierArrayCollapsibleElement{display:flex;align-items:center;flex:1;justify-content:space-between;height:100%;color:var(--third-color)}.guifierFieldLabelName{display:flex;align-items:center;font-size:larger;height:45px}.guifierArrayLabelContainer{position:relative;display:flex;height:100%;flex-direction:column;align-items:center;justify-content:flex-start;transform:translate(-50%);padding-right:var(--primary-border-width)}.guifierArrayLabelContainerForUpperLevel{transform:none;width:70px}.guifierArrayLabelLineForUpperLevel{position:absolute;width:50%;transform:translate(-50%);border-bottom:var(--primary-dashed-border);margin-left:6px;margin-top:calc(var(--primary-padding) + 12.5px)}.guifierArrayIndexLabel{position:relative;z-index:1;display:flex;justify-content:center;align-items:center;height:35px;width:35px;margin-top:15px;background-color:#fff;border:var(--primary-border);border-radius:100%;color:var(--third-color);background-color:var(--fourth-color);font-weight:700}.guifierArrayMainContainerbody{display:flex}.guifierArrayLevelsContainer{display:flex;height:100%}.guifierArrayLevelElement{width:35px;height:100%;background-color:transparent;border-right:var(--primary-dashed-border)}.guifierArrayLevelElement:first-of-type{width:35px;height:100%;background-color:transparent;border-right:var(--primary-dashed-border)}.guifierCollapsibleElementContent{display:flex;position:relative;z-index:1;height:100%;border-bottom:1px solid rgba(0,0,0,.075)}.guifierCollapsibleElementInnerContentContainer{padding:20px 20px 20px 35px;flex:1}.guifierArrayFieldDeleteButton{display:flex;align-items:flex-start;color:var(--third-color);width:0px;padding-left:0;transition:.3s;opacity:0;cursor:pointer;margin-top:var(--primary-padding)}.guifierArrayFieldContainer:hover .guifierArrayFieldDeleteButton{padding-left:var(--second-padding);width:34px;opacity:1}.guifierContainerFieldType{height:66px}.guifierTextField{padding:7.5px 15px;border-radius:var(--primary-border-radius);border:var(--primary-border);outline:3px solid transparent;transition:.15s;width:100%;height:45px;font-size:medium}.guifierTextField:focus{border:2px solid var(--primary-color);outline:3px solid var(--second-color)}.guifierNumberInputContainer{display:flex;gap:6px;position:relative;flex:1}.guifierNumberField{padding:7.5px 15px;border-radius:var(--primary-border-radius);border:var(--primary-border);outline:3px solid transparent;transition:.15s;width:100%;height:45px;font-size:medium}.guifierNumberField:focus{border:2px solid var(--primary-color);outline:3px solid var(--second-color)}.guifierNumberField::-webkit-inner-spin-button,.guifierNumberField::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.guifierNumberField{appearance:textfield;-moz-appearance:textfield}.guifierButtonsContainer{display:flex;flex-direction:column-reverse;flex:1}.guifierNumberButton{display:flex;flex:1;justify-content:center;align-items:center;width:30px;color:#888e9d;cursor:pointer;border:var(--primary-border)}.guifierNumberButton:first-child{border-radius:0 0 var(--primary-border-radius) var(--primary-border-radius)}.guifierNumberButton:last-child{border-radius:var(--primary-border-radius) var(--primary-border-radius) 0 0;border-bottom:none}.guifierNumberButton span{font-size:small}.guifierBooleanField{display:flex;gap:2px;height:45px;padding:4px;border:var(--primary-border);border-radius:var(--primary-border-radius);width:fit-content;color:#00000080;overflow:hidden;font-size:medium}.guifierBooleanElement{display:flex;justify-content:center;align-items:center;padding:0 10px;border-radius:var(--primary-border-radius);border:2px solid transparent;transition:.15s;cursor:pointer}.guifierBooleanTrueElementSelect{background-color:#bcffc3;border:2px solid #A0E4A7}.guifierBooleanFalseElementSelect{background-color:#ffbcbc;border:2px solid #E4A0A0}.guifierNullField{display:flex;align-items:center;justify-content:center;color:#888e9d;border-radius:var(--primary-border-radius);border:var(--primary-border);height:45px;width:fit-content;padding:20px;gap:7.5px}.guifierCardsContainer{display:grid;grid-template-columns:1fr 1fr;gap:10px}.guifierCard{box-sizing:content-box!important;display:flex;flex-direction:column;justify-content:center;align-items:center;border:var(--primary-border);border-radius:var(--primary-border-radius);padding:15px;height:75px;cursor:pointer;transition:.15s;outline:3px solid transparent}.guifierCard:hover{border-color:#00000040;background-color:#00000006}.cardIconElement .material-icons-outlined{font-size:40px!important;color:#000000bf}.guifierSelectedCard{border-color:var(--primary-color)!important;outline:3px solid var(--second-color)}.cardTextElement{margin-top:10px}:root{--primary-color: #1D5EFF;--second-color: #B7C7F2;--third-color: #575757;--fourth-color: #F5F7FB;--fifth-color: #FFFFFF;--sixth-color: #CDD0DE;--primary-padding: 20px;--second-padding: 10px;--primary-grid-gap: 20px;--header-horizontal-padding: 15px;--primary-border-radius: 10px;--primary-border-width: 2px;--primary-border: var(--primary-border-width) solid var(--sixth-color);--second-border: 1px solid var(--sixth-color);--primary-dashed-border: var(--primary-border-width) dashed var(--sixth-color);--primary-selected-border: var(--primary-border-width) solid #1D5EFF}.guifierMainWrapper *,.guifierErrorContainer *{box-sizing:border-box;font-family:Roboto,Arial,Helvetica,sans-serif}.material-icons-outlined{font-family:Material Icons Outlined}.material-icons-outlined::selection{background-color:transparent}.guifierFullHeight{height:100%}.guifierHeightZero{height:0!important}.guifierPrimaryBgColor{background-color:var(--fourth-color)}.guifierSecondaryBgColor{background-color:var(--fifth-color)}.guifierPrimaryMarginTop{margin-top:var(--primary-padding)}.guifierPrimaryMarginBottom{margin-bottom:var(--primary-padding)}.guifierPrimaryTextColor{color:var(--third-color)}.guifierPrimaryTextMediumSize{font-size:medium}.guifierRotate{transform:rotate(180deg)}.guifierPrimaryBottomBorder{border-bottom:var(--primary-border)}.guifierNoneDisplay{display:none!important}.guifierOddBackground{background-color:#49494909}.guifierOpacityZero{opacity:0;pointer-events:none}.guifierShowElementWithAnimation{opacity:1;transform:translateY(0)}.guifierRemovePadding{padding:0!important}.guifierErrorContainer{background-color:#ff00001a;border-radius:var(--primary-border-radius);border:2px solid rgba(255,0,0,.25);height:100%}.guifierErrorContainerError{border-bottom:2px solid rgba(255,0,0,.25);padding:var(--primary-padding);font-weight:700;color:maroon}.guifierErrorContainerContent{padding:var(--primary-padding);font-weight:700;color:#b60000}.guifierDescriptionTooltip{position:absolute;bottom:15px;left:15px;width:100%;background-color:#fff;opacity:0;height:fit-content;font-weight:400;font-size:medium;z-index:1;transition:.25s;pointer-events:none;color:var(--third-color);border-radius:var(--primary-border-radius)}.guifierDescriptionTooltip .descriptionHeader{display:flex;align-items:center;gap:7.5px;border:var(--primary-border);padding:7.5px;border-radius:var(--primary-border-radius) var(--primary-border-radius) 0 0;font-weight:700}.guifierDescriptionTooltip .descriptionHeader .guifierDescriptionSymbol{color:#00000080;border-color:#00000080}.guifierDescriptionTooltip .descriptionHeader .descriptionFieldType{color:#7b68ee}.guifierDescriptionTooltip .descriptionBody{border:var(--primary-border);border-top:none;padding:var(--second-padding);border-radius:0 0 var(--primary-border-radius) var(--primary-border-radius)}')),document.head.appendChild(e)}}catch(o){console.error("vite-plugin-css-injected-by-js",o)}})();
var f_ = Object.defineProperty;
var d_ = (e, t, r) => t in e ? f_(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var B = (e, t, r) => (d_(e, typeof t != "symbol" ? t + "" : t, r), r), Zc = (e, t, r) => {
  if (!t.has(e))
    throw TypeError("Cannot " + r);
};
var Pe = (e, t, r) => (Zc(e, t, "read from private field"), r ? r.call(e) : t.get(e)), as = (e, t, r) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, r);
}, Mt = (e, t, r, s) => (Zc(e, t, "write to private field"), s ? s.call(e, r) : t.set(e, r), r);
var Wn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function $o(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Of = { exports: {} };
(function(e) {
  var t = function() {
    function r(T, A) {
      return A != null && T instanceof A;
    }
    var s;
    try {
      s = Map;
    } catch {
      s = function() {
      };
    }
    var a;
    try {
      a = Set;
    } catch {
      a = function() {
      };
    }
    var l;
    try {
      l = Promise;
    } catch {
      l = function() {
      };
    }
    function u(T, A, C, E, P) {
      typeof A == "object" && (C = A.depth, E = A.prototype, P = A.includeNonEnumerable, A = A.circular);
      var U = [], H = [], $ = typeof Buffer < "u";
      typeof A > "u" && (A = !0), typeof C > "u" && (C = 1 / 0);
      function Z(k, se) {
        if (k === null)
          return null;
        if (se === 0)
          return k;
        var Y, ge;
        if (typeof k != "object")
          return k;
        if (r(k, s))
          Y = new s();
        else if (r(k, a))
          Y = new a();
        else if (r(k, l))
          Y = new l(function(Se, $e) {
            k.then(function(Nn) {
              Se(Z(Nn, se - 1));
            }, function(Nn) {
              $e(Z(Nn, se - 1));
            });
          });
        else if (u.__isArray(k))
          Y = [];
        else if (u.__isRegExp(k))
          Y = new RegExp(k.source, x(k)), k.lastIndex && (Y.lastIndex = k.lastIndex);
        else if (u.__isDate(k))
          Y = new Date(k.getTime());
        else {
          if ($ && Buffer.isBuffer(k))
            return Buffer.allocUnsafe ? Y = Buffer.allocUnsafe(k.length) : Y = new Buffer(k.length), k.copy(Y), Y;
          r(k, Error) ? Y = Object.create(k) : typeof E > "u" ? (ge = Object.getPrototypeOf(k), Y = Object.create(ge)) : (Y = Object.create(E), ge = E);
        }
        if (A) {
          var jt = U.indexOf(k);
          if (jt != -1)
            return H[jt];
          U.push(k), H.push(Y);
        }
        r(k, s) && k.forEach(function(Se, $e) {
          var Nn = Z($e, se - 1), er = Z(Se, se - 1);
          Y.set(Nn, er);
        }), r(k, a) && k.forEach(function(Se) {
          var $e = Z(Se, se - 1);
          Y.add($e);
        });
        for (var Me in k) {
          var cn;
          ge && (cn = Object.getOwnPropertyDescriptor(ge, Me)), !(cn && cn.set == null) && (Y[Me] = Z(k[Me], se - 1));
        }
        if (Object.getOwnPropertySymbols)
          for (var dt = Object.getOwnPropertySymbols(k), Me = 0; Me < dt.length; Me++) {
            var Gt = dt[Me], Ze = Object.getOwnPropertyDescriptor(k, Gt);
            Ze && !Ze.enumerable && !P || (Y[Gt] = Z(k[Gt], se - 1), Ze.enumerable || Object.defineProperty(Y, Gt, {
              enumerable: !1
            }));
          }
        if (P)
          for (var At = Object.getOwnPropertyNames(k), Me = 0; Me < At.length; Me++) {
            var it = At[Me], Ze = Object.getOwnPropertyDescriptor(k, it);
            Ze && Ze.enumerable || (Y[it] = Z(k[it], se - 1), Object.defineProperty(Y, it, {
              enumerable: !1
            }));
          }
        return Y;
      }
      return Z(T, C);
    }
    u.clonePrototype = function(A) {
      if (A === null)
        return null;
      var C = function() {
      };
      return C.prototype = A, new C();
    };
    function f(T) {
      return Object.prototype.toString.call(T);
    }
    u.__objToStr = f;
    function d(T) {
      return typeof T == "object" && f(T) === "[object Date]";
    }
    u.__isDate = d;
    function g(T) {
      return typeof T == "object" && f(T) === "[object Array]";
    }
    u.__isArray = g;
    function _(T) {
      return typeof T == "object" && f(T) === "[object RegExp]";
    }
    u.__isRegExp = _;
    function x(T) {
      var A = "";
      return T.global && (A += "g"), T.ignoreCase && (A += "i"), T.multiline && (A += "m"), A;
    }
    return u.__getRegExpFlags = x, u;
  }();
  e.exports && (e.exports = t);
})(Of);
var h_ = Of.exports;
const Vc = /* @__PURE__ */ $o(h_);
var Do = {}, ks = {};
(function(e) {
  const t = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", r = t + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040", s = "[" + t + "][" + r + "]*", a = new RegExp("^" + s + "$"), l = function(f, d) {
    const g = [];
    let _ = d.exec(f);
    for (; _; ) {
      const x = [];
      x.startIndex = d.lastIndex - _[0].length;
      const T = _.length;
      for (let A = 0; A < T; A++)
        x.push(_[A]);
      g.push(x), _ = d.exec(f);
    }
    return g;
  }, u = function(f) {
    const d = a.exec(f);
    return !(d === null || typeof d > "u");
  };
  e.isExist = function(f) {
    return typeof f < "u";
  }, e.isEmptyObject = function(f) {
    return Object.keys(f).length === 0;
  }, e.merge = function(f, d, g) {
    if (d) {
      const _ = Object.keys(d), x = _.length;
      for (let T = 0; T < x; T++)
        g === "strict" ? f[_[T]] = [d[_[T]]] : f[_[T]] = d[_[T]];
    }
  }, e.getValue = function(f) {
    return e.isExist(f) ? f : "";
  }, e.isName = u, e.getAllMatches = l, e.nameRegexp = s;
})(ks);
const Wo = ks, p_ = {
  allowBooleanAttributes: !1,
  //A tag can have attributes without any value
  unpairedTags: []
};
Do.validate = function(e, t) {
  t = Object.assign({}, p_, t);
  const r = [];
  let s = !1, a = !1;
  e[0] === "\uFEFF" && (e = e.substr(1));
  for (let l = 0; l < e.length; l++)
    if (e[l] === "<" && e[l + 1] === "?") {
      if (l += 2, l = Gc(e, l), l.err)
        return l;
    } else if (e[l] === "<") {
      let u = l;
      if (l++, e[l] === "!") {
        l = Yc(e, l);
        continue;
      } else {
        let f = !1;
        e[l] === "/" && (f = !0, l++);
        let d = "";
        for (; l < e.length && e[l] !== ">" && e[l] !== " " && e[l] !== "	" && e[l] !== `
` && e[l] !== "\r"; l++)
          d += e[l];
        if (d = d.trim(), d[d.length - 1] === "/" && (d = d.substring(0, d.length - 1), l--), !b_(d)) {
          let x;
          return d.trim().length === 0 ? x = "Invalid space after '<'." : x = "Tag '" + d + "' is an invalid name.", Ce("InvalidTag", x, Qe(e, l));
        }
        const g = v_(e, l);
        if (g === !1)
          return Ce("InvalidAttr", "Attributes for '" + d + "' have open quote.", Qe(e, l));
        let _ = g.value;
        if (l = g.index, _[_.length - 1] === "/") {
          const x = l - _.length;
          _ = _.substring(0, _.length - 1);
          const T = qc(_, t);
          if (T === !0)
            s = !0;
          else
            return Ce(T.err.code, T.err.msg, Qe(e, x + T.err.line));
        } else if (f)
          if (g.tagClosed) {
            if (_.trim().length > 0)
              return Ce("InvalidTag", "Closing tag '" + d + "' can't have attributes or invalid starting.", Qe(e, u));
            {
              const x = r.pop();
              if (d !== x.tagName) {
                let T = Qe(e, x.tagStartPos);
                return Ce(
                  "InvalidTag",
                  "Expected closing tag '" + x.tagName + "' (opened in line " + T.line + ", col " + T.col + ") instead of closing tag '" + d + "'.",
                  Qe(e, u)
                );
              }
              r.length == 0 && (a = !0);
            }
          } else
            return Ce("InvalidTag", "Closing tag '" + d + "' doesn't have proper closing.", Qe(e, l));
        else {
          const x = qc(_, t);
          if (x !== !0)
            return Ce(x.err.code, x.err.msg, Qe(e, l - _.length + x.err.line));
          if (a === !0)
            return Ce("InvalidXml", "Multiple possible root nodes found.", Qe(e, l));
          t.unpairedTags.indexOf(d) !== -1 || r.push({ tagName: d, tagStartPos: u }), s = !0;
        }
        for (l++; l < e.length; l++)
          if (e[l] === "<")
            if (e[l + 1] === "!") {
              l++, l = Yc(e, l);
              continue;
            } else if (e[l + 1] === "?") {
              if (l = Gc(e, ++l), l.err)
                return l;
            } else
              break;
          else if (e[l] === "&") {
            const x = x_(e, l);
            if (x == -1)
              return Ce("InvalidChar", "char '&' is not expected.", Qe(e, l));
            l = x;
          } else if (a === !0 && !jc(e[l]))
            return Ce("InvalidXml", "Extra text at the end", Qe(e, l));
        e[l] === "<" && l--;
      }
    } else {
      if (jc(e[l]))
        continue;
      return Ce("InvalidChar", "char '" + e[l] + "' is not expected.", Qe(e, l));
    }
  if (s) {
    if (r.length == 1)
      return Ce("InvalidTag", "Unclosed tag '" + r[0].tagName + "'.", Qe(e, r[0].tagStartPos));
    if (r.length > 0)
      return Ce("InvalidXml", "Invalid '" + JSON.stringify(r.map((l) => l.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
  } else
    return Ce("InvalidXml", "Start tag expected.", 1);
  return !0;
};
function jc(e) {
  return e === " " || e === "	" || e === `
` || e === "\r";
}
function Gc(e, t) {
  const r = t;
  for (; t < e.length; t++)
    if (e[t] == "?" || e[t] == " ") {
      const s = e.substr(r, t - r);
      if (t > 5 && s === "xml")
        return Ce("InvalidXml", "XML declaration allowed only at the start of the document.", Qe(e, t));
      if (e[t] == "?" && e[t + 1] == ">") {
        t++;
        break;
      } else
        continue;
    }
  return t;
}
function Yc(e, t) {
  if (e.length > t + 5 && e[t + 1] === "-" && e[t + 2] === "-") {
    for (t += 3; t < e.length; t++)
      if (e[t] === "-" && e[t + 1] === "-" && e[t + 2] === ">") {
        t += 2;
        break;
      }
  } else if (e.length > t + 8 && e[t + 1] === "D" && e[t + 2] === "O" && e[t + 3] === "C" && e[t + 4] === "T" && e[t + 5] === "Y" && e[t + 6] === "P" && e[t + 7] === "E") {
    let r = 1;
    for (t += 8; t < e.length; t++)
      if (e[t] === "<")
        r++;
      else if (e[t] === ">" && (r--, r === 0))
        break;
  } else if (e.length > t + 9 && e[t + 1] === "[" && e[t + 2] === "C" && e[t + 3] === "D" && e[t + 4] === "A" && e[t + 5] === "T" && e[t + 6] === "A" && e[t + 7] === "[") {
    for (t += 8; t < e.length; t++)
      if (e[t] === "]" && e[t + 1] === "]" && e[t + 2] === ">") {
        t += 2;
        break;
      }
  }
  return t;
}
const g_ = '"', m_ = "'";
function v_(e, t) {
  let r = "", s = "", a = !1;
  for (; t < e.length; t++) {
    if (e[t] === g_ || e[t] === m_)
      s === "" ? s = e[t] : s !== e[t] || (s = "");
    else if (e[t] === ">" && s === "") {
      a = !0;
      break;
    }
    r += e[t];
  }
  return s !== "" ? !1 : {
    value: r,
    index: t,
    tagClosed: a
  };
}
const y_ = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
function qc(e, t) {
  const r = Wo.getAllMatches(e, y_), s = {};
  for (let a = 0; a < r.length; a++) {
    if (r[a][1].length === 0)
      return Ce("InvalidAttr", "Attribute '" + r[a][2] + "' has no space in starting.", ni(r[a]));
    if (r[a][3] !== void 0 && r[a][4] === void 0)
      return Ce("InvalidAttr", "Attribute '" + r[a][2] + "' is without value.", ni(r[a]));
    if (r[a][3] === void 0 && !t.allowBooleanAttributes)
      return Ce("InvalidAttr", "boolean attribute '" + r[a][2] + "' is not allowed.", ni(r[a]));
    const l = r[a][2];
    if (!w_(l))
      return Ce("InvalidAttr", "Attribute '" + l + "' is an invalid name.", ni(r[a]));
    if (!s.hasOwnProperty(l))
      s[l] = 1;
    else
      return Ce("InvalidAttr", "Attribute '" + l + "' is repeated.", ni(r[a]));
  }
  return !0;
}
function __(e, t) {
  let r = /\d/;
  for (e[t] === "x" && (t++, r = /[\da-fA-F]/); t < e.length; t++) {
    if (e[t] === ";")
      return t;
    if (!e[t].match(r))
      break;
  }
  return -1;
}
function x_(e, t) {
  if (t++, e[t] === ";")
    return -1;
  if (e[t] === "#")
    return t++, __(e, t);
  let r = 0;
  for (; t < e.length; t++, r++)
    if (!(e[t].match(/\w/) && r < 20)) {
      if (e[t] === ";")
        break;
      return -1;
    }
  return t;
}
function Ce(e, t, r) {
  return {
    err: {
      code: e,
      msg: t,
      line: r.line || r,
      col: r.col
    }
  };
}
function w_(e) {
  return Wo.isName(e);
}
function b_(e) {
  return Wo.isName(e);
}
function Qe(e, t) {
  const r = e.substring(0, t).split(/\r?\n/);
  return {
    line: r.length,
    // column number is last line's length + 1, because column numbering starts at 1:
    col: r[r.length - 1].length + 1
  };
}
function ni(e) {
  return e.startIndex + e[1].length;
}
var Uo = {};
const Nf = {
  preserveOrder: !1,
  attributeNamePrefix: "@_",
  attributesGroupName: !1,
  textNodeName: "#text",
  ignoreAttributes: !0,
  removeNSPrefix: !1,
  // remove NS from tag name or attribute name if true
  allowBooleanAttributes: !1,
  //a tag can have attributes without any value
  //ignoreRootElement : false,
  parseTagValue: !0,
  parseAttributeValue: !1,
  trimValues: !0,
  //Trim string values of tag and attributes
  cdataPropName: !1,
  numberParseOptions: {
    hex: !0,
    leadingZeros: !0,
    eNotation: !0
  },
  tagValueProcessor: function(e, t) {
    return t;
  },
  attributeValueProcessor: function(e, t) {
    return t;
  },
  stopNodes: [],
  //nested tags will not be parsed even for errors
  alwaysCreateTextNode: !1,
  isArray: () => !1,
  commentPropName: !1,
  unpairedTags: [],
  processEntities: !0,
  htmlEntities: !1,
  ignoreDeclaration: !1,
  ignorePiTags: !1,
  transformTagName: !1,
  transformAttributeName: !1,
  updateTag: function(e, t, r) {
    return e;
  }
  // skipEmptyListItem: false
}, E_ = function(e) {
  return Object.assign({}, Nf, e);
};
Uo.buildOptions = E_;
Uo.defaultOptions = Nf;
class A_ {
  constructor(t) {
    this.tagname = t, this.child = [], this[":@"] = {};
  }
  add(t, r) {
    t === "__proto__" && (t = "#__proto__"), this.child.push({ [t]: r });
  }
  addChild(t) {
    t.tagname === "__proto__" && (t.tagname = "#__proto__"), t[":@"] && Object.keys(t[":@"]).length > 0 ? this.child.push({ [t.tagname]: t.child, [":@"]: t[":@"] }) : this.child.push({ [t.tagname]: t.child });
  }
}
var C_ = A_;
const T_ = ks;
function S_(e, t) {
  const r = {};
  if (e[t + 3] === "O" && e[t + 4] === "C" && e[t + 5] === "T" && e[t + 6] === "Y" && e[t + 7] === "P" && e[t + 8] === "E") {
    t = t + 9;
    let s = 1, a = !1, l = !1, u = "";
    for (; t < e.length; t++)
      if (e[t] === "<" && !l) {
        if (a && N_(e, t))
          t += 7, [entityName, val, t] = L_(e, t + 1), val.indexOf("&") === -1 && (r[P_(entityName)] = {
            regx: RegExp(`&${entityName};`, "g"),
            val
          });
        else if (a && I_(e, t))
          t += 8;
        else if (a && k_(e, t))
          t += 8;
        else if (a && R_(e, t))
          t += 9;
        else if (O_)
          l = !0;
        else
          throw new Error("Invalid DOCTYPE");
        s++, u = "";
      } else if (e[t] === ">") {
        if (l ? e[t - 1] === "-" && e[t - 2] === "-" && (l = !1, s--) : s--, s === 0)
          break;
      } else
        e[t] === "[" ? a = !0 : u += e[t];
    if (s !== 0)
      throw new Error("Unclosed DOCTYPE");
  } else
    throw new Error("Invalid Tag instead of DOCTYPE");
  return { entities: r, i: t };
}
function L_(e, t) {
  let r = "";
  for (; t < e.length && e[t] !== "'" && e[t] !== '"'; t++)
    r += e[t];
  if (r = r.trim(), r.indexOf(" ") !== -1)
    throw new Error("External entites are not supported");
  const s = e[t++];
  let a = "";
  for (; t < e.length && e[t] !== s; t++)
    a += e[t];
  return [r, a, t];
}
function O_(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "-" && e[t + 3] === "-";
}
function N_(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "E" && e[t + 3] === "N" && e[t + 4] === "T" && e[t + 5] === "I" && e[t + 6] === "T" && e[t + 7] === "Y";
}
function I_(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "E" && e[t + 3] === "L" && e[t + 4] === "E" && e[t + 5] === "M" && e[t + 6] === "E" && e[t + 7] === "N" && e[t + 8] === "T";
}
function k_(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "A" && e[t + 3] === "T" && e[t + 4] === "T" && e[t + 5] === "L" && e[t + 6] === "I" && e[t + 7] === "S" && e[t + 8] === "T";
}
function R_(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "N" && e[t + 3] === "O" && e[t + 4] === "T" && e[t + 5] === "A" && e[t + 6] === "T" && e[t + 7] === "I" && e[t + 8] === "O" && e[t + 9] === "N";
}
function P_(e) {
  if (T_.isName(e))
    return e;
  throw new Error(`Invalid entity name ${e}`);
}
var F_ = S_;
const B_ = /^[-+]?0x[a-fA-F0-9]+$/, M_ = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
!Number.parseInt && window.parseInt && (Number.parseInt = window.parseInt);
!Number.parseFloat && window.parseFloat && (Number.parseFloat = window.parseFloat);
const $_ = {
  hex: !0,
  leadingZeros: !0,
  decimalPoint: ".",
  eNotation: !0
  //skipLike: /regex/
};
function D_(e, t = {}) {
  if (t = Object.assign({}, $_, t), !e || typeof e != "string")
    return e;
  let r = e.trim();
  if (t.skipLike !== void 0 && t.skipLike.test(r))
    return e;
  if (t.hex && B_.test(r))
    return Number.parseInt(r, 16);
  {
    const s = M_.exec(r);
    if (s) {
      const a = s[1], l = s[2];
      let u = W_(s[3]);
      const f = s[4] || s[6];
      if (!t.leadingZeros && l.length > 0 && a && r[2] !== ".")
        return e;
      if (!t.leadingZeros && l.length > 0 && !a && r[1] !== ".")
        return e;
      {
        const d = Number(r), g = "" + d;
        return g.search(/[eE]/) !== -1 || f ? t.eNotation ? d : e : r.indexOf(".") !== -1 ? g === "0" && u === "" || g === u || a && g === "-" + u ? d : e : l ? u === g || a + u === g ? d : e : r === g || r === a + g ? d : e;
      }
    } else
      return e;
  }
}
function W_(e) {
  return e && e.indexOf(".") !== -1 && (e = e.replace(/0+$/, ""), e === "." ? e = "0" : e[0] === "." ? e = "0" + e : e[e.length - 1] === "." && (e = e.substr(0, e.length - 1))), e;
}
var U_ = D_;
const Ho = ks, ri = C_, H_ = F_, Z_ = U_;
"<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, Ho.nameRegexp);
let V_ = class {
  constructor(t) {
    this.options = t, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = {
      apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
      gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
      lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
      quot: { regex: /&(quot|#34|#x22);/g, val: '"' }
    }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }, this.htmlEntities = {
      space: { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      cent: { regex: /&(cent|#162);/g, val: "" },
      pound: { regex: /&(pound|#163);/g, val: "" },
      yen: { regex: /&(yen|#165);/g, val: "" },
      euro: { regex: /&(euro|#8364);/g, val: "" },
      copyright: { regex: /&(copy|#169);/g, val: "" },
      reg: { regex: /&(reg|#174);/g, val: "" },
      inr: { regex: /&(inr|#8377);/g, val: "" }
    }, this.addExternalEntities = j_, this.parseXml = K_, this.parseTextData = G_, this.resolveNameSpace = Y_, this.buildAttributesMap = z_, this.isItStopNode = ex, this.replaceEntitiesValue = J_, this.readStopNodeData = nx, this.saveTextToParentTag = Q_, this.addChild = X_;
  }
};
function j_(e) {
  const t = Object.keys(e);
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    this.lastEntities[s] = {
      regex: new RegExp("&" + s + ";", "g"),
      val: e[s]
    };
  }
}
function G_(e, t, r, s, a, l, u) {
  if (e !== void 0 && (this.options.trimValues && !s && (e = e.trim()), e.length > 0)) {
    u || (e = this.replaceEntitiesValue(e));
    const f = this.options.tagValueProcessor(t, e, r, a, l);
    return f == null ? e : typeof f != typeof e || f !== e ? f : this.options.trimValues ? po(e, this.options.parseTagValue, this.options.numberParseOptions) : e.trim() === e ? po(e, this.options.parseTagValue, this.options.numberParseOptions) : e;
  }
}
function Y_(e) {
  if (this.options.removeNSPrefix) {
    const t = e.split(":"), r = e.charAt(0) === "/" ? "/" : "";
    if (t[0] === "xmlns")
      return "";
    t.length === 2 && (e = r + t[1]);
  }
  return e;
}
const q_ = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
function z_(e, t, r) {
  if (!this.options.ignoreAttributes && typeof e == "string") {
    const s = Ho.getAllMatches(e, q_), a = s.length, l = {};
    for (let u = 0; u < a; u++) {
      const f = this.resolveNameSpace(s[u][1]);
      let d = s[u][4], g = this.options.attributeNamePrefix + f;
      if (f.length)
        if (this.options.transformAttributeName && (g = this.options.transformAttributeName(g)), g === "__proto__" && (g = "#__proto__"), d !== void 0) {
          this.options.trimValues && (d = d.trim()), d = this.replaceEntitiesValue(d);
          const _ = this.options.attributeValueProcessor(f, d, t);
          _ == null ? l[g] = d : typeof _ != typeof d || _ !== d ? l[g] = _ : l[g] = po(
            d,
            this.options.parseAttributeValue,
            this.options.numberParseOptions
          );
        } else
          this.options.allowBooleanAttributes && (l[g] = !0);
    }
    if (!Object.keys(l).length)
      return;
    if (this.options.attributesGroupName) {
      const u = {};
      return u[this.options.attributesGroupName] = l, u;
    }
    return l;
  }
}
const K_ = function(e) {
  e = e.replace(/\r\n?/g, `
`);
  const t = new ri("!xml");
  let r = t, s = "", a = "";
  for (let l = 0; l < e.length; l++)
    if (e[l] === "<")
      if (e[l + 1] === "/") {
        const f = zn(e, ">", l, "Closing Tag is not closed.");
        let d = e.substring(l + 2, f).trim();
        if (this.options.removeNSPrefix) {
          const x = d.indexOf(":");
          x !== -1 && (d = d.substr(x + 1));
        }
        this.options.transformTagName && (d = this.options.transformTagName(d)), r && (s = this.saveTextToParentTag(s, r, a));
        const g = a.substring(a.lastIndexOf(".") + 1);
        if (d && this.options.unpairedTags.indexOf(d) !== -1)
          throw new Error(`Unpaired tag can not be used as closing tag: </${d}>`);
        let _ = 0;
        g && this.options.unpairedTags.indexOf(g) !== -1 ? (_ = a.lastIndexOf(".", a.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : _ = a.lastIndexOf("."), a = a.substring(0, _), r = this.tagsNodeStack.pop(), s = "", l = f;
      } else if (e[l + 1] === "?") {
        let f = ho(e, l, !1, "?>");
        if (!f)
          throw new Error("Pi Tag is not closed.");
        if (s = this.saveTextToParentTag(s, r, a), !(this.options.ignoreDeclaration && f.tagName === "?xml" || this.options.ignorePiTags)) {
          const d = new ri(f.tagName);
          d.add(this.options.textNodeName, ""), f.tagName !== f.tagExp && f.attrExpPresent && (d[":@"] = this.buildAttributesMap(f.tagExp, a, f.tagName)), this.addChild(r, d, a);
        }
        l = f.closeIndex + 1;
      } else if (e.substr(l + 1, 3) === "!--") {
        const f = zn(e, "-->", l + 4, "Comment is not closed.");
        if (this.options.commentPropName) {
          const d = e.substring(l + 4, f - 2);
          s = this.saveTextToParentTag(s, r, a), r.add(this.options.commentPropName, [{ [this.options.textNodeName]: d }]);
        }
        l = f;
      } else if (e.substr(l + 1, 2) === "!D") {
        const f = H_(e, l);
        this.docTypeEntities = f.entities, l = f.i;
      } else if (e.substr(l + 1, 2) === "![") {
        const f = zn(e, "]]>", l, "CDATA is not closed.") - 2, d = e.substring(l + 9, f);
        if (s = this.saveTextToParentTag(s, r, a), this.options.cdataPropName)
          r.add(this.options.cdataPropName, [{ [this.options.textNodeName]: d }]);
        else {
          let g = this.parseTextData(d, r.tagname, a, !0, !1, !0);
          g == null && (g = ""), r.add(this.options.textNodeName, g);
        }
        l = f + 2;
      } else {
        let f = ho(e, l, this.options.removeNSPrefix), d = f.tagName, g = f.tagExp, _ = f.attrExpPresent, x = f.closeIndex;
        this.options.transformTagName && (d = this.options.transformTagName(d)), r && s && r.tagname !== "!xml" && (s = this.saveTextToParentTag(s, r, a, !1));
        const T = r;
        if (T && this.options.unpairedTags.indexOf(T.tagname) !== -1 && (r = this.tagsNodeStack.pop(), a = a.substring(0, a.lastIndexOf("."))), d !== t.tagname && (a += a ? "." + d : d), this.isItStopNode(this.options.stopNodes, a, d)) {
          let A = "";
          if (g.length > 0 && g.lastIndexOf("/") === g.length - 1)
            l = f.closeIndex;
          else if (this.options.unpairedTags.indexOf(d) !== -1)
            l = f.closeIndex;
          else {
            const E = this.readStopNodeData(e, d, x + 1);
            if (!E)
              throw new Error(`Unexpected end of ${d}`);
            l = E.i, A = E.tagContent;
          }
          const C = new ri(d);
          d !== g && _ && (C[":@"] = this.buildAttributesMap(g, a, d)), A && (A = this.parseTextData(A, d, a, !0, _, !0, !0)), a = a.substr(0, a.lastIndexOf(".")), C.add(this.options.textNodeName, A), this.addChild(r, C, a);
        } else {
          if (g.length > 0 && g.lastIndexOf("/") === g.length - 1) {
            d[d.length - 1] === "/" ? (d = d.substr(0, d.length - 1), a = a.substr(0, a.length - 1), g = d) : g = g.substr(0, g.length - 1), this.options.transformTagName && (d = this.options.transformTagName(d));
            const A = new ri(d);
            d !== g && _ && (A[":@"] = this.buildAttributesMap(g, a, d)), this.addChild(r, A, a), a = a.substr(0, a.lastIndexOf("."));
          } else {
            const A = new ri(d);
            this.tagsNodeStack.push(r), d !== g && _ && (A[":@"] = this.buildAttributesMap(g, a, d)), this.addChild(r, A, a), r = A;
          }
          s = "", l = x;
        }
      }
    else
      s += e[l];
  return t.child;
};
function X_(e, t, r) {
  const s = this.options.updateTag(t.tagname, r, t[":@"]);
  s === !1 || (typeof s == "string" && (t.tagname = s), e.addChild(t));
}
const J_ = function(e) {
  if (this.options.processEntities) {
    for (let t in this.docTypeEntities) {
      const r = this.docTypeEntities[t];
      e = e.replace(r.regx, r.val);
    }
    for (let t in this.lastEntities) {
      const r = this.lastEntities[t];
      e = e.replace(r.regex, r.val);
    }
    if (this.options.htmlEntities)
      for (let t in this.htmlEntities) {
        const r = this.htmlEntities[t];
        e = e.replace(r.regex, r.val);
      }
    e = e.replace(this.ampEntity.regex, this.ampEntity.val);
  }
  return e;
};
function Q_(e, t, r, s) {
  return e && (s === void 0 && (s = Object.keys(t.child).length === 0), e = this.parseTextData(
    e,
    t.tagname,
    r,
    !1,
    t[":@"] ? Object.keys(t[":@"]).length !== 0 : !1,
    s
  ), e !== void 0 && e !== "" && t.add(this.options.textNodeName, e), e = ""), e;
}
function ex(e, t, r) {
  const s = "*." + r;
  for (const a in e) {
    const l = e[a];
    if (s === l || t === l)
      return !0;
  }
  return !1;
}
function tx(e, t, r = ">") {
  let s, a = "";
  for (let l = t; l < e.length; l++) {
    let u = e[l];
    if (s)
      u === s && (s = "");
    else if (u === '"' || u === "'")
      s = u;
    else if (u === r[0])
      if (r[1]) {
        if (e[l + 1] === r[1])
          return {
            data: a,
            index: l
          };
      } else
        return {
          data: a,
          index: l
        };
    else
      u === "	" && (u = " ");
    a += u;
  }
}
function zn(e, t, r, s) {
  const a = e.indexOf(t, r);
  if (a === -1)
    throw new Error(s);
  return a + t.length - 1;
}
function ho(e, t, r, s = ">") {
  const a = tx(e, t + 1, s);
  if (!a)
    return;
  let l = a.data;
  const u = a.index, f = l.search(/\s/);
  let d = l, g = !0;
  if (f !== -1 && (d = l.substr(0, f).replace(/\s\s*$/, ""), l = l.substr(f + 1)), r) {
    const _ = d.indexOf(":");
    _ !== -1 && (d = d.substr(_ + 1), g = d !== a.data.substr(_ + 1));
  }
  return {
    tagName: d,
    tagExp: l,
    closeIndex: u,
    attrExpPresent: g
  };
}
function nx(e, t, r) {
  const s = r;
  let a = 1;
  for (; r < e.length; r++)
    if (e[r] === "<")
      if (e[r + 1] === "/") {
        const l = zn(e, ">", r, `${t} is not closed`);
        if (e.substring(r + 2, l).trim() === t && (a--, a === 0))
          return {
            tagContent: e.substring(s, r),
            i: l
          };
        r = l;
      } else if (e[r + 1] === "?")
        r = zn(e, "?>", r + 1, "StopNode is not closed.");
      else if (e.substr(r + 1, 3) === "!--")
        r = zn(e, "-->", r + 3, "StopNode is not closed.");
      else if (e.substr(r + 1, 2) === "![")
        r = zn(e, "]]>", r, "StopNode is not closed.") - 2;
      else {
        const l = ho(e, r, ">");
        l && ((l && l.tagName) === t && l.tagExp[l.tagExp.length - 1] !== "/" && a++, r = l.closeIndex);
      }
}
function po(e, t, r) {
  if (t && typeof e == "string") {
    const s = e.trim();
    return s === "true" ? !0 : s === "false" ? !1 : Z_(e, r);
  } else
    return Ho.isExist(e) ? e : "";
}
var rx = V_, If = {};
function ix(e, t) {
  return kf(e, t);
}
function kf(e, t, r) {
  let s;
  const a = {};
  for (let l = 0; l < e.length; l++) {
    const u = e[l], f = sx(u);
    let d = "";
    if (r === void 0 ? d = f : d = r + "." + f, f === t.textNodeName)
      s === void 0 ? s = u[f] : s += "" + u[f];
    else {
      if (f === void 0)
        continue;
      if (u[f]) {
        let g = kf(u[f], t, d);
        const _ = ox(g, t);
        u[":@"] ? ax(g, u[":@"], d, t) : Object.keys(g).length === 1 && g[t.textNodeName] !== void 0 && !t.alwaysCreateTextNode ? g = g[t.textNodeName] : Object.keys(g).length === 0 && (t.alwaysCreateTextNode ? g[t.textNodeName] = "" : g = ""), a[f] !== void 0 && a.hasOwnProperty(f) ? (Array.isArray(a[f]) || (a[f] = [a[f]]), a[f].push(g)) : t.isArray(f, d, _) ? a[f] = [g] : a[f] = g;
      }
    }
  }
  return typeof s == "string" ? s.length > 0 && (a[t.textNodeName] = s) : s !== void 0 && (a[t.textNodeName] = s), a;
}
function sx(e) {
  const t = Object.keys(e);
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    if (s !== ":@")
      return s;
  }
}
function ax(e, t, r, s) {
  if (t) {
    const a = Object.keys(t), l = a.length;
    for (let u = 0; u < l; u++) {
      const f = a[u];
      s.isArray(f, r + "." + f, !0, !0) ? e[f] = [t[f]] : e[f] = t[f];
    }
  }
}
function ox(e, t) {
  const { textNodeName: r } = t, s = Object.keys(e).length;
  return !!(s === 0 || s === 1 && (e[r] || typeof e[r] == "boolean" || e[r] === 0));
}
If.prettify = ix;
const { buildOptions: lx } = Uo, ux = rx, { prettify: cx } = If, fx = Do;
let dx = class {
  constructor(t) {
    this.externalEntities = {}, this.options = lx(t);
  }
  /**
   * Parse XML dats to JS object 
   * @param {string|Buffer} xmlData 
   * @param {boolean|Object} validationOption 
   */
  parse(t, r) {
    if (typeof t != "string")
      if (t.toString)
        t = t.toString();
      else
        throw new Error("XML data is accepted in String or Bytes[] form.");
    if (r) {
      r === !0 && (r = {});
      const l = fx.validate(t, r);
      if (l !== !0)
        throw Error(`${l.err.msg}:${l.err.line}:${l.err.col}`);
    }
    const s = new ux(this.options);
    s.addExternalEntities(this.externalEntities);
    const a = s.parseXml(t);
    return this.options.preserveOrder || a === void 0 ? a : cx(a, this.options);
  }
  /**
   * Add Entity which is not by default supported by this library
   * @param {string} key 
   * @param {string} value 
   */
  addEntity(t, r) {
    if (r.indexOf("&") !== -1)
      throw new Error("Entity value can't have '&'");
    if (t.indexOf("&") !== -1 || t.indexOf(";") !== -1)
      throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
    if (r === "&")
      throw new Error("An entity with value '&' is not permitted");
    this.externalEntities[t] = r;
  }
};
var hx = dx;
const px = `
`;
function gx(e, t) {
  let r = "";
  return t.format && t.indentBy.length > 0 && (r = px), Rf(e, t, "", r);
}
function Rf(e, t, r, s) {
  let a = "", l = !1;
  for (let u = 0; u < e.length; u++) {
    const f = e[u], d = mx(f);
    let g = "";
    if (r.length === 0 ? g = d : g = `${r}.${d}`, d === t.textNodeName) {
      let C = f[d];
      vx(g, t) || (C = t.tagValueProcessor(d, C), C = Pf(C, t)), l && (a += s), a += C, l = !1;
      continue;
    } else if (d === t.cdataPropName) {
      l && (a += s), a += `<![CDATA[${f[d][0][t.textNodeName]}]]>`, l = !1;
      continue;
    } else if (d === t.commentPropName) {
      a += s + `<!--${f[d][0][t.textNodeName]}-->`, l = !0;
      continue;
    } else if (d[0] === "?") {
      const C = zc(f[":@"], t), E = d === "?xml" ? "" : s;
      let P = f[d][0][t.textNodeName];
      P = P.length !== 0 ? " " + P : "", a += E + `<${d}${P}${C}?>`, l = !0;
      continue;
    }
    let _ = s;
    _ !== "" && (_ += t.indentBy);
    const x = zc(f[":@"], t), T = s + `<${d}${x}`, A = Rf(f[d], t, g, _);
    t.unpairedTags.indexOf(d) !== -1 ? t.suppressUnpairedNode ? a += T + ">" : a += T + "/>" : (!A || A.length === 0) && t.suppressEmptyNode ? a += T + "/>" : A && A.endsWith(">") ? a += T + `>${A}${s}</${d}>` : (a += T + ">", A && s !== "" && (A.includes("/>") || A.includes("</")) ? a += s + t.indentBy + A + s : a += A, a += `</${d}>`), l = !0;
  }
  return a;
}
function mx(e) {
  const t = Object.keys(e);
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    if (s !== ":@")
      return s;
  }
}
function zc(e, t) {
  let r = "";
  if (e && !t.ignoreAttributes)
    for (let s in e) {
      let a = t.attributeValueProcessor(s, e[s]);
      a = Pf(a, t), a === !0 && t.suppressBooleanAttributes ? r += ` ${s.substr(t.attributeNamePrefix.length)}` : r += ` ${s.substr(t.attributeNamePrefix.length)}="${a}"`;
    }
  return r;
}
function vx(e, t) {
  e = e.substr(0, e.length - t.textNodeName.length - 1);
  let r = e.substr(e.lastIndexOf(".") + 1);
  for (let s in t.stopNodes)
    if (t.stopNodes[s] === e || t.stopNodes[s] === "*." + r)
      return !0;
  return !1;
}
function Pf(e, t) {
  if (e && e.length > 0 && t.processEntities)
    for (let r = 0; r < t.entities.length; r++) {
      const s = t.entities[r];
      e = e.replace(s.regex, s.val);
    }
  return e;
}
var yx = gx;
const _x = yx, xx = {
  attributeNamePrefix: "@_",
  attributesGroupName: !1,
  textNodeName: "#text",
  ignoreAttributes: !0,
  cdataPropName: !1,
  format: !1,
  indentBy: "  ",
  suppressEmptyNode: !1,
  suppressUnpairedNode: !0,
  suppressBooleanAttributes: !0,
  tagValueProcessor: function(e, t) {
    return t;
  },
  attributeValueProcessor: function(e, t) {
    return t;
  },
  preserveOrder: !1,
  commentPropName: !1,
  unpairedTags: [],
  entities: [
    { regex: new RegExp("&", "g"), val: "&amp;" },
    //it must be on top
    { regex: new RegExp(">", "g"), val: "&gt;" },
    { regex: new RegExp("<", "g"), val: "&lt;" },
    { regex: new RegExp("'", "g"), val: "&apos;" },
    { regex: new RegExp('"', "g"), val: "&quot;" }
  ],
  processEntities: !0,
  stopNodes: [],
  // transformTagName: false,
  // transformAttributeName: false,
  oneListGroup: !1
};
function Ln(e) {
  this.options = Object.assign({}, xx, e), this.options.ignoreAttributes || this.options.attributesGroupName ? this.isAttribute = function() {
    return !1;
  } : (this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = Ex), this.processTextOrObjNode = wx, this.options.format ? (this.indentate = bx, this.tagEndChar = `>
`, this.newLine = `
`) : (this.indentate = function() {
    return "";
  }, this.tagEndChar = ">", this.newLine = "");
}
Ln.prototype.build = function(e) {
  return this.options.preserveOrder ? _x(e, this.options) : (Array.isArray(e) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (e = {
    [this.options.arrayNodeName]: e
  }), this.j2x(e, 0).val);
};
Ln.prototype.j2x = function(e, t) {
  let r = "", s = "";
  for (let a in e)
    if (!(typeof e[a] > "u"))
      if (e[a] === null)
        a[0] === "?" ? s += this.indentate(t) + "<" + a + "?" + this.tagEndChar : s += this.indentate(t) + "<" + a + "/" + this.tagEndChar;
      else if (e[a] instanceof Date)
        s += this.buildTextValNode(e[a], a, "", t);
      else if (typeof e[a] != "object") {
        const l = this.isAttribute(a);
        if (l)
          r += this.buildAttrPairStr(l, "" + e[a]);
        else if (a === this.options.textNodeName) {
          let u = this.options.tagValueProcessor(a, "" + e[a]);
          s += this.replaceEntitiesValue(u);
        } else
          s += this.buildTextValNode(e[a], a, "", t);
      } else if (Array.isArray(e[a])) {
        const l = e[a].length;
        let u = "";
        for (let f = 0; f < l; f++) {
          const d = e[a][f];
          typeof d > "u" || (d === null ? a[0] === "?" ? s += this.indentate(t) + "<" + a + "?" + this.tagEndChar : s += this.indentate(t) + "<" + a + "/" + this.tagEndChar : typeof d == "object" ? this.options.oneListGroup ? u += this.j2x(d, t + 1).val : u += this.processTextOrObjNode(d, a, t) : u += this.buildTextValNode(d, a, "", t));
        }
        this.options.oneListGroup && (u = this.buildObjectNode(u, a, "", t)), s += u;
      } else if (this.options.attributesGroupName && a === this.options.attributesGroupName) {
        const l = Object.keys(e[a]), u = l.length;
        for (let f = 0; f < u; f++)
          r += this.buildAttrPairStr(l[f], "" + e[a][l[f]]);
      } else
        s += this.processTextOrObjNode(e[a], a, t);
  return { attrStr: r, val: s };
};
Ln.prototype.buildAttrPairStr = function(e, t) {
  return t = this.options.attributeValueProcessor(e, "" + t), t = this.replaceEntitiesValue(t), this.options.suppressBooleanAttributes && t === "true" ? " " + e : " " + e + '="' + t + '"';
};
function wx(e, t, r) {
  const s = this.j2x(e, r + 1);
  return e[this.options.textNodeName] !== void 0 && Object.keys(e).length === 1 ? this.buildTextValNode(e[this.options.textNodeName], t, s.attrStr, r) : this.buildObjectNode(s.val, t, s.attrStr, r);
}
Ln.prototype.buildObjectNode = function(e, t, r, s) {
  if (e === "")
    return t[0] === "?" ? this.indentate(s) + "<" + t + r + "?" + this.tagEndChar : this.indentate(s) + "<" + t + r + this.closeTag(t) + this.tagEndChar;
  {
    let a = "</" + t + this.tagEndChar, l = "";
    return t[0] === "?" && (l = "?", a = ""), r && e.indexOf("<") === -1 ? this.indentate(s) + "<" + t + r + l + ">" + e + a : this.options.commentPropName !== !1 && t === this.options.commentPropName && l.length === 0 ? this.indentate(s) + `<!--${e}-->` + this.newLine : this.indentate(s) + "<" + t + r + l + this.tagEndChar + e + this.indentate(s) + a;
  }
};
Ln.prototype.closeTag = function(e) {
  let t = "";
  return this.options.unpairedTags.indexOf(e) !== -1 ? this.options.suppressUnpairedNode || (t = "/") : this.options.suppressEmptyNode ? t = "/" : t = `></${e}`, t;
};
Ln.prototype.buildTextValNode = function(e, t, r, s) {
  if (this.options.cdataPropName !== !1 && t === this.options.cdataPropName)
    return this.indentate(s) + `<![CDATA[${e}]]>` + this.newLine;
  if (this.options.commentPropName !== !1 && t === this.options.commentPropName)
    return this.indentate(s) + `<!--${e}-->` + this.newLine;
  if (t[0] === "?")
    return this.indentate(s) + "<" + t + r + "?" + this.tagEndChar;
  {
    let a = this.options.tagValueProcessor(t, e);
    return a = this.replaceEntitiesValue(a), a === "" ? this.indentate(s) + "<" + t + r + this.closeTag(t) + this.tagEndChar : this.indentate(s) + "<" + t + r + ">" + a + "</" + t + this.tagEndChar;
  }
};
Ln.prototype.replaceEntitiesValue = function(e) {
  if (e && e.length > 0 && this.options.processEntities)
    for (let t = 0; t < this.options.entities.length; t++) {
      const r = this.options.entities[t];
      e = e.replace(r.regex, r.val);
    }
  return e;
};
function bx(e) {
  return this.options.indentBy.repeat(e);
}
function Ex(e) {
  return e.startsWith(this.options.attributeNamePrefix) ? e.substr(this.attrPrefixLen) : !1;
}
var Ax = Ln;
const Cx = Do, Tx = hx, Sx = Ax;
var Kc = {
  XMLParser: Tx,
  XMLValidator: Cx,
  XMLBuilder: Sx
};
/*!
 * Copyright (c) Squirrel Chat et al., All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
function Lx(e, t) {
  let r = e.slice(0, t).split(/\r\n|\n|\r/g);
  return [r.length, r.pop().length + 1];
}
function Ox(e, t, r) {
  let s = e.split(/\r\n|\n|\r/g), a = "", l = (Math.log10(t + 1) | 0) + 1;
  for (let u = t - 1; u <= t + 1; u++) {
    let f = s[u - 1];
    f && (a += u.toString().padEnd(l, " "), a += ":  ", a += f, a += `
`, u === t && (a += " ".repeat(l + r + 2), a += `^
`));
  }
  return a;
}
class le extends Error {
  constructor(r, s) {
    const [a, l] = Lx(s.toml, s.ptr), u = Ox(s.toml, a, l);
    super(`Invalid TOML document: ${r}

${u}`, s);
    B(this, "line");
    B(this, "column");
    B(this, "codeblock");
    this.line = a, this.column = l, this.codeblock = u;
  }
}
/*!
 * Copyright (c) Squirrel Chat et al., All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
function ls(e, t = 0, r = e.length) {
  let s = e.indexOf(`
`, t);
  return e[s - 1] === "\r" && s--, s <= r ? s : -1;
}
function Zo(e, t) {
  for (let r = t; r < e.length; r++) {
    let s = e[r];
    if (s === `
`)
      return r;
    if (s === "\r" && e[r + 1] === `
`)
      return r + 1;
    if (s < " " && s !== "	" || s === "")
      throw new le("control characters are not allowed in comments", {
        toml: e,
        ptr: t
      });
  }
  return e.length;
}
function sn(e, t, r, s) {
  let a;
  for (; (a = e[t]) === " " || a === "	" || !r && (a === `
` || a === "\r" && e[t + 1] === `
`); )
    t++;
  return s || a !== "#" ? t : sn(e, Zo(e, t), r);
}
function Xc(e, t, r, s, a = !1) {
  if (!s)
    return t = ls(e, t), t < 0 ? e.length : t;
  for (let l = t; l < e.length; l++) {
    let u = e[l];
    if (u === "#")
      l = ls(e, l);
    else {
      if (u === r)
        return l + 1;
      if (u === s)
        return l;
      if (a && (u === `
` || u === "\r" && e[l + 1] === `
`))
        return l;
    }
  }
  throw new le("cannot find end of structure", {
    toml: e,
    ptr: t
  });
}
function Ff(e, t) {
  let r = e[t], s = r === e[t + 1] && e[t + 1] === e[t + 2] ? e.slice(t, t + 3) : r;
  t += s.length - 1;
  do
    t = e.indexOf(s, ++t);
  while (t > -1 && r !== "'" && e[t - 1] === "\\" && e[t - 2] !== "\\");
  return t > -1 && (t += s.length, s.length > 1 && (e[t] === r && t++, e[t] === r && t++)), t;
}
/*!
 * Copyright (c) Squirrel Chat et al., All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
let Nx = /^(\d{4}-\d{2}-\d{2})?[T ]?(?:(\d{2}):\d{2}:\d{2}(?:\.\d+)?)?(Z|[-+]\d{2}:\d{2})?$/i;
var $t, Dt, Ye;
const Er = class extends Date {
  constructor(r) {
    let s = !0, a = !0, l = "Z";
    if (typeof r == "string") {
      let u = r.match(Nx);
      u ? (u[1] || (s = !1, r = `0000-01-01T${r}`), a = !!u[2], u[2] && +u[2] > 23 ? r = "" : (l = u[3] || null, r = r.toUpperCase(), !l && a && (r += "Z"))) : r = "";
    }
    super(r);
    as(this, $t, !1);
    as(this, Dt, !1);
    as(this, Ye, null);
    isNaN(this.getTime()) || (Mt(this, $t, s), Mt(this, Dt, a), Mt(this, Ye, l));
  }
  isDateTime() {
    return Pe(this, $t) && Pe(this, Dt);
  }
  isLocal() {
    return !Pe(this, $t) || !Pe(this, Dt) || !Pe(this, Ye);
  }
  isDate() {
    return Pe(this, $t) && !Pe(this, Dt);
  }
  isTime() {
    return Pe(this, Dt) && !Pe(this, $t);
  }
  isValid() {
    return Pe(this, $t) || Pe(this, Dt);
  }
  toISOString() {
    let r = super.toISOString();
    if (this.isDate())
      return r.slice(0, 10);
    if (this.isTime())
      return r.slice(11, 23);
    if (Pe(this, Ye) === null)
      return r.slice(0, -1);
    if (Pe(this, Ye) === "Z")
      return r;
    let s = +Pe(this, Ye).slice(1, 3) * 60 + +Pe(this, Ye).slice(4, 6);
    return s = Pe(this, Ye)[0] === "-" ? s : -s, new Date(this.getTime() - s * 6e4).toISOString().slice(0, -1) + Pe(this, Ye);
  }
  static wrapAsOffsetDateTime(r, s = "Z") {
    let a = new Er(r);
    return Mt(a, Ye, s), a;
  }
  static wrapAsLocalDateTime(r) {
    let s = new Er(r);
    return Mt(s, Ye, null), s;
  }
  static wrapAsLocalDate(r) {
    let s = new Er(r);
    return Mt(s, Dt, !1), Mt(s, Ye, null), s;
  }
  static wrapAsLocalTime(r) {
    let s = new Er(r);
    return Mt(s, $t, !1), Mt(s, Ye, null), s;
  }
};
let us = Er;
$t = new WeakMap(), Dt = new WeakMap(), Ye = new WeakMap();
/*!
 * Copyright (c) Squirrel Chat et al., All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
let Ix = /^((0x[0-9a-fA-F](_?[0-9a-fA-F])*)|(([+-]|0[ob])?\d(_?\d)*))$/, kx = /^[+-]?\d(_?\d)*(\.\d(_?\d)*)?([eE][+-]?\d(_?\d)*)?$/, Rx = /^[+-]?0[0-9_]/, Px = /^[0-9a-f]{4,8}$/i, Jc = {
  b: "\b",
  t: "	",
  n: `
`,
  f: "\f",
  r: "\r",
  '"': '"',
  "\\": "\\"
};
function Bf(e, t = 0, r = e.length) {
  let s = e[t] === "'", a = e[t++] === e[t] && e[t] === e[t + 1];
  a && (r -= 2, e[t += 2] === "\r" && t++, e[t] === `
` && t++);
  let l = 0, u, f = "", d = t;
  for (; t < r - 1; ) {
    let g = e[t++];
    if (g === `
` || g === "\r" && e[t] === `
`) {
      if (!a)
        throw new le("newlines are not allowed in strings", {
          toml: e,
          ptr: t - 1
        });
    } else if (g < " " && g !== "	" || g === "")
      throw new le("control characters are not allowed in strings", {
        toml: e,
        ptr: t - 1
      });
    if (u) {
      if (u = !1, g === "u" || g === "U") {
        let _ = e.slice(t, t += g === "u" ? 4 : 8);
        if (!Px.test(_))
          throw new le("invalid unicode escape", {
            toml: e,
            ptr: l
          });
        try {
          f += String.fromCodePoint(parseInt(_, 16));
        } catch {
          throw new le("invalid unicode escape", {
            toml: e,
            ptr: l
          });
        }
      } else if (a && (g === `
` || g === " " || g === "	" || g === "\r")) {
        if (t = sn(e, t - 1, !0), e[t] !== `
` && e[t] !== "\r")
          throw new le("invalid escape: only line-ending whitespace may be escaped", {
            toml: e,
            ptr: l
          });
        t = sn(e, t);
      } else if (g in Jc)
        f += Jc[g];
      else
        throw new le("unrecognized escape sequence", {
          toml: e,
          ptr: l
        });
      d = t;
    } else
      !s && g === "\\" && (l = t - 1, u = !0, f += e.slice(d, l));
  }
  return f + e.slice(d, r - 1);
}
function Fx(e, t, r) {
  if (e === "true")
    return !0;
  if (e === "false")
    return !1;
  if (e === "-inf")
    return -1 / 0;
  if (e === "inf" || e === "+inf")
    return 1 / 0;
  if (e === "nan" || e === "+nan" || e === "-nan")
    return NaN;
  if (e === "-0")
    return 0;
  let s;
  if ((s = Ix.test(e)) || kx.test(e)) {
    if (Rx.test(e))
      throw new le("leading zeroes are not allowed", {
        toml: t,
        ptr: r
      });
    let l = +e.replace(/_/g, "");
    if (isNaN(l))
      throw new le("invalid number", {
        toml: t,
        ptr: r
      });
    if (s && !Number.isSafeInteger(l))
      throw new le("integer value cannot be represented losslessly", {
        toml: t,
        ptr: r
      });
    return l;
  }
  let a = new us(e);
  if (!a.isValid())
    throw new le("invalid value", {
      toml: t,
      ptr: r
    });
  return a;
}
/*!
 * Copyright (c) Squirrel Chat et al., All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
function Bx(e, t, r, s) {
  let a = e.slice(t, r), l = a.indexOf("#");
  l > -1 && (Zo(e, l), a = a.slice(0, l));
  let u = a.trimEnd();
  if (!s) {
    let f = a.indexOf(`
`, u.length);
    if (f > -1)
      throw new le("newlines are not allowed in inline tables", {
        toml: e,
        ptr: t + f
      });
  }
  return [u, l];
}
function Vo(e, t, r) {
  let s = e[t];
  if (s === "[" || s === "{") {
    let [u, f] = s === "[" ? Dx(e, t) : $x(e, t), d = Xc(e, f, ",", r);
    if (r === "}") {
      let g = ls(e, f, d);
      if (g > -1)
        throw new le("newlines are not allowed in inline tables", {
          toml: e,
          ptr: g
        });
    }
    return [u, d];
  }
  let a;
  if (s === '"' || s === "'") {
    a = Ff(e, t);
    let u = Bf(e, t, a);
    if (r) {
      if (a = sn(e, a, r !== "]"), e[a] && e[a] !== "," && e[a] !== r && e[a] !== `
` && e[a] !== "\r")
        throw new le("unexpected character encountered", {
          toml: e,
          ptr: a
        });
      a += +(e[a] === ",");
    }
    return [u, a];
  }
  a = Xc(e, t, ",", r);
  let l = Bx(e, t, a - +(e[a - 1] === ","), r === "]");
  if (!l[0])
    throw new le("incomplete key-value declaration: no value specified", {
      toml: e,
      ptr: t
    });
  return r && l[1] > -1 && (a = sn(e, t + l[1]), a += +(e[a] === ",")), [
    Fx(l[0], e, t),
    a
  ];
}
/*!
 * Copyright (c) Squirrel Chat et al., All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
let Mx = /^[a-zA-Z0-9-_]+[ \t]*$/;
function go(e, t, r = "=") {
  let s = t - 1, a = [], l = e.indexOf(r, t);
  if (l < 0)
    throw new le("incomplete key-value: cannot find end of key", {
      toml: e,
      ptr: t
    });
  do {
    let u = e[t = ++s];
    if (u !== " " && u !== "	")
      if (u === '"' || u === "'") {
        if (u === e[t + 1] && u === e[t + 2])
          throw new le("multiline strings are not allowed in keys", {
            toml: e,
            ptr: t
          });
        let f = Ff(e, t);
        if (f < 0)
          throw new le("unfinished string encountered", {
            toml: e,
            ptr: t
          });
        s = e.indexOf(".", f);
        let d = e.slice(f, s < 0 || s > l ? l : s), g = ls(d);
        if (g > -1)
          throw new le("newlines are not allowed in keys", {
            toml: e,
            ptr: t + s + g
          });
        if (d.trimStart())
          throw new le("found extra tokens after the string part", {
            toml: e,
            ptr: f
          });
        if (l < f && (l = e.indexOf(r, f), l < 0))
          throw new le("incomplete key-value: cannot find end of key", {
            toml: e,
            ptr: t
          });
        a.push(Bf(e, t, f));
      } else {
        s = e.indexOf(".", t);
        let f = e.slice(t, s < 0 || s > l ? l : s);
        if (!Mx.test(f))
          throw new le("only letter, numbers, dashes and underscores are allowed in keys", {
            toml: e,
            ptr: t
          });
        a.push(f.trimEnd());
      }
  } while (s + 1 && s < l);
  return [a, sn(e, l + 1, !0, !0)];
}
function $x(e, t) {
  let r = {}, s = /* @__PURE__ */ new Set(), a, l = 0;
  for (t++; (a = e[t++]) !== "}" && a; ) {
    if (a === `
`)
      throw new le("newlines are not allowed in inline tables", {
        toml: e,
        ptr: t - 1
      });
    if (a === "#")
      throw new le("inline tables cannot contain comments", {
        toml: e,
        ptr: t - 1
      });
    if (a === ",")
      throw new le("expected key-value, found comma", {
        toml: e,
        ptr: t - 1
      });
    if (a !== " " && a !== "	") {
      let u, f = r, d = !1, [g, _] = go(e, t - 1);
      for (let A = 0; A < g.length; A++) {
        if (A && (f = d ? f[u] : f[u] = {}), u = g[A], (d = Object.hasOwn(f, u)) && (typeof f[u] != "object" || s.has(f[u])))
          throw new le("trying to redefine an already defined value", {
            toml: e,
            ptr: t
          });
        !d && u === "__proto__" && Object.defineProperty(f, u, { enumerable: !0, configurable: !0, writable: !0 });
      }
      if (d)
        throw new le("trying to redefine an already defined value", {
          toml: e,
          ptr: t
        });
      let [x, T] = Vo(e, _, "}");
      s.add(x), f[u] = x, t = T, l = e[t - 1] === "," ? t - 1 : 0;
    }
  }
  if (l)
    throw new le("trailing commas are not allowed in inline tables", {
      toml: e,
      ptr: l
    });
  if (!a)
    throw new le("unfinished table encountered", {
      toml: e,
      ptr: t
    });
  return [r, t];
}
function Dx(e, t) {
  let r = [], s;
  for (t++; (s = e[t++]) !== "]" && s; ) {
    if (s === ",")
      throw new le("expected value, found comma", {
        toml: e,
        ptr: t - 1
      });
    if (s === "#")
      t = Zo(e, t);
    else if (s !== " " && s !== "	" && s !== `
` && s !== "\r") {
      let a = Vo(e, t - 1, "]");
      r.push(a[0]), t = a[1];
    }
  }
  if (!s)
    throw new le("unfinished array encountered", {
      toml: e,
      ptr: t
    });
  return [r, t];
}
/*!
 * Copyright (c) Squirrel Chat et al., All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
function Qc(e, t, r, s) {
  var g, _;
  let a = t, l = r, u, f = !1, d;
  for (let x = 0; x < e.length; x++) {
    if (x) {
      if (a = f ? a[u] : a[u] = {}, l = (d = l[u]).c, s === 0 && (d.t === 1 || d.t === 2))
        return null;
      if (d.t === 2) {
        let T = a.length - 1;
        a = a[T], l = l[T].c;
      }
    }
    if (u = e[x], (f = Object.hasOwn(a, u)) && ((g = l[u]) == null ? void 0 : g.t) === 0 && ((_ = l[u]) != null && _.d))
      return null;
    f || (u === "__proto__" && (Object.defineProperty(a, u, { enumerable: !0, configurable: !0, writable: !0 }), Object.defineProperty(l, u, { enumerable: !0, configurable: !0, writable: !0 })), l[u] = {
      t: x < e.length - 1 && s === 2 ? 3 : s,
      d: !1,
      i: 0,
      c: {}
    });
  }
  if (d = l[u], d.t !== s && !(s === 1 && d.t === 3) || (s === 2 && (d.d || (d.d = !0, a[u] = []), a[u].push(a = {}), d.c[d.i++] = d = { t: 1, d: !1, i: 0, c: {} }), d.d))
    return null;
  if (d.d = !0, s === 1)
    a = f ? a[u] : a[u] = {};
  else if (s === 0 && f)
    return null;
  return [u, a, d.c];
}
function Wx(e) {
  let t = {}, r = {}, s = t, a = r;
  for (let l = sn(e, 0); l < e.length; ) {
    if (e[l] === "[") {
      let u = e[++l] === "[", f = go(e, l += +u, "]");
      if (u) {
        if (e[f[1] - 1] !== "]")
          throw new le("expected end of table declaration", {
            toml: e,
            ptr: f[1] - 1
          });
        f[1]++;
      }
      let d = Qc(
        f[0],
        t,
        r,
        u ? 2 : 1
        /* Type.EXPLICIT */
      );
      if (!d)
        throw new le("trying to redefine an already defined table or value", {
          toml: e,
          ptr: l
        });
      a = d[2], s = d[1], l = f[1];
    } else {
      let u = go(e, l), f = Qc(
        u[0],
        s,
        a,
        0
        /* Type.DOTTED */
      );
      if (!f)
        throw new le("trying to redefine an already defined table or value", {
          toml: e,
          ptr: l
        });
      let d = Vo(e, u[1]);
      f[1][f[0]] = d[0], l = d[1];
    }
    if (l = sn(e, l, !0), e[l] && e[l] !== `
` && e[l] !== "\r")
      throw new le("each key-value declaration must be followed by an end-of-line", {
        toml: e,
        ptr: l
      });
    l = sn(e, l);
  }
  return t;
}
/*!
 * Copyright (c) Squirrel Chat et al., All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
const Mf = /^[a-z0-9-_]+$/i;
function Rs(e) {
  let t = typeof e;
  if (t === "object") {
    if (Array.isArray(e))
      return "array";
    if (e instanceof Date)
      return "date";
  }
  return t;
}
function Ux(e) {
  for (let t = 0; t < e.length; t++)
    if (Rs(e[t]) !== "object")
      return !1;
  return e.length != 0;
}
function jo(e) {
  return JSON.stringify(e).replace(/\x7f/g, "\\u007f");
}
function Go(e, t = Rs(e)) {
  if (t === "number")
    return isNaN(e) ? "nan" : e === 1 / 0 ? "inf" : e === -1 / 0 ? "-inf" : e.toString();
  if (t === "bigint" || t === "boolean")
    return e.toString();
  if (t === "string")
    return jo(e);
  if (t === "date") {
    if (isNaN(e.getTime()))
      throw new TypeError("cannot serialize invalid date");
    return e.toISOString();
  }
  if (t === "object")
    return Hx(e);
  if (t === "array")
    return Zx(e);
}
function Hx(e) {
  let t = Object.keys(e);
  if (t.length === 0)
    return "{}";
  let r = "{ ";
  for (let s = 0; s < t.length; s++) {
    let a = t[s];
    s && (r += ", "), r += Mf.test(a) ? a : jo(a), r += " = ", r += Go(e[a]);
  }
  return r + " }";
}
function Zx(e) {
  if (e.length === 0)
    return "[]";
  let t = "[ ";
  for (let r = 0; r < e.length; r++) {
    if (r && (t += ", "), e[r] === null || e[r] === void 0)
      throw new TypeError("arrays cannot contain null or undefined values");
    t += Go(e[r]);
  }
  return t + " ]";
}
function Vx(e, t) {
  let r = "";
  for (let s = 0; s < e.length; s++)
    r += `[[${t}]]
`, r += Yo(e[s], t), r += `

`;
  return r;
}
function Yo(e, t = "") {
  let r = "", s = "", a = Object.keys(e);
  for (let l = 0; l < a.length; l++) {
    let u = a[l];
    if (e[u] !== null && e[u] !== void 0) {
      let f = Rs(e[u]);
      if (f === "symbol" || f === "function")
        throw new TypeError(`cannot serialize values of type '${f}'`);
      let d = Mf.test(u) ? u : jo(u);
      if (f === "array" && Ux(e[u]))
        s += Vx(e[u], t ? `${t}.${d}` : d);
      else if (f === "object") {
        let g = t ? `${t}.${d}` : d;
        s += `[${g}]
`, s += Yo(e[u], g), s += `

`;
      } else
        r += d, r += " = ", r += Go(e[u], f), r += `
`;
    }
  }
  return `${r}
${s}`.trim();
}
function jx(e) {
  if (Rs(e) !== "object")
    throw new TypeError("stringify can only be called with an object");
  return Yo(e);
}
var de;
(function(e) {
  e.assertEqual = (a) => a;
  function t(a) {
  }
  e.assertIs = t;
  function r(a) {
    throw new Error();
  }
  e.assertNever = r, e.arrayToEnum = (a) => {
    const l = {};
    for (const u of a)
      l[u] = u;
    return l;
  }, e.getValidEnumValues = (a) => {
    const l = e.objectKeys(a).filter((f) => typeof a[a[f]] != "number"), u = {};
    for (const f of l)
      u[f] = a[f];
    return e.objectValues(u);
  }, e.objectValues = (a) => e.objectKeys(a).map(function(l) {
    return a[l];
  }), e.objectKeys = typeof Object.keys == "function" ? (a) => Object.keys(a) : (a) => {
    const l = [];
    for (const u in a)
      Object.prototype.hasOwnProperty.call(a, u) && l.push(u);
    return l;
  }, e.find = (a, l) => {
    for (const u of a)
      if (l(u))
        return u;
  }, e.isInteger = typeof Number.isInteger == "function" ? (a) => Number.isInteger(a) : (a) => typeof a == "number" && isFinite(a) && Math.floor(a) === a;
  function s(a, l = " | ") {
    return a.map((u) => typeof u == "string" ? `'${u}'` : u).join(l);
  }
  e.joinValues = s, e.jsonStringifyReplacer = (a, l) => typeof l == "bigint" ? l.toString() : l;
})(de || (de = {}));
var ef;
(function(e) {
  e.mergeShapes = (t, r) => ({
    ...t,
    ...r
    // second overwrites first
  });
})(ef || (ef = {}));
const M = de.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), Un = (e) => {
  switch (typeof e) {
    case "undefined":
      return M.undefined;
    case "string":
      return M.string;
    case "number":
      return isNaN(e) ? M.nan : M.number;
    case "boolean":
      return M.boolean;
    case "function":
      return M.function;
    case "bigint":
      return M.bigint;
    case "symbol":
      return M.symbol;
    case "object":
      return Array.isArray(e) ? M.array : e === null ? M.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? M.promise : typeof Map < "u" && e instanceof Map ? M.map : typeof Set < "u" && e instanceof Set ? M.set : typeof Date < "u" && e instanceof Date ? M.date : M.object;
    default:
      return M.unknown;
  }
}, R = de.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
class Wt extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (s) => {
      this.issues = [...this.issues, s];
    }, this.addIssues = (s = []) => {
      this.issues = [...this.issues, ...s];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const r = t || function(l) {
      return l.message;
    }, s = { _errors: [] }, a = (l) => {
      for (const u of l.issues)
        if (u.code === "invalid_union")
          u.unionErrors.map(a);
        else if (u.code === "invalid_return_type")
          a(u.returnTypeError);
        else if (u.code === "invalid_arguments")
          a(u.argumentsError);
        else if (u.path.length === 0)
          s._errors.push(r(u));
        else {
          let f = s, d = 0;
          for (; d < u.path.length; ) {
            const g = u.path[d];
            d === u.path.length - 1 ? (f[g] = f[g] || { _errors: [] }, f[g]._errors.push(r(u))) : f[g] = f[g] || { _errors: [] }, f = f[g], d++;
          }
        }
    };
    return a(this), s;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, de.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (r) => r.message) {
    const r = {}, s = [];
    for (const a of this.issues)
      a.path.length > 0 ? (r[a.path[0]] = r[a.path[0]] || [], r[a.path[0]].push(t(a))) : s.push(t(a));
    return { formErrors: s, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
}
Wt.create = (e) => new Wt(e);
const cs = (e, t) => {
  let r;
  switch (e.code) {
    case R.invalid_type:
      e.received === M.undefined ? r = "Required" : r = `Expected ${e.expected}, received ${e.received}`;
      break;
    case R.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(e.expected, de.jsonStringifyReplacer)}`;
      break;
    case R.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${de.joinValues(e.keys, ", ")}`;
      break;
    case R.invalid_union:
      r = "Invalid input";
      break;
    case R.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${de.joinValues(e.options)}`;
      break;
    case R.invalid_enum_value:
      r = `Invalid enum value. Expected ${de.joinValues(e.options)}, received '${e.received}'`;
      break;
    case R.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case R.invalid_return_type:
      r = "Invalid function return type";
      break;
    case R.invalid_date:
      r = "Invalid date";
      break;
    case R.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (r = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? r = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? r = `Invalid input: must end with "${e.validation.endsWith}"` : de.assertNever(e.validation) : e.validation !== "regex" ? r = `Invalid ${e.validation}` : r = "Invalid";
      break;
    case R.too_small:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : r = "Invalid input";
      break;
    case R.too_big:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? r = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : r = "Invalid input";
      break;
    case R.custom:
      r = "Invalid input";
      break;
    case R.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case R.not_multiple_of:
      r = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case R.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = t.defaultError, de.assertNever(e);
  }
  return { message: r };
};
let Gx = cs;
function mo() {
  return Gx;
}
const vo = (e) => {
  const { data: t, path: r, errorMaps: s, issueData: a } = e, l = [...r, ...a.path || []], u = {
    ...a,
    path: l
  };
  let f = "";
  const d = s.filter((g) => !!g).slice().reverse();
  for (const g of d)
    f = g(u, { data: t, defaultError: f }).message;
  return {
    ...a,
    path: l,
    message: a.message || f
  };
};
function W(e, t) {
  const r = vo({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      mo(),
      cs
      // then global default map
    ].filter((s) => !!s)
  });
  e.common.issues.push(r);
}
class qe {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, r) {
    const s = [];
    for (const a of r) {
      if (a.status === "aborted")
        return ee;
      a.status === "dirty" && t.dirty(), s.push(a.value);
    }
    return { status: t.value, value: s };
  }
  static async mergeObjectAsync(t, r) {
    const s = [];
    for (const a of r)
      s.push({
        key: await a.key,
        value: await a.value
      });
    return qe.mergeObjectSync(t, s);
  }
  static mergeObjectSync(t, r) {
    const s = {};
    for (const a of r) {
      const { key: l, value: u } = a;
      if (l.status === "aborted" || u.status === "aborted")
        return ee;
      l.status === "dirty" && t.dirty(), u.status === "dirty" && t.dirty(), (typeof u.value < "u" || a.alwaysSet) && (s[l.value] = u.value);
    }
    return { status: t.value, value: s };
  }
}
const ee = Object.freeze({
  status: "aborted"
}), Yx = (e) => ({ status: "dirty", value: e }), rt = (e) => ({ status: "valid", value: e }), tf = (e) => e.status === "aborted", nf = (e) => e.status === "dirty", yo = (e) => e.status === "valid", _o = (e) => typeof Promise < "u" && e instanceof Promise;
var G;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(G || (G = {}));
class Zt {
  constructor(t, r, s, a) {
    this._cachedPath = [], this.parent = t, this.data = r, this._path = s, this._key = a;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const rf = (e, t) => {
  if (yo(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const r = new Wt(e.common.issues);
      return this._error = r, this._error;
    }
  };
};
function ne(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: r, required_error: s, description: a } = e;
  if (t && (r || s))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: a } : { errorMap: (u, f) => u.code !== "invalid_type" ? { message: f.defaultError } : typeof f.data > "u" ? { message: s ?? f.defaultError } : { message: r ?? f.defaultError }, description: a };
}
class ue {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return Un(t.data);
  }
  _getOrReturnCtx(t, r) {
    return r || {
      common: t.parent.common,
      data: t.data,
      parsedType: Un(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new qe(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: Un(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const r = this._parse(t);
    if (_o(r))
      throw new Error("Synchronous parse encountered promise.");
    return r;
  }
  _parseAsync(t) {
    const r = this._parse(t);
    return Promise.resolve(r);
  }
  parse(t, r) {
    const s = this.safeParse(t, r);
    if (s.success)
      return s.data;
    throw s.error;
  }
  safeParse(t, r) {
    var s;
    const a = {
      common: {
        issues: [],
        async: (s = r == null ? void 0 : r.async) !== null && s !== void 0 ? s : !1,
        contextualErrorMap: r == null ? void 0 : r.errorMap
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Un(t)
    }, l = this._parseSync({ data: t, path: a.path, parent: a });
    return rf(a, l);
  }
  async parseAsync(t, r) {
    const s = await this.safeParseAsync(t, r);
    if (s.success)
      return s.data;
    throw s.error;
  }
  async safeParseAsync(t, r) {
    const s = {
      common: {
        issues: [],
        contextualErrorMap: r == null ? void 0 : r.errorMap,
        async: !0
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Un(t)
    }, a = this._parse({ data: t, path: s.path, parent: s }), l = await (_o(a) ? a : Promise.resolve(a));
    return rf(s, l);
  }
  refine(t, r) {
    const s = (a) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(a) : r;
    return this._refinement((a, l) => {
      const u = t(a), f = () => l.addIssue({
        code: R.custom,
        ...s(a)
      });
      return typeof Promise < "u" && u instanceof Promise ? u.then((d) => d ? !0 : (f(), !1)) : u ? !0 : (f(), !1);
    });
  }
  refinement(t, r) {
    return this._refinement((s, a) => t(s) ? !0 : (a.addIssue(typeof r == "function" ? r(s, a) : r), !1));
  }
  _refinement(t) {
    return new on({
      schema: this,
      typeName: X.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return bn.create(this, this._def);
  }
  nullable() {
    return Nr.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return Ut.create(this, this._def);
  }
  promise() {
    return oi.create(this, this._def);
  }
  or(t) {
    return hs.create([this, t], this._def);
  }
  and(t) {
    return ps.create(this, t, this._def);
  }
  transform(t) {
    return new on({
      ...ne(this._def),
      schema: this,
      typeName: X.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const r = typeof t == "function" ? t : () => t;
    return new _s({
      ...ne(this._def),
      innerType: this,
      defaultValue: r,
      typeName: X.ZodDefault
    });
  }
  brand() {
    return new sw({
      typeName: X.ZodBranded,
      type: this,
      ...ne(this._def)
    });
  }
  catch(t) {
    const r = typeof t == "function" ? t : () => t;
    return new To({
      ...ne(this._def),
      innerType: this,
      catchValue: r,
      typeName: X.ZodCatch
    });
  }
  describe(t) {
    const r = this.constructor;
    return new r({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return Ps.create(this, t);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const qx = /^c[^\s-]{8,}$/i, zx = /^[a-z][a-z0-9]*$/, Kx = /[0-9A-HJKMNP-TV-Z]{26}/, Xx = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, Jx = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/, Qx = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u, ew = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, tw = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, nw = (e) => e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function rw(e, t) {
  return !!((t === "v4" || !t) && ew.test(e) || (t === "v6" || !t) && tw.test(e));
}
class rn extends ue {
  constructor() {
    super(...arguments), this._regex = (t, r, s) => this.refinement((a) => t.test(a), {
      validation: r,
      code: R.invalid_string,
      ...G.errToObj(s)
    }), this.nonempty = (t) => this.min(1, G.errToObj(t)), this.trim = () => new rn({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    }), this.toLowerCase = () => new rn({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }), this.toUpperCase = () => new rn({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== M.string) {
      const l = this._getOrReturnCtx(t);
      return W(
        l,
        {
          code: R.invalid_type,
          expected: M.string,
          received: l.parsedType
        }
        //
      ), ee;
    }
    const s = new qe();
    let a;
    for (const l of this._def.checks)
      if (l.kind === "min")
        t.data.length < l.value && (a = this._getOrReturnCtx(t, a), W(a, {
          code: R.too_small,
          minimum: l.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: l.message
        }), s.dirty());
      else if (l.kind === "max")
        t.data.length > l.value && (a = this._getOrReturnCtx(t, a), W(a, {
          code: R.too_big,
          maximum: l.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: l.message
        }), s.dirty());
      else if (l.kind === "length") {
        const u = t.data.length > l.value, f = t.data.length < l.value;
        (u || f) && (a = this._getOrReturnCtx(t, a), u ? W(a, {
          code: R.too_big,
          maximum: l.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: l.message
        }) : f && W(a, {
          code: R.too_small,
          minimum: l.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: l.message
        }), s.dirty());
      } else if (l.kind === "email")
        Jx.test(t.data) || (a = this._getOrReturnCtx(t, a), W(a, {
          validation: "email",
          code: R.invalid_string,
          message: l.message
        }), s.dirty());
      else if (l.kind === "emoji")
        Qx.test(t.data) || (a = this._getOrReturnCtx(t, a), W(a, {
          validation: "emoji",
          code: R.invalid_string,
          message: l.message
        }), s.dirty());
      else if (l.kind === "uuid")
        Xx.test(t.data) || (a = this._getOrReturnCtx(t, a), W(a, {
          validation: "uuid",
          code: R.invalid_string,
          message: l.message
        }), s.dirty());
      else if (l.kind === "cuid")
        qx.test(t.data) || (a = this._getOrReturnCtx(t, a), W(a, {
          validation: "cuid",
          code: R.invalid_string,
          message: l.message
        }), s.dirty());
      else if (l.kind === "cuid2")
        zx.test(t.data) || (a = this._getOrReturnCtx(t, a), W(a, {
          validation: "cuid2",
          code: R.invalid_string,
          message: l.message
        }), s.dirty());
      else if (l.kind === "ulid")
        Kx.test(t.data) || (a = this._getOrReturnCtx(t, a), W(a, {
          validation: "ulid",
          code: R.invalid_string,
          message: l.message
        }), s.dirty());
      else if (l.kind === "url")
        try {
          new URL(t.data);
        } catch {
          a = this._getOrReturnCtx(t, a), W(a, {
            validation: "url",
            code: R.invalid_string,
            message: l.message
          }), s.dirty();
        }
      else
        l.kind === "regex" ? (l.regex.lastIndex = 0, l.regex.test(t.data) || (a = this._getOrReturnCtx(t, a), W(a, {
          validation: "regex",
          code: R.invalid_string,
          message: l.message
        }), s.dirty())) : l.kind === "trim" ? t.data = t.data.trim() : l.kind === "includes" ? t.data.includes(l.value, l.position) || (a = this._getOrReturnCtx(t, a), W(a, {
          code: R.invalid_string,
          validation: { includes: l.value, position: l.position },
          message: l.message
        }), s.dirty()) : l.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : l.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : l.kind === "startsWith" ? t.data.startsWith(l.value) || (a = this._getOrReturnCtx(t, a), W(a, {
          code: R.invalid_string,
          validation: { startsWith: l.value },
          message: l.message
        }), s.dirty()) : l.kind === "endsWith" ? t.data.endsWith(l.value) || (a = this._getOrReturnCtx(t, a), W(a, {
          code: R.invalid_string,
          validation: { endsWith: l.value },
          message: l.message
        }), s.dirty()) : l.kind === "datetime" ? nw(l).test(t.data) || (a = this._getOrReturnCtx(t, a), W(a, {
          code: R.invalid_string,
          validation: "datetime",
          message: l.message
        }), s.dirty()) : l.kind === "ip" ? rw(t.data, l.version) || (a = this._getOrReturnCtx(t, a), W(a, {
          validation: "ip",
          code: R.invalid_string,
          message: l.message
        }), s.dirty()) : de.assertNever(l);
    return { status: s.value, value: t.data };
  }
  _addCheck(t) {
    return new rn({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...G.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...G.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...G.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...G.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...G.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...G.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...G.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...G.errToObj(t) });
  }
  datetime(t) {
    var r;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (r = t == null ? void 0 : t.offset) !== null && r !== void 0 ? r : !1,
      ...G.errToObj(t == null ? void 0 : t.message)
    });
  }
  regex(t, r) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...G.errToObj(r)
    });
  }
  includes(t, r) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: r == null ? void 0 : r.position,
      ...G.errToObj(r == null ? void 0 : r.message)
    });
  }
  startsWith(t, r) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...G.errToObj(r)
    });
  }
  endsWith(t, r) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...G.errToObj(r)
    });
  }
  min(t, r) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...G.errToObj(r)
    });
  }
  max(t, r) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...G.errToObj(r)
    });
  }
  length(t, r) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...G.errToObj(r)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
}
rn.create = (e) => {
  var t;
  return new rn({
    checks: [],
    typeName: X.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...ne(e)
  });
};
function iw(e, t) {
  const r = (e.toString().split(".")[1] || "").length, s = (t.toString().split(".")[1] || "").length, a = r > s ? r : s, l = parseInt(e.toFixed(a).replace(".", "")), u = parseInt(t.toFixed(a).replace(".", ""));
  return l % u / Math.pow(10, a);
}
class Sr extends ue {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== M.number) {
      const l = this._getOrReturnCtx(t);
      return W(l, {
        code: R.invalid_type,
        expected: M.number,
        received: l.parsedType
      }), ee;
    }
    let s;
    const a = new qe();
    for (const l of this._def.checks)
      l.kind === "int" ? de.isInteger(t.data) || (s = this._getOrReturnCtx(t, s), W(s, {
        code: R.invalid_type,
        expected: "integer",
        received: "float",
        message: l.message
      }), a.dirty()) : l.kind === "min" ? (l.inclusive ? t.data < l.value : t.data <= l.value) && (s = this._getOrReturnCtx(t, s), W(s, {
        code: R.too_small,
        minimum: l.value,
        type: "number",
        inclusive: l.inclusive,
        exact: !1,
        message: l.message
      }), a.dirty()) : l.kind === "max" ? (l.inclusive ? t.data > l.value : t.data >= l.value) && (s = this._getOrReturnCtx(t, s), W(s, {
        code: R.too_big,
        maximum: l.value,
        type: "number",
        inclusive: l.inclusive,
        exact: !1,
        message: l.message
      }), a.dirty()) : l.kind === "multipleOf" ? iw(t.data, l.value) !== 0 && (s = this._getOrReturnCtx(t, s), W(s, {
        code: R.not_multiple_of,
        multipleOf: l.value,
        message: l.message
      }), a.dirty()) : l.kind === "finite" ? Number.isFinite(t.data) || (s = this._getOrReturnCtx(t, s), W(s, {
        code: R.not_finite,
        message: l.message
      }), a.dirty()) : de.assertNever(l);
    return { status: a.value, value: t.data };
  }
  gte(t, r) {
    return this.setLimit("min", t, !0, G.toString(r));
  }
  gt(t, r) {
    return this.setLimit("min", t, !1, G.toString(r));
  }
  lte(t, r) {
    return this.setLimit("max", t, !0, G.toString(r));
  }
  lt(t, r) {
    return this.setLimit("max", t, !1, G.toString(r));
  }
  setLimit(t, r, s, a) {
    return new Sr({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: r,
          inclusive: s,
          message: G.toString(a)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Sr({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: G.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: G.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: G.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: G.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: G.toString(t)
    });
  }
  multipleOf(t, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: G.toString(r)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: G.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: G.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: G.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && de.isInteger(t.value));
  }
  get isFinite() {
    let t = null, r = null;
    for (const s of this._def.checks) {
      if (s.kind === "finite" || s.kind === "int" || s.kind === "multipleOf")
        return !0;
      s.kind === "min" ? (r === null || s.value > r) && (r = s.value) : s.kind === "max" && (t === null || s.value < t) && (t = s.value);
    }
    return Number.isFinite(r) && Number.isFinite(t);
  }
}
Sr.create = (e) => new Sr({
  checks: [],
  typeName: X.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...ne(e)
});
class Lr extends ue {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== M.bigint) {
      const l = this._getOrReturnCtx(t);
      return W(l, {
        code: R.invalid_type,
        expected: M.bigint,
        received: l.parsedType
      }), ee;
    }
    let s;
    const a = new qe();
    for (const l of this._def.checks)
      l.kind === "min" ? (l.inclusive ? t.data < l.value : t.data <= l.value) && (s = this._getOrReturnCtx(t, s), W(s, {
        code: R.too_small,
        type: "bigint",
        minimum: l.value,
        inclusive: l.inclusive,
        message: l.message
      }), a.dirty()) : l.kind === "max" ? (l.inclusive ? t.data > l.value : t.data >= l.value) && (s = this._getOrReturnCtx(t, s), W(s, {
        code: R.too_big,
        type: "bigint",
        maximum: l.value,
        inclusive: l.inclusive,
        message: l.message
      }), a.dirty()) : l.kind === "multipleOf" ? t.data % l.value !== BigInt(0) && (s = this._getOrReturnCtx(t, s), W(s, {
        code: R.not_multiple_of,
        multipleOf: l.value,
        message: l.message
      }), a.dirty()) : de.assertNever(l);
    return { status: a.value, value: t.data };
  }
  gte(t, r) {
    return this.setLimit("min", t, !0, G.toString(r));
  }
  gt(t, r) {
    return this.setLimit("min", t, !1, G.toString(r));
  }
  lte(t, r) {
    return this.setLimit("max", t, !0, G.toString(r));
  }
  lt(t, r) {
    return this.setLimit("max", t, !1, G.toString(r));
  }
  setLimit(t, r, s, a) {
    return new Lr({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: r,
          inclusive: s,
          message: G.toString(a)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Lr({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: G.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: G.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: G.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: G.toString(t)
    });
  }
  multipleOf(t, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: G.toString(r)
    });
  }
  get minValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
}
Lr.create = (e) => {
  var t;
  return new Lr({
    checks: [],
    typeName: X.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...ne(e)
  });
};
class xo extends ue {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== M.boolean) {
      const s = this._getOrReturnCtx(t);
      return W(s, {
        code: R.invalid_type,
        expected: M.boolean,
        received: s.parsedType
      }), ee;
    }
    return rt(t.data);
  }
}
xo.create = (e) => new xo({
  typeName: X.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...ne(e)
});
class ai extends ue {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== M.date) {
      const l = this._getOrReturnCtx(t);
      return W(l, {
        code: R.invalid_type,
        expected: M.date,
        received: l.parsedType
      }), ee;
    }
    if (isNaN(t.data.getTime())) {
      const l = this._getOrReturnCtx(t);
      return W(l, {
        code: R.invalid_date
      }), ee;
    }
    const s = new qe();
    let a;
    for (const l of this._def.checks)
      l.kind === "min" ? t.data.getTime() < l.value && (a = this._getOrReturnCtx(t, a), W(a, {
        code: R.too_small,
        message: l.message,
        inclusive: !0,
        exact: !1,
        minimum: l.value,
        type: "date"
      }), s.dirty()) : l.kind === "max" ? t.data.getTime() > l.value && (a = this._getOrReturnCtx(t, a), W(a, {
        code: R.too_big,
        message: l.message,
        inclusive: !0,
        exact: !1,
        maximum: l.value,
        type: "date"
      }), s.dirty()) : de.assertNever(l);
    return {
      status: s.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new ai({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, r) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: G.toString(r)
    });
  }
  max(t, r) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: G.toString(r)
    });
  }
  get minDate() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t != null ? new Date(t) : null;
  }
}
ai.create = (e) => new ai({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || !1,
  typeName: X.ZodDate,
  ...ne(e)
});
class wo extends ue {
  _parse(t) {
    if (this._getType(t) !== M.symbol) {
      const s = this._getOrReturnCtx(t);
      return W(s, {
        code: R.invalid_type,
        expected: M.symbol,
        received: s.parsedType
      }), ee;
    }
    return rt(t.data);
  }
}
wo.create = (e) => new wo({
  typeName: X.ZodSymbol,
  ...ne(e)
});
class fs extends ue {
  _parse(t) {
    if (this._getType(t) !== M.undefined) {
      const s = this._getOrReturnCtx(t);
      return W(s, {
        code: R.invalid_type,
        expected: M.undefined,
        received: s.parsedType
      }), ee;
    }
    return rt(t.data);
  }
}
fs.create = (e) => new fs({
  typeName: X.ZodUndefined,
  ...ne(e)
});
class ds extends ue {
  _parse(t) {
    if (this._getType(t) !== M.null) {
      const s = this._getOrReturnCtx(t);
      return W(s, {
        code: R.invalid_type,
        expected: M.null,
        received: s.parsedType
      }), ee;
    }
    return rt(t.data);
  }
}
ds.create = (e) => new ds({
  typeName: X.ZodNull,
  ...ne(e)
});
class bo extends ue {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return rt(t.data);
  }
}
bo.create = (e) => new bo({
  typeName: X.ZodAny,
  ...ne(e)
});
class Ar extends ue {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return rt(t.data);
  }
}
Ar.create = (e) => new Ar({
  typeName: X.ZodUnknown,
  ...ne(e)
});
class An extends ue {
  _parse(t) {
    const r = this._getOrReturnCtx(t);
    return W(r, {
      code: R.invalid_type,
      expected: M.never,
      received: r.parsedType
    }), ee;
  }
}
An.create = (e) => new An({
  typeName: X.ZodNever,
  ...ne(e)
});
class Eo extends ue {
  _parse(t) {
    if (this._getType(t) !== M.undefined) {
      const s = this._getOrReturnCtx(t);
      return W(s, {
        code: R.invalid_type,
        expected: M.void,
        received: s.parsedType
      }), ee;
    }
    return rt(t.data);
  }
}
Eo.create = (e) => new Eo({
  typeName: X.ZodVoid,
  ...ne(e)
});
class Ut extends ue {
  _parse(t) {
    const { ctx: r, status: s } = this._processInputParams(t), a = this._def;
    if (r.parsedType !== M.array)
      return W(r, {
        code: R.invalid_type,
        expected: M.array,
        received: r.parsedType
      }), ee;
    if (a.exactLength !== null) {
      const u = r.data.length > a.exactLength.value, f = r.data.length < a.exactLength.value;
      (u || f) && (W(r, {
        code: u ? R.too_big : R.too_small,
        minimum: f ? a.exactLength.value : void 0,
        maximum: u ? a.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: a.exactLength.message
      }), s.dirty());
    }
    if (a.minLength !== null && r.data.length < a.minLength.value && (W(r, {
      code: R.too_small,
      minimum: a.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: a.minLength.message
    }), s.dirty()), a.maxLength !== null && r.data.length > a.maxLength.value && (W(r, {
      code: R.too_big,
      maximum: a.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: a.maxLength.message
    }), s.dirty()), r.common.async)
      return Promise.all([...r.data].map((u, f) => a.type._parseAsync(new Zt(r, u, r.path, f)))).then((u) => qe.mergeArray(s, u));
    const l = [...r.data].map((u, f) => a.type._parseSync(new Zt(r, u, r.path, f)));
    return qe.mergeArray(s, l);
  }
  get element() {
    return this._def.type;
  }
  min(t, r) {
    return new Ut({
      ...this._def,
      minLength: { value: t, message: G.toString(r) }
    });
  }
  max(t, r) {
    return new Ut({
      ...this._def,
      maxLength: { value: t, message: G.toString(r) }
    });
  }
  length(t, r) {
    return new Ut({
      ...this._def,
      exactLength: { value: t, message: G.toString(r) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
Ut.create = (e, t) => new Ut({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: X.ZodArray,
  ...ne(t)
});
function yr(e) {
  if (e instanceof be) {
    const t = {};
    for (const r in e.shape) {
      const s = e.shape[r];
      t[r] = bn.create(yr(s));
    }
    return new be({
      ...e._def,
      shape: () => t
    });
  } else
    return e instanceof Ut ? new Ut({
      ...e._def,
      type: yr(e.element)
    }) : e instanceof bn ? bn.create(yr(e.unwrap())) : e instanceof Nr ? Nr.create(yr(e.unwrap())) : e instanceof an ? an.create(e.items.map((t) => yr(t))) : e;
}
class be extends ue {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), r = de.objectKeys(t);
    return this._cached = { shape: t, keys: r };
  }
  _parse(t) {
    if (this._getType(t) !== M.object) {
      const g = this._getOrReturnCtx(t);
      return W(g, {
        code: R.invalid_type,
        expected: M.object,
        received: g.parsedType
      }), ee;
    }
    const { status: s, ctx: a } = this._processInputParams(t), { shape: l, keys: u } = this._getCached(), f = [];
    if (!(this._def.catchall instanceof An && this._def.unknownKeys === "strip"))
      for (const g in a.data)
        u.includes(g) || f.push(g);
    const d = [];
    for (const g of u) {
      const _ = l[g], x = a.data[g];
      d.push({
        key: { status: "valid", value: g },
        value: _._parse(new Zt(a, x, a.path, g)),
        alwaysSet: g in a.data
      });
    }
    if (this._def.catchall instanceof An) {
      const g = this._def.unknownKeys;
      if (g === "passthrough")
        for (const _ of f)
          d.push({
            key: { status: "valid", value: _ },
            value: { status: "valid", value: a.data[_] }
          });
      else if (g === "strict")
        f.length > 0 && (W(a, {
          code: R.unrecognized_keys,
          keys: f
        }), s.dirty());
      else if (g !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const g = this._def.catchall;
      for (const _ of f) {
        const x = a.data[_];
        d.push({
          key: { status: "valid", value: _ },
          value: g._parse(
            new Zt(a, x, a.path, _)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: _ in a.data
        });
      }
    }
    return a.common.async ? Promise.resolve().then(async () => {
      const g = [];
      for (const _ of d) {
        const x = await _.key;
        g.push({
          key: x,
          value: await _.value,
          alwaysSet: _.alwaysSet
        });
      }
      return g;
    }).then((g) => qe.mergeObjectSync(s, g)) : qe.mergeObjectSync(s, d);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return G.errToObj, new be({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (r, s) => {
          var a, l, u, f;
          const d = (u = (l = (a = this._def).errorMap) === null || l === void 0 ? void 0 : l.call(a, r, s).message) !== null && u !== void 0 ? u : s.defaultError;
          return r.code === "unrecognized_keys" ? {
            message: (f = G.errToObj(t).message) !== null && f !== void 0 ? f : d
          } : {
            message: d
          };
        }
      } : {}
    });
  }
  strip() {
    return new be({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new be({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new be({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new be({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: X.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, r) {
    return this.augment({ [t]: r });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new be({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const r = {};
    return de.objectKeys(t).forEach((s) => {
      t[s] && this.shape[s] && (r[s] = this.shape[s]);
    }), new be({
      ...this._def,
      shape: () => r
    });
  }
  omit(t) {
    const r = {};
    return de.objectKeys(this.shape).forEach((s) => {
      t[s] || (r[s] = this.shape[s]);
    }), new be({
      ...this._def,
      shape: () => r
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return yr(this);
  }
  partial(t) {
    const r = {};
    return de.objectKeys(this.shape).forEach((s) => {
      const a = this.shape[s];
      t && !t[s] ? r[s] = a : r[s] = a.optional();
    }), new be({
      ...this._def,
      shape: () => r
    });
  }
  required(t) {
    const r = {};
    return de.objectKeys(this.shape).forEach((s) => {
      if (t && !t[s])
        r[s] = this.shape[s];
      else {
        let l = this.shape[s];
        for (; l instanceof bn; )
          l = l._def.innerType;
        r[s] = l;
      }
    }), new be({
      ...this._def,
      shape: () => r
    });
  }
  keyof() {
    return $f(de.objectKeys(this.shape));
  }
}
be.create = (e, t) => new be({
  shape: () => e,
  unknownKeys: "strip",
  catchall: An.create(),
  typeName: X.ZodObject,
  ...ne(t)
});
be.strictCreate = (e, t) => new be({
  shape: () => e,
  unknownKeys: "strict",
  catchall: An.create(),
  typeName: X.ZodObject,
  ...ne(t)
});
be.lazycreate = (e, t) => new be({
  shape: e,
  unknownKeys: "strip",
  catchall: An.create(),
  typeName: X.ZodObject,
  ...ne(t)
});
class hs extends ue {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), s = this._def.options;
    function a(l) {
      for (const f of l)
        if (f.result.status === "valid")
          return f.result;
      for (const f of l)
        if (f.result.status === "dirty")
          return r.common.issues.push(...f.ctx.common.issues), f.result;
      const u = l.map((f) => new Wt(f.ctx.common.issues));
      return W(r, {
        code: R.invalid_union,
        unionErrors: u
      }), ee;
    }
    if (r.common.async)
      return Promise.all(s.map(async (l) => {
        const u = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await l._parseAsync({
            data: r.data,
            path: r.path,
            parent: u
          }),
          ctx: u
        };
      })).then(a);
    {
      let l;
      const u = [];
      for (const d of s) {
        const g = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        }, _ = d._parseSync({
          data: r.data,
          path: r.path,
          parent: g
        });
        if (_.status === "valid")
          return _;
        _.status === "dirty" && !l && (l = { result: _, ctx: g }), g.common.issues.length && u.push(g.common.issues);
      }
      if (l)
        return r.common.issues.push(...l.ctx.common.issues), l.result;
      const f = u.map((d) => new Wt(d));
      return W(r, {
        code: R.invalid_union,
        unionErrors: f
      }), ee;
    }
  }
  get options() {
    return this._def.options;
  }
}
hs.create = (e, t) => new hs({
  options: e,
  typeName: X.ZodUnion,
  ...ne(t)
});
const os = (e) => e instanceof ms ? os(e.schema) : e instanceof on ? os(e.innerType()) : e instanceof vs ? [e.value] : e instanceof Jn ? e.options : e instanceof ys ? Object.keys(e.enum) : e instanceof _s ? os(e._def.innerType) : e instanceof fs ? [void 0] : e instanceof ds ? [null] : null;
class qo extends ue {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== M.object)
      return W(r, {
        code: R.invalid_type,
        expected: M.object,
        received: r.parsedType
      }), ee;
    const s = this.discriminator, a = r.data[s], l = this.optionsMap.get(a);
    return l ? r.common.async ? l._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    }) : l._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }) : (W(r, {
      code: R.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [s]
    }), ee);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, r, s) {
    const a = /* @__PURE__ */ new Map();
    for (const l of r) {
      const u = os(l.shape[t]);
      if (!u)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const f of u) {
        if (a.has(f))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(f)}`);
        a.set(f, l);
      }
    }
    return new qo({
      typeName: X.ZodDiscriminatedUnion,
      discriminator: t,
      options: r,
      optionsMap: a,
      ...ne(s)
    });
  }
}
function Ao(e, t) {
  const r = Un(e), s = Un(t);
  if (e === t)
    return { valid: !0, data: e };
  if (r === M.object && s === M.object) {
    const a = de.objectKeys(t), l = de.objectKeys(e).filter((f) => a.indexOf(f) !== -1), u = { ...e, ...t };
    for (const f of l) {
      const d = Ao(e[f], t[f]);
      if (!d.valid)
        return { valid: !1 };
      u[f] = d.data;
    }
    return { valid: !0, data: u };
  } else if (r === M.array && s === M.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const a = [];
    for (let l = 0; l < e.length; l++) {
      const u = e[l], f = t[l], d = Ao(u, f);
      if (!d.valid)
        return { valid: !1 };
      a.push(d.data);
    }
    return { valid: !0, data: a };
  } else
    return r === M.date && s === M.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
class ps extends ue {
  _parse(t) {
    const { status: r, ctx: s } = this._processInputParams(t), a = (l, u) => {
      if (tf(l) || tf(u))
        return ee;
      const f = Ao(l.value, u.value);
      return f.valid ? ((nf(l) || nf(u)) && r.dirty(), { status: r.value, value: f.data }) : (W(s, {
        code: R.invalid_intersection_types
      }), ee);
    };
    return s.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: s.data,
        path: s.path,
        parent: s
      }),
      this._def.right._parseAsync({
        data: s.data,
        path: s.path,
        parent: s
      })
    ]).then(([l, u]) => a(l, u)) : a(this._def.left._parseSync({
      data: s.data,
      path: s.path,
      parent: s
    }), this._def.right._parseSync({
      data: s.data,
      path: s.path,
      parent: s
    }));
  }
}
ps.create = (e, t, r) => new ps({
  left: e,
  right: t,
  typeName: X.ZodIntersection,
  ...ne(r)
});
class an extends ue {
  _parse(t) {
    const { status: r, ctx: s } = this._processInputParams(t);
    if (s.parsedType !== M.array)
      return W(s, {
        code: R.invalid_type,
        expected: M.array,
        received: s.parsedType
      }), ee;
    if (s.data.length < this._def.items.length)
      return W(s, {
        code: R.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), ee;
    !this._def.rest && s.data.length > this._def.items.length && (W(s, {
      code: R.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), r.dirty());
    const l = [...s.data].map((u, f) => {
      const d = this._def.items[f] || this._def.rest;
      return d ? d._parse(new Zt(s, u, s.path, f)) : null;
    }).filter((u) => !!u);
    return s.common.async ? Promise.all(l).then((u) => qe.mergeArray(r, u)) : qe.mergeArray(r, l);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new an({
      ...this._def,
      rest: t
    });
  }
}
an.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new an({
    items: e,
    typeName: X.ZodTuple,
    rest: null,
    ...ne(t)
  });
};
class gs extends ue {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: r, ctx: s } = this._processInputParams(t);
    if (s.parsedType !== M.object)
      return W(s, {
        code: R.invalid_type,
        expected: M.object,
        received: s.parsedType
      }), ee;
    const a = [], l = this._def.keyType, u = this._def.valueType;
    for (const f in s.data)
      a.push({
        key: l._parse(new Zt(s, f, s.path, f)),
        value: u._parse(new Zt(s, s.data[f], s.path, f))
      });
    return s.common.async ? qe.mergeObjectAsync(r, a) : qe.mergeObjectSync(r, a);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, r, s) {
    return r instanceof ue ? new gs({
      keyType: t,
      valueType: r,
      typeName: X.ZodRecord,
      ...ne(s)
    }) : new gs({
      keyType: rn.create(),
      valueType: t,
      typeName: X.ZodRecord,
      ...ne(r)
    });
  }
}
class Co extends ue {
  _parse(t) {
    const { status: r, ctx: s } = this._processInputParams(t);
    if (s.parsedType !== M.map)
      return W(s, {
        code: R.invalid_type,
        expected: M.map,
        received: s.parsedType
      }), ee;
    const a = this._def.keyType, l = this._def.valueType, u = [...s.data.entries()].map(([f, d], g) => ({
      key: a._parse(new Zt(s, f, s.path, [g, "key"])),
      value: l._parse(new Zt(s, d, s.path, [g, "value"]))
    }));
    if (s.common.async) {
      const f = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const d of u) {
          const g = await d.key, _ = await d.value;
          if (g.status === "aborted" || _.status === "aborted")
            return ee;
          (g.status === "dirty" || _.status === "dirty") && r.dirty(), f.set(g.value, _.value);
        }
        return { status: r.value, value: f };
      });
    } else {
      const f = /* @__PURE__ */ new Map();
      for (const d of u) {
        const g = d.key, _ = d.value;
        if (g.status === "aborted" || _.status === "aborted")
          return ee;
        (g.status === "dirty" || _.status === "dirty") && r.dirty(), f.set(g.value, _.value);
      }
      return { status: r.value, value: f };
    }
  }
}
Co.create = (e, t, r) => new Co({
  valueType: t,
  keyType: e,
  typeName: X.ZodMap,
  ...ne(r)
});
class Or extends ue {
  _parse(t) {
    const { status: r, ctx: s } = this._processInputParams(t);
    if (s.parsedType !== M.set)
      return W(s, {
        code: R.invalid_type,
        expected: M.set,
        received: s.parsedType
      }), ee;
    const a = this._def;
    a.minSize !== null && s.data.size < a.minSize.value && (W(s, {
      code: R.too_small,
      minimum: a.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: a.minSize.message
    }), r.dirty()), a.maxSize !== null && s.data.size > a.maxSize.value && (W(s, {
      code: R.too_big,
      maximum: a.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: a.maxSize.message
    }), r.dirty());
    const l = this._def.valueType;
    function u(d) {
      const g = /* @__PURE__ */ new Set();
      for (const _ of d) {
        if (_.status === "aborted")
          return ee;
        _.status === "dirty" && r.dirty(), g.add(_.value);
      }
      return { status: r.value, value: g };
    }
    const f = [...s.data.values()].map((d, g) => l._parse(new Zt(s, d, s.path, g)));
    return s.common.async ? Promise.all(f).then((d) => u(d)) : u(f);
  }
  min(t, r) {
    return new Or({
      ...this._def,
      minSize: { value: t, message: G.toString(r) }
    });
  }
  max(t, r) {
    return new Or({
      ...this._def,
      maxSize: { value: t, message: G.toString(r) }
    });
  }
  size(t, r) {
    return this.min(t, r).max(t, r);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
Or.create = (e, t) => new Or({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: X.ZodSet,
  ...ne(t)
});
class si extends ue {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== M.function)
      return W(r, {
        code: R.invalid_type,
        expected: M.function,
        received: r.parsedType
      }), ee;
    function s(f, d) {
      return vo({
        data: f,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          mo(),
          cs
        ].filter((g) => !!g),
        issueData: {
          code: R.invalid_arguments,
          argumentsError: d
        }
      });
    }
    function a(f, d) {
      return vo({
        data: f,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          mo(),
          cs
        ].filter((g) => !!g),
        issueData: {
          code: R.invalid_return_type,
          returnTypeError: d
        }
      });
    }
    const l = { errorMap: r.common.contextualErrorMap }, u = r.data;
    return this._def.returns instanceof oi ? rt(async (...f) => {
      const d = new Wt([]), g = await this._def.args.parseAsync(f, l).catch((T) => {
        throw d.addIssue(s(f, T)), d;
      }), _ = await u(...g);
      return await this._def.returns._def.type.parseAsync(_, l).catch((T) => {
        throw d.addIssue(a(_, T)), d;
      });
    }) : rt((...f) => {
      const d = this._def.args.safeParse(f, l);
      if (!d.success)
        throw new Wt([s(f, d.error)]);
      const g = u(...d.data), _ = this._def.returns.safeParse(g, l);
      if (!_.success)
        throw new Wt([a(g, _.error)]);
      return _.data;
    });
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new si({
      ...this._def,
      args: an.create(t).rest(Ar.create())
    });
  }
  returns(t) {
    return new si({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, r, s) {
    return new si({
      args: t || an.create([]).rest(Ar.create()),
      returns: r || Ar.create(),
      typeName: X.ZodFunction,
      ...ne(s)
    });
  }
}
class ms extends ue {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
  }
}
ms.create = (e, t) => new ms({
  getter: e,
  typeName: X.ZodLazy,
  ...ne(t)
});
class vs extends ue {
  _parse(t) {
    if (t.data !== this._def.value) {
      const r = this._getOrReturnCtx(t);
      return W(r, {
        received: r.data,
        code: R.invalid_literal,
        expected: this._def.value
      }), ee;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
vs.create = (e, t) => new vs({
  value: e,
  typeName: X.ZodLiteral,
  ...ne(t)
});
function $f(e, t) {
  return new Jn({
    values: e,
    typeName: X.ZodEnum,
    ...ne(t)
  });
}
class Jn extends ue {
  _parse(t) {
    if (typeof t.data != "string") {
      const r = this._getOrReturnCtx(t), s = this._def.values;
      return W(r, {
        expected: de.joinValues(s),
        received: r.parsedType,
        code: R.invalid_type
      }), ee;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const r = this._getOrReturnCtx(t), s = this._def.values;
      return W(r, {
        received: r.data,
        code: R.invalid_enum_value,
        options: s
      }), ee;
    }
    return rt(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  get Values() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  get Enum() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  extract(t) {
    return Jn.create(t);
  }
  exclude(t) {
    return Jn.create(this.options.filter((r) => !t.includes(r)));
  }
}
Jn.create = $f;
class ys extends ue {
  _parse(t) {
    const r = de.getValidEnumValues(this._def.values), s = this._getOrReturnCtx(t);
    if (s.parsedType !== M.string && s.parsedType !== M.number) {
      const a = de.objectValues(r);
      return W(s, {
        expected: de.joinValues(a),
        received: s.parsedType,
        code: R.invalid_type
      }), ee;
    }
    if (r.indexOf(t.data) === -1) {
      const a = de.objectValues(r);
      return W(s, {
        received: s.data,
        code: R.invalid_enum_value,
        options: a
      }), ee;
    }
    return rt(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
ys.create = (e, t) => new ys({
  values: e,
  typeName: X.ZodNativeEnum,
  ...ne(t)
});
class oi extends ue {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== M.promise && r.common.async === !1)
      return W(r, {
        code: R.invalid_type,
        expected: M.promise,
        received: r.parsedType
      }), ee;
    const s = r.parsedType === M.promise ? r.data : Promise.resolve(r.data);
    return rt(s.then((a) => this._def.type.parseAsync(a, {
      path: r.path,
      errorMap: r.common.contextualErrorMap
    })));
  }
}
oi.create = (e, t) => new oi({
  type: e,
  typeName: X.ZodPromise,
  ...ne(t)
});
class on extends ue {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === X.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: r, ctx: s } = this._processInputParams(t), a = this._def.effect || null;
    if (a.type === "preprocess") {
      const u = a.transform(s.data);
      return s.common.async ? Promise.resolve(u).then((f) => this._def.schema._parseAsync({
        data: f,
        path: s.path,
        parent: s
      })) : this._def.schema._parseSync({
        data: u,
        path: s.path,
        parent: s
      });
    }
    const l = {
      addIssue: (u) => {
        W(s, u), u.fatal ? r.abort() : r.dirty();
      },
      get path() {
        return s.path;
      }
    };
    if (l.addIssue = l.addIssue.bind(l), a.type === "refinement") {
      const u = (f) => {
        const d = a.refinement(f, l);
        if (s.common.async)
          return Promise.resolve(d);
        if (d instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return f;
      };
      if (s.common.async === !1) {
        const f = this._def.schema._parseSync({
          data: s.data,
          path: s.path,
          parent: s
        });
        return f.status === "aborted" ? ee : (f.status === "dirty" && r.dirty(), u(f.value), { status: r.value, value: f.value });
      } else
        return this._def.schema._parseAsync({ data: s.data, path: s.path, parent: s }).then((f) => f.status === "aborted" ? ee : (f.status === "dirty" && r.dirty(), u(f.value).then(() => ({ status: r.value, value: f.value }))));
    }
    if (a.type === "transform")
      if (s.common.async === !1) {
        const u = this._def.schema._parseSync({
          data: s.data,
          path: s.path,
          parent: s
        });
        if (!yo(u))
          return u;
        const f = a.transform(u.value, l);
        if (f instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: r.value, value: f };
      } else
        return this._def.schema._parseAsync({ data: s.data, path: s.path, parent: s }).then((u) => yo(u) ? Promise.resolve(a.transform(u.value, l)).then((f) => ({ status: r.value, value: f })) : u);
    de.assertNever(a);
  }
}
on.create = (e, t, r) => new on({
  schema: e,
  typeName: X.ZodEffects,
  effect: t,
  ...ne(r)
});
on.createWithPreprocess = (e, t, r) => new on({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: X.ZodEffects,
  ...ne(r)
});
class bn extends ue {
  _parse(t) {
    return this._getType(t) === M.undefined ? rt(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
bn.create = (e, t) => new bn({
  innerType: e,
  typeName: X.ZodOptional,
  ...ne(t)
});
class Nr extends ue {
  _parse(t) {
    return this._getType(t) === M.null ? rt(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Nr.create = (e, t) => new Nr({
  innerType: e,
  typeName: X.ZodNullable,
  ...ne(t)
});
class _s extends ue {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    let s = r.data;
    return r.parsedType === M.undefined && (s = this._def.defaultValue()), this._def.innerType._parse({
      data: s,
      path: r.path,
      parent: r
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
_s.create = (e, t) => new _s({
  innerType: e,
  typeName: X.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...ne(t)
});
class To extends ue {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), s = {
      ...r,
      common: {
        ...r.common,
        issues: []
      }
    }, a = this._def.innerType._parse({
      data: s.data,
      path: s.path,
      parent: {
        ...s
      }
    });
    return _o(a) ? a.then((l) => ({
      status: "valid",
      value: l.status === "valid" ? l.value : this._def.catchValue({
        get error() {
          return new Wt(s.common.issues);
        },
        input: s.data
      })
    })) : {
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new Wt(s.common.issues);
        },
        input: s.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
To.create = (e, t) => new To({
  innerType: e,
  typeName: X.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...ne(t)
});
class So extends ue {
  _parse(t) {
    if (this._getType(t) !== M.nan) {
      const s = this._getOrReturnCtx(t);
      return W(s, {
        code: R.invalid_type,
        expected: M.nan,
        received: s.parsedType
      }), ee;
    }
    return { status: "valid", value: t.data };
  }
}
So.create = (e) => new So({
  typeName: X.ZodNaN,
  ...ne(e)
});
class sw extends ue {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), s = r.data;
    return this._def.type._parse({
      data: s,
      path: r.path,
      parent: r
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Ps extends ue {
  _parse(t) {
    const { status: r, ctx: s } = this._processInputParams(t);
    if (s.common.async)
      return (async () => {
        const l = await this._def.in._parseAsync({
          data: s.data,
          path: s.path,
          parent: s
        });
        return l.status === "aborted" ? ee : l.status === "dirty" ? (r.dirty(), Yx(l.value)) : this._def.out._parseAsync({
          data: l.value,
          path: s.path,
          parent: s
        });
      })();
    {
      const a = this._def.in._parseSync({
        data: s.data,
        path: s.path,
        parent: s
      });
      return a.status === "aborted" ? ee : a.status === "dirty" ? (r.dirty(), {
        status: "dirty",
        value: a.value
      }) : this._def.out._parseSync({
        data: a.value,
        path: s.path,
        parent: s
      });
    }
  }
  static create(t, r) {
    return new Ps({
      in: t,
      out: r,
      typeName: X.ZodPipeline
    });
  }
}
be.lazycreate;
var X;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline";
})(X || (X = {}));
const Kn = rn.create;
Sr.create;
So.create;
Lr.create;
const _r = xo.create;
ai.create;
wo.create;
fs.create;
ds.create;
const sf = bo.create;
Ar.create;
An.create;
Eo.create;
const aw = Ut.create, zo = be.create;
be.strictCreate;
hs.create;
qo.create;
ps.create;
an.create;
gs.create;
Co.create;
Or.create;
const ow = si.create;
ms.create;
vs.create;
Jn.create;
const lw = ys.create;
oi.create;
on.create;
bn.create;
Nr.create;
on.createWithPreprocess;
Ps.create;
var et = /* @__PURE__ */ ((e) => (e.Js = "js", e.Json = "json", e.Yaml = "yaml", e.Xml = "xml", e.Toml = "toml", e))(et || {}), Ne = /* @__PURE__ */ ((e) => (e.String = "string", e.Number = "number", e.Boolean = "boolean", e.Object = "object", e.Array = "array", e.Null = "null", e.Undefined = "undefined", e.NaN = "NaN", e.Date = "Date", e))(Ne || {});
const uw = zo({
  elementSelector: Kn(),
  data: sf(),
  dataType: Kn(),
  rootContainerName: Kn().default("root"),
  withoutContainer: _r().default(!1),
  flipBackgroundColors: _r().default(!1),
  expandFieldsToFullWidth: _r().default(!1),
  readOnlyMode: _r().default(!1),
  onChange: ow().optional(),
  xmlRootName: sf(),
  fullScreen: _r().default(!1)
}), cw = uw.extend({
  dataType: lw(et)
}), af = {
  _path: [],
  _key: "",
  _valueType: Ne.String,
  _value: "",
  _fieldType: void 0
};
const Lo = Math.min, Cr = Math.max, xs = Math.round, Cn = (e) => ({
  x: e,
  y: e
}), fw = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, dw = {
  start: "end",
  end: "start"
};
function of(e, t, r) {
  return Cr(e, Lo(t, r));
}
function Fs(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Qn(e) {
  return e.split("-")[0];
}
function Bs(e) {
  return e.split("-")[1];
}
function Df(e) {
  return e === "x" ? "y" : "x";
}
function Wf(e) {
  return e === "y" ? "height" : "width";
}
function Ms(e) {
  return ["top", "bottom"].includes(Qn(e)) ? "y" : "x";
}
function Uf(e) {
  return Df(Ms(e));
}
function hw(e, t, r) {
  r === void 0 && (r = !1);
  const s = Bs(e), a = Uf(e), l = Wf(a);
  let u = a === "x" ? s === (r ? "end" : "start") ? "right" : "left" : s === "start" ? "bottom" : "top";
  return t.reference[l] > t.floating[l] && (u = ws(u)), [u, ws(u)];
}
function pw(e) {
  const t = ws(e);
  return [Oo(e), t, Oo(t)];
}
function Oo(e) {
  return e.replace(/start|end/g, (t) => dw[t]);
}
function gw(e, t, r) {
  const s = ["left", "right"], a = ["right", "left"], l = ["top", "bottom"], u = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return r ? t ? a : s : t ? s : a;
    case "left":
    case "right":
      return t ? l : u;
    default:
      return [];
  }
}
function mw(e, t, r, s) {
  const a = Bs(e);
  let l = gw(Qn(e), r === "start", s);
  return a && (l = l.map((u) => u + "-" + a), t && (l = l.concat(l.map(Oo)))), l;
}
function ws(e) {
  return e.replace(/left|right|bottom|top/g, (t) => fw[t]);
}
function vw(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function yw(e) {
  return typeof e != "number" ? vw(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function bs(e) {
  return {
    ...e,
    top: e.y,
    left: e.x,
    right: e.x + e.width,
    bottom: e.y + e.height
  };
}
function lf(e, t, r) {
  let {
    reference: s,
    floating: a
  } = e;
  const l = Ms(t), u = Uf(t), f = Wf(u), d = Qn(t), g = l === "y", _ = s.x + s.width / 2 - a.width / 2, x = s.y + s.height / 2 - a.height / 2, T = s[f] / 2 - a[f] / 2;
  let A;
  switch (d) {
    case "top":
      A = {
        x: _,
        y: s.y - a.height
      };
      break;
    case "bottom":
      A = {
        x: _,
        y: s.y + s.height
      };
      break;
    case "right":
      A = {
        x: s.x + s.width,
        y: x
      };
      break;
    case "left":
      A = {
        x: s.x - a.width,
        y: x
      };
      break;
    default:
      A = {
        x: s.x,
        y: s.y
      };
  }
  switch (Bs(t)) {
    case "start":
      A[u] -= T * (r && g ? -1 : 1);
      break;
    case "end":
      A[u] += T * (r && g ? -1 : 1);
      break;
  }
  return A;
}
const _w = async (e, t, r) => {
  const {
    placement: s = "bottom",
    strategy: a = "absolute",
    middleware: l = [],
    platform: u
  } = r, f = l.filter(Boolean), d = await (u.isRTL == null ? void 0 : u.isRTL(t));
  let g = await u.getElementRects({
    reference: e,
    floating: t,
    strategy: a
  }), {
    x: _,
    y: x
  } = lf(g, s, d), T = s, A = {}, C = 0;
  for (let E = 0; E < f.length; E++) {
    const {
      name: P,
      fn: U
    } = f[E], {
      x: H,
      y: $,
      data: Z,
      reset: k
    } = await U({
      x: _,
      y: x,
      initialPlacement: s,
      placement: T,
      strategy: a,
      middlewareData: A,
      rects: g,
      platform: u,
      elements: {
        reference: e,
        floating: t
      }
    });
    if (_ = H ?? _, x = $ ?? x, A = {
      ...A,
      [P]: {
        ...A[P],
        ...Z
      }
    }, k && C <= 50) {
      C++, typeof k == "object" && (k.placement && (T = k.placement), k.rects && (g = k.rects === !0 ? await u.getElementRects({
        reference: e,
        floating: t,
        strategy: a
      }) : k.rects), {
        x: _,
        y: x
      } = lf(g, T, d)), E = -1;
      continue;
    }
  }
  return {
    x: _,
    y: x,
    placement: T,
    strategy: a,
    middlewareData: A
  };
};
async function Hf(e, t) {
  var r;
  t === void 0 && (t = {});
  const {
    x: s,
    y: a,
    platform: l,
    rects: u,
    elements: f,
    strategy: d
  } = e, {
    boundary: g = "clippingAncestors",
    rootBoundary: _ = "viewport",
    elementContext: x = "floating",
    altBoundary: T = !1,
    padding: A = 0
  } = Fs(t, e), C = yw(A), P = f[T ? x === "floating" ? "reference" : "floating" : x], U = bs(await l.getClippingRect({
    element: (r = await (l.isElement == null ? void 0 : l.isElement(P))) == null || r ? P : P.contextElement || await (l.getDocumentElement == null ? void 0 : l.getDocumentElement(f.floating)),
    boundary: g,
    rootBoundary: _,
    strategy: d
  })), H = x === "floating" ? {
    ...u.floating,
    x: s,
    y: a
  } : u.reference, $ = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(f.floating)), Z = await (l.isElement == null ? void 0 : l.isElement($)) ? await (l.getScale == null ? void 0 : l.getScale($)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, k = bs(l.convertOffsetParentRelativeRectToViewportRelativeRect ? await l.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: H,
    offsetParent: $,
    strategy: d
  }) : H);
  return {
    top: (U.top - k.top + C.top) / Z.y,
    bottom: (k.bottom - U.bottom + C.bottom) / Z.y,
    left: (U.left - k.left + C.left) / Z.x,
    right: (k.right - U.right + C.right) / Z.x
  };
}
const xw = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var r, s;
      const {
        placement: a,
        middlewareData: l,
        rects: u,
        initialPlacement: f,
        platform: d,
        elements: g
      } = t, {
        mainAxis: _ = !0,
        crossAxis: x = !0,
        fallbackPlacements: T,
        fallbackStrategy: A = "bestFit",
        fallbackAxisSideDirection: C = "none",
        flipAlignment: E = !0,
        ...P
      } = Fs(e, t);
      if ((r = l.arrow) != null && r.alignmentOffset)
        return {};
      const U = Qn(a), H = Qn(f) === f, $ = await (d.isRTL == null ? void 0 : d.isRTL(g.floating)), Z = T || (H || !E ? [ws(f)] : pw(f));
      !T && C !== "none" && Z.push(...mw(f, E, C, $));
      const k = [f, ...Z], se = await Hf(t, P), Y = [];
      let ge = ((s = l.flip) == null ? void 0 : s.overflows) || [];
      if (_ && Y.push(se[U]), x) {
        const dt = hw(a, u, $);
        Y.push(se[dt[0]], se[dt[1]]);
      }
      if (ge = [...ge, {
        placement: a,
        overflows: Y
      }], !Y.every((dt) => dt <= 0)) {
        var jt, Me;
        const dt = (((jt = l.flip) == null ? void 0 : jt.index) || 0) + 1, Gt = k[dt];
        if (Gt)
          return {
            data: {
              index: dt,
              overflows: ge
            },
            reset: {
              placement: Gt
            }
          };
        let Ze = (Me = ge.filter((At) => At.overflows[0] <= 0).sort((At, it) => At.overflows[1] - it.overflows[1])[0]) == null ? void 0 : Me.placement;
        if (!Ze)
          switch (A) {
            case "bestFit": {
              var cn;
              const At = (cn = ge.map((it) => [it.placement, it.overflows.filter((Se) => Se > 0).reduce((Se, $e) => Se + $e, 0)]).sort((it, Se) => it[1] - Se[1])[0]) == null ? void 0 : cn[0];
              At && (Ze = At);
              break;
            }
            case "initialPlacement":
              Ze = f;
              break;
          }
        if (a !== Ze)
          return {
            reset: {
              placement: Ze
            }
          };
      }
      return {};
    }
  };
};
async function ww(e, t) {
  const {
    placement: r,
    platform: s,
    elements: a
  } = e, l = await (s.isRTL == null ? void 0 : s.isRTL(a.floating)), u = Qn(r), f = Bs(r), d = Ms(r) === "y", g = ["left", "top"].includes(u) ? -1 : 1, _ = l && d ? -1 : 1, x = Fs(t, e);
  let {
    mainAxis: T,
    crossAxis: A,
    alignmentAxis: C
  } = typeof x == "number" ? {
    mainAxis: x,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...x
  };
  return f && typeof C == "number" && (A = f === "end" ? C * -1 : C), d ? {
    x: A * _,
    y: T * g
  } : {
    x: T * g,
    y: A * _
  };
}
const bw = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var r, s;
      const {
        x: a,
        y: l,
        placement: u,
        middlewareData: f
      } = t, d = await ww(t, e);
      return u === ((r = f.offset) == null ? void 0 : r.placement) && (s = f.arrow) != null && s.alignmentOffset ? {} : {
        x: a + d.x,
        y: l + d.y,
        data: {
          ...d,
          placement: u
        }
      };
    }
  };
}, Ew = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: r,
        y: s,
        placement: a
      } = t, {
        mainAxis: l = !0,
        crossAxis: u = !1,
        limiter: f = {
          fn: (P) => {
            let {
              x: U,
              y: H
            } = P;
            return {
              x: U,
              y: H
            };
          }
        },
        ...d
      } = Fs(e, t), g = {
        x: r,
        y: s
      }, _ = await Hf(t, d), x = Ms(Qn(a)), T = Df(x);
      let A = g[T], C = g[x];
      if (l) {
        const P = T === "y" ? "top" : "left", U = T === "y" ? "bottom" : "right", H = A + _[P], $ = A - _[U];
        A = of(H, A, $);
      }
      if (u) {
        const P = x === "y" ? "top" : "left", U = x === "y" ? "bottom" : "right", H = C + _[P], $ = C - _[U];
        C = of(H, C, $);
      }
      const E = f.fn({
        ...t,
        [T]: A,
        [x]: C
      });
      return {
        ...E,
        data: {
          x: E.x - r,
          y: E.y - s
        }
      };
    }
  };
};
function Tn(e) {
  return Zf(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function ft(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function On(e) {
  var t;
  return (t = (Zf(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function Zf(e) {
  return e instanceof Node || e instanceof ft(e).Node;
}
function ln(e) {
  return e instanceof Element || e instanceof ft(e).Element;
}
function Vt(e) {
  return e instanceof HTMLElement || e instanceof ft(e).HTMLElement;
}
function uf(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof ft(e).ShadowRoot;
}
function hi(e) {
  const {
    overflow: t,
    overflowX: r,
    overflowY: s,
    display: a
  } = Et(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + s + r) && !["inline", "contents"].includes(a);
}
function Aw(e) {
  return ["table", "td", "th"].includes(Tn(e));
}
function Ko(e) {
  const t = Xo(), r = Et(e);
  return r.transform !== "none" || r.perspective !== "none" || (r.containerType ? r.containerType !== "normal" : !1) || !t && (r.backdropFilter ? r.backdropFilter !== "none" : !1) || !t && (r.filter ? r.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((s) => (r.willChange || "").includes(s)) || ["paint", "layout", "strict", "content"].some((s) => (r.contain || "").includes(s));
}
function Cw(e) {
  let t = Ir(e);
  for (; Vt(t) && !$s(t); ) {
    if (Ko(t))
      return t;
    t = Ir(t);
  }
  return null;
}
function Xo() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function $s(e) {
  return ["html", "body", "#document"].includes(Tn(e));
}
function Et(e) {
  return ft(e).getComputedStyle(e);
}
function Ds(e) {
  return ln(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.pageXOffset,
    scrollTop: e.pageYOffset
  };
}
function Ir(e) {
  if (Tn(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    uf(e) && e.host || // Fallback.
    On(e)
  );
  return uf(t) ? t.host : t;
}
function Vf(e) {
  const t = Ir(e);
  return $s(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Vt(t) && hi(t) ? t : Vf(t);
}
function No(e, t, r) {
  var s;
  t === void 0 && (t = []), r === void 0 && (r = !0);
  const a = Vf(e), l = a === ((s = e.ownerDocument) == null ? void 0 : s.body), u = ft(a);
  return l ? t.concat(u, u.visualViewport || [], hi(a) ? a : [], u.frameElement && r ? No(u.frameElement) : []) : t.concat(a, No(a, [], r));
}
function jf(e) {
  const t = Et(e);
  let r = parseFloat(t.width) || 0, s = parseFloat(t.height) || 0;
  const a = Vt(e), l = a ? e.offsetWidth : r, u = a ? e.offsetHeight : s, f = xs(r) !== l || xs(s) !== u;
  return f && (r = l, s = u), {
    width: r,
    height: s,
    $: f
  };
}
function Gf(e) {
  return ln(e) ? e : e.contextElement;
}
function Tr(e) {
  const t = Gf(e);
  if (!Vt(t))
    return Cn(1);
  const r = t.getBoundingClientRect(), {
    width: s,
    height: a,
    $: l
  } = jf(t);
  let u = (l ? xs(r.width) : r.width) / s, f = (l ? xs(r.height) : r.height) / a;
  return (!u || !Number.isFinite(u)) && (u = 1), (!f || !Number.isFinite(f)) && (f = 1), {
    x: u,
    y: f
  };
}
const Tw = /* @__PURE__ */ Cn(0);
function Yf(e) {
  const t = ft(e);
  return !Xo() || !t.visualViewport ? Tw : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function Sw(e, t, r) {
  return t === void 0 && (t = !1), !r || t && r !== ft(e) ? !1 : t;
}
function li(e, t, r, s) {
  t === void 0 && (t = !1), r === void 0 && (r = !1);
  const a = e.getBoundingClientRect(), l = Gf(e);
  let u = Cn(1);
  t && (s ? ln(s) && (u = Tr(s)) : u = Tr(e));
  const f = Sw(l, r, s) ? Yf(l) : Cn(0);
  let d = (a.left + f.x) / u.x, g = (a.top + f.y) / u.y, _ = a.width / u.x, x = a.height / u.y;
  if (l) {
    const T = ft(l), A = s && ln(s) ? ft(s) : s;
    let C = T.frameElement;
    for (; C && s && A !== T; ) {
      const E = Tr(C), P = C.getBoundingClientRect(), U = Et(C), H = P.left + (C.clientLeft + parseFloat(U.paddingLeft)) * E.x, $ = P.top + (C.clientTop + parseFloat(U.paddingTop)) * E.y;
      d *= E.x, g *= E.y, _ *= E.x, x *= E.y, d += H, g += $, C = ft(C).frameElement;
    }
  }
  return bs({
    width: _,
    height: x,
    x: d,
    y: g
  });
}
function Lw(e) {
  let {
    rect: t,
    offsetParent: r,
    strategy: s
  } = e;
  const a = Vt(r), l = On(r);
  if (r === l)
    return t;
  let u = {
    scrollLeft: 0,
    scrollTop: 0
  }, f = Cn(1);
  const d = Cn(0);
  if ((a || !a && s !== "fixed") && ((Tn(r) !== "body" || hi(l)) && (u = Ds(r)), Vt(r))) {
    const g = li(r);
    f = Tr(r), d.x = g.x + r.clientLeft, d.y = g.y + r.clientTop;
  }
  return {
    width: t.width * f.x,
    height: t.height * f.y,
    x: t.x * f.x - u.scrollLeft * f.x + d.x,
    y: t.y * f.y - u.scrollTop * f.y + d.y
  };
}
function Ow(e) {
  return Array.from(e.getClientRects());
}
function qf(e) {
  return li(On(e)).left + Ds(e).scrollLeft;
}
function Nw(e) {
  const t = On(e), r = Ds(e), s = e.ownerDocument.body, a = Cr(t.scrollWidth, t.clientWidth, s.scrollWidth, s.clientWidth), l = Cr(t.scrollHeight, t.clientHeight, s.scrollHeight, s.clientHeight);
  let u = -r.scrollLeft + qf(e);
  const f = -r.scrollTop;
  return Et(s).direction === "rtl" && (u += Cr(t.clientWidth, s.clientWidth) - a), {
    width: a,
    height: l,
    x: u,
    y: f
  };
}
function Iw(e, t) {
  const r = ft(e), s = On(e), a = r.visualViewport;
  let l = s.clientWidth, u = s.clientHeight, f = 0, d = 0;
  if (a) {
    l = a.width, u = a.height;
    const g = Xo();
    (!g || g && t === "fixed") && (f = a.offsetLeft, d = a.offsetTop);
  }
  return {
    width: l,
    height: u,
    x: f,
    y: d
  };
}
function kw(e, t) {
  const r = li(e, !0, t === "fixed"), s = r.top + e.clientTop, a = r.left + e.clientLeft, l = Vt(e) ? Tr(e) : Cn(1), u = e.clientWidth * l.x, f = e.clientHeight * l.y, d = a * l.x, g = s * l.y;
  return {
    width: u,
    height: f,
    x: d,
    y: g
  };
}
function cf(e, t, r) {
  let s;
  if (t === "viewport")
    s = Iw(e, r);
  else if (t === "document")
    s = Nw(On(e));
  else if (ln(t))
    s = kw(t, r);
  else {
    const a = Yf(e);
    s = {
      ...t,
      x: t.x - a.x,
      y: t.y - a.y
    };
  }
  return bs(s);
}
function zf(e, t) {
  const r = Ir(e);
  return r === t || !ln(r) || $s(r) ? !1 : Et(r).position === "fixed" || zf(r, t);
}
function Rw(e, t) {
  const r = t.get(e);
  if (r)
    return r;
  let s = No(e, [], !1).filter((f) => ln(f) && Tn(f) !== "body"), a = null;
  const l = Et(e).position === "fixed";
  let u = l ? Ir(e) : e;
  for (; ln(u) && !$s(u); ) {
    const f = Et(u), d = Ko(u);
    !d && f.position === "fixed" && (a = null), (l ? !d && !a : !d && f.position === "static" && !!a && ["absolute", "fixed"].includes(a.position) || hi(u) && !d && zf(e, u)) ? s = s.filter((_) => _ !== u) : a = f, u = Ir(u);
  }
  return t.set(e, s), s;
}
function Pw(e) {
  let {
    element: t,
    boundary: r,
    rootBoundary: s,
    strategy: a
  } = e;
  const u = [...r === "clippingAncestors" ? Rw(t, this._c) : [].concat(r), s], f = u[0], d = u.reduce((g, _) => {
    const x = cf(t, _, a);
    return g.top = Cr(x.top, g.top), g.right = Lo(x.right, g.right), g.bottom = Lo(x.bottom, g.bottom), g.left = Cr(x.left, g.left), g;
  }, cf(t, f, a));
  return {
    width: d.right - d.left,
    height: d.bottom - d.top,
    x: d.left,
    y: d.top
  };
}
function Fw(e) {
  const {
    width: t,
    height: r
  } = jf(e);
  return {
    width: t,
    height: r
  };
}
function Bw(e, t, r) {
  const s = Vt(t), a = On(t), l = r === "fixed", u = li(e, !0, l, t);
  let f = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const d = Cn(0);
  if (s || !s && !l)
    if ((Tn(t) !== "body" || hi(a)) && (f = Ds(t)), s) {
      const g = li(t, !0, l, t);
      d.x = g.x + t.clientLeft, d.y = g.y + t.clientTop;
    } else
      a && (d.x = qf(a));
  return {
    x: u.left + f.scrollLeft - d.x,
    y: u.top + f.scrollTop - d.y,
    width: u.width,
    height: u.height
  };
}
function ff(e, t) {
  return !Vt(e) || Et(e).position === "fixed" ? null : t ? t(e) : e.offsetParent;
}
function Kf(e, t) {
  const r = ft(e);
  if (!Vt(e))
    return r;
  let s = ff(e, t);
  for (; s && Aw(s) && Et(s).position === "static"; )
    s = ff(s, t);
  return s && (Tn(s) === "html" || Tn(s) === "body" && Et(s).position === "static" && !Ko(s)) ? r : s || Cw(e) || r;
}
const Mw = async function(e) {
  let {
    reference: t,
    floating: r,
    strategy: s
  } = e;
  const a = this.getOffsetParent || Kf, l = this.getDimensions;
  return {
    reference: Bw(t, await a(r), s),
    floating: {
      x: 0,
      y: 0,
      ...await l(r)
    }
  };
};
function $w(e) {
  return Et(e).direction === "rtl";
}
const Dw = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Lw,
  getDocumentElement: On,
  getClippingRect: Pw,
  getOffsetParent: Kf,
  getElementRects: Mw,
  getClientRects: Ow,
  getDimensions: Fw,
  getScale: Tr,
  isElement: ln,
  isRTL: $w
}, Ww = Ew, Uw = xw, Hw = (e, t, r) => {
  const s = /* @__PURE__ */ new Map(), a = {
    platform: Dw,
    ...r
  }, l = {
    ...a.platform,
    _c: s
  };
  return _w(e, t, {
    ...a,
    platform: l
  });
};
var Es = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
Es.exports;
(function(e, t) {
  (function() {
    var r, s = "4.17.21", a = 200, l = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", u = "Expected a function", f = "Invalid `variable` option passed into `_.template`", d = "__lodash_hash_undefined__", g = 500, _ = "__lodash_placeholder__", x = 1, T = 2, A = 4, C = 1, E = 2, P = 1, U = 2, H = 4, $ = 8, Z = 16, k = 32, se = 64, Y = 128, ge = 256, jt = 512, Me = 30, cn = "...", dt = 800, Gt = 16, Ze = 1, At = 2, it = 3, Se = 1 / 0, $e = 9007199254740991, Nn = 17976931348623157e292, er = 0 / 0, Rt = 4294967295, Ed = Rt - 1, Ad = Rt >>> 1, Cd = [
      ["ary", Y],
      ["bind", P],
      ["bindKey", U],
      ["curry", $],
      ["curryRight", Z],
      ["flip", jt],
      ["partial", k],
      ["partialRight", se],
      ["rearg", ge]
    ], tr = "[object Arguments]", pi = "[object Array]", Td = "[object AsyncFunction]", Pr = "[object Boolean]", Fr = "[object Date]", Sd = "[object DOMException]", gi = "[object Error]", mi = "[object Function]", dl = "[object GeneratorFunction]", Ct = "[object Map]", Br = "[object Number]", Ld = "[object Null]", Yt = "[object Object]", hl = "[object Promise]", Od = "[object Proxy]", Mr = "[object RegExp]", Tt = "[object Set]", $r = "[object String]", vi = "[object Symbol]", Nd = "[object Undefined]", Dr = "[object WeakMap]", Id = "[object WeakSet]", Wr = "[object ArrayBuffer]", nr = "[object DataView]", Hs = "[object Float32Array]", Zs = "[object Float64Array]", Vs = "[object Int8Array]", js = "[object Int16Array]", Gs = "[object Int32Array]", Ys = "[object Uint8Array]", qs = "[object Uint8ClampedArray]", zs = "[object Uint16Array]", Ks = "[object Uint32Array]", kd = /\b__p \+= '';/g, Rd = /\b(__p \+=) '' \+/g, Pd = /(__e\(.*?\)|\b__t\)) \+\n'';/g, pl = /&(?:amp|lt|gt|quot|#39);/g, gl = /[&<>"']/g, Fd = RegExp(pl.source), Bd = RegExp(gl.source), Md = /<%-([\s\S]+?)%>/g, $d = /<%([\s\S]+?)%>/g, ml = /<%=([\s\S]+?)%>/g, Dd = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Wd = /^\w*$/, Ud = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Xs = /[\\^$.*+?()[\]{}|]/g, Hd = RegExp(Xs.source), Js = /^\s+/, Zd = /\s/, Vd = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, jd = /\{\n\/\* \[wrapped with (.+)\] \*/, Gd = /,? & /, Yd = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, qd = /[()=,{}\[\]\/\s]/, zd = /\\(\\)?/g, Kd = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, vl = /\w*$/, Xd = /^[-+]0x[0-9a-f]+$/i, Jd = /^0b[01]+$/i, Qd = /^\[object .+?Constructor\]$/, eh = /^0o[0-7]+$/i, th = /^(?:0|[1-9]\d*)$/, nh = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, yi = /($^)/, rh = /['\n\r\u2028\u2029\\]/g, _i = "\\ud800-\\udfff", ih = "\\u0300-\\u036f", sh = "\\ufe20-\\ufe2f", ah = "\\u20d0-\\u20ff", yl = ih + sh + ah, _l = "\\u2700-\\u27bf", xl = "a-z\\xdf-\\xf6\\xf8-\\xff", oh = "\\xac\\xb1\\xd7\\xf7", lh = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", uh = "\\u2000-\\u206f", ch = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", wl = "A-Z\\xc0-\\xd6\\xd8-\\xde", bl = "\\ufe0e\\ufe0f", El = oh + lh + uh + ch, Qs = "[']", fh = "[" + _i + "]", Al = "[" + El + "]", xi = "[" + yl + "]", Cl = "\\d+", dh = "[" + _l + "]", Tl = "[" + xl + "]", Sl = "[^" + _i + El + Cl + _l + xl + wl + "]", ea = "\\ud83c[\\udffb-\\udfff]", hh = "(?:" + xi + "|" + ea + ")", Ll = "[^" + _i + "]", ta = "(?:\\ud83c[\\udde6-\\uddff]){2}", na = "[\\ud800-\\udbff][\\udc00-\\udfff]", rr = "[" + wl + "]", Ol = "\\u200d", Nl = "(?:" + Tl + "|" + Sl + ")", ph = "(?:" + rr + "|" + Sl + ")", Il = "(?:" + Qs + "(?:d|ll|m|re|s|t|ve))?", kl = "(?:" + Qs + "(?:D|LL|M|RE|S|T|VE))?", Rl = hh + "?", Pl = "[" + bl + "]?", gh = "(?:" + Ol + "(?:" + [Ll, ta, na].join("|") + ")" + Pl + Rl + ")*", mh = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", vh = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", Fl = Pl + Rl + gh, yh = "(?:" + [dh, ta, na].join("|") + ")" + Fl, _h = "(?:" + [Ll + xi + "?", xi, ta, na, fh].join("|") + ")", xh = RegExp(Qs, "g"), wh = RegExp(xi, "g"), ra = RegExp(ea + "(?=" + ea + ")|" + _h + Fl, "g"), bh = RegExp([
      rr + "?" + Tl + "+" + Il + "(?=" + [Al, rr, "$"].join("|") + ")",
      ph + "+" + kl + "(?=" + [Al, rr + Nl, "$"].join("|") + ")",
      rr + "?" + Nl + "+" + Il,
      rr + "+" + kl,
      vh,
      mh,
      Cl,
      yh
    ].join("|"), "g"), Eh = RegExp("[" + Ol + _i + yl + bl + "]"), Ah = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Ch = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], Th = -1, ye = {};
    ye[Hs] = ye[Zs] = ye[Vs] = ye[js] = ye[Gs] = ye[Ys] = ye[qs] = ye[zs] = ye[Ks] = !0, ye[tr] = ye[pi] = ye[Wr] = ye[Pr] = ye[nr] = ye[Fr] = ye[gi] = ye[mi] = ye[Ct] = ye[Br] = ye[Yt] = ye[Mr] = ye[Tt] = ye[$r] = ye[Dr] = !1;
    var ve = {};
    ve[tr] = ve[pi] = ve[Wr] = ve[nr] = ve[Pr] = ve[Fr] = ve[Hs] = ve[Zs] = ve[Vs] = ve[js] = ve[Gs] = ve[Ct] = ve[Br] = ve[Yt] = ve[Mr] = ve[Tt] = ve[$r] = ve[vi] = ve[Ys] = ve[qs] = ve[zs] = ve[Ks] = !0, ve[gi] = ve[mi] = ve[Dr] = !1;
    var Sh = {
      // Latin-1 Supplement block.
      : "A",
      : "A",
      : "A",
      : "A",
      : "A",
      : "A",
      : "a",
      : "a",
      : "a",
      : "a",
      : "a",
      : "a",
      : "C",
      : "c",
      : "D",
      : "d",
      : "E",
      : "E",
      : "E",
      : "E",
      : "e",
      : "e",
      : "e",
      : "e",
      : "I",
      : "I",
      : "I",
      : "I",
      : "i",
      : "i",
      : "i",
      : "i",
      : "N",
      : "n",
      : "O",
      : "O",
      : "O",
      : "O",
      : "O",
      : "O",
      : "o",
      : "o",
      : "o",
      : "o",
      : "o",
      : "o",
      : "U",
      : "U",
      : "U",
      : "U",
      : "u",
      : "u",
      : "u",
      : "u",
      : "Y",
      : "y",
      : "y",
      : "Ae",
      : "ae",
      : "Th",
      : "th",
      : "ss",
      // Latin Extended-A block.
      : "A",
      : "A",
      : "A",
      : "a",
      : "a",
      : "a",
      : "C",
      : "C",
      : "C",
      : "C",
      : "c",
      : "c",
      : "c",
      : "c",
      : "D",
      : "D",
      : "d",
      : "d",
      : "E",
      : "E",
      : "E",
      : "E",
      : "E",
      : "e",
      : "e",
      : "e",
      : "e",
      : "e",
      : "G",
      : "G",
      : "G",
      : "G",
      : "g",
      : "g",
      : "g",
      : "g",
      : "H",
      : "H",
      : "h",
      : "h",
      : "I",
      : "I",
      : "I",
      : "I",
      : "I",
      : "i",
      : "i",
      : "i",
      : "i",
      : "i",
      : "J",
      : "j",
      : "K",
      : "k",
      : "k",
      : "L",
      : "L",
      : "L",
      : "L",
      : "L",
      : "l",
      : "l",
      : "l",
      : "l",
      : "l",
      : "N",
      : "N",
      : "N",
      : "N",
      : "n",
      : "n",
      : "n",
      : "n",
      : "O",
      : "O",
      : "O",
      : "o",
      : "o",
      : "o",
      : "R",
      : "R",
      : "R",
      : "r",
      : "r",
      : "r",
      : "S",
      : "S",
      : "S",
      : "S",
      : "s",
      : "s",
      : "s",
      : "s",
      : "T",
      : "T",
      : "T",
      : "t",
      : "t",
      : "t",
      : "U",
      : "U",
      : "U",
      : "U",
      : "U",
      : "U",
      : "u",
      : "u",
      : "u",
      : "u",
      : "u",
      : "u",
      : "W",
      : "w",
      : "Y",
      : "y",
      : "Y",
      : "Z",
      : "Z",
      : "Z",
      : "z",
      : "z",
      : "z",
      : "IJ",
      : "ij",
      : "Oe",
      : "oe",
      : "'n",
      : "s"
    }, Lh = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, Oh = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, Nh = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, Ih = parseFloat, kh = parseInt, Bl = typeof Wn == "object" && Wn && Wn.Object === Object && Wn, Rh = typeof self == "object" && self && self.Object === Object && self, Fe = Bl || Rh || Function("return this")(), ia = t && !t.nodeType && t, In = ia && !0 && e && !e.nodeType && e, Ml = In && In.exports === ia, sa = Ml && Bl.process, ht = function() {
      try {
        var w = In && In.require && In.require("util").types;
        return w || sa && sa.binding && sa.binding("util");
      } catch {
      }
    }(), $l = ht && ht.isArrayBuffer, Dl = ht && ht.isDate, Wl = ht && ht.isMap, Ul = ht && ht.isRegExp, Hl = ht && ht.isSet, Zl = ht && ht.isTypedArray;
    function st(w, L, S) {
      switch (S.length) {
        case 0:
          return w.call(L);
        case 1:
          return w.call(L, S[0]);
        case 2:
          return w.call(L, S[0], S[1]);
        case 3:
          return w.call(L, S[0], S[1], S[2]);
      }
      return w.apply(L, S);
    }
    function Ph(w, L, S, D) {
      for (var J = -1, fe = w == null ? 0 : w.length; ++J < fe; ) {
        var Le = w[J];
        L(D, Le, S(Le), w);
      }
      return D;
    }
    function pt(w, L) {
      for (var S = -1, D = w == null ? 0 : w.length; ++S < D && L(w[S], S, w) !== !1; )
        ;
      return w;
    }
    function Fh(w, L) {
      for (var S = w == null ? 0 : w.length; S-- && L(w[S], S, w) !== !1; )
        ;
      return w;
    }
    function Vl(w, L) {
      for (var S = -1, D = w == null ? 0 : w.length; ++S < D; )
        if (!L(w[S], S, w))
          return !1;
      return !0;
    }
    function fn(w, L) {
      for (var S = -1, D = w == null ? 0 : w.length, J = 0, fe = []; ++S < D; ) {
        var Le = w[S];
        L(Le, S, w) && (fe[J++] = Le);
      }
      return fe;
    }
    function wi(w, L) {
      var S = w == null ? 0 : w.length;
      return !!S && ir(w, L, 0) > -1;
    }
    function aa(w, L, S) {
      for (var D = -1, J = w == null ? 0 : w.length; ++D < J; )
        if (S(L, w[D]))
          return !0;
      return !1;
    }
    function _e(w, L) {
      for (var S = -1, D = w == null ? 0 : w.length, J = Array(D); ++S < D; )
        J[S] = L(w[S], S, w);
      return J;
    }
    function dn(w, L) {
      for (var S = -1, D = L.length, J = w.length; ++S < D; )
        w[J + S] = L[S];
      return w;
    }
    function oa(w, L, S, D) {
      var J = -1, fe = w == null ? 0 : w.length;
      for (D && fe && (S = w[++J]); ++J < fe; )
        S = L(S, w[J], J, w);
      return S;
    }
    function Bh(w, L, S, D) {
      var J = w == null ? 0 : w.length;
      for (D && J && (S = w[--J]); J--; )
        S = L(S, w[J], J, w);
      return S;
    }
    function la(w, L) {
      for (var S = -1, D = w == null ? 0 : w.length; ++S < D; )
        if (L(w[S], S, w))
          return !0;
      return !1;
    }
    var Mh = ua("length");
    function $h(w) {
      return w.split("");
    }
    function Dh(w) {
      return w.match(Yd) || [];
    }
    function jl(w, L, S) {
      var D;
      return S(w, function(J, fe, Le) {
        if (L(J, fe, Le))
          return D = fe, !1;
      }), D;
    }
    function bi(w, L, S, D) {
      for (var J = w.length, fe = S + (D ? 1 : -1); D ? fe-- : ++fe < J; )
        if (L(w[fe], fe, w))
          return fe;
      return -1;
    }
    function ir(w, L, S) {
      return L === L ? Xh(w, L, S) : bi(w, Gl, S);
    }
    function Wh(w, L, S, D) {
      for (var J = S - 1, fe = w.length; ++J < fe; )
        if (D(w[J], L))
          return J;
      return -1;
    }
    function Gl(w) {
      return w !== w;
    }
    function Yl(w, L) {
      var S = w == null ? 0 : w.length;
      return S ? fa(w, L) / S : er;
    }
    function ua(w) {
      return function(L) {
        return L == null ? r : L[w];
      };
    }
    function ca(w) {
      return function(L) {
        return w == null ? r : w[L];
      };
    }
    function ql(w, L, S, D, J) {
      return J(w, function(fe, Le, me) {
        S = D ? (D = !1, fe) : L(S, fe, Le, me);
      }), S;
    }
    function Uh(w, L) {
      var S = w.length;
      for (w.sort(L); S--; )
        w[S] = w[S].value;
      return w;
    }
    function fa(w, L) {
      for (var S, D = -1, J = w.length; ++D < J; ) {
        var fe = L(w[D]);
        fe !== r && (S = S === r ? fe : S + fe);
      }
      return S;
    }
    function da(w, L) {
      for (var S = -1, D = Array(w); ++S < w; )
        D[S] = L(S);
      return D;
    }
    function Hh(w, L) {
      return _e(L, function(S) {
        return [S, w[S]];
      });
    }
    function zl(w) {
      return w && w.slice(0, Ql(w) + 1).replace(Js, "");
    }
    function at(w) {
      return function(L) {
        return w(L);
      };
    }
    function ha(w, L) {
      return _e(L, function(S) {
        return w[S];
      });
    }
    function Ur(w, L) {
      return w.has(L);
    }
    function Kl(w, L) {
      for (var S = -1, D = w.length; ++S < D && ir(L, w[S], 0) > -1; )
        ;
      return S;
    }
    function Xl(w, L) {
      for (var S = w.length; S-- && ir(L, w[S], 0) > -1; )
        ;
      return S;
    }
    function Zh(w, L) {
      for (var S = w.length, D = 0; S--; )
        w[S] === L && ++D;
      return D;
    }
    var Vh = ca(Sh), jh = ca(Lh);
    function Gh(w) {
      return "\\" + Nh[w];
    }
    function Yh(w, L) {
      return w == null ? r : w[L];
    }
    function sr(w) {
      return Eh.test(w);
    }
    function qh(w) {
      return Ah.test(w);
    }
    function zh(w) {
      for (var L, S = []; !(L = w.next()).done; )
        S.push(L.value);
      return S;
    }
    function pa(w) {
      var L = -1, S = Array(w.size);
      return w.forEach(function(D, J) {
        S[++L] = [J, D];
      }), S;
    }
    function Jl(w, L) {
      return function(S) {
        return w(L(S));
      };
    }
    function hn(w, L) {
      for (var S = -1, D = w.length, J = 0, fe = []; ++S < D; ) {
        var Le = w[S];
        (Le === L || Le === _) && (w[S] = _, fe[J++] = S);
      }
      return fe;
    }
    function Ei(w) {
      var L = -1, S = Array(w.size);
      return w.forEach(function(D) {
        S[++L] = D;
      }), S;
    }
    function Kh(w) {
      var L = -1, S = Array(w.size);
      return w.forEach(function(D) {
        S[++L] = [D, D];
      }), S;
    }
    function Xh(w, L, S) {
      for (var D = S - 1, J = w.length; ++D < J; )
        if (w[D] === L)
          return D;
      return -1;
    }
    function Jh(w, L, S) {
      for (var D = S + 1; D--; )
        if (w[D] === L)
          return D;
      return D;
    }
    function ar(w) {
      return sr(w) ? ep(w) : Mh(w);
    }
    function St(w) {
      return sr(w) ? tp(w) : $h(w);
    }
    function Ql(w) {
      for (var L = w.length; L-- && Zd.test(w.charAt(L)); )
        ;
      return L;
    }
    var Qh = ca(Oh);
    function ep(w) {
      for (var L = ra.lastIndex = 0; ra.test(w); )
        ++L;
      return L;
    }
    function tp(w) {
      return w.match(ra) || [];
    }
    function np(w) {
      return w.match(bh) || [];
    }
    var rp = function w(L) {
      L = L == null ? Fe : or.defaults(Fe.Object(), L, or.pick(Fe, Ch));
      var S = L.Array, D = L.Date, J = L.Error, fe = L.Function, Le = L.Math, me = L.Object, ga = L.RegExp, ip = L.String, gt = L.TypeError, Ai = S.prototype, sp = fe.prototype, lr = me.prototype, Ci = L["__core-js_shared__"], Ti = sp.toString, pe = lr.hasOwnProperty, ap = 0, eu = function() {
        var n = /[^.]+$/.exec(Ci && Ci.keys && Ci.keys.IE_PROTO || "");
        return n ? "Symbol(src)_1." + n : "";
      }(), Si = lr.toString, op = Ti.call(me), lp = Fe._, up = ga(
        "^" + Ti.call(pe).replace(Xs, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), Li = Ml ? L.Buffer : r, pn = L.Symbol, Oi = L.Uint8Array, tu = Li ? Li.allocUnsafe : r, Ni = Jl(me.getPrototypeOf, me), nu = me.create, ru = lr.propertyIsEnumerable, Ii = Ai.splice, iu = pn ? pn.isConcatSpreadable : r, Hr = pn ? pn.iterator : r, kn = pn ? pn.toStringTag : r, ki = function() {
        try {
          var n = Mn(me, "defineProperty");
          return n({}, "", {}), n;
        } catch {
        }
      }(), cp = L.clearTimeout !== Fe.clearTimeout && L.clearTimeout, fp = D && D.now !== Fe.Date.now && D.now, dp = L.setTimeout !== Fe.setTimeout && L.setTimeout, Ri = Le.ceil, Pi = Le.floor, ma = me.getOwnPropertySymbols, hp = Li ? Li.isBuffer : r, su = L.isFinite, pp = Ai.join, gp = Jl(me.keys, me), Oe = Le.max, De = Le.min, mp = D.now, vp = L.parseInt, au = Le.random, yp = Ai.reverse, va = Mn(L, "DataView"), Zr = Mn(L, "Map"), ya = Mn(L, "Promise"), ur = Mn(L, "Set"), Vr = Mn(L, "WeakMap"), jr = Mn(me, "create"), Fi = Vr && new Vr(), cr = {}, _p = $n(va), xp = $n(Zr), wp = $n(ya), bp = $n(ur), Ep = $n(Vr), Bi = pn ? pn.prototype : r, Gr = Bi ? Bi.valueOf : r, ou = Bi ? Bi.toString : r;
      function p(n) {
        if (we(n) && !Q(n) && !(n instanceof oe)) {
          if (n instanceof mt)
            return n;
          if (pe.call(n, "__wrapped__"))
            return lc(n);
        }
        return new mt(n);
      }
      var fr = function() {
        function n() {
        }
        return function(i) {
          if (!xe(i))
            return {};
          if (nu)
            return nu(i);
          n.prototype = i;
          var o = new n();
          return n.prototype = r, o;
        };
      }();
      function Mi() {
      }
      function mt(n, i) {
        this.__wrapped__ = n, this.__actions__ = [], this.__chain__ = !!i, this.__index__ = 0, this.__values__ = r;
      }
      p.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: Md,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: $d,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: ml,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: p
        }
      }, p.prototype = Mi.prototype, p.prototype.constructor = p, mt.prototype = fr(Mi.prototype), mt.prototype.constructor = mt;
      function oe(n) {
        this.__wrapped__ = n, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = Rt, this.__views__ = [];
      }
      function Ap() {
        var n = new oe(this.__wrapped__);
        return n.__actions__ = ze(this.__actions__), n.__dir__ = this.__dir__, n.__filtered__ = this.__filtered__, n.__iteratees__ = ze(this.__iteratees__), n.__takeCount__ = this.__takeCount__, n.__views__ = ze(this.__views__), n;
      }
      function Cp() {
        if (this.__filtered__) {
          var n = new oe(this);
          n.__dir__ = -1, n.__filtered__ = !0;
        } else
          n = this.clone(), n.__dir__ *= -1;
        return n;
      }
      function Tp() {
        var n = this.__wrapped__.value(), i = this.__dir__, o = Q(n), c = i < 0, h = o ? n.length : 0, m = $g(0, h, this.__views__), v = m.start, y = m.end, b = y - v, O = c ? y : v - 1, N = this.__iteratees__, I = N.length, F = 0, V = De(b, this.__takeCount__);
        if (!o || !c && h == b && V == b)
          return Iu(n, this.__actions__);
        var z = [];
        e:
          for (; b-- && F < V; ) {
            O += i;
            for (var re = -1, K = n[O]; ++re < I; ) {
              var ae = N[re], ce = ae.iteratee, ut = ae.type, Ge = ce(K);
              if (ut == At)
                K = Ge;
              else if (!Ge) {
                if (ut == Ze)
                  continue e;
                break e;
              }
            }
            z[F++] = K;
          }
        return z;
      }
      oe.prototype = fr(Mi.prototype), oe.prototype.constructor = oe;
      function Rn(n) {
        var i = -1, o = n == null ? 0 : n.length;
        for (this.clear(); ++i < o; ) {
          var c = n[i];
          this.set(c[0], c[1]);
        }
      }
      function Sp() {
        this.__data__ = jr ? jr(null) : {}, this.size = 0;
      }
      function Lp(n) {
        var i = this.has(n) && delete this.__data__[n];
        return this.size -= i ? 1 : 0, i;
      }
      function Op(n) {
        var i = this.__data__;
        if (jr) {
          var o = i[n];
          return o === d ? r : o;
        }
        return pe.call(i, n) ? i[n] : r;
      }
      function Np(n) {
        var i = this.__data__;
        return jr ? i[n] !== r : pe.call(i, n);
      }
      function Ip(n, i) {
        var o = this.__data__;
        return this.size += this.has(n) ? 0 : 1, o[n] = jr && i === r ? d : i, this;
      }
      Rn.prototype.clear = Sp, Rn.prototype.delete = Lp, Rn.prototype.get = Op, Rn.prototype.has = Np, Rn.prototype.set = Ip;
      function qt(n) {
        var i = -1, o = n == null ? 0 : n.length;
        for (this.clear(); ++i < o; ) {
          var c = n[i];
          this.set(c[0], c[1]);
        }
      }
      function kp() {
        this.__data__ = [], this.size = 0;
      }
      function Rp(n) {
        var i = this.__data__, o = $i(i, n);
        if (o < 0)
          return !1;
        var c = i.length - 1;
        return o == c ? i.pop() : Ii.call(i, o, 1), --this.size, !0;
      }
      function Pp(n) {
        var i = this.__data__, o = $i(i, n);
        return o < 0 ? r : i[o][1];
      }
      function Fp(n) {
        return $i(this.__data__, n) > -1;
      }
      function Bp(n, i) {
        var o = this.__data__, c = $i(o, n);
        return c < 0 ? (++this.size, o.push([n, i])) : o[c][1] = i, this;
      }
      qt.prototype.clear = kp, qt.prototype.delete = Rp, qt.prototype.get = Pp, qt.prototype.has = Fp, qt.prototype.set = Bp;
      function zt(n) {
        var i = -1, o = n == null ? 0 : n.length;
        for (this.clear(); ++i < o; ) {
          var c = n[i];
          this.set(c[0], c[1]);
        }
      }
      function Mp() {
        this.size = 0, this.__data__ = {
          hash: new Rn(),
          map: new (Zr || qt)(),
          string: new Rn()
        };
      }
      function $p(n) {
        var i = Ki(this, n).delete(n);
        return this.size -= i ? 1 : 0, i;
      }
      function Dp(n) {
        return Ki(this, n).get(n);
      }
      function Wp(n) {
        return Ki(this, n).has(n);
      }
      function Up(n, i) {
        var o = Ki(this, n), c = o.size;
        return o.set(n, i), this.size += o.size == c ? 0 : 1, this;
      }
      zt.prototype.clear = Mp, zt.prototype.delete = $p, zt.prototype.get = Dp, zt.prototype.has = Wp, zt.prototype.set = Up;
      function Pn(n) {
        var i = -1, o = n == null ? 0 : n.length;
        for (this.__data__ = new zt(); ++i < o; )
          this.add(n[i]);
      }
      function Hp(n) {
        return this.__data__.set(n, d), this;
      }
      function Zp(n) {
        return this.__data__.has(n);
      }
      Pn.prototype.add = Pn.prototype.push = Hp, Pn.prototype.has = Zp;
      function Lt(n) {
        var i = this.__data__ = new qt(n);
        this.size = i.size;
      }
      function Vp() {
        this.__data__ = new qt(), this.size = 0;
      }
      function jp(n) {
        var i = this.__data__, o = i.delete(n);
        return this.size = i.size, o;
      }
      function Gp(n) {
        return this.__data__.get(n);
      }
      function Yp(n) {
        return this.__data__.has(n);
      }
      function qp(n, i) {
        var o = this.__data__;
        if (o instanceof qt) {
          var c = o.__data__;
          if (!Zr || c.length < a - 1)
            return c.push([n, i]), this.size = ++o.size, this;
          o = this.__data__ = new zt(c);
        }
        return o.set(n, i), this.size = o.size, this;
      }
      Lt.prototype.clear = Vp, Lt.prototype.delete = jp, Lt.prototype.get = Gp, Lt.prototype.has = Yp, Lt.prototype.set = qp;
      function lu(n, i) {
        var o = Q(n), c = !o && Dn(n), h = !o && !c && _n(n), m = !o && !c && !h && gr(n), v = o || c || h || m, y = v ? da(n.length, ip) : [], b = y.length;
        for (var O in n)
          (i || pe.call(n, O)) && !(v && // Safari 9 has enumerable `arguments.length` in strict mode.
          (O == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          h && (O == "offset" || O == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          m && (O == "buffer" || O == "byteLength" || O == "byteOffset") || // Skip index properties.
          Qt(O, b))) && y.push(O);
        return y;
      }
      function uu(n) {
        var i = n.length;
        return i ? n[Oa(0, i - 1)] : r;
      }
      function zp(n, i) {
        return Xi(ze(n), Fn(i, 0, n.length));
      }
      function Kp(n) {
        return Xi(ze(n));
      }
      function _a(n, i, o) {
        (o !== r && !Ot(n[i], o) || o === r && !(i in n)) && Kt(n, i, o);
      }
      function Yr(n, i, o) {
        var c = n[i];
        (!(pe.call(n, i) && Ot(c, o)) || o === r && !(i in n)) && Kt(n, i, o);
      }
      function $i(n, i) {
        for (var o = n.length; o--; )
          if (Ot(n[o][0], i))
            return o;
        return -1;
      }
      function Xp(n, i, o, c) {
        return gn(n, function(h, m, v) {
          i(c, h, o(h), v);
        }), c;
      }
      function cu(n, i) {
        return n && Ft(i, Re(i), n);
      }
      function Jp(n, i) {
        return n && Ft(i, Xe(i), n);
      }
      function Kt(n, i, o) {
        i == "__proto__" && ki ? ki(n, i, {
          configurable: !0,
          enumerable: !0,
          value: o,
          writable: !0
        }) : n[i] = o;
      }
      function xa(n, i) {
        for (var o = -1, c = i.length, h = S(c), m = n == null; ++o < c; )
          h[o] = m ? r : eo(n, i[o]);
        return h;
      }
      function Fn(n, i, o) {
        return n === n && (o !== r && (n = n <= o ? n : o), i !== r && (n = n >= i ? n : i)), n;
      }
      function vt(n, i, o, c, h, m) {
        var v, y = i & x, b = i & T, O = i & A;
        if (o && (v = h ? o(n, c, h, m) : o(n)), v !== r)
          return v;
        if (!xe(n))
          return n;
        var N = Q(n);
        if (N) {
          if (v = Wg(n), !y)
            return ze(n, v);
        } else {
          var I = We(n), F = I == mi || I == dl;
          if (_n(n))
            return Pu(n, y);
          if (I == Yt || I == tr || F && !h) {
            if (v = b || F ? {} : Qu(n), !y)
              return b ? Og(n, Jp(v, n)) : Lg(n, cu(v, n));
          } else {
            if (!ve[I])
              return h ? n : {};
            v = Ug(n, I, y);
          }
        }
        m || (m = new Lt());
        var V = m.get(n);
        if (V)
          return V;
        m.set(n, v), Lc(n) ? n.forEach(function(K) {
          v.add(vt(K, i, o, K, n, m));
        }) : Tc(n) && n.forEach(function(K, ae) {
          v.set(ae, vt(K, i, o, ae, n, m));
        });
        var z = O ? b ? Wa : Da : b ? Xe : Re, re = N ? r : z(n);
        return pt(re || n, function(K, ae) {
          re && (ae = K, K = n[ae]), Yr(v, ae, vt(K, i, o, ae, n, m));
        }), v;
      }
      function Qp(n) {
        var i = Re(n);
        return function(o) {
          return fu(o, n, i);
        };
      }
      function fu(n, i, o) {
        var c = o.length;
        if (n == null)
          return !c;
        for (n = me(n); c--; ) {
          var h = o[c], m = i[h], v = n[h];
          if (v === r && !(h in n) || !m(v))
            return !1;
        }
        return !0;
      }
      function du(n, i, o) {
        if (typeof n != "function")
          throw new gt(u);
        return ei(function() {
          n.apply(r, o);
        }, i);
      }
      function qr(n, i, o, c) {
        var h = -1, m = wi, v = !0, y = n.length, b = [], O = i.length;
        if (!y)
          return b;
        o && (i = _e(i, at(o))), c ? (m = aa, v = !1) : i.length >= a && (m = Ur, v = !1, i = new Pn(i));
        e:
          for (; ++h < y; ) {
            var N = n[h], I = o == null ? N : o(N);
            if (N = c || N !== 0 ? N : 0, v && I === I) {
              for (var F = O; F--; )
                if (i[F] === I)
                  continue e;
              b.push(N);
            } else
              m(i, I, c) || b.push(N);
          }
        return b;
      }
      var gn = Du(Pt), hu = Du(ba, !0);
      function eg(n, i) {
        var o = !0;
        return gn(n, function(c, h, m) {
          return o = !!i(c, h, m), o;
        }), o;
      }
      function Di(n, i, o) {
        for (var c = -1, h = n.length; ++c < h; ) {
          var m = n[c], v = i(m);
          if (v != null && (y === r ? v === v && !lt(v) : o(v, y)))
            var y = v, b = m;
        }
        return b;
      }
      function tg(n, i, o, c) {
        var h = n.length;
        for (o = te(o), o < 0 && (o = -o > h ? 0 : h + o), c = c === r || c > h ? h : te(c), c < 0 && (c += h), c = o > c ? 0 : Nc(c); o < c; )
          n[o++] = i;
        return n;
      }
      function pu(n, i) {
        var o = [];
        return gn(n, function(c, h, m) {
          i(c, h, m) && o.push(c);
        }), o;
      }
      function Be(n, i, o, c, h) {
        var m = -1, v = n.length;
        for (o || (o = Zg), h || (h = []); ++m < v; ) {
          var y = n[m];
          i > 0 && o(y) ? i > 1 ? Be(y, i - 1, o, c, h) : dn(h, y) : c || (h[h.length] = y);
        }
        return h;
      }
      var wa = Wu(), gu = Wu(!0);
      function Pt(n, i) {
        return n && wa(n, i, Re);
      }
      function ba(n, i) {
        return n && gu(n, i, Re);
      }
      function Wi(n, i) {
        return fn(i, function(o) {
          return en(n[o]);
        });
      }
      function Bn(n, i) {
        i = vn(i, n);
        for (var o = 0, c = i.length; n != null && o < c; )
          n = n[Bt(i[o++])];
        return o && o == c ? n : r;
      }
      function mu(n, i, o) {
        var c = i(n);
        return Q(n) ? c : dn(c, o(n));
      }
      function Ve(n) {
        return n == null ? n === r ? Nd : Ld : kn && kn in me(n) ? Mg(n) : Kg(n);
      }
      function Ea(n, i) {
        return n > i;
      }
      function ng(n, i) {
        return n != null && pe.call(n, i);
      }
      function rg(n, i) {
        return n != null && i in me(n);
      }
      function ig(n, i, o) {
        return n >= De(i, o) && n < Oe(i, o);
      }
      function Aa(n, i, o) {
        for (var c = o ? aa : wi, h = n[0].length, m = n.length, v = m, y = S(m), b = 1 / 0, O = []; v--; ) {
          var N = n[v];
          v && i && (N = _e(N, at(i))), b = De(N.length, b), y[v] = !o && (i || h >= 120 && N.length >= 120) ? new Pn(v && N) : r;
        }
        N = n[0];
        var I = -1, F = y[0];
        e:
          for (; ++I < h && O.length < b; ) {
            var V = N[I], z = i ? i(V) : V;
            if (V = o || V !== 0 ? V : 0, !(F ? Ur(F, z) : c(O, z, o))) {
              for (v = m; --v; ) {
                var re = y[v];
                if (!(re ? Ur(re, z) : c(n[v], z, o)))
                  continue e;
              }
              F && F.push(z), O.push(V);
            }
          }
        return O;
      }
      function sg(n, i, o, c) {
        return Pt(n, function(h, m, v) {
          i(c, o(h), m, v);
        }), c;
      }
      function zr(n, i, o) {
        i = vn(i, n), n = rc(n, i);
        var c = n == null ? n : n[Bt(_t(i))];
        return c == null ? r : st(c, n, o);
      }
      function vu(n) {
        return we(n) && Ve(n) == tr;
      }
      function ag(n) {
        return we(n) && Ve(n) == Wr;
      }
      function og(n) {
        return we(n) && Ve(n) == Fr;
      }
      function Kr(n, i, o, c, h) {
        return n === i ? !0 : n == null || i == null || !we(n) && !we(i) ? n !== n && i !== i : lg(n, i, o, c, Kr, h);
      }
      function lg(n, i, o, c, h, m) {
        var v = Q(n), y = Q(i), b = v ? pi : We(n), O = y ? pi : We(i);
        b = b == tr ? Yt : b, O = O == tr ? Yt : O;
        var N = b == Yt, I = O == Yt, F = b == O;
        if (F && _n(n)) {
          if (!_n(i))
            return !1;
          v = !0, N = !1;
        }
        if (F && !N)
          return m || (m = new Lt()), v || gr(n) ? Ku(n, i, o, c, h, m) : Fg(n, i, b, o, c, h, m);
        if (!(o & C)) {
          var V = N && pe.call(n, "__wrapped__"), z = I && pe.call(i, "__wrapped__");
          if (V || z) {
            var re = V ? n.value() : n, K = z ? i.value() : i;
            return m || (m = new Lt()), h(re, K, o, c, m);
          }
        }
        return F ? (m || (m = new Lt()), Bg(n, i, o, c, h, m)) : !1;
      }
      function ug(n) {
        return we(n) && We(n) == Ct;
      }
      function Ca(n, i, o, c) {
        var h = o.length, m = h, v = !c;
        if (n == null)
          return !m;
        for (n = me(n); h--; ) {
          var y = o[h];
          if (v && y[2] ? y[1] !== n[y[0]] : !(y[0] in n))
            return !1;
        }
        for (; ++h < m; ) {
          y = o[h];
          var b = y[0], O = n[b], N = y[1];
          if (v && y[2]) {
            if (O === r && !(b in n))
              return !1;
          } else {
            var I = new Lt();
            if (c)
              var F = c(O, N, b, n, i, I);
            if (!(F === r ? Kr(N, O, C | E, c, I) : F))
              return !1;
          }
        }
        return !0;
      }
      function yu(n) {
        if (!xe(n) || jg(n))
          return !1;
        var i = en(n) ? up : Qd;
        return i.test($n(n));
      }
      function cg(n) {
        return we(n) && Ve(n) == Mr;
      }
      function fg(n) {
        return we(n) && We(n) == Tt;
      }
      function dg(n) {
        return we(n) && rs(n.length) && !!ye[Ve(n)];
      }
      function _u(n) {
        return typeof n == "function" ? n : n == null ? Je : typeof n == "object" ? Q(n) ? bu(n[0], n[1]) : wu(n) : Uc(n);
      }
      function Ta(n) {
        if (!Qr(n))
          return gp(n);
        var i = [];
        for (var o in me(n))
          pe.call(n, o) && o != "constructor" && i.push(o);
        return i;
      }
      function hg(n) {
        if (!xe(n))
          return zg(n);
        var i = Qr(n), o = [];
        for (var c in n)
          c == "constructor" && (i || !pe.call(n, c)) || o.push(c);
        return o;
      }
      function Sa(n, i) {
        return n < i;
      }
      function xu(n, i) {
        var o = -1, c = Ke(n) ? S(n.length) : [];
        return gn(n, function(h, m, v) {
          c[++o] = i(h, m, v);
        }), c;
      }
      function wu(n) {
        var i = Ha(n);
        return i.length == 1 && i[0][2] ? tc(i[0][0], i[0][1]) : function(o) {
          return o === n || Ca(o, n, i);
        };
      }
      function bu(n, i) {
        return Va(n) && ec(i) ? tc(Bt(n), i) : function(o) {
          var c = eo(o, n);
          return c === r && c === i ? to(o, n) : Kr(i, c, C | E);
        };
      }
      function Ui(n, i, o, c, h) {
        n !== i && wa(i, function(m, v) {
          if (h || (h = new Lt()), xe(m))
            pg(n, i, v, o, Ui, c, h);
          else {
            var y = c ? c(Ga(n, v), m, v + "", n, i, h) : r;
            y === r && (y = m), _a(n, v, y);
          }
        }, Xe);
      }
      function pg(n, i, o, c, h, m, v) {
        var y = Ga(n, o), b = Ga(i, o), O = v.get(b);
        if (O) {
          _a(n, o, O);
          return;
        }
        var N = m ? m(y, b, o + "", n, i, v) : r, I = N === r;
        if (I) {
          var F = Q(b), V = !F && _n(b), z = !F && !V && gr(b);
          N = b, F || V || z ? Q(y) ? N = y : Ee(y) ? N = ze(y) : V ? (I = !1, N = Pu(b, !0)) : z ? (I = !1, N = Fu(b, !0)) : N = [] : ti(b) || Dn(b) ? (N = y, Dn(y) ? N = Ic(y) : (!xe(y) || en(y)) && (N = Qu(b))) : I = !1;
        }
        I && (v.set(b, N), h(N, b, c, m, v), v.delete(b)), _a(n, o, N);
      }
      function Eu(n, i) {
        var o = n.length;
        if (o)
          return i += i < 0 ? o : 0, Qt(i, o) ? n[i] : r;
      }
      function Au(n, i, o) {
        i.length ? i = _e(i, function(m) {
          return Q(m) ? function(v) {
            return Bn(v, m.length === 1 ? m[0] : m);
          } : m;
        }) : i = [Je];
        var c = -1;
        i = _e(i, at(q()));
        var h = xu(n, function(m, v, y) {
          var b = _e(i, function(O) {
            return O(m);
          });
          return { criteria: b, index: ++c, value: m };
        });
        return Uh(h, function(m, v) {
          return Sg(m, v, o);
        });
      }
      function gg(n, i) {
        return Cu(n, i, function(o, c) {
          return to(n, c);
        });
      }
      function Cu(n, i, o) {
        for (var c = -1, h = i.length, m = {}; ++c < h; ) {
          var v = i[c], y = Bn(n, v);
          o(y, v) && Xr(m, vn(v, n), y);
        }
        return m;
      }
      function mg(n) {
        return function(i) {
          return Bn(i, n);
        };
      }
      function La(n, i, o, c) {
        var h = c ? Wh : ir, m = -1, v = i.length, y = n;
        for (n === i && (i = ze(i)), o && (y = _e(n, at(o))); ++m < v; )
          for (var b = 0, O = i[m], N = o ? o(O) : O; (b = h(y, N, b, c)) > -1; )
            y !== n && Ii.call(y, b, 1), Ii.call(n, b, 1);
        return n;
      }
      function Tu(n, i) {
        for (var o = n ? i.length : 0, c = o - 1; o--; ) {
          var h = i[o];
          if (o == c || h !== m) {
            var m = h;
            Qt(h) ? Ii.call(n, h, 1) : ka(n, h);
          }
        }
        return n;
      }
      function Oa(n, i) {
        return n + Pi(au() * (i - n + 1));
      }
      function vg(n, i, o, c) {
        for (var h = -1, m = Oe(Ri((i - n) / (o || 1)), 0), v = S(m); m--; )
          v[c ? m : ++h] = n, n += o;
        return v;
      }
      function Na(n, i) {
        var o = "";
        if (!n || i < 1 || i > $e)
          return o;
        do
          i % 2 && (o += n), i = Pi(i / 2), i && (n += n);
        while (i);
        return o;
      }
      function ie(n, i) {
        return Ya(nc(n, i, Je), n + "");
      }
      function yg(n) {
        return uu(mr(n));
      }
      function _g(n, i) {
        var o = mr(n);
        return Xi(o, Fn(i, 0, o.length));
      }
      function Xr(n, i, o, c) {
        if (!xe(n))
          return n;
        i = vn(i, n);
        for (var h = -1, m = i.length, v = m - 1, y = n; y != null && ++h < m; ) {
          var b = Bt(i[h]), O = o;
          if (b === "__proto__" || b === "constructor" || b === "prototype")
            return n;
          if (h != v) {
            var N = y[b];
            O = c ? c(N, b, y) : r, O === r && (O = xe(N) ? N : Qt(i[h + 1]) ? [] : {});
          }
          Yr(y, b, O), y = y[b];
        }
        return n;
      }
      var Su = Fi ? function(n, i) {
        return Fi.set(n, i), n;
      } : Je, xg = ki ? function(n, i) {
        return ki(n, "toString", {
          configurable: !0,
          enumerable: !1,
          value: ro(i),
          writable: !0
        });
      } : Je;
      function wg(n) {
        return Xi(mr(n));
      }
      function yt(n, i, o) {
        var c = -1, h = n.length;
        i < 0 && (i = -i > h ? 0 : h + i), o = o > h ? h : o, o < 0 && (o += h), h = i > o ? 0 : o - i >>> 0, i >>>= 0;
        for (var m = S(h); ++c < h; )
          m[c] = n[c + i];
        return m;
      }
      function bg(n, i) {
        var o;
        return gn(n, function(c, h, m) {
          return o = i(c, h, m), !o;
        }), !!o;
      }
      function Hi(n, i, o) {
        var c = 0, h = n == null ? c : n.length;
        if (typeof i == "number" && i === i && h <= Ad) {
          for (; c < h; ) {
            var m = c + h >>> 1, v = n[m];
            v !== null && !lt(v) && (o ? v <= i : v < i) ? c = m + 1 : h = m;
          }
          return h;
        }
        return Ia(n, i, Je, o);
      }
      function Ia(n, i, o, c) {
        var h = 0, m = n == null ? 0 : n.length;
        if (m === 0)
          return 0;
        i = o(i);
        for (var v = i !== i, y = i === null, b = lt(i), O = i === r; h < m; ) {
          var N = Pi((h + m) / 2), I = o(n[N]), F = I !== r, V = I === null, z = I === I, re = lt(I);
          if (v)
            var K = c || z;
          else
            O ? K = z && (c || F) : y ? K = z && F && (c || !V) : b ? K = z && F && !V && (c || !re) : V || re ? K = !1 : K = c ? I <= i : I < i;
          K ? h = N + 1 : m = N;
        }
        return De(m, Ed);
      }
      function Lu(n, i) {
        for (var o = -1, c = n.length, h = 0, m = []; ++o < c; ) {
          var v = n[o], y = i ? i(v) : v;
          if (!o || !Ot(y, b)) {
            var b = y;
            m[h++] = v === 0 ? 0 : v;
          }
        }
        return m;
      }
      function Ou(n) {
        return typeof n == "number" ? n : lt(n) ? er : +n;
      }
      function ot(n) {
        if (typeof n == "string")
          return n;
        if (Q(n))
          return _e(n, ot) + "";
        if (lt(n))
          return ou ? ou.call(n) : "";
        var i = n + "";
        return i == "0" && 1 / n == -Se ? "-0" : i;
      }
      function mn(n, i, o) {
        var c = -1, h = wi, m = n.length, v = !0, y = [], b = y;
        if (o)
          v = !1, h = aa;
        else if (m >= a) {
          var O = i ? null : Rg(n);
          if (O)
            return Ei(O);
          v = !1, h = Ur, b = new Pn();
        } else
          b = i ? [] : y;
        e:
          for (; ++c < m; ) {
            var N = n[c], I = i ? i(N) : N;
            if (N = o || N !== 0 ? N : 0, v && I === I) {
              for (var F = b.length; F--; )
                if (b[F] === I)
                  continue e;
              i && b.push(I), y.push(N);
            } else
              h(b, I, o) || (b !== y && b.push(I), y.push(N));
          }
        return y;
      }
      function ka(n, i) {
        return i = vn(i, n), n = rc(n, i), n == null || delete n[Bt(_t(i))];
      }
      function Nu(n, i, o, c) {
        return Xr(n, i, o(Bn(n, i)), c);
      }
      function Zi(n, i, o, c) {
        for (var h = n.length, m = c ? h : -1; (c ? m-- : ++m < h) && i(n[m], m, n); )
          ;
        return o ? yt(n, c ? 0 : m, c ? m + 1 : h) : yt(n, c ? m + 1 : 0, c ? h : m);
      }
      function Iu(n, i) {
        var o = n;
        return o instanceof oe && (o = o.value()), oa(i, function(c, h) {
          return h.func.apply(h.thisArg, dn([c], h.args));
        }, o);
      }
      function Ra(n, i, o) {
        var c = n.length;
        if (c < 2)
          return c ? mn(n[0]) : [];
        for (var h = -1, m = S(c); ++h < c; )
          for (var v = n[h], y = -1; ++y < c; )
            y != h && (m[h] = qr(m[h] || v, n[y], i, o));
        return mn(Be(m, 1), i, o);
      }
      function ku(n, i, o) {
        for (var c = -1, h = n.length, m = i.length, v = {}; ++c < h; ) {
          var y = c < m ? i[c] : r;
          o(v, n[c], y);
        }
        return v;
      }
      function Pa(n) {
        return Ee(n) ? n : [];
      }
      function Fa(n) {
        return typeof n == "function" ? n : Je;
      }
      function vn(n, i) {
        return Q(n) ? n : Va(n, i) ? [n] : oc(he(n));
      }
      var Eg = ie;
      function yn(n, i, o) {
        var c = n.length;
        return o = o === r ? c : o, !i && o >= c ? n : yt(n, i, o);
      }
      var Ru = cp || function(n) {
        return Fe.clearTimeout(n);
      };
      function Pu(n, i) {
        if (i)
          return n.slice();
        var o = n.length, c = tu ? tu(o) : new n.constructor(o);
        return n.copy(c), c;
      }
      function Ba(n) {
        var i = new n.constructor(n.byteLength);
        return new Oi(i).set(new Oi(n)), i;
      }
      function Ag(n, i) {
        var o = i ? Ba(n.buffer) : n.buffer;
        return new n.constructor(o, n.byteOffset, n.byteLength);
      }
      function Cg(n) {
        var i = new n.constructor(n.source, vl.exec(n));
        return i.lastIndex = n.lastIndex, i;
      }
      function Tg(n) {
        return Gr ? me(Gr.call(n)) : {};
      }
      function Fu(n, i) {
        var o = i ? Ba(n.buffer) : n.buffer;
        return new n.constructor(o, n.byteOffset, n.length);
      }
      function Bu(n, i) {
        if (n !== i) {
          var o = n !== r, c = n === null, h = n === n, m = lt(n), v = i !== r, y = i === null, b = i === i, O = lt(i);
          if (!y && !O && !m && n > i || m && v && b && !y && !O || c && v && b || !o && b || !h)
            return 1;
          if (!c && !m && !O && n < i || O && o && h && !c && !m || y && o && h || !v && h || !b)
            return -1;
        }
        return 0;
      }
      function Sg(n, i, o) {
        for (var c = -1, h = n.criteria, m = i.criteria, v = h.length, y = o.length; ++c < v; ) {
          var b = Bu(h[c], m[c]);
          if (b) {
            if (c >= y)
              return b;
            var O = o[c];
            return b * (O == "desc" ? -1 : 1);
          }
        }
        return n.index - i.index;
      }
      function Mu(n, i, o, c) {
        for (var h = -1, m = n.length, v = o.length, y = -1, b = i.length, O = Oe(m - v, 0), N = S(b + O), I = !c; ++y < b; )
          N[y] = i[y];
        for (; ++h < v; )
          (I || h < m) && (N[o[h]] = n[h]);
        for (; O--; )
          N[y++] = n[h++];
        return N;
      }
      function $u(n, i, o, c) {
        for (var h = -1, m = n.length, v = -1, y = o.length, b = -1, O = i.length, N = Oe(m - y, 0), I = S(N + O), F = !c; ++h < N; )
          I[h] = n[h];
        for (var V = h; ++b < O; )
          I[V + b] = i[b];
        for (; ++v < y; )
          (F || h < m) && (I[V + o[v]] = n[h++]);
        return I;
      }
      function ze(n, i) {
        var o = -1, c = n.length;
        for (i || (i = S(c)); ++o < c; )
          i[o] = n[o];
        return i;
      }
      function Ft(n, i, o, c) {
        var h = !o;
        o || (o = {});
        for (var m = -1, v = i.length; ++m < v; ) {
          var y = i[m], b = c ? c(o[y], n[y], y, o, n) : r;
          b === r && (b = n[y]), h ? Kt(o, y, b) : Yr(o, y, b);
        }
        return o;
      }
      function Lg(n, i) {
        return Ft(n, Za(n), i);
      }
      function Og(n, i) {
        return Ft(n, Xu(n), i);
      }
      function Vi(n, i) {
        return function(o, c) {
          var h = Q(o) ? Ph : Xp, m = i ? i() : {};
          return h(o, n, q(c, 2), m);
        };
      }
      function dr(n) {
        return ie(function(i, o) {
          var c = -1, h = o.length, m = h > 1 ? o[h - 1] : r, v = h > 2 ? o[2] : r;
          for (m = n.length > 3 && typeof m == "function" ? (h--, m) : r, v && je(o[0], o[1], v) && (m = h < 3 ? r : m, h = 1), i = me(i); ++c < h; ) {
            var y = o[c];
            y && n(i, y, c, m);
          }
          return i;
        });
      }
      function Du(n, i) {
        return function(o, c) {
          if (o == null)
            return o;
          if (!Ke(o))
            return n(o, c);
          for (var h = o.length, m = i ? h : -1, v = me(o); (i ? m-- : ++m < h) && c(v[m], m, v) !== !1; )
            ;
          return o;
        };
      }
      function Wu(n) {
        return function(i, o, c) {
          for (var h = -1, m = me(i), v = c(i), y = v.length; y--; ) {
            var b = v[n ? y : ++h];
            if (o(m[b], b, m) === !1)
              break;
          }
          return i;
        };
      }
      function Ng(n, i, o) {
        var c = i & P, h = Jr(n);
        function m() {
          var v = this && this !== Fe && this instanceof m ? h : n;
          return v.apply(c ? o : this, arguments);
        }
        return m;
      }
      function Uu(n) {
        return function(i) {
          i = he(i);
          var o = sr(i) ? St(i) : r, c = o ? o[0] : i.charAt(0), h = o ? yn(o, 1).join("") : i.slice(1);
          return c[n]() + h;
        };
      }
      function hr(n) {
        return function(i) {
          return oa(Dc($c(i).replace(xh, "")), n, "");
        };
      }
      function Jr(n) {
        return function() {
          var i = arguments;
          switch (i.length) {
            case 0:
              return new n();
            case 1:
              return new n(i[0]);
            case 2:
              return new n(i[0], i[1]);
            case 3:
              return new n(i[0], i[1], i[2]);
            case 4:
              return new n(i[0], i[1], i[2], i[3]);
            case 5:
              return new n(i[0], i[1], i[2], i[3], i[4]);
            case 6:
              return new n(i[0], i[1], i[2], i[3], i[4], i[5]);
            case 7:
              return new n(i[0], i[1], i[2], i[3], i[4], i[5], i[6]);
          }
          var o = fr(n.prototype), c = n.apply(o, i);
          return xe(c) ? c : o;
        };
      }
      function Ig(n, i, o) {
        var c = Jr(n);
        function h() {
          for (var m = arguments.length, v = S(m), y = m, b = pr(h); y--; )
            v[y] = arguments[y];
          var O = m < 3 && v[0] !== b && v[m - 1] !== b ? [] : hn(v, b);
          if (m -= O.length, m < o)
            return Gu(
              n,
              i,
              ji,
              h.placeholder,
              r,
              v,
              O,
              r,
              r,
              o - m
            );
          var N = this && this !== Fe && this instanceof h ? c : n;
          return st(N, this, v);
        }
        return h;
      }
      function Hu(n) {
        return function(i, o, c) {
          var h = me(i);
          if (!Ke(i)) {
            var m = q(o, 3);
            i = Re(i), o = function(y) {
              return m(h[y], y, h);
            };
          }
          var v = n(i, o, c);
          return v > -1 ? h[m ? i[v] : v] : r;
        };
      }
      function Zu(n) {
        return Jt(function(i) {
          var o = i.length, c = o, h = mt.prototype.thru;
          for (n && i.reverse(); c--; ) {
            var m = i[c];
            if (typeof m != "function")
              throw new gt(u);
            if (h && !v && zi(m) == "wrapper")
              var v = new mt([], !0);
          }
          for (c = v ? c : o; ++c < o; ) {
            m = i[c];
            var y = zi(m), b = y == "wrapper" ? Ua(m) : r;
            b && ja(b[0]) && b[1] == (Y | $ | k | ge) && !b[4].length && b[9] == 1 ? v = v[zi(b[0])].apply(v, b[3]) : v = m.length == 1 && ja(m) ? v[y]() : v.thru(m);
          }
          return function() {
            var O = arguments, N = O[0];
            if (v && O.length == 1 && Q(N))
              return v.plant(N).value();
            for (var I = 0, F = o ? i[I].apply(this, O) : N; ++I < o; )
              F = i[I].call(this, F);
            return F;
          };
        });
      }
      function ji(n, i, o, c, h, m, v, y, b, O) {
        var N = i & Y, I = i & P, F = i & U, V = i & ($ | Z), z = i & jt, re = F ? r : Jr(n);
        function K() {
          for (var ae = arguments.length, ce = S(ae), ut = ae; ut--; )
            ce[ut] = arguments[ut];
          if (V)
            var Ge = pr(K), ct = Zh(ce, Ge);
          if (c && (ce = Mu(ce, c, h, V)), m && (ce = $u(ce, m, v, V)), ae -= ct, V && ae < O) {
            var Ae = hn(ce, Ge);
            return Gu(
              n,
              i,
              ji,
              K.placeholder,
              o,
              ce,
              Ae,
              y,
              b,
              O - ae
            );
          }
          var Nt = I ? o : this, nn = F ? Nt[n] : n;
          return ae = ce.length, y ? ce = Xg(ce, y) : z && ae > 1 && ce.reverse(), N && b < ae && (ce.length = b), this && this !== Fe && this instanceof K && (nn = re || Jr(nn)), nn.apply(Nt, ce);
        }
        return K;
      }
      function Vu(n, i) {
        return function(o, c) {
          return sg(o, n, i(c), {});
        };
      }
      function Gi(n, i) {
        return function(o, c) {
          var h;
          if (o === r && c === r)
            return i;
          if (o !== r && (h = o), c !== r) {
            if (h === r)
              return c;
            typeof o == "string" || typeof c == "string" ? (o = ot(o), c = ot(c)) : (o = Ou(o), c = Ou(c)), h = n(o, c);
          }
          return h;
        };
      }
      function Ma(n) {
        return Jt(function(i) {
          return i = _e(i, at(q())), ie(function(o) {
            var c = this;
            return n(i, function(h) {
              return st(h, c, o);
            });
          });
        });
      }
      function Yi(n, i) {
        i = i === r ? " " : ot(i);
        var o = i.length;
        if (o < 2)
          return o ? Na(i, n) : i;
        var c = Na(i, Ri(n / ar(i)));
        return sr(i) ? yn(St(c), 0, n).join("") : c.slice(0, n);
      }
      function kg(n, i, o, c) {
        var h = i & P, m = Jr(n);
        function v() {
          for (var y = -1, b = arguments.length, O = -1, N = c.length, I = S(N + b), F = this && this !== Fe && this instanceof v ? m : n; ++O < N; )
            I[O] = c[O];
          for (; b--; )
            I[O++] = arguments[++y];
          return st(F, h ? o : this, I);
        }
        return v;
      }
      function ju(n) {
        return function(i, o, c) {
          return c && typeof c != "number" && je(i, o, c) && (o = c = r), i = tn(i), o === r ? (o = i, i = 0) : o = tn(o), c = c === r ? i < o ? 1 : -1 : tn(c), vg(i, o, c, n);
        };
      }
      function qi(n) {
        return function(i, o) {
          return typeof i == "string" && typeof o == "string" || (i = xt(i), o = xt(o)), n(i, o);
        };
      }
      function Gu(n, i, o, c, h, m, v, y, b, O) {
        var N = i & $, I = N ? v : r, F = N ? r : v, V = N ? m : r, z = N ? r : m;
        i |= N ? k : se, i &= ~(N ? se : k), i & H || (i &= ~(P | U));
        var re = [
          n,
          i,
          h,
          V,
          I,
          z,
          F,
          y,
          b,
          O
        ], K = o.apply(r, re);
        return ja(n) && ic(K, re), K.placeholder = c, sc(K, n, i);
      }
      function $a(n) {
        var i = Le[n];
        return function(o, c) {
          if (o = xt(o), c = c == null ? 0 : De(te(c), 292), c && su(o)) {
            var h = (he(o) + "e").split("e"), m = i(h[0] + "e" + (+h[1] + c));
            return h = (he(m) + "e").split("e"), +(h[0] + "e" + (+h[1] - c));
          }
          return i(o);
        };
      }
      var Rg = ur && 1 / Ei(new ur([, -0]))[1] == Se ? function(n) {
        return new ur(n);
      } : ao;
      function Yu(n) {
        return function(i) {
          var o = We(i);
          return o == Ct ? pa(i) : o == Tt ? Kh(i) : Hh(i, n(i));
        };
      }
      function Xt(n, i, o, c, h, m, v, y) {
        var b = i & U;
        if (!b && typeof n != "function")
          throw new gt(u);
        var O = c ? c.length : 0;
        if (O || (i &= ~(k | se), c = h = r), v = v === r ? v : Oe(te(v), 0), y = y === r ? y : te(y), O -= h ? h.length : 0, i & se) {
          var N = c, I = h;
          c = h = r;
        }
        var F = b ? r : Ua(n), V = [
          n,
          i,
          o,
          c,
          h,
          N,
          I,
          m,
          v,
          y
        ];
        if (F && qg(V, F), n = V[0], i = V[1], o = V[2], c = V[3], h = V[4], y = V[9] = V[9] === r ? b ? 0 : n.length : Oe(V[9] - O, 0), !y && i & ($ | Z) && (i &= ~($ | Z)), !i || i == P)
          var z = Ng(n, i, o);
        else
          i == $ || i == Z ? z = Ig(n, i, y) : (i == k || i == (P | k)) && !h.length ? z = kg(n, i, o, c) : z = ji.apply(r, V);
        var re = F ? Su : ic;
        return sc(re(z, V), n, i);
      }
      function qu(n, i, o, c) {
        return n === r || Ot(n, lr[o]) && !pe.call(c, o) ? i : n;
      }
      function zu(n, i, o, c, h, m) {
        return xe(n) && xe(i) && (m.set(i, n), Ui(n, i, r, zu, m), m.delete(i)), n;
      }
      function Pg(n) {
        return ti(n) ? r : n;
      }
      function Ku(n, i, o, c, h, m) {
        var v = o & C, y = n.length, b = i.length;
        if (y != b && !(v && b > y))
          return !1;
        var O = m.get(n), N = m.get(i);
        if (O && N)
          return O == i && N == n;
        var I = -1, F = !0, V = o & E ? new Pn() : r;
        for (m.set(n, i), m.set(i, n); ++I < y; ) {
          var z = n[I], re = i[I];
          if (c)
            var K = v ? c(re, z, I, i, n, m) : c(z, re, I, n, i, m);
          if (K !== r) {
            if (K)
              continue;
            F = !1;
            break;
          }
          if (V) {
            if (!la(i, function(ae, ce) {
              if (!Ur(V, ce) && (z === ae || h(z, ae, o, c, m)))
                return V.push(ce);
            })) {
              F = !1;
              break;
            }
          } else if (!(z === re || h(z, re, o, c, m))) {
            F = !1;
            break;
          }
        }
        return m.delete(n), m.delete(i), F;
      }
      function Fg(n, i, o, c, h, m, v) {
        switch (o) {
          case nr:
            if (n.byteLength != i.byteLength || n.byteOffset != i.byteOffset)
              return !1;
            n = n.buffer, i = i.buffer;
          case Wr:
            return !(n.byteLength != i.byteLength || !m(new Oi(n), new Oi(i)));
          case Pr:
          case Fr:
          case Br:
            return Ot(+n, +i);
          case gi:
            return n.name == i.name && n.message == i.message;
          case Mr:
          case $r:
            return n == i + "";
          case Ct:
            var y = pa;
          case Tt:
            var b = c & C;
            if (y || (y = Ei), n.size != i.size && !b)
              return !1;
            var O = v.get(n);
            if (O)
              return O == i;
            c |= E, v.set(n, i);
            var N = Ku(y(n), y(i), c, h, m, v);
            return v.delete(n), N;
          case vi:
            if (Gr)
              return Gr.call(n) == Gr.call(i);
        }
        return !1;
      }
      function Bg(n, i, o, c, h, m) {
        var v = o & C, y = Da(n), b = y.length, O = Da(i), N = O.length;
        if (b != N && !v)
          return !1;
        for (var I = b; I--; ) {
          var F = y[I];
          if (!(v ? F in i : pe.call(i, F)))
            return !1;
        }
        var V = m.get(n), z = m.get(i);
        if (V && z)
          return V == i && z == n;
        var re = !0;
        m.set(n, i), m.set(i, n);
        for (var K = v; ++I < b; ) {
          F = y[I];
          var ae = n[F], ce = i[F];
          if (c)
            var ut = v ? c(ce, ae, F, i, n, m) : c(ae, ce, F, n, i, m);
          if (!(ut === r ? ae === ce || h(ae, ce, o, c, m) : ut)) {
            re = !1;
            break;
          }
          K || (K = F == "constructor");
        }
        if (re && !K) {
          var Ge = n.constructor, ct = i.constructor;
          Ge != ct && "constructor" in n && "constructor" in i && !(typeof Ge == "function" && Ge instanceof Ge && typeof ct == "function" && ct instanceof ct) && (re = !1);
        }
        return m.delete(n), m.delete(i), re;
      }
      function Jt(n) {
        return Ya(nc(n, r, fc), n + "");
      }
      function Da(n) {
        return mu(n, Re, Za);
      }
      function Wa(n) {
        return mu(n, Xe, Xu);
      }
      var Ua = Fi ? function(n) {
        return Fi.get(n);
      } : ao;
      function zi(n) {
        for (var i = n.name + "", o = cr[i], c = pe.call(cr, i) ? o.length : 0; c--; ) {
          var h = o[c], m = h.func;
          if (m == null || m == n)
            return h.name;
        }
        return i;
      }
      function pr(n) {
        var i = pe.call(p, "placeholder") ? p : n;
        return i.placeholder;
      }
      function q() {
        var n = p.iteratee || io;
        return n = n === io ? _u : n, arguments.length ? n(arguments[0], arguments[1]) : n;
      }
      function Ki(n, i) {
        var o = n.__data__;
        return Vg(i) ? o[typeof i == "string" ? "string" : "hash"] : o.map;
      }
      function Ha(n) {
        for (var i = Re(n), o = i.length; o--; ) {
          var c = i[o], h = n[c];
          i[o] = [c, h, ec(h)];
        }
        return i;
      }
      function Mn(n, i) {
        var o = Yh(n, i);
        return yu(o) ? o : r;
      }
      function Mg(n) {
        var i = pe.call(n, kn), o = n[kn];
        try {
          n[kn] = r;
          var c = !0;
        } catch {
        }
        var h = Si.call(n);
        return c && (i ? n[kn] = o : delete n[kn]), h;
      }
      var Za = ma ? function(n) {
        return n == null ? [] : (n = me(n), fn(ma(n), function(i) {
          return ru.call(n, i);
        }));
      } : oo, Xu = ma ? function(n) {
        for (var i = []; n; )
          dn(i, Za(n)), n = Ni(n);
        return i;
      } : oo, We = Ve;
      (va && We(new va(new ArrayBuffer(1))) != nr || Zr && We(new Zr()) != Ct || ya && We(ya.resolve()) != hl || ur && We(new ur()) != Tt || Vr && We(new Vr()) != Dr) && (We = function(n) {
        var i = Ve(n), o = i == Yt ? n.constructor : r, c = o ? $n(o) : "";
        if (c)
          switch (c) {
            case _p:
              return nr;
            case xp:
              return Ct;
            case wp:
              return hl;
            case bp:
              return Tt;
            case Ep:
              return Dr;
          }
        return i;
      });
      function $g(n, i, o) {
        for (var c = -1, h = o.length; ++c < h; ) {
          var m = o[c], v = m.size;
          switch (m.type) {
            case "drop":
              n += v;
              break;
            case "dropRight":
              i -= v;
              break;
            case "take":
              i = De(i, n + v);
              break;
            case "takeRight":
              n = Oe(n, i - v);
              break;
          }
        }
        return { start: n, end: i };
      }
      function Dg(n) {
        var i = n.match(jd);
        return i ? i[1].split(Gd) : [];
      }
      function Ju(n, i, o) {
        i = vn(i, n);
        for (var c = -1, h = i.length, m = !1; ++c < h; ) {
          var v = Bt(i[c]);
          if (!(m = n != null && o(n, v)))
            break;
          n = n[v];
        }
        return m || ++c != h ? m : (h = n == null ? 0 : n.length, !!h && rs(h) && Qt(v, h) && (Q(n) || Dn(n)));
      }
      function Wg(n) {
        var i = n.length, o = new n.constructor(i);
        return i && typeof n[0] == "string" && pe.call(n, "index") && (o.index = n.index, o.input = n.input), o;
      }
      function Qu(n) {
        return typeof n.constructor == "function" && !Qr(n) ? fr(Ni(n)) : {};
      }
      function Ug(n, i, o) {
        var c = n.constructor;
        switch (i) {
          case Wr:
            return Ba(n);
          case Pr:
          case Fr:
            return new c(+n);
          case nr:
            return Ag(n, o);
          case Hs:
          case Zs:
          case Vs:
          case js:
          case Gs:
          case Ys:
          case qs:
          case zs:
          case Ks:
            return Fu(n, o);
          case Ct:
            return new c();
          case Br:
          case $r:
            return new c(n);
          case Mr:
            return Cg(n);
          case Tt:
            return new c();
          case vi:
            return Tg(n);
        }
      }
      function Hg(n, i) {
        var o = i.length;
        if (!o)
          return n;
        var c = o - 1;
        return i[c] = (o > 1 ? "& " : "") + i[c], i = i.join(o > 2 ? ", " : " "), n.replace(Vd, `{
/* [wrapped with ` + i + `] */
`);
      }
      function Zg(n) {
        return Q(n) || Dn(n) || !!(iu && n && n[iu]);
      }
      function Qt(n, i) {
        var o = typeof n;
        return i = i ?? $e, !!i && (o == "number" || o != "symbol" && th.test(n)) && n > -1 && n % 1 == 0 && n < i;
      }
      function je(n, i, o) {
        if (!xe(o))
          return !1;
        var c = typeof i;
        return (c == "number" ? Ke(o) && Qt(i, o.length) : c == "string" && i in o) ? Ot(o[i], n) : !1;
      }
      function Va(n, i) {
        if (Q(n))
          return !1;
        var o = typeof n;
        return o == "number" || o == "symbol" || o == "boolean" || n == null || lt(n) ? !0 : Wd.test(n) || !Dd.test(n) || i != null && n in me(i);
      }
      function Vg(n) {
        var i = typeof n;
        return i == "string" || i == "number" || i == "symbol" || i == "boolean" ? n !== "__proto__" : n === null;
      }
      function ja(n) {
        var i = zi(n), o = p[i];
        if (typeof o != "function" || !(i in oe.prototype))
          return !1;
        if (n === o)
          return !0;
        var c = Ua(o);
        return !!c && n === c[0];
      }
      function jg(n) {
        return !!eu && eu in n;
      }
      var Gg = Ci ? en : lo;
      function Qr(n) {
        var i = n && n.constructor, o = typeof i == "function" && i.prototype || lr;
        return n === o;
      }
      function ec(n) {
        return n === n && !xe(n);
      }
      function tc(n, i) {
        return function(o) {
          return o == null ? !1 : o[n] === i && (i !== r || n in me(o));
        };
      }
      function Yg(n) {
        var i = ts(n, function(c) {
          return o.size === g && o.clear(), c;
        }), o = i.cache;
        return i;
      }
      function qg(n, i) {
        var o = n[1], c = i[1], h = o | c, m = h < (P | U | Y), v = c == Y && o == $ || c == Y && o == ge && n[7].length <= i[8] || c == (Y | ge) && i[7].length <= i[8] && o == $;
        if (!(m || v))
          return n;
        c & P && (n[2] = i[2], h |= o & P ? 0 : H);
        var y = i[3];
        if (y) {
          var b = n[3];
          n[3] = b ? Mu(b, y, i[4]) : y, n[4] = b ? hn(n[3], _) : i[4];
        }
        return y = i[5], y && (b = n[5], n[5] = b ? $u(b, y, i[6]) : y, n[6] = b ? hn(n[5], _) : i[6]), y = i[7], y && (n[7] = y), c & Y && (n[8] = n[8] == null ? i[8] : De(n[8], i[8])), n[9] == null && (n[9] = i[9]), n[0] = i[0], n[1] = h, n;
      }
      function zg(n) {
        var i = [];
        if (n != null)
          for (var o in me(n))
            i.push(o);
        return i;
      }
      function Kg(n) {
        return Si.call(n);
      }
      function nc(n, i, o) {
        return i = Oe(i === r ? n.length - 1 : i, 0), function() {
          for (var c = arguments, h = -1, m = Oe(c.length - i, 0), v = S(m); ++h < m; )
            v[h] = c[i + h];
          h = -1;
          for (var y = S(i + 1); ++h < i; )
            y[h] = c[h];
          return y[i] = o(v), st(n, this, y);
        };
      }
      function rc(n, i) {
        return i.length < 2 ? n : Bn(n, yt(i, 0, -1));
      }
      function Xg(n, i) {
        for (var o = n.length, c = De(i.length, o), h = ze(n); c--; ) {
          var m = i[c];
          n[c] = Qt(m, o) ? h[m] : r;
        }
        return n;
      }
      function Ga(n, i) {
        if (!(i === "constructor" && typeof n[i] == "function") && i != "__proto__")
          return n[i];
      }
      var ic = ac(Su), ei = dp || function(n, i) {
        return Fe.setTimeout(n, i);
      }, Ya = ac(xg);
      function sc(n, i, o) {
        var c = i + "";
        return Ya(n, Hg(c, Jg(Dg(c), o)));
      }
      function ac(n) {
        var i = 0, o = 0;
        return function() {
          var c = mp(), h = Gt - (c - o);
          if (o = c, h > 0) {
            if (++i >= dt)
              return arguments[0];
          } else
            i = 0;
          return n.apply(r, arguments);
        };
      }
      function Xi(n, i) {
        var o = -1, c = n.length, h = c - 1;
        for (i = i === r ? c : i; ++o < i; ) {
          var m = Oa(o, h), v = n[m];
          n[m] = n[o], n[o] = v;
        }
        return n.length = i, n;
      }
      var oc = Yg(function(n) {
        var i = [];
        return n.charCodeAt(0) === 46 && i.push(""), n.replace(Ud, function(o, c, h, m) {
          i.push(h ? m.replace(zd, "$1") : c || o);
        }), i;
      });
      function Bt(n) {
        if (typeof n == "string" || lt(n))
          return n;
        var i = n + "";
        return i == "0" && 1 / n == -Se ? "-0" : i;
      }
      function $n(n) {
        if (n != null) {
          try {
            return Ti.call(n);
          } catch {
          }
          try {
            return n + "";
          } catch {
          }
        }
        return "";
      }
      function Jg(n, i) {
        return pt(Cd, function(o) {
          var c = "_." + o[0];
          i & o[1] && !wi(n, c) && n.push(c);
        }), n.sort();
      }
      function lc(n) {
        if (n instanceof oe)
          return n.clone();
        var i = new mt(n.__wrapped__, n.__chain__);
        return i.__actions__ = ze(n.__actions__), i.__index__ = n.__index__, i.__values__ = n.__values__, i;
      }
      function Qg(n, i, o) {
        (o ? je(n, i, o) : i === r) ? i = 1 : i = Oe(te(i), 0);
        var c = n == null ? 0 : n.length;
        if (!c || i < 1)
          return [];
        for (var h = 0, m = 0, v = S(Ri(c / i)); h < c; )
          v[m++] = yt(n, h, h += i);
        return v;
      }
      function em(n) {
        for (var i = -1, o = n == null ? 0 : n.length, c = 0, h = []; ++i < o; ) {
          var m = n[i];
          m && (h[c++] = m);
        }
        return h;
      }
      function tm() {
        var n = arguments.length;
        if (!n)
          return [];
        for (var i = S(n - 1), o = arguments[0], c = n; c--; )
          i[c - 1] = arguments[c];
        return dn(Q(o) ? ze(o) : [o], Be(i, 1));
      }
      var nm = ie(function(n, i) {
        return Ee(n) ? qr(n, Be(i, 1, Ee, !0)) : [];
      }), rm = ie(function(n, i) {
        var o = _t(i);
        return Ee(o) && (o = r), Ee(n) ? qr(n, Be(i, 1, Ee, !0), q(o, 2)) : [];
      }), im = ie(function(n, i) {
        var o = _t(i);
        return Ee(o) && (o = r), Ee(n) ? qr(n, Be(i, 1, Ee, !0), r, o) : [];
      });
      function sm(n, i, o) {
        var c = n == null ? 0 : n.length;
        return c ? (i = o || i === r ? 1 : te(i), yt(n, i < 0 ? 0 : i, c)) : [];
      }
      function am(n, i, o) {
        var c = n == null ? 0 : n.length;
        return c ? (i = o || i === r ? 1 : te(i), i = c - i, yt(n, 0, i < 0 ? 0 : i)) : [];
      }
      function om(n, i) {
        return n && n.length ? Zi(n, q(i, 3), !0, !0) : [];
      }
      function lm(n, i) {
        return n && n.length ? Zi(n, q(i, 3), !0) : [];
      }
      function um(n, i, o, c) {
        var h = n == null ? 0 : n.length;
        return h ? (o && typeof o != "number" && je(n, i, o) && (o = 0, c = h), tg(n, i, o, c)) : [];
      }
      function uc(n, i, o) {
        var c = n == null ? 0 : n.length;
        if (!c)
          return -1;
        var h = o == null ? 0 : te(o);
        return h < 0 && (h = Oe(c + h, 0)), bi(n, q(i, 3), h);
      }
      function cc(n, i, o) {
        var c = n == null ? 0 : n.length;
        if (!c)
          return -1;
        var h = c - 1;
        return o !== r && (h = te(o), h = o < 0 ? Oe(c + h, 0) : De(h, c - 1)), bi(n, q(i, 3), h, !0);
      }
      function fc(n) {
        var i = n == null ? 0 : n.length;
        return i ? Be(n, 1) : [];
      }
      function cm(n) {
        var i = n == null ? 0 : n.length;
        return i ? Be(n, Se) : [];
      }
      function fm(n, i) {
        var o = n == null ? 0 : n.length;
        return o ? (i = i === r ? 1 : te(i), Be(n, i)) : [];
      }
      function dm(n) {
        for (var i = -1, o = n == null ? 0 : n.length, c = {}; ++i < o; ) {
          var h = n[i];
          c[h[0]] = h[1];
        }
        return c;
      }
      function dc(n) {
        return n && n.length ? n[0] : r;
      }
      function hm(n, i, o) {
        var c = n == null ? 0 : n.length;
        if (!c)
          return -1;
        var h = o == null ? 0 : te(o);
        return h < 0 && (h = Oe(c + h, 0)), ir(n, i, h);
      }
      function pm(n) {
        var i = n == null ? 0 : n.length;
        return i ? yt(n, 0, -1) : [];
      }
      var gm = ie(function(n) {
        var i = _e(n, Pa);
        return i.length && i[0] === n[0] ? Aa(i) : [];
      }), mm = ie(function(n) {
        var i = _t(n), o = _e(n, Pa);
        return i === _t(o) ? i = r : o.pop(), o.length && o[0] === n[0] ? Aa(o, q(i, 2)) : [];
      }), vm = ie(function(n) {
        var i = _t(n), o = _e(n, Pa);
        return i = typeof i == "function" ? i : r, i && o.pop(), o.length && o[0] === n[0] ? Aa(o, r, i) : [];
      });
      function ym(n, i) {
        return n == null ? "" : pp.call(n, i);
      }
      function _t(n) {
        var i = n == null ? 0 : n.length;
        return i ? n[i - 1] : r;
      }
      function _m(n, i, o) {
        var c = n == null ? 0 : n.length;
        if (!c)
          return -1;
        var h = c;
        return o !== r && (h = te(o), h = h < 0 ? Oe(c + h, 0) : De(h, c - 1)), i === i ? Jh(n, i, h) : bi(n, Gl, h, !0);
      }
      function xm(n, i) {
        return n && n.length ? Eu(n, te(i)) : r;
      }
      var wm = ie(hc);
      function hc(n, i) {
        return n && n.length && i && i.length ? La(n, i) : n;
      }
      function bm(n, i, o) {
        return n && n.length && i && i.length ? La(n, i, q(o, 2)) : n;
      }
      function Em(n, i, o) {
        return n && n.length && i && i.length ? La(n, i, r, o) : n;
      }
      var Am = Jt(function(n, i) {
        var o = n == null ? 0 : n.length, c = xa(n, i);
        return Tu(n, _e(i, function(h) {
          return Qt(h, o) ? +h : h;
        }).sort(Bu)), c;
      });
      function Cm(n, i) {
        var o = [];
        if (!(n && n.length))
          return o;
        var c = -1, h = [], m = n.length;
        for (i = q(i, 3); ++c < m; ) {
          var v = n[c];
          i(v, c, n) && (o.push(v), h.push(c));
        }
        return Tu(n, h), o;
      }
      function qa(n) {
        return n == null ? n : yp.call(n);
      }
      function Tm(n, i, o) {
        var c = n == null ? 0 : n.length;
        return c ? (o && typeof o != "number" && je(n, i, o) ? (i = 0, o = c) : (i = i == null ? 0 : te(i), o = o === r ? c : te(o)), yt(n, i, o)) : [];
      }
      function Sm(n, i) {
        return Hi(n, i);
      }
      function Lm(n, i, o) {
        return Ia(n, i, q(o, 2));
      }
      function Om(n, i) {
        var o = n == null ? 0 : n.length;
        if (o) {
          var c = Hi(n, i);
          if (c < o && Ot(n[c], i))
            return c;
        }
        return -1;
      }
      function Nm(n, i) {
        return Hi(n, i, !0);
      }
      function Im(n, i, o) {
        return Ia(n, i, q(o, 2), !0);
      }
      function km(n, i) {
        var o = n == null ? 0 : n.length;
        if (o) {
          var c = Hi(n, i, !0) - 1;
          if (Ot(n[c], i))
            return c;
        }
        return -1;
      }
      function Rm(n) {
        return n && n.length ? Lu(n) : [];
      }
      function Pm(n, i) {
        return n && n.length ? Lu(n, q(i, 2)) : [];
      }
      function Fm(n) {
        var i = n == null ? 0 : n.length;
        return i ? yt(n, 1, i) : [];
      }
      function Bm(n, i, o) {
        return n && n.length ? (i = o || i === r ? 1 : te(i), yt(n, 0, i < 0 ? 0 : i)) : [];
      }
      function Mm(n, i, o) {
        var c = n == null ? 0 : n.length;
        return c ? (i = o || i === r ? 1 : te(i), i = c - i, yt(n, i < 0 ? 0 : i, c)) : [];
      }
      function $m(n, i) {
        return n && n.length ? Zi(n, q(i, 3), !1, !0) : [];
      }
      function Dm(n, i) {
        return n && n.length ? Zi(n, q(i, 3)) : [];
      }
      var Wm = ie(function(n) {
        return mn(Be(n, 1, Ee, !0));
      }), Um = ie(function(n) {
        var i = _t(n);
        return Ee(i) && (i = r), mn(Be(n, 1, Ee, !0), q(i, 2));
      }), Hm = ie(function(n) {
        var i = _t(n);
        return i = typeof i == "function" ? i : r, mn(Be(n, 1, Ee, !0), r, i);
      });
      function Zm(n) {
        return n && n.length ? mn(n) : [];
      }
      function Vm(n, i) {
        return n && n.length ? mn(n, q(i, 2)) : [];
      }
      function jm(n, i) {
        return i = typeof i == "function" ? i : r, n && n.length ? mn(n, r, i) : [];
      }
      function za(n) {
        if (!(n && n.length))
          return [];
        var i = 0;
        return n = fn(n, function(o) {
          if (Ee(o))
            return i = Oe(o.length, i), !0;
        }), da(i, function(o) {
          return _e(n, ua(o));
        });
      }
      function pc(n, i) {
        if (!(n && n.length))
          return [];
        var o = za(n);
        return i == null ? o : _e(o, function(c) {
          return st(i, r, c);
        });
      }
      var Gm = ie(function(n, i) {
        return Ee(n) ? qr(n, i) : [];
      }), Ym = ie(function(n) {
        return Ra(fn(n, Ee));
      }), qm = ie(function(n) {
        var i = _t(n);
        return Ee(i) && (i = r), Ra(fn(n, Ee), q(i, 2));
      }), zm = ie(function(n) {
        var i = _t(n);
        return i = typeof i == "function" ? i : r, Ra(fn(n, Ee), r, i);
      }), Km = ie(za);
      function Xm(n, i) {
        return ku(n || [], i || [], Yr);
      }
      function Jm(n, i) {
        return ku(n || [], i || [], Xr);
      }
      var Qm = ie(function(n) {
        var i = n.length, o = i > 1 ? n[i - 1] : r;
        return o = typeof o == "function" ? (n.pop(), o) : r, pc(n, o);
      });
      function gc(n) {
        var i = p(n);
        return i.__chain__ = !0, i;
      }
      function ev(n, i) {
        return i(n), n;
      }
      function Ji(n, i) {
        return i(n);
      }
      var tv = Jt(function(n) {
        var i = n.length, o = i ? n[0] : 0, c = this.__wrapped__, h = function(m) {
          return xa(m, n);
        };
        return i > 1 || this.__actions__.length || !(c instanceof oe) || !Qt(o) ? this.thru(h) : (c = c.slice(o, +o + (i ? 1 : 0)), c.__actions__.push({
          func: Ji,
          args: [h],
          thisArg: r
        }), new mt(c, this.__chain__).thru(function(m) {
          return i && !m.length && m.push(r), m;
        }));
      });
      function nv() {
        return gc(this);
      }
      function rv() {
        return new mt(this.value(), this.__chain__);
      }
      function iv() {
        this.__values__ === r && (this.__values__ = Oc(this.value()));
        var n = this.__index__ >= this.__values__.length, i = n ? r : this.__values__[this.__index__++];
        return { done: n, value: i };
      }
      function sv() {
        return this;
      }
      function av(n) {
        for (var i, o = this; o instanceof Mi; ) {
          var c = lc(o);
          c.__index__ = 0, c.__values__ = r, i ? h.__wrapped__ = c : i = c;
          var h = c;
          o = o.__wrapped__;
        }
        return h.__wrapped__ = n, i;
      }
      function ov() {
        var n = this.__wrapped__;
        if (n instanceof oe) {
          var i = n;
          return this.__actions__.length && (i = new oe(this)), i = i.reverse(), i.__actions__.push({
            func: Ji,
            args: [qa],
            thisArg: r
          }), new mt(i, this.__chain__);
        }
        return this.thru(qa);
      }
      function lv() {
        return Iu(this.__wrapped__, this.__actions__);
      }
      var uv = Vi(function(n, i, o) {
        pe.call(n, o) ? ++n[o] : Kt(n, o, 1);
      });
      function cv(n, i, o) {
        var c = Q(n) ? Vl : eg;
        return o && je(n, i, o) && (i = r), c(n, q(i, 3));
      }
      function fv(n, i) {
        var o = Q(n) ? fn : pu;
        return o(n, q(i, 3));
      }
      var dv = Hu(uc), hv = Hu(cc);
      function pv(n, i) {
        return Be(Qi(n, i), 1);
      }
      function gv(n, i) {
        return Be(Qi(n, i), Se);
      }
      function mv(n, i, o) {
        return o = o === r ? 1 : te(o), Be(Qi(n, i), o);
      }
      function mc(n, i) {
        var o = Q(n) ? pt : gn;
        return o(n, q(i, 3));
      }
      function vc(n, i) {
        var o = Q(n) ? Fh : hu;
        return o(n, q(i, 3));
      }
      var vv = Vi(function(n, i, o) {
        pe.call(n, o) ? n[o].push(i) : Kt(n, o, [i]);
      });
      function yv(n, i, o, c) {
        n = Ke(n) ? n : mr(n), o = o && !c ? te(o) : 0;
        var h = n.length;
        return o < 0 && (o = Oe(h + o, 0)), is(n) ? o <= h && n.indexOf(i, o) > -1 : !!h && ir(n, i, o) > -1;
      }
      var _v = ie(function(n, i, o) {
        var c = -1, h = typeof i == "function", m = Ke(n) ? S(n.length) : [];
        return gn(n, function(v) {
          m[++c] = h ? st(i, v, o) : zr(v, i, o);
        }), m;
      }), xv = Vi(function(n, i, o) {
        Kt(n, o, i);
      });
      function Qi(n, i) {
        var o = Q(n) ? _e : xu;
        return o(n, q(i, 3));
      }
      function wv(n, i, o, c) {
        return n == null ? [] : (Q(i) || (i = i == null ? [] : [i]), o = c ? r : o, Q(o) || (o = o == null ? [] : [o]), Au(n, i, o));
      }
      var bv = Vi(function(n, i, o) {
        n[o ? 0 : 1].push(i);
      }, function() {
        return [[], []];
      });
      function Ev(n, i, o) {
        var c = Q(n) ? oa : ql, h = arguments.length < 3;
        return c(n, q(i, 4), o, h, gn);
      }
      function Av(n, i, o) {
        var c = Q(n) ? Bh : ql, h = arguments.length < 3;
        return c(n, q(i, 4), o, h, hu);
      }
      function Cv(n, i) {
        var o = Q(n) ? fn : pu;
        return o(n, ns(q(i, 3)));
      }
      function Tv(n) {
        var i = Q(n) ? uu : yg;
        return i(n);
      }
      function Sv(n, i, o) {
        (o ? je(n, i, o) : i === r) ? i = 1 : i = te(i);
        var c = Q(n) ? zp : _g;
        return c(n, i);
      }
      function Lv(n) {
        var i = Q(n) ? Kp : wg;
        return i(n);
      }
      function Ov(n) {
        if (n == null)
          return 0;
        if (Ke(n))
          return is(n) ? ar(n) : n.length;
        var i = We(n);
        return i == Ct || i == Tt ? n.size : Ta(n).length;
      }
      function Nv(n, i, o) {
        var c = Q(n) ? la : bg;
        return o && je(n, i, o) && (i = r), c(n, q(i, 3));
      }
      var Iv = ie(function(n, i) {
        if (n == null)
          return [];
        var o = i.length;
        return o > 1 && je(n, i[0], i[1]) ? i = [] : o > 2 && je(i[0], i[1], i[2]) && (i = [i[0]]), Au(n, Be(i, 1), []);
      }), es = fp || function() {
        return Fe.Date.now();
      };
      function kv(n, i) {
        if (typeof i != "function")
          throw new gt(u);
        return n = te(n), function() {
          if (--n < 1)
            return i.apply(this, arguments);
        };
      }
      function yc(n, i, o) {
        return i = o ? r : i, i = n && i == null ? n.length : i, Xt(n, Y, r, r, r, r, i);
      }
      function _c(n, i) {
        var o;
        if (typeof i != "function")
          throw new gt(u);
        return n = te(n), function() {
          return --n > 0 && (o = i.apply(this, arguments)), n <= 1 && (i = r), o;
        };
      }
      var Ka = ie(function(n, i, o) {
        var c = P;
        if (o.length) {
          var h = hn(o, pr(Ka));
          c |= k;
        }
        return Xt(n, c, i, o, h);
      }), xc = ie(function(n, i, o) {
        var c = P | U;
        if (o.length) {
          var h = hn(o, pr(xc));
          c |= k;
        }
        return Xt(i, c, n, o, h);
      });
      function wc(n, i, o) {
        i = o ? r : i;
        var c = Xt(n, $, r, r, r, r, r, i);
        return c.placeholder = wc.placeholder, c;
      }
      function bc(n, i, o) {
        i = o ? r : i;
        var c = Xt(n, Z, r, r, r, r, r, i);
        return c.placeholder = bc.placeholder, c;
      }
      function Ec(n, i, o) {
        var c, h, m, v, y, b, O = 0, N = !1, I = !1, F = !0;
        if (typeof n != "function")
          throw new gt(u);
        i = xt(i) || 0, xe(o) && (N = !!o.leading, I = "maxWait" in o, m = I ? Oe(xt(o.maxWait) || 0, i) : m, F = "trailing" in o ? !!o.trailing : F);
        function V(Ae) {
          var Nt = c, nn = h;
          return c = h = r, O = Ae, v = n.apply(nn, Nt), v;
        }
        function z(Ae) {
          return O = Ae, y = ei(ae, i), N ? V(Ae) : v;
        }
        function re(Ae) {
          var Nt = Ae - b, nn = Ae - O, Hc = i - Nt;
          return I ? De(Hc, m - nn) : Hc;
        }
        function K(Ae) {
          var Nt = Ae - b, nn = Ae - O;
          return b === r || Nt >= i || Nt < 0 || I && nn >= m;
        }
        function ae() {
          var Ae = es();
          if (K(Ae))
            return ce(Ae);
          y = ei(ae, re(Ae));
        }
        function ce(Ae) {
          return y = r, F && c ? V(Ae) : (c = h = r, v);
        }
        function ut() {
          y !== r && Ru(y), O = 0, c = b = h = y = r;
        }
        function Ge() {
          return y === r ? v : ce(es());
        }
        function ct() {
          var Ae = es(), Nt = K(Ae);
          if (c = arguments, h = this, b = Ae, Nt) {
            if (y === r)
              return z(b);
            if (I)
              return Ru(y), y = ei(ae, i), V(b);
          }
          return y === r && (y = ei(ae, i)), v;
        }
        return ct.cancel = ut, ct.flush = Ge, ct;
      }
      var Rv = ie(function(n, i) {
        return du(n, 1, i);
      }), Pv = ie(function(n, i, o) {
        return du(n, xt(i) || 0, o);
      });
      function Fv(n) {
        return Xt(n, jt);
      }
      function ts(n, i) {
        if (typeof n != "function" || i != null && typeof i != "function")
          throw new gt(u);
        var o = function() {
          var c = arguments, h = i ? i.apply(this, c) : c[0], m = o.cache;
          if (m.has(h))
            return m.get(h);
          var v = n.apply(this, c);
          return o.cache = m.set(h, v) || m, v;
        };
        return o.cache = new (ts.Cache || zt)(), o;
      }
      ts.Cache = zt;
      function ns(n) {
        if (typeof n != "function")
          throw new gt(u);
        return function() {
          var i = arguments;
          switch (i.length) {
            case 0:
              return !n.call(this);
            case 1:
              return !n.call(this, i[0]);
            case 2:
              return !n.call(this, i[0], i[1]);
            case 3:
              return !n.call(this, i[0], i[1], i[2]);
          }
          return !n.apply(this, i);
        };
      }
      function Bv(n) {
        return _c(2, n);
      }
      var Mv = Eg(function(n, i) {
        i = i.length == 1 && Q(i[0]) ? _e(i[0], at(q())) : _e(Be(i, 1), at(q()));
        var o = i.length;
        return ie(function(c) {
          for (var h = -1, m = De(c.length, o); ++h < m; )
            c[h] = i[h].call(this, c[h]);
          return st(n, this, c);
        });
      }), Xa = ie(function(n, i) {
        var o = hn(i, pr(Xa));
        return Xt(n, k, r, i, o);
      }), Ac = ie(function(n, i) {
        var o = hn(i, pr(Ac));
        return Xt(n, se, r, i, o);
      }), $v = Jt(function(n, i) {
        return Xt(n, ge, r, r, r, i);
      });
      function Dv(n, i) {
        if (typeof n != "function")
          throw new gt(u);
        return i = i === r ? i : te(i), ie(n, i);
      }
      function Wv(n, i) {
        if (typeof n != "function")
          throw new gt(u);
        return i = i == null ? 0 : Oe(te(i), 0), ie(function(o) {
          var c = o[i], h = yn(o, 0, i);
          return c && dn(h, c), st(n, this, h);
        });
      }
      function Uv(n, i, o) {
        var c = !0, h = !0;
        if (typeof n != "function")
          throw new gt(u);
        return xe(o) && (c = "leading" in o ? !!o.leading : c, h = "trailing" in o ? !!o.trailing : h), Ec(n, i, {
          leading: c,
          maxWait: i,
          trailing: h
        });
      }
      function Hv(n) {
        return yc(n, 1);
      }
      function Zv(n, i) {
        return Xa(Fa(i), n);
      }
      function Vv() {
        if (!arguments.length)
          return [];
        var n = arguments[0];
        return Q(n) ? n : [n];
      }
      function jv(n) {
        return vt(n, A);
      }
      function Gv(n, i) {
        return i = typeof i == "function" ? i : r, vt(n, A, i);
      }
      function Yv(n) {
        return vt(n, x | A);
      }
      function qv(n, i) {
        return i = typeof i == "function" ? i : r, vt(n, x | A, i);
      }
      function zv(n, i) {
        return i == null || fu(n, i, Re(i));
      }
      function Ot(n, i) {
        return n === i || n !== n && i !== i;
      }
      var Kv = qi(Ea), Xv = qi(function(n, i) {
        return n >= i;
      }), Dn = vu(function() {
        return arguments;
      }()) ? vu : function(n) {
        return we(n) && pe.call(n, "callee") && !ru.call(n, "callee");
      }, Q = S.isArray, Jv = $l ? at($l) : ag;
      function Ke(n) {
        return n != null && rs(n.length) && !en(n);
      }
      function Ee(n) {
        return we(n) && Ke(n);
      }
      function Qv(n) {
        return n === !0 || n === !1 || we(n) && Ve(n) == Pr;
      }
      var _n = hp || lo, e0 = Dl ? at(Dl) : og;
      function t0(n) {
        return we(n) && n.nodeType === 1 && !ti(n);
      }
      function n0(n) {
        if (n == null)
          return !0;
        if (Ke(n) && (Q(n) || typeof n == "string" || typeof n.splice == "function" || _n(n) || gr(n) || Dn(n)))
          return !n.length;
        var i = We(n);
        if (i == Ct || i == Tt)
          return !n.size;
        if (Qr(n))
          return !Ta(n).length;
        for (var o in n)
          if (pe.call(n, o))
            return !1;
        return !0;
      }
      function r0(n, i) {
        return Kr(n, i);
      }
      function i0(n, i, o) {
        o = typeof o == "function" ? o : r;
        var c = o ? o(n, i) : r;
        return c === r ? Kr(n, i, r, o) : !!c;
      }
      function Ja(n) {
        if (!we(n))
          return !1;
        var i = Ve(n);
        return i == gi || i == Sd || typeof n.message == "string" && typeof n.name == "string" && !ti(n);
      }
      function s0(n) {
        return typeof n == "number" && su(n);
      }
      function en(n) {
        if (!xe(n))
          return !1;
        var i = Ve(n);
        return i == mi || i == dl || i == Td || i == Od;
      }
      function Cc(n) {
        return typeof n == "number" && n == te(n);
      }
      function rs(n) {
        return typeof n == "number" && n > -1 && n % 1 == 0 && n <= $e;
      }
      function xe(n) {
        var i = typeof n;
        return n != null && (i == "object" || i == "function");
      }
      function we(n) {
        return n != null && typeof n == "object";
      }
      var Tc = Wl ? at(Wl) : ug;
      function a0(n, i) {
        return n === i || Ca(n, i, Ha(i));
      }
      function o0(n, i, o) {
        return o = typeof o == "function" ? o : r, Ca(n, i, Ha(i), o);
      }
      function l0(n) {
        return Sc(n) && n != +n;
      }
      function u0(n) {
        if (Gg(n))
          throw new J(l);
        return yu(n);
      }
      function c0(n) {
        return n === null;
      }
      function f0(n) {
        return n == null;
      }
      function Sc(n) {
        return typeof n == "number" || we(n) && Ve(n) == Br;
      }
      function ti(n) {
        if (!we(n) || Ve(n) != Yt)
          return !1;
        var i = Ni(n);
        if (i === null)
          return !0;
        var o = pe.call(i, "constructor") && i.constructor;
        return typeof o == "function" && o instanceof o && Ti.call(o) == op;
      }
      var Qa = Ul ? at(Ul) : cg;
      function d0(n) {
        return Cc(n) && n >= -$e && n <= $e;
      }
      var Lc = Hl ? at(Hl) : fg;
      function is(n) {
        return typeof n == "string" || !Q(n) && we(n) && Ve(n) == $r;
      }
      function lt(n) {
        return typeof n == "symbol" || we(n) && Ve(n) == vi;
      }
      var gr = Zl ? at(Zl) : dg;
      function h0(n) {
        return n === r;
      }
      function p0(n) {
        return we(n) && We(n) == Dr;
      }
      function g0(n) {
        return we(n) && Ve(n) == Id;
      }
      var m0 = qi(Sa), v0 = qi(function(n, i) {
        return n <= i;
      });
      function Oc(n) {
        if (!n)
          return [];
        if (Ke(n))
          return is(n) ? St(n) : ze(n);
        if (Hr && n[Hr])
          return zh(n[Hr]());
        var i = We(n), o = i == Ct ? pa : i == Tt ? Ei : mr;
        return o(n);
      }
      function tn(n) {
        if (!n)
          return n === 0 ? n : 0;
        if (n = xt(n), n === Se || n === -Se) {
          var i = n < 0 ? -1 : 1;
          return i * Nn;
        }
        return n === n ? n : 0;
      }
      function te(n) {
        var i = tn(n), o = i % 1;
        return i === i ? o ? i - o : i : 0;
      }
      function Nc(n) {
        return n ? Fn(te(n), 0, Rt) : 0;
      }
      function xt(n) {
        if (typeof n == "number")
          return n;
        if (lt(n))
          return er;
        if (xe(n)) {
          var i = typeof n.valueOf == "function" ? n.valueOf() : n;
          n = xe(i) ? i + "" : i;
        }
        if (typeof n != "string")
          return n === 0 ? n : +n;
        n = zl(n);
        var o = Jd.test(n);
        return o || eh.test(n) ? kh(n.slice(2), o ? 2 : 8) : Xd.test(n) ? er : +n;
      }
      function Ic(n) {
        return Ft(n, Xe(n));
      }
      function y0(n) {
        return n ? Fn(te(n), -$e, $e) : n === 0 ? n : 0;
      }
      function he(n) {
        return n == null ? "" : ot(n);
      }
      var _0 = dr(function(n, i) {
        if (Qr(i) || Ke(i)) {
          Ft(i, Re(i), n);
          return;
        }
        for (var o in i)
          pe.call(i, o) && Yr(n, o, i[o]);
      }), kc = dr(function(n, i) {
        Ft(i, Xe(i), n);
      }), ss = dr(function(n, i, o, c) {
        Ft(i, Xe(i), n, c);
      }), x0 = dr(function(n, i, o, c) {
        Ft(i, Re(i), n, c);
      }), w0 = Jt(xa);
      function b0(n, i) {
        var o = fr(n);
        return i == null ? o : cu(o, i);
      }
      var E0 = ie(function(n, i) {
        n = me(n);
        var o = -1, c = i.length, h = c > 2 ? i[2] : r;
        for (h && je(i[0], i[1], h) && (c = 1); ++o < c; )
          for (var m = i[o], v = Xe(m), y = -1, b = v.length; ++y < b; ) {
            var O = v[y], N = n[O];
            (N === r || Ot(N, lr[O]) && !pe.call(n, O)) && (n[O] = m[O]);
          }
        return n;
      }), A0 = ie(function(n) {
        return n.push(r, zu), st(Rc, r, n);
      });
      function C0(n, i) {
        return jl(n, q(i, 3), Pt);
      }
      function T0(n, i) {
        return jl(n, q(i, 3), ba);
      }
      function S0(n, i) {
        return n == null ? n : wa(n, q(i, 3), Xe);
      }
      function L0(n, i) {
        return n == null ? n : gu(n, q(i, 3), Xe);
      }
      function O0(n, i) {
        return n && Pt(n, q(i, 3));
      }
      function N0(n, i) {
        return n && ba(n, q(i, 3));
      }
      function I0(n) {
        return n == null ? [] : Wi(n, Re(n));
      }
      function k0(n) {
        return n == null ? [] : Wi(n, Xe(n));
      }
      function eo(n, i, o) {
        var c = n == null ? r : Bn(n, i);
        return c === r ? o : c;
      }
      function R0(n, i) {
        return n != null && Ju(n, i, ng);
      }
      function to(n, i) {
        return n != null && Ju(n, i, rg);
      }
      var P0 = Vu(function(n, i, o) {
        i != null && typeof i.toString != "function" && (i = Si.call(i)), n[i] = o;
      }, ro(Je)), F0 = Vu(function(n, i, o) {
        i != null && typeof i.toString != "function" && (i = Si.call(i)), pe.call(n, i) ? n[i].push(o) : n[i] = [o];
      }, q), B0 = ie(zr);
      function Re(n) {
        return Ke(n) ? lu(n) : Ta(n);
      }
      function Xe(n) {
        return Ke(n) ? lu(n, !0) : hg(n);
      }
      function M0(n, i) {
        var o = {};
        return i = q(i, 3), Pt(n, function(c, h, m) {
          Kt(o, i(c, h, m), c);
        }), o;
      }
      function $0(n, i) {
        var o = {};
        return i = q(i, 3), Pt(n, function(c, h, m) {
          Kt(o, h, i(c, h, m));
        }), o;
      }
      var D0 = dr(function(n, i, o) {
        Ui(n, i, o);
      }), Rc = dr(function(n, i, o, c) {
        Ui(n, i, o, c);
      }), W0 = Jt(function(n, i) {
        var o = {};
        if (n == null)
          return o;
        var c = !1;
        i = _e(i, function(m) {
          return m = vn(m, n), c || (c = m.length > 1), m;
        }), Ft(n, Wa(n), o), c && (o = vt(o, x | T | A, Pg));
        for (var h = i.length; h--; )
          ka(o, i[h]);
        return o;
      });
      function U0(n, i) {
        return Pc(n, ns(q(i)));
      }
      var H0 = Jt(function(n, i) {
        return n == null ? {} : gg(n, i);
      });
      function Pc(n, i) {
        if (n == null)
          return {};
        var o = _e(Wa(n), function(c) {
          return [c];
        });
        return i = q(i), Cu(n, o, function(c, h) {
          return i(c, h[0]);
        });
      }
      function Z0(n, i, o) {
        i = vn(i, n);
        var c = -1, h = i.length;
        for (h || (h = 1, n = r); ++c < h; ) {
          var m = n == null ? r : n[Bt(i[c])];
          m === r && (c = h, m = o), n = en(m) ? m.call(n) : m;
        }
        return n;
      }
      function V0(n, i, o) {
        return n == null ? n : Xr(n, i, o);
      }
      function j0(n, i, o, c) {
        return c = typeof c == "function" ? c : r, n == null ? n : Xr(n, i, o, c);
      }
      var Fc = Yu(Re), Bc = Yu(Xe);
      function G0(n, i, o) {
        var c = Q(n), h = c || _n(n) || gr(n);
        if (i = q(i, 4), o == null) {
          var m = n && n.constructor;
          h ? o = c ? new m() : [] : xe(n) ? o = en(m) ? fr(Ni(n)) : {} : o = {};
        }
        return (h ? pt : Pt)(n, function(v, y, b) {
          return i(o, v, y, b);
        }), o;
      }
      function Y0(n, i) {
        return n == null ? !0 : ka(n, i);
      }
      function q0(n, i, o) {
        return n == null ? n : Nu(n, i, Fa(o));
      }
      function z0(n, i, o, c) {
        return c = typeof c == "function" ? c : r, n == null ? n : Nu(n, i, Fa(o), c);
      }
      function mr(n) {
        return n == null ? [] : ha(n, Re(n));
      }
      function K0(n) {
        return n == null ? [] : ha(n, Xe(n));
      }
      function X0(n, i, o) {
        return o === r && (o = i, i = r), o !== r && (o = xt(o), o = o === o ? o : 0), i !== r && (i = xt(i), i = i === i ? i : 0), Fn(xt(n), i, o);
      }
      function J0(n, i, o) {
        return i = tn(i), o === r ? (o = i, i = 0) : o = tn(o), n = xt(n), ig(n, i, o);
      }
      function Q0(n, i, o) {
        if (o && typeof o != "boolean" && je(n, i, o) && (i = o = r), o === r && (typeof i == "boolean" ? (o = i, i = r) : typeof n == "boolean" && (o = n, n = r)), n === r && i === r ? (n = 0, i = 1) : (n = tn(n), i === r ? (i = n, n = 0) : i = tn(i)), n > i) {
          var c = n;
          n = i, i = c;
        }
        if (o || n % 1 || i % 1) {
          var h = au();
          return De(n + h * (i - n + Ih("1e-" + ((h + "").length - 1))), i);
        }
        return Oa(n, i);
      }
      var ey = hr(function(n, i, o) {
        return i = i.toLowerCase(), n + (o ? Mc(i) : i);
      });
      function Mc(n) {
        return no(he(n).toLowerCase());
      }
      function $c(n) {
        return n = he(n), n && n.replace(nh, Vh).replace(wh, "");
      }
      function ty(n, i, o) {
        n = he(n), i = ot(i);
        var c = n.length;
        o = o === r ? c : Fn(te(o), 0, c);
        var h = o;
        return o -= i.length, o >= 0 && n.slice(o, h) == i;
      }
      function ny(n) {
        return n = he(n), n && Bd.test(n) ? n.replace(gl, jh) : n;
      }
      function ry(n) {
        return n = he(n), n && Hd.test(n) ? n.replace(Xs, "\\$&") : n;
      }
      var iy = hr(function(n, i, o) {
        return n + (o ? "-" : "") + i.toLowerCase();
      }), sy = hr(function(n, i, o) {
        return n + (o ? " " : "") + i.toLowerCase();
      }), ay = Uu("toLowerCase");
      function oy(n, i, o) {
        n = he(n), i = te(i);
        var c = i ? ar(n) : 0;
        if (!i || c >= i)
          return n;
        var h = (i - c) / 2;
        return Yi(Pi(h), o) + n + Yi(Ri(h), o);
      }
      function ly(n, i, o) {
        n = he(n), i = te(i);
        var c = i ? ar(n) : 0;
        return i && c < i ? n + Yi(i - c, o) : n;
      }
      function uy(n, i, o) {
        n = he(n), i = te(i);
        var c = i ? ar(n) : 0;
        return i && c < i ? Yi(i - c, o) + n : n;
      }
      function cy(n, i, o) {
        return o || i == null ? i = 0 : i && (i = +i), vp(he(n).replace(Js, ""), i || 0);
      }
      function fy(n, i, o) {
        return (o ? je(n, i, o) : i === r) ? i = 1 : i = te(i), Na(he(n), i);
      }
      function dy() {
        var n = arguments, i = he(n[0]);
        return n.length < 3 ? i : i.replace(n[1], n[2]);
      }
      var hy = hr(function(n, i, o) {
        return n + (o ? "_" : "") + i.toLowerCase();
      });
      function py(n, i, o) {
        return o && typeof o != "number" && je(n, i, o) && (i = o = r), o = o === r ? Rt : o >>> 0, o ? (n = he(n), n && (typeof i == "string" || i != null && !Qa(i)) && (i = ot(i), !i && sr(n)) ? yn(St(n), 0, o) : n.split(i, o)) : [];
      }
      var gy = hr(function(n, i, o) {
        return n + (o ? " " : "") + no(i);
      });
      function my(n, i, o) {
        return n = he(n), o = o == null ? 0 : Fn(te(o), 0, n.length), i = ot(i), n.slice(o, o + i.length) == i;
      }
      function vy(n, i, o) {
        var c = p.templateSettings;
        o && je(n, i, o) && (i = r), n = he(n), i = ss({}, i, c, qu);
        var h = ss({}, i.imports, c.imports, qu), m = Re(h), v = ha(h, m), y, b, O = 0, N = i.interpolate || yi, I = "__p += '", F = ga(
          (i.escape || yi).source + "|" + N.source + "|" + (N === ml ? Kd : yi).source + "|" + (i.evaluate || yi).source + "|$",
          "g"
        ), V = "//# sourceURL=" + (pe.call(i, "sourceURL") ? (i.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Th + "]") + `
`;
        n.replace(F, function(K, ae, ce, ut, Ge, ct) {
          return ce || (ce = ut), I += n.slice(O, ct).replace(rh, Gh), ae && (y = !0, I += `' +
__e(` + ae + `) +
'`), Ge && (b = !0, I += `';
` + Ge + `;
__p += '`), ce && (I += `' +
((__t = (` + ce + `)) == null ? '' : __t) +
'`), O = ct + K.length, K;
        }), I += `';
`;
        var z = pe.call(i, "variable") && i.variable;
        if (!z)
          I = `with (obj) {
` + I + `
}
`;
        else if (qd.test(z))
          throw new J(f);
        I = (b ? I.replace(kd, "") : I).replace(Rd, "$1").replace(Pd, "$1;"), I = "function(" + (z || "obj") + `) {
` + (z ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (y ? ", __e = _.escape" : "") + (b ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + I + `return __p
}`;
        var re = Wc(function() {
          return fe(m, V + "return " + I).apply(r, v);
        });
        if (re.source = I, Ja(re))
          throw re;
        return re;
      }
      function yy(n) {
        return he(n).toLowerCase();
      }
      function _y(n) {
        return he(n).toUpperCase();
      }
      function xy(n, i, o) {
        if (n = he(n), n && (o || i === r))
          return zl(n);
        if (!n || !(i = ot(i)))
          return n;
        var c = St(n), h = St(i), m = Kl(c, h), v = Xl(c, h) + 1;
        return yn(c, m, v).join("");
      }
      function wy(n, i, o) {
        if (n = he(n), n && (o || i === r))
          return n.slice(0, Ql(n) + 1);
        if (!n || !(i = ot(i)))
          return n;
        var c = St(n), h = Xl(c, St(i)) + 1;
        return yn(c, 0, h).join("");
      }
      function by(n, i, o) {
        if (n = he(n), n && (o || i === r))
          return n.replace(Js, "");
        if (!n || !(i = ot(i)))
          return n;
        var c = St(n), h = Kl(c, St(i));
        return yn(c, h).join("");
      }
      function Ey(n, i) {
        var o = Me, c = cn;
        if (xe(i)) {
          var h = "separator" in i ? i.separator : h;
          o = "length" in i ? te(i.length) : o, c = "omission" in i ? ot(i.omission) : c;
        }
        n = he(n);
        var m = n.length;
        if (sr(n)) {
          var v = St(n);
          m = v.length;
        }
        if (o >= m)
          return n;
        var y = o - ar(c);
        if (y < 1)
          return c;
        var b = v ? yn(v, 0, y).join("") : n.slice(0, y);
        if (h === r)
          return b + c;
        if (v && (y += b.length - y), Qa(h)) {
          if (n.slice(y).search(h)) {
            var O, N = b;
            for (h.global || (h = ga(h.source, he(vl.exec(h)) + "g")), h.lastIndex = 0; O = h.exec(N); )
              var I = O.index;
            b = b.slice(0, I === r ? y : I);
          }
        } else if (n.indexOf(ot(h), y) != y) {
          var F = b.lastIndexOf(h);
          F > -1 && (b = b.slice(0, F));
        }
        return b + c;
      }
      function Ay(n) {
        return n = he(n), n && Fd.test(n) ? n.replace(pl, Qh) : n;
      }
      var Cy = hr(function(n, i, o) {
        return n + (o ? " " : "") + i.toUpperCase();
      }), no = Uu("toUpperCase");
      function Dc(n, i, o) {
        return n = he(n), i = o ? r : i, i === r ? qh(n) ? np(n) : Dh(n) : n.match(i) || [];
      }
      var Wc = ie(function(n, i) {
        try {
          return st(n, r, i);
        } catch (o) {
          return Ja(o) ? o : new J(o);
        }
      }), Ty = Jt(function(n, i) {
        return pt(i, function(o) {
          o = Bt(o), Kt(n, o, Ka(n[o], n));
        }), n;
      });
      function Sy(n) {
        var i = n == null ? 0 : n.length, o = q();
        return n = i ? _e(n, function(c) {
          if (typeof c[1] != "function")
            throw new gt(u);
          return [o(c[0]), c[1]];
        }) : [], ie(function(c) {
          for (var h = -1; ++h < i; ) {
            var m = n[h];
            if (st(m[0], this, c))
              return st(m[1], this, c);
          }
        });
      }
      function Ly(n) {
        return Qp(vt(n, x));
      }
      function ro(n) {
        return function() {
          return n;
        };
      }
      function Oy(n, i) {
        return n == null || n !== n ? i : n;
      }
      var Ny = Zu(), Iy = Zu(!0);
      function Je(n) {
        return n;
      }
      function io(n) {
        return _u(typeof n == "function" ? n : vt(n, x));
      }
      function ky(n) {
        return wu(vt(n, x));
      }
      function Ry(n, i) {
        return bu(n, vt(i, x));
      }
      var Py = ie(function(n, i) {
        return function(o) {
          return zr(o, n, i);
        };
      }), Fy = ie(function(n, i) {
        return function(o) {
          return zr(n, o, i);
        };
      });
      function so(n, i, o) {
        var c = Re(i), h = Wi(i, c);
        o == null && !(xe(i) && (h.length || !c.length)) && (o = i, i = n, n = this, h = Wi(i, Re(i)));
        var m = !(xe(o) && "chain" in o) || !!o.chain, v = en(n);
        return pt(h, function(y) {
          var b = i[y];
          n[y] = b, v && (n.prototype[y] = function() {
            var O = this.__chain__;
            if (m || O) {
              var N = n(this.__wrapped__), I = N.__actions__ = ze(this.__actions__);
              return I.push({ func: b, args: arguments, thisArg: n }), N.__chain__ = O, N;
            }
            return b.apply(n, dn([this.value()], arguments));
          });
        }), n;
      }
      function By() {
        return Fe._ === this && (Fe._ = lp), this;
      }
      function ao() {
      }
      function My(n) {
        return n = te(n), ie(function(i) {
          return Eu(i, n);
        });
      }
      var $y = Ma(_e), Dy = Ma(Vl), Wy = Ma(la);
      function Uc(n) {
        return Va(n) ? ua(Bt(n)) : mg(n);
      }
      function Uy(n) {
        return function(i) {
          return n == null ? r : Bn(n, i);
        };
      }
      var Hy = ju(), Zy = ju(!0);
      function oo() {
        return [];
      }
      function lo() {
        return !1;
      }
      function Vy() {
        return {};
      }
      function jy() {
        return "";
      }
      function Gy() {
        return !0;
      }
      function Yy(n, i) {
        if (n = te(n), n < 1 || n > $e)
          return [];
        var o = Rt, c = De(n, Rt);
        i = q(i), n -= Rt;
        for (var h = da(c, i); ++o < n; )
          i(o);
        return h;
      }
      function qy(n) {
        return Q(n) ? _e(n, Bt) : lt(n) ? [n] : ze(oc(he(n)));
      }
      function zy(n) {
        var i = ++ap;
        return he(n) + i;
      }
      var Ky = Gi(function(n, i) {
        return n + i;
      }, 0), Xy = $a("ceil"), Jy = Gi(function(n, i) {
        return n / i;
      }, 1), Qy = $a("floor");
      function e_(n) {
        return n && n.length ? Di(n, Je, Ea) : r;
      }
      function t_(n, i) {
        return n && n.length ? Di(n, q(i, 2), Ea) : r;
      }
      function n_(n) {
        return Yl(n, Je);
      }
      function r_(n, i) {
        return Yl(n, q(i, 2));
      }
      function i_(n) {
        return n && n.length ? Di(n, Je, Sa) : r;
      }
      function s_(n, i) {
        return n && n.length ? Di(n, q(i, 2), Sa) : r;
      }
      var a_ = Gi(function(n, i) {
        return n * i;
      }, 1), o_ = $a("round"), l_ = Gi(function(n, i) {
        return n - i;
      }, 0);
      function u_(n) {
        return n && n.length ? fa(n, Je) : 0;
      }
      function c_(n, i) {
        return n && n.length ? fa(n, q(i, 2)) : 0;
      }
      return p.after = kv, p.ary = yc, p.assign = _0, p.assignIn = kc, p.assignInWith = ss, p.assignWith = x0, p.at = w0, p.before = _c, p.bind = Ka, p.bindAll = Ty, p.bindKey = xc, p.castArray = Vv, p.chain = gc, p.chunk = Qg, p.compact = em, p.concat = tm, p.cond = Sy, p.conforms = Ly, p.constant = ro, p.countBy = uv, p.create = b0, p.curry = wc, p.curryRight = bc, p.debounce = Ec, p.defaults = E0, p.defaultsDeep = A0, p.defer = Rv, p.delay = Pv, p.difference = nm, p.differenceBy = rm, p.differenceWith = im, p.drop = sm, p.dropRight = am, p.dropRightWhile = om, p.dropWhile = lm, p.fill = um, p.filter = fv, p.flatMap = pv, p.flatMapDeep = gv, p.flatMapDepth = mv, p.flatten = fc, p.flattenDeep = cm, p.flattenDepth = fm, p.flip = Fv, p.flow = Ny, p.flowRight = Iy, p.fromPairs = dm, p.functions = I0, p.functionsIn = k0, p.groupBy = vv, p.initial = pm, p.intersection = gm, p.intersectionBy = mm, p.intersectionWith = vm, p.invert = P0, p.invertBy = F0, p.invokeMap = _v, p.iteratee = io, p.keyBy = xv, p.keys = Re, p.keysIn = Xe, p.map = Qi, p.mapKeys = M0, p.mapValues = $0, p.matches = ky, p.matchesProperty = Ry, p.memoize = ts, p.merge = D0, p.mergeWith = Rc, p.method = Py, p.methodOf = Fy, p.mixin = so, p.negate = ns, p.nthArg = My, p.omit = W0, p.omitBy = U0, p.once = Bv, p.orderBy = wv, p.over = $y, p.overArgs = Mv, p.overEvery = Dy, p.overSome = Wy, p.partial = Xa, p.partialRight = Ac, p.partition = bv, p.pick = H0, p.pickBy = Pc, p.property = Uc, p.propertyOf = Uy, p.pull = wm, p.pullAll = hc, p.pullAllBy = bm, p.pullAllWith = Em, p.pullAt = Am, p.range = Hy, p.rangeRight = Zy, p.rearg = $v, p.reject = Cv, p.remove = Cm, p.rest = Dv, p.reverse = qa, p.sampleSize = Sv, p.set = V0, p.setWith = j0, p.shuffle = Lv, p.slice = Tm, p.sortBy = Iv, p.sortedUniq = Rm, p.sortedUniqBy = Pm, p.split = py, p.spread = Wv, p.tail = Fm, p.take = Bm, p.takeRight = Mm, p.takeRightWhile = $m, p.takeWhile = Dm, p.tap = ev, p.throttle = Uv, p.thru = Ji, p.toArray = Oc, p.toPairs = Fc, p.toPairsIn = Bc, p.toPath = qy, p.toPlainObject = Ic, p.transform = G0, p.unary = Hv, p.union = Wm, p.unionBy = Um, p.unionWith = Hm, p.uniq = Zm, p.uniqBy = Vm, p.uniqWith = jm, p.unset = Y0, p.unzip = za, p.unzipWith = pc, p.update = q0, p.updateWith = z0, p.values = mr, p.valuesIn = K0, p.without = Gm, p.words = Dc, p.wrap = Zv, p.xor = Ym, p.xorBy = qm, p.xorWith = zm, p.zip = Km, p.zipObject = Xm, p.zipObjectDeep = Jm, p.zipWith = Qm, p.entries = Fc, p.entriesIn = Bc, p.extend = kc, p.extendWith = ss, so(p, p), p.add = Ky, p.attempt = Wc, p.camelCase = ey, p.capitalize = Mc, p.ceil = Xy, p.clamp = X0, p.clone = jv, p.cloneDeep = Yv, p.cloneDeepWith = qv, p.cloneWith = Gv, p.conformsTo = zv, p.deburr = $c, p.defaultTo = Oy, p.divide = Jy, p.endsWith = ty, p.eq = Ot, p.escape = ny, p.escapeRegExp = ry, p.every = cv, p.find = dv, p.findIndex = uc, p.findKey = C0, p.findLast = hv, p.findLastIndex = cc, p.findLastKey = T0, p.floor = Qy, p.forEach = mc, p.forEachRight = vc, p.forIn = S0, p.forInRight = L0, p.forOwn = O0, p.forOwnRight = N0, p.get = eo, p.gt = Kv, p.gte = Xv, p.has = R0, p.hasIn = to, p.head = dc, p.identity = Je, p.includes = yv, p.indexOf = hm, p.inRange = J0, p.invoke = B0, p.isArguments = Dn, p.isArray = Q, p.isArrayBuffer = Jv, p.isArrayLike = Ke, p.isArrayLikeObject = Ee, p.isBoolean = Qv, p.isBuffer = _n, p.isDate = e0, p.isElement = t0, p.isEmpty = n0, p.isEqual = r0, p.isEqualWith = i0, p.isError = Ja, p.isFinite = s0, p.isFunction = en, p.isInteger = Cc, p.isLength = rs, p.isMap = Tc, p.isMatch = a0, p.isMatchWith = o0, p.isNaN = l0, p.isNative = u0, p.isNil = f0, p.isNull = c0, p.isNumber = Sc, p.isObject = xe, p.isObjectLike = we, p.isPlainObject = ti, p.isRegExp = Qa, p.isSafeInteger = d0, p.isSet = Lc, p.isString = is, p.isSymbol = lt, p.isTypedArray = gr, p.isUndefined = h0, p.isWeakMap = p0, p.isWeakSet = g0, p.join = ym, p.kebabCase = iy, p.last = _t, p.lastIndexOf = _m, p.lowerCase = sy, p.lowerFirst = ay, p.lt = m0, p.lte = v0, p.max = e_, p.maxBy = t_, p.mean = n_, p.meanBy = r_, p.min = i_, p.minBy = s_, p.stubArray = oo, p.stubFalse = lo, p.stubObject = Vy, p.stubString = jy, p.stubTrue = Gy, p.multiply = a_, p.nth = xm, p.noConflict = By, p.noop = ao, p.now = es, p.pad = oy, p.padEnd = ly, p.padStart = uy, p.parseInt = cy, p.random = Q0, p.reduce = Ev, p.reduceRight = Av, p.repeat = fy, p.replace = dy, p.result = Z0, p.round = o_, p.runInContext = w, p.sample = Tv, p.size = Ov, p.snakeCase = hy, p.some = Nv, p.sortedIndex = Sm, p.sortedIndexBy = Lm, p.sortedIndexOf = Om, p.sortedLastIndex = Nm, p.sortedLastIndexBy = Im, p.sortedLastIndexOf = km, p.startCase = gy, p.startsWith = my, p.subtract = l_, p.sum = u_, p.sumBy = c_, p.template = vy, p.times = Yy, p.toFinite = tn, p.toInteger = te, p.toLength = Nc, p.toLower = yy, p.toNumber = xt, p.toSafeInteger = y0, p.toString = he, p.toUpper = _y, p.trim = xy, p.trimEnd = wy, p.trimStart = by, p.truncate = Ey, p.unescape = Ay, p.uniqueId = zy, p.upperCase = Cy, p.upperFirst = no, p.each = mc, p.eachRight = vc, p.first = dc, so(p, function() {
        var n = {};
        return Pt(p, function(i, o) {
          pe.call(p.prototype, o) || (n[o] = i);
        }), n;
      }(), { chain: !1 }), p.VERSION = s, pt(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(n) {
        p[n].placeholder = p;
      }), pt(["drop", "take"], function(n, i) {
        oe.prototype[n] = function(o) {
          o = o === r ? 1 : Oe(te(o), 0);
          var c = this.__filtered__ && !i ? new oe(this) : this.clone();
          return c.__filtered__ ? c.__takeCount__ = De(o, c.__takeCount__) : c.__views__.push({
            size: De(o, Rt),
            type: n + (c.__dir__ < 0 ? "Right" : "")
          }), c;
        }, oe.prototype[n + "Right"] = function(o) {
          return this.reverse()[n](o).reverse();
        };
      }), pt(["filter", "map", "takeWhile"], function(n, i) {
        var o = i + 1, c = o == Ze || o == it;
        oe.prototype[n] = function(h) {
          var m = this.clone();
          return m.__iteratees__.push({
            iteratee: q(h, 3),
            type: o
          }), m.__filtered__ = m.__filtered__ || c, m;
        };
      }), pt(["head", "last"], function(n, i) {
        var o = "take" + (i ? "Right" : "");
        oe.prototype[n] = function() {
          return this[o](1).value()[0];
        };
      }), pt(["initial", "tail"], function(n, i) {
        var o = "drop" + (i ? "" : "Right");
        oe.prototype[n] = function() {
          return this.__filtered__ ? new oe(this) : this[o](1);
        };
      }), oe.prototype.compact = function() {
        return this.filter(Je);
      }, oe.prototype.find = function(n) {
        return this.filter(n).head();
      }, oe.prototype.findLast = function(n) {
        return this.reverse().find(n);
      }, oe.prototype.invokeMap = ie(function(n, i) {
        return typeof n == "function" ? new oe(this) : this.map(function(o) {
          return zr(o, n, i);
        });
      }), oe.prototype.reject = function(n) {
        return this.filter(ns(q(n)));
      }, oe.prototype.slice = function(n, i) {
        n = te(n);
        var o = this;
        return o.__filtered__ && (n > 0 || i < 0) ? new oe(o) : (n < 0 ? o = o.takeRight(-n) : n && (o = o.drop(n)), i !== r && (i = te(i), o = i < 0 ? o.dropRight(-i) : o.take(i - n)), o);
      }, oe.prototype.takeRightWhile = function(n) {
        return this.reverse().takeWhile(n).reverse();
      }, oe.prototype.toArray = function() {
        return this.take(Rt);
      }, Pt(oe.prototype, function(n, i) {
        var o = /^(?:filter|find|map|reject)|While$/.test(i), c = /^(?:head|last)$/.test(i), h = p[c ? "take" + (i == "last" ? "Right" : "") : i], m = c || /^find/.test(i);
        h && (p.prototype[i] = function() {
          var v = this.__wrapped__, y = c ? [1] : arguments, b = v instanceof oe, O = y[0], N = b || Q(v), I = function(ae) {
            var ce = h.apply(p, dn([ae], y));
            return c && F ? ce[0] : ce;
          };
          N && o && typeof O == "function" && O.length != 1 && (b = N = !1);
          var F = this.__chain__, V = !!this.__actions__.length, z = m && !F, re = b && !V;
          if (!m && N) {
            v = re ? v : new oe(this);
            var K = n.apply(v, y);
            return K.__actions__.push({ func: Ji, args: [I], thisArg: r }), new mt(K, F);
          }
          return z && re ? n.apply(this, y) : (K = this.thru(I), z ? c ? K.value()[0] : K.value() : K);
        });
      }), pt(["pop", "push", "shift", "sort", "splice", "unshift"], function(n) {
        var i = Ai[n], o = /^(?:push|sort|unshift)$/.test(n) ? "tap" : "thru", c = /^(?:pop|shift)$/.test(n);
        p.prototype[n] = function() {
          var h = arguments;
          if (c && !this.__chain__) {
            var m = this.value();
            return i.apply(Q(m) ? m : [], h);
          }
          return this[o](function(v) {
            return i.apply(Q(v) ? v : [], h);
          });
        };
      }), Pt(oe.prototype, function(n, i) {
        var o = p[i];
        if (o) {
          var c = o.name + "";
          pe.call(cr, c) || (cr[c] = []), cr[c].push({ name: i, func: o });
        }
      }), cr[ji(r, U).name] = [{
        name: "wrapper",
        func: r
      }], oe.prototype.clone = Ap, oe.prototype.reverse = Cp, oe.prototype.value = Tp, p.prototype.at = tv, p.prototype.chain = nv, p.prototype.commit = rv, p.prototype.next = iv, p.prototype.plant = av, p.prototype.reverse = ov, p.prototype.toJSON = p.prototype.valueOf = p.prototype.value = lv, p.prototype.first = p.prototype.head, Hr && (p.prototype[Hr] = sv), p;
    }, or = rp();
    In ? ((In.exports = or)._ = or, ia._ = or) : Fe._ = or;
  }).call(Wn);
})(Es, Es.exports);
var Jo = Es.exports;
const Ie = /* @__PURE__ */ $o(Jo);
const Qo = zo({
  fullWidth: _r().default(!1),
  description: Kn().optional()
});
class kt {
  constructor(t, r, s) {
    /**
     * this is a refrance of the Data object
     */
    B(this, "data");
    /**
     * This is the property of the current field. a property is a part that
     * represents the field in the data object that has all the data
     */
    B(this, "property");
    /**
     * This is the params of the guifier object. here you can find all the configurations of the user
     */
    B(this, "params");
    /**
     * This is the keyName of the current field. if the field is an object property
     * it will have a string key and if its an array key its going to have a number key
     */
    B(this, "keyName");
    /**
     * every field has two colors theme to make them more visible when they are nested
     * this property decides which color theme to use
     */
    B(this, "showSecondaryColors", !1);
    /**
     * The localParam property is the this.property._params
     */
    B(this, "localParam");
    /**
     * this property tells if the current field is a big field (if it requires more than 45px height) like object, array or a rich text field
     */
    B(this, "isCollapsible", !1);
    this.params = s, this.property = t, this.data = r, this.keyName = t._key, this.property._params === void 0 && (this.property._params = {}), this.localParam = Qo.parse(this.property._params);
  }
  /**
   * This function is responsible for setting the new value to the property
   */
  setValue(t) {
    this.property._value = t, this.params.onChange !== void 0 && this.params.onChange();
  }
  /**
   * This function is responsible for drawing the collapsible fields wihtout a container.
   *  This function needs to be overridden by a child field class and it created to be used
   * with arrays containers
   */
  drawCollapsibleFieldContentWithoutContainer() {
    const t = document.createElement("p");
    return t.innerHTML = "drawCollapsibleFieldContentWithoutContainer method is not defined in this field", t;
  }
}
/**
 * this is name of the field internaly
 */
B(kt, "fieldName", "field"), /**
 * this is the label name thats shown for users
 */
B(kt, "fieldLabelName", "Field"), /**
 * this is the icon thats shown for users
 */
B(kt, "fieldIcon", ""), /**
 * this the flag that determens if the field is Base or a CustomField
 */
B(kt, "isBaseField", !0);
const sl = class extends kt {
  constructor() {
    super(...arguments);
    /**
     * this property tells if the current field is a big field like object, array or a rich text field
     */
    B(this, "isCollapsible", !0);
    /**
     * this property sets the space an object will take in a grid
     */
    B(this, "gridSpace", 2);
    /**
     * this property tells if the current field is a big field like object, array or a rich text field
     */
    B(this, "containerLength", 0);
    /**
     * this property tells if the current field is a big field like object, array or a rich text field
     */
    B(this, "contentBody", document.createElement("div"));
  }
  /**
   * This method is responsible for drawing the body when the container is empty
   *
   * @returns {HTMLElement} html element object
   */
  drawEmptyContent(r = !1) {
    const s = r ? "Elements" : "Properties", a = r ? "Element" : "Property", l = document.createElement("div");
    l.classList.add("guifierEmptyContentContianer");
    const u = document.createElement("div");
    u.classList.add("emptyContentContianerWrapper"), l.append(u);
    const f = document.createElement("h2");
    f.classList.add("guifierEmptyTitle"), f.append(`No ${s}`), u.append(f);
    const d = document.createElement("p");
    d.classList.add("guifierEmptyParagraph"), d.append(`You dont have any ${s} yet. Click the button below to add one.`), u.append(d);
    const g = document.createElement("div");
    return g.classList.add("guifierEmptyButton"), g.append(`Add ${a}`), g.append(this.drawAddButton()), g.addEventListener("click", () => {
      Promise.resolve().then(async () => {
        r ? await this.letUserAddElement() : await this.letUserAddProperty();
      }).catch((_) => {
        console.error(_);
      });
    }), u.append(g), l;
  }
  /**
   * this method checks if the current container is the
   * first container and its not a nested container
   *
   * @returns {HTMLElement} html element object
   */
  containerInFirstLevel() {
    return this.property._path.length === 1;
  }
  /**
   * This function is responsible for drawing the container in an object container
   *
   * @returns {HTMLElement} html element object
   */
  drawContainer() {
    const r = document.createElement("div");
    r.classList.add("guifierContainer"), r.classList.add("guifierObjectFieldContainer"), r.style.gridColumn = `span ${this.gridSpace}`, this.showSecondaryColors ? r.classList.add("guifierSecondaryBgColor") : r.classList.add("guifierPrimaryBgColor"), r.append(this.drawHeader());
    const s = r.querySelector(".guifierContainerHeaderButtons");
    return s !== null && sl.showHeaderButtonsWhenHovering(s, r), r;
  }
  /**
   * This function will draw the container with its contents
   *
   * @returns {HTMLElement} html element object
   */
  drawContentWithContainer() {
    const r = this.drawContainer();
    return r.append(this.draw()), r;
  }
  /**
   * This function is responsible for drawing the header for a container field
   *
   * @returns {HTMLElement} html element object
   */
  drawHeader() {
    const r = document.createElement("div");
    r.classList.add("guifierContainerHeader"), r.classList.add("guifierPrimaryBottomBorder");
    const s = this.property._key, a = document.createElement("div");
    this.property._path.length !== 1 && a.append(bt(this.property._valueType === "array" ? "data_array" : "data_object")), a.classList.add("guifierContainerHeaderKeyName"), a.append(this.property._path.length === 1 ? this.params.rootContainerName : s.toString()), r.append(a), Jo.isEmpty(this.property._params.description) || (a.append(Xf()), Jf(this, r));
    const l = this.drawContainerHeaderButtons();
    return r.append(l), r;
  }
  /**
   * This function is responsible for drawing the header part where we add buttons
   *
   * @returns {HTMLElement} html element object
   */
  drawContainerHeaderButtons(r = !1) {
    const s = document.createElement("div");
    return s.classList.add("guifierContainerHeaderButtons"), this.params.readOnlyMode || (this.containerInFirstLevel() && this.params.fullScreen && s.append(this.drawFullScreenButton()), this.containerInFirstLevel() || s.append(this.drawDeleteButton()), s.append(this.drawAddButton())), this.containerInFirstLevel() || s.append(this.drawCollapseButton(r)), s;
  }
  /**
   * This function is responsible for adding the effect of showing buttons when hovering on the object
   *
   * @returns {HTMLElement} html element object
   */
  static showHeaderButtonsWhenHovering(r, s, a = !1) {
    let l;
    s.addEventListener("mouseenter", () => {
      if (r !== void 0) {
        const u = a ? Array.from(r.children) : Array.from(r.children).reverse(), f = 50;
        clearTimeout(l), u.forEach((d, g) => {
          d.innerHTML !== "expand_less" && (l = setTimeout(() => {
            r.style.pointerEvents = "all", d.classList.add("guifierShowElementWithAnimation");
          }, f * g));
        });
      }
    }), s.addEventListener("mouseleave", () => {
      if (r !== void 0) {
        const u = a ? Array.from(r.children).reverse() : Array.from(r.children), f = 100;
        clearTimeout(l), u.forEach((d, g) => {
          d.innerHTML !== "expand_less" && (l = setTimeout(() => {
            r.style.pointerEvents = "none", d.classList.remove("guifierShowElementWithAnimation");
          }, f * g));
        });
      }
    });
  }
  /**
   * This function is responsible for drawing the collapse button for the container field
   *
   * @returns {HTMLElement} html element object
   */
  drawCollapseButton(r = !1) {
    const s = bt("expand_less");
    return s.classList.add("guifierContainerCollapseButton"), r ? s.classList.add("guifierRotate") : s.classList.remove("guifierRotate"), s;
  }
  /**
   * This function is responsible for drawing the delete button for the container field
   *
   * @returns {HTMLElement} html element object
   */
  drawDeleteButton() {
    return bt("delete");
  }
  /**
   * This function is responsible for drawing the add button for the container field
   *
   * @returns {HTMLElement} html element object
   */
  drawAddButton() {
    return bt("add");
  }
  /**
   * This function is responsible for drawing the fullScreen button for the container field
   *
   * @returns {HTMLElement} html element object
   */
  drawFullScreenButton() {
    const r = bt("fullscreen"), s = bt("fullscreen_exit");
    s.setAttribute("style", "display: none");
    const a = document.createElement("span");
    a.style.height = "25px", a.append(r), a.append(s);
    const l = document.querySelector(this.params.elementSelector);
    return a.addEventListener("click", () => {
      r.getAttribute("style") !== null ? (s.setAttribute("style", "display: none"), r.removeAttribute("style"), document.exitFullscreen(), l.removeAttribute("style")) : (r.setAttribute("style", "display: none"), s.removeAttribute("style"), l == null || l.requestFullscreen(), l.setAttribute("style", "padding: 2vw"));
    }), document.addEventListener("fullscreenchange", () => {
      document.fullscreenElement === null && (s.setAttribute("style", "display: none"), r.removeAttribute("style"), l.removeAttribute("style"));
    }), a;
  }
};
let wn = sl;
/**
 * this is name of the field internaly
 */
B(wn, "fieldName", "container"), /**
 * this is the label name thats shown for users
 */
B(wn, "fieldLabelName", "Container");
class Ws {
  constructor(t) {
    /**
     * dialog Params
     */
    B(this, "params");
    /**
     * This is the data that will be used to instantiate the guifier obejct
     * to draw the second page that will be used to fill the meta data of
     * the field that will be created
     */
    B(this, "data");
    /**
     * This is the data that will be used to instantiate the guifier obejct
     * to draw the second page that will be used to fill the meta data of
     * the field that will be created
     */
    B(this, "guifier", null);
    /**
     * This is the body container element of the dialog element
     */
    B(this, "dialogContainerBody", document.createElement("div"));
    /**
     * This is the whole dialog element
     */
    B(this, "dialogElement", document.createElement("div"));
    /**
     * This is the back arrow html element
     */
    B(this, "guifierGeneratedContent", document.createElement("div"));
    /**
     * This is the Cancel Button html element
     */
    B(this, "cancelButton", document.createElement("div"));
    /**
     * This is the Confirm Button html element
     */
    B(this, "confirmButton", document.createElement("div"));
    this.params = t, this.buildGuifierDialog(), this.hideDialog();
  }
  /**
   * This function shows dialog and returns data
   * @returns the data of click on confirm or returns null if clicked on cancel
   */
  async get(t) {
    return this.data = t, this.guifierGeneratedContent = this.drawGuifierGeneratedContent(this.data), this.dialogContainerBody.append(this.guifierGeneratedContent), this.showDialog(), await new Promise((r) => {
      this.confirmButton.addEventListener("click", () => {
        var a;
        const s = (a = this.guifier) == null ? void 0 : a.getData(et.Js);
        for (const l in s) {
          const u = s[l];
          if (Ie.isEmpty(u)) {
            alert("Please ensure that all required fields have been completed.");
            return;
          }
        }
        r(s), this.hideDialog(), setTimeout(() => {
          this.removeDialog();
        }, 150);
      }), this.cancelButton.addEventListener("click", () => {
        r(null), this.hideDialog(), setTimeout(() => {
          this.removeDialog();
        }, 150);
      });
    });
  }
  /**
   * This is the function resposible to show the dialog element in the
   * the selected element with the chosen Id
   */
  buildGuifierDialog() {
    const t = document.querySelector(this.params.elementSelector);
    t !== null && t.append(this.drawdialog());
  }
  /**
   * This function is responsible for drawing the dialog element
   */
  drawdialog() {
    const t = document.createElement("div");
    return t.classList.add("guifierDialogBackgroundContainer"), this.dialogElement = t, t.append(this.drawDialogContainer()), t.addEventListener("click", (r) => {
      r.target.classList.contains("guifierDialogBackgroundContainer") && (this.hideDialog(), setTimeout(() => {
        this.removeDialog();
      }, 150));
    }), t;
  }
  /**
   * This function is responsible for showing the dialog
   */
  showDialog() {
    setTimeout(() => {
      this.dialogElement.classList.remove("guifierOpacityZero");
    }, 0);
  }
  /**
   * This function is responsible for hiding the dialog
   */
  hideDialog() {
    this.dialogElement.classList.add("guifierOpacityZero"), this.clearGuifierGeneratedContent();
  }
  /**
   * This function is responsible for removing the dialog
   */
  removeDialog() {
    var t, r;
    (r = (t = this.dialogContainerBody.parentElement) == null ? void 0 : t.parentElement) == null || r.remove();
  }
  /**
   * This function is responsible for drawing the dialog container element
   */
  drawDialogContainer() {
    const t = document.createElement("div");
    t.classList.add("guifierDialogContainer");
    const r = document.createElement("div");
    r.classList.add("guifierDialogContainerTitle"), r.append(this.params.dialogTitle), r.append(bt("add")), t.append(r);
    const s = document.createElement("div");
    s.classList.add("guifierDialogContainerBody"), this.dialogContainerBody = s, t.append(this.dialogContainerBody);
    const a = document.createElement("div");
    a.classList.add("guifierDialogFooter");
    const l = document.createElement("div");
    l.classList.add("guifierDialogCancelButton"), l.classList.add("guifierDialogButton"), l.append("Cancel"), this.cancelButton = l, a.append(l);
    const u = document.createElement("div");
    return u.classList.add("guifierDialogConfirmButton"), u.classList.add("guifierDialogButton"), u.append("Confirm"), this.confirmButton = u, a.append(u), t.append(a), t;
  }
  /**
   * This function is responsible for drawing a grid element
   */
  drawGuifierGeneratedContent(t) {
    const r = {
      elementSelector: this.params.elementSelector,
      data: t,
      dataType: et.Js,
      withoutContainer: !0,
      flipBackgroundColors: !0,
      expandFieldsToFullWidth: !0,
      readOnlyMode: !0
    };
    this.guifier = new bE(r);
    const s = this.guifier.getGeneratedHtmlElement(), a = document.createElement("div");
    return a.classList.add("guifierGeneratedContent"), a.append(s), a;
  }
  /**
   * This function clears the guifierGeneratedContent element
   */
  clearGuifierGeneratedContent() {
    this.guifierGeneratedContent.innerHTML = "";
  }
  /**
   * This function will show a dialog and return its data
   *
   * @param {any} data is the data you want the user to set in the dialog
   * @param {DialogParameters} params is the parameter of the dialog
   * @returns the data of click on confirm or returns null if clicked on cancel
   */
  static async get(t, r) {
    const s = r;
    return await new Ws(s).get(t);
  }
}
const Ns = class extends wn {
  /**
   * This function validates the _params of the property object
   */
  validateParams() {
  }
  /**
   * This function validates the _rules of the property object
   */
  validateRules() {
  }
  /**
   * This function validates the _rules of the property object
   */
  getFieldLabelName() {
    return Ns.fieldLabelName;
  }
  /**
   * this function is responsible for drawing the HTMLElement object
   *
   * @returns {HTMLElement} html element object
   */
  draw() {
    const t = document.createElement("div");
    t.classList.add("guifierObjectContainerbody"), this.containerInFirstLevel() && (t.style.overflowY = "auto");
    const r = this.property._value;
    if (this.containerLength = Object.keys(r).length, Ie.isEmpty(r))
      t.append(this.drawEmptyContent(!1));
    else
      for (const s in r) {
        const a = r[s], l = this.drawProperty(a);
        t.append(l);
      }
    return this.contentBody = t, t;
  }
  /**
   * This function is responsible for drawing a property of the object
   */
  drawProperty(t) {
    const r = el(t, this.data, this.params);
    let s;
    if (r.isCollapsible) {
      r.showSecondaryColors = !this.showSecondaryColors;
      const a = r.drawContentWithContainer(), l = a.children[0].children[1];
      Ns.addingEventListenerForHeaderButtons(l, this, r), s = a;
    } else {
      const a = document.createElement("div");
      a.classList.add("guifierObjectFieldContainer"), r.localParam.fullWidth ? a.style.gridColumn = "span 2" : a.style.gridColumn = "span 1", this.params.expandFieldsToFullWidth && (a.style.gridColumn = "span 2");
      const l = document.createElement("div");
      l.classList.add("guifierObjectLabelContainer");
      const u = document.createElement("div");
      u.classList.add("guifierObjectLabelTextPart");
      const f = t._key;
      u.append(f.toString()), l.append(u);
      const d = document.createElement("div");
      d.classList.add("guifierObjectLabelButtonsPart");
      const g = this.drawFieldButtons(r, a);
      wn.showHeaderButtonsWhenHovering(g, a, !0), d.append(g), l.append(d), a.append(l), r.showSecondaryColors = this.showSecondaryColors;
      const _ = r.draw(), x = document.createElement("div");
      x.classList.add("guifierObjectfieldInnerContainer"), x.append(_), a.append(x), Jo.isEmpty(r.property._params.description) || (u.append(Xf()), Jf(r, a)), s = a;
    }
    return s;
  }
  /**
   * This function is responsible for drawing the object without a container. used for objects in arrays
   */
  drawCollapsibleFieldContentWithoutContainer() {
    const t = this.draw();
    return t.style.padding = "0", t;
  }
  /**
   * This function is responsible for drawing buttons that edits a field in an object container
   */
  drawFieldButtons(t, r) {
    const s = document.createElement("div");
    s.classList.add("fieldButtons"), this.params.readOnlyMode && (s.style.display = "none");
    const a = bt("delete");
    return a.addEventListener("click", () => {
      this.deleteProperty(t.keyName), r.remove();
    }), s.append(a), s;
  }
  /**
   * This function is responsible of adding event listeners to the header buttons of an object container
   */
  static addingEventListenerForHeaderButtons(t, r, s) {
    t !== null && Array.from(t.children).forEach((l) => {
      switch (l.innerHTML) {
        case "expand_less":
          l.addEventListener("click", () => {
            var d, g, _;
            const u = (g = (d = l.parentElement) == null ? void 0 : d.parentElement) == null ? void 0 : g.nextElementSibling;
            ((_ = l.parentElement) == null ? void 0 : _.parentElement).classList.toggle("guifierPrimaryBottomBorder"), l.classList.toggle("guifierRotate"), u.classList.toggle("guifierNoneDisplay");
          });
          break;
        case "delete":
          l.addEventListener("click", () => {
            r.deleteProperty(s.keyName);
            const f = s.contentBody.closest(".guifierObjectFieldContainer");
            f == null || f.remove();
          });
          break;
        case "add":
          l.addEventListener("click", () => {
            Promise.resolve().then(async () => {
              s.getFieldLabelName() === "Object" ? await s.letUserAddProperty() : s.getFieldLabelName() === "Array" && await s.letUserAddElement();
            }).catch((u) => {
              console.error(u);
            });
          });
          break;
      }
    });
  }
  /**
   * This function is responsible for deleting an object property in the ui
   */
  deleteProperty(t) {
    const r = Ie.cloneDeep(this.property._path);
    r.push(t);
    const s = r;
    this.data.removeData(s), this.containerLength--, this.containerLength === 0 && this.contentBody.append(this.drawEmptyContent(!1)), this.params.onChange !== void 0 && this.params.onChange();
  }
  /**
   * This function is responsible for adding a property in an object container
   */
  addProperty(t) {
    t = Ie.cloneDeep(t), this.data.addProperty(t), this.containerLength === 0 && (this.contentBody.innerHTML = ""), this.contentBody.append(this.drawProperty(t)), this.containerLength++, this.params.onChange !== void 0 && this.params.onChange();
  }
  /**
   * This function lets the user add a property to an object container by showing a prompt to him
   */
  async letUserAddProperty() {
    const t = [];
    for (const l in kr) {
      const u = kr[l];
      u.staticObject.isBaseField && t.push({
        icon: u.staticObject.fieldIcon,
        text: u.staticObject.fieldLabelName,
        value: u.staticObject.fieldName
      });
    }
    const r = {
      "Field Name": "",
      "Field Type": {
        _fieldType: "cardSelect",
        _params: {
          cards: t
        },
        _value: ""
      }
    }, s = {
      elementSelector: this.params.elementSelector + " > div",
      dialogTitle: "New Field"
    }, a = await Ws.get(r, s);
    if (a !== null) {
      const l = {
        _path: [...this.property._path, a["Field Name"]],
        _key: a["Field Name"],
        _valueType: wt(As(a["Field Type"])),
        _value: As(a["Field Type"]),
        // FIXME: this function here adds a huge object instead of just returning an empty object when creating two objects in the gui
        _fieldType: a["Field Type"],
        _rules: void 0,
        _params: void 0
      };
      this.addProperty(l);
    }
  }
};
let xn = Ns;
/**
 * this is name of the field internaly
 */
B(xn, "fieldName", "object"), B(xn, "fieldLabelName", "Object"), /**
 * this is the icon thats shown for users
 */
B(xn, "fieldIcon", "data_object");
const Is = class extends wn {
  constructor() {
    super(...arguments);
    B(this, "numberOfLevels", 0);
    B(this, "contentBody", document.createElement("div"));
  }
  /**
   * This function validates the _params of the property array
   */
  validateParams() {
  }
  /**
   * This function validates the _rules of the property array
   */
  validateRules() {
  }
  /**
   * This function validates the _rules of the property object
   */
  getFieldLabelName() {
    return Is.fieldLabelName;
  }
  /**
   * this function is responsible for drawing the HTMLElement array
   *
   * @returns {HTMLElement} html element array
   */
  draw() {
    const r = document.createElement("div");
    r.classList.add("guifierArrayContainerbody"), this.containerInFirstLevel() && (r.style.overflowY = "auto");
    const s = this.property._value;
    if (Ie.isEmpty(s)) {
      r.append(this.drawEmptyContent(!0));
      const a = r.querySelector(".guifierEmptyContentContianer");
      a == null || a.prepend(this.drawArrayLevels(this.numberOfLevels - 1));
    } else
      for (const a in s) {
        const l = s[a];
        r.append(this.drawElement(l)), this.containerLength++;
      }
    return this.contentBody = r, r;
  }
  /**
   * This function is responsible for drawing an array element
   *
   * @returns {HTMLElement} html element object
   */
  drawElement(r) {
    const s = document.createElement("div");
    s.classList.add("guifierArrayFieldContainer"), s.dataset.elementIndex = `${this.containerLength}`, df(this.containerLength) && s.classList.add("guifierOddBackground"), s.append(this.drawArrayLevels(this.numberOfLevels));
    const a = r._key, l = document.createElement("div");
    if (l.classList.add("guifierArrayLabelContainer"), this.numberOfLevels > 0) {
      l.classList.add("guifierArrayLabelContainerForUpperLevel");
      const x = document.createElement("div");
      x.classList.add("guifierArrayLabelLineForUpperLevel"), l.append(x);
    }
    const u = document.createElement("div");
    u.classList.add("guifierArrayIndexLabel"), this.showSecondaryColors ? u.classList.add("guifierPrimaryBgColor") : u.classList.add("guifierSecondaryBgColor"), u.innerHTML = `${a + 1}`, l.append(u), s.append(l);
    const f = document.createElement("div");
    f.classList.add("guifierArrayfieldInnerContainer");
    const d = el(r, this.data, this.params);
    let g;
    if (d.isCollapsible ? (g = this.drawCollapsibleArrayElement(d), s.classList.add("guifierContainerFieldType")) : (d.showSecondaryColors = this.showSecondaryColors, g = d.draw(), s.classList.add("guifierBaseFieldType")), f.append(g), s.append(f), d.isCollapsible) {
      const x = document.createDocumentFragment();
      x.append(s), this.containerLength === this.property._value.length - 1 ? x.append(this.drawCollapsibleArrayElementContent(d, !0)) : x.append(this.drawCollapsibleArrayElementContent(d));
      const T = s.querySelector(".guifierContainerHeaderButtons");
      return wn.showHeaderButtonsWhenHovering(T, s), Is.addingEventListenerForHeaderButtons(T, this, d), x;
    }
    const _ = this.drawArrayFieldDeleteButton();
    return s.append(_), s;
  }
  /**
   * This function is responsible for drawing the button in the array field element
   *
   * @returns {HTMLElement} html element object
   */
  drawArrayFieldDeleteButton() {
    const r = this.drawDeleteButton();
    return this.params.readOnlyMode && (r.style.display = "none"), r.classList.add("guifierArrayFieldDeleteButton"), r.addEventListener("click", () => {
      var a;
      const s = parseInt((a = r.parentElement) == null ? void 0 : a.dataset.elementIndex);
      this.removeElement(s);
    }), r;
  }
  /**
   * This function is responsible for drawing an array element that is Collapsible
   *
   * @returns {HTMLElement} html element object
   */
  drawCollapsibleArrayElement(r) {
    const s = document.createElement("div");
    s.classList.add("guifierArrayCollapsibleElement");
    const a = document.createElement("div");
    a.classList.add("guifierFieldLabelName"), a.innerHTML = r.getFieldLabelName(), s.append(a);
    const l = r.drawContainerHeaderButtons(!0);
    return s.append(l), s;
  }
  /**
   * This function is responsible for drawing the content of an array element that is Collapsible
   *
   * @returns {HTMLElement} html element object
   */
  drawCollapsibleArrayElementContent(r, s = !1) {
    const a = document.createElement("div");
    if (a.classList.add("guifierCollapsibleElementContent"), this.showSecondaryColors ? a.classList.add("guifierSecondaryBgColor") : a.classList.add("guifierPrimaryBgColor"), s && (a.style.borderRadius = "0 0 7.5px 7.5px"), r.showSecondaryColors = this.showSecondaryColors, r.getFieldLabelName() !== "Array") {
      a.append(this.drawArrayLevels(this.numberOfLevels));
      const l = document.createElement("div");
      l.classList.add("guifierCollapsibleElementInnerContentContainer"), l.append(r.drawCollapsibleFieldContentWithoutContainer()), a.append(l);
    } else {
      const l = r;
      l.numberOfLevels = this.numberOfLevels + 1, a.append(l.draw());
    }
    return a.classList.add("guifierNoneDisplay"), a;
  }
  /**
   * This function is responsible for drawing levels line for the array
   *
   * @returns {HTMLElement} html element object
   */
  drawArrayLevels(r) {
    const s = document.createElement("div");
    s.classList.add("guifierArrayLevelsContainer"), r === 0 && r++;
    for (let a = 0; a < r; a++) {
      const l = document.createElement("div");
      l.classList.add("guifierArrayLevelElement"), s.append(l);
    }
    return s;
  }
  /**
   * This function is responsible adding event listeners to the header buttons of an object container
   */
  static addingEventListenerForHeaderButtons(r, s, a) {
    r !== null && Array.from(r.children).forEach((u) => {
      switch (u.innerHTML) {
        case "expand_less":
          u.addEventListener("click", () => {
            var d, g, _, x;
            const f = (x = (_ = (g = (d = u.parentElement) == null ? void 0 : d.parentElement) == null ? void 0 : g.parentElement) == null ? void 0 : _.parentElement) == null ? void 0 : x.nextElementSibling;
            u.classList.toggle("guifierRotate"), f.classList.toggle("guifierNoneDisplay");
          });
          break;
        case "delete":
          u.addEventListener("click", (f) => {
            var x, T, A;
            const g = (A = (T = (x = f.target.parentElement) == null ? void 0 : x.parentElement) == null ? void 0 : T.parentElement) == null ? void 0 : A.parentElement, _ = g == null ? void 0 : g.dataset.elementIndex;
            s.removeElement(parseInt(_));
          });
          break;
        case "add":
          u.addEventListener("click", () => {
            Promise.resolve().then(async () => {
              a.getFieldLabelName() === "Object" ? await a.letUserAddProperty() : a.getFieldLabelName() === "Array" && await a.letUserAddElement();
            }).catch((f) => {
              console.error(f);
            });
          });
          break;
      }
    });
  }
  /**
   * This function is responsible for deleting an element in an array container in the ui
   */
  removeElement(r) {
    var l;
    const s = this.getArrayFieldContainers();
    s[r].classList.contains("guifierContainerFieldType") && ((l = s[r].nextElementSibling) == null || l.remove()), s[r].remove();
    const a = Ie.cloneDeep(this.property._path);
    a.push(r), this.data.removeData(a), this.resetElementsUiInArrayContainer(), this.containerLength--, this.containerLength === 0 && this.contentBody.append(this.drawEmptyContent(!0)), this.params.onChange !== void 0 && this.params.onChange();
  }
  /**
   * This function lets the user add an element by showing a prompt to him
   */
  async letUserAddElement() {
    const r = [];
    for (const u in kr) {
      const f = kr[u];
      f.staticObject.isBaseField && r.push({
        icon: f.staticObject.fieldIcon,
        text: f.staticObject.fieldLabelName,
        value: f.staticObject.fieldName
      });
    }
    const s = {
      "Field Type": {
        _fieldType: "cardSelect",
        _params: {
          cards: r
        },
        _value: ""
      }
    }, a = {
      elementSelector: this.params.elementSelector + " > div",
      dialogTitle: "New Field"
    }, l = await Ws.get(s, a);
    if (l !== null) {
      const u = {
        _path: [...this.property._path, this.containerLength],
        _key: this.containerLength,
        _valueType: wt(As(l["Field Type"])),
        _value: As(l["Field Type"]),
        _fieldType: l["Field Type"],
        _rules: void 0,
        _params: void 0
      };
      this.addElement(u);
    }
  }
  /**
   * This function is responsible for adding a property in an object container
   */
  addElement(r) {
    r = Ie.cloneDeep(r), this.data.addElement(r), this.containerLength === 0 && (this.contentBody.innerHTML = "");
    const s = this.drawElement(r);
    this.contentBody.append(s), this.containerLength++, this.params.onChange !== void 0 && this.params.onChange();
  }
  /**
   * This function is responsible for redrawing Elements in an Array Container
   */
  resetElementsUiInArrayContainer() {
    this.getArrayFieldContainers().forEach((s, a) => {
      const l = s.querySelector(".guifierArrayIndexLabel");
      l !== null && (l.innerHTML = `${a + 1}`), s.classList.remove("guifierOddBackground"), df(a) && s.classList.add("guifierOddBackground"), s.dataset.elementIndex = `${a}`;
    });
  }
  /**
   * This function is responsible for getting all the ArrayFieldContainers
   */
  getArrayFieldContainers() {
    const r = [];
    for (let s = 0; s < this.contentBody.children.length; s++)
      this.contentBody.children[s].classList.contains("guifierArrayFieldContainer") && r.push(this.contentBody.children[s]);
    return r;
  }
};
let Hn = Is;
/**
 * this is name of the field internaly
 */
B(Hn, "fieldName", "array"), B(Hn, "fieldLabelName", "Array"), /**
 * this is the icon thats shown for users
 */
B(Hn, "fieldIcon", "data_array");
const Zw = Qo.extend({}), al = class extends kt {
  constructor() {
    super(...arguments);
    /**
     * The localParam property is the this.property._params of this field
     */
    B(this, "localParam", Zw.parse(this.property._params));
  }
  /**
   * This function validates the _params of the property object
   */
  validateParams() {
  }
  /**
   * This function validates the _rules of the property object
   */
  validateRules() {
  }
  /**
   * This function validates the _rules of the property object
   */
  getFieldLabelName() {
    return al.fieldLabelName;
  }
  /**
   * this function is responsible for drawing the text field HTMLElement
   *
   * @returns {HTMLElement} html element object
   */
  draw() {
    const r = document.createElement("input");
    return r.type = "text", r.classList.add("guifierTextField"), this.property._value !== "" && (r.value = this.property._value), r.placeholder = "Text Field", this.showSecondaryColors ? r.classList.add("guifierPrimaryBgColor") : r.classList.add("guifierSecondaryBgColor"), r.addEventListener("input", (s) => {
      this.inputEventHandler(s);
    }), r;
  }
  /**
   * This function handles the input event on the text field
   */
  inputEventHandler(r) {
    const s = r.target;
    this.setValue(s.value);
  }
};
let Zn = al;
/**
 * this is name of the field internaly
 */
B(Zn, "fieldName", "text"), /**
 * this is shown name to the user
 */
B(Zn, "fieldLabelName", "Text"), /**
 * this is the icon thats shown for users
 */
B(Zn, "fieldIcon", "title");
const ol = class extends kt {
  constructor() {
    super(...arguments);
    /**
     * this property is an interval handler used to simulate
     * keeping pressing on the plus or minus buttons
     */
    B(this, "intervalId", 0);
  }
  /**
   * This function validates the _params of the property object
   */
  validateParams() {
  }
  /**
   * This function validates the _rules of the property object
   */
  validateRules() {
  }
  /**
   * This function validates the _rules of the property object
   */
  getFieldLabelName() {
    return ol.fieldLabelName;
  }
  /**
   * this function is responsible for drawing the text field HTMLElement
   *
   * @returns {HTMLElement} html element object
   */
  draw() {
    const r = document.createElement("div");
    r.classList.add("guifierNumberInputContainer");
    const s = document.createElement("input");
    s.type = "number", s.classList.add("guifierNumberField"), this.property._value !== "" && (s.value = this.property._value);
    const a = document.createElement("div");
    a.classList.add("guifierButtonsContainer");
    const l = document.createElement("div"), u = bt("keyboard_arrow_down");
    l.classList.add("guifierNumberButton"), l.append(u), l.addEventListener("mousedown", (g) => {
      g.button === 0 && this.keyDownInputButtonsEventHandler(s, !1);
    }), l.addEventListener("mouseup", () => {
      this.keyUpInputButtonsEventHandler();
    });
    const f = document.createElement("div"), d = bt("keyboard_arrow_up");
    return f.classList.add("guifierNumberButton"), f.append(d), f.addEventListener("mousedown", (g) => {
      g.button === 0 && this.keyDownInputButtonsEventHandler(s, !0);
    }), f.addEventListener("mouseup", () => {
      this.keyUpInputButtonsEventHandler();
    }), this.showSecondaryColors ? (l.classList.add("guifierPrimaryBgColor"), f.classList.add("guifierPrimaryBgColor")) : (l.classList.add("guifierSecondaryBgColor"), f.classList.add("guifierSecondaryBgColor")), a.append(l), a.append(f), r.append(s), r.append(a), s.addEventListener("input", () => {
      this.inputEventHandler(s);
    }), this.showSecondaryColors ? s.classList.add("guifierPrimaryBgColor") : s.classList.add("guifierSecondaryBgColor"), r;
  }
  /**
   * This function handles the input event on the text field
   */
  inputEventHandler(r) {
    this.setValue(parseFloat(r.value));
  }
  /**
   * This function handles the click event on the minus and plus buttons
   */
  keyDownInputButtonsEventHandler(r, s) {
    clearInterval(this.intervalId), r.value === "" && (r.value = "0"), s ? (r.value = (parseFloat(r.value) + 1).toString(), this.intervalId = setInterval(() => {
      r.value = (parseFloat(r.value) + 1).toString();
    }, 100)) : (r.value = (parseFloat(r.value) - 1).toString(), this.intervalId = setInterval(() => {
      r.value = (parseFloat(r.value) - 1).toString();
    }, 100)), this.setValue(parseFloat(r.value));
  }
  /**
   * This function handles the key up even that will stop the interval from running
   */
  keyUpInputButtonsEventHandler() {
    clearInterval(this.intervalId);
  }
};
let Vn = ol;
/**
 * this is name of the field internaly
 */
B(Vn, "fieldName", "number"), B(Vn, "fieldLabelName", "Number"), /**
 * this is the icon thats shown for users
 */
B(Vn, "fieldIcon", "numbers");
const ll = class extends kt {
  /**
   * This function validates the _params of the property object
   */
  validateParams() {
  }
  /**
   * This function validates the _rules of the property object
   */
  validateRules() {
  }
  /**
   * This function validates the _rules of the property object
   */
  getFieldLabelName() {
    return ll.fieldLabelName;
  }
  /**
   * this function is responsible for drawing the Boolean field HTMLElement
   *
   * @returns {HTMLElement} html element object
   */
  draw() {
    const t = document.createElement("div");
    t.classList.add("guifierBooleanField");
    const r = document.createElement("div");
    r.classList.add("guifierBooleanElement"), r.classList.add("guifierBooleanTrueElement"), r.innerHTML = "True", t.append(r);
    const s = document.createElement("div");
    return s.classList.add("guifierBooleanElement"), s.classList.add("guifierBooleanFalseElement"), s.innerHTML = "False", t.append(s), this.property._value === !0 ? r.classList.add("guifierBooleanTrueElementSelect") : s.classList.add("guifierBooleanFalseElementSelect"), this.showSecondaryColors ? t.classList.add("guifierPrimaryBgColor") : t.classList.add("guifierSecondaryBgColor"), t.addEventListener("click", (a) => {
      this.booleanEventHandler(a, r, s);
    }), t;
  }
  /**
   * this function is responsible handling the event when you click on the boolean field
   */
  booleanEventHandler(t, r, s) {
    const a = t.target;
    a.classList.contains("guifierBooleanTrueElement") ? (r.classList.add("guifierBooleanTrueElementSelect"), s.classList.remove("guifierBooleanFalseElementSelect"), this.setValue(!0)) : a.classList.contains("guifierBooleanFalseElement") && (s.classList.add("guifierBooleanFalseElementSelect"), r.classList.remove("guifierBooleanTrueElementSelect"), this.setValue(!1));
  }
};
let jn = ll;
/**
 * this is name of the field internaly
 */
B(jn, "fieldName", "boolean"), B(jn, "fieldLabelName", "Boolean"), /**
 * this is the icon thats shown for users
 */
B(jn, "fieldIcon", "check_box");
const ul = class extends kt {
  /**
   * This function validates the _params of the property object
   */
  validateParams() {
  }
  /**
   * This function validates the _rules of the property object
   */
  validateRules() {
  }
  /**
   * This function validates the _rules of the property object
   */
  getFieldLabelName() {
    return ul.fieldLabelName;
  }
  /**
   * this function is responsible for drawing the text field HTMLElement
   *
   * @returns {HTMLElement} html element object
   */
  draw() {
    const t = document.createElement("div");
    t.classList.add("guifierNullField");
    const r = document.createElement("div");
    r.classList.add("guifierNullFieldText"), r.innerHTML = "Null", t.append(r);
    const s = bt("block");
    return t.append(s), t;
  }
};
let Gn = ul;
/**
 * this is name of the field internaly
 */
B(Gn, "fieldName", "null"), B(Gn, "fieldLabelName", "Null"), /**
 * this is the icon thats shown for users
 */
B(Gn, "fieldIcon", "block");
const Vw = zo({
  icon: Kn(),
  text: Kn(),
  value: Kn()
}), jw = Qo.extend({
  cards: aw(Vw)
}), cl = class extends kt {
  constructor() {
    super(...arguments);
    /**
     * The localParam property is the this.property._params of this field
     */
    B(this, "localParam", jw.parse(this.property._params));
  }
  /**
   * This function validates the _params of the property object
   */
  validateParams() {
  }
  /**
   * This function validates the _rules of the property object
   */
  validateRules() {
  }
  /**
   * This function validates the _rules of the property object
   */
  getFieldLabelName() {
    return cl.fieldLabelName;
  }
  /**
   * this function is responsible for drawing the text field HTMLElement
   *
   * @returns {HTMLElement} html element object
   */
  draw() {
    const r = document.createElement("div");
    r.classList.add("guifierCardsContainer");
    for (let s = 0; s < this.localParam.cards.length; s++) {
      const a = this.localParam.cards[s], l = document.createElement("div");
      l.classList.add("guifierCard"), l.addEventListener("click", () => {
        this.cardClickHandler(l, r, a);
      }), r.append(l);
      const u = document.createElement("div");
      u.classList.add("cardIconElement"), u.append(bt(a.icon)), l.append(u);
      const f = document.createElement("div");
      f.classList.add("cardTextElement"), f.innerHTML = a.text, l.append(f);
    }
    return r;
  }
  /**
   * this function is responsible for handling the click on the cards
   */
  cardClickHandler(r, s, a) {
    this.selectCard(r, s, a);
  }
  /**
   * this function is responsible for selecting one of the cards
   */
  selectCard(r, s, a) {
    const l = s.querySelectorAll(".guifierCard");
    for (let u = 0; u < l.length; u++)
      l[u].classList.remove("guifierSelectedCard");
    r.classList.add("guifierSelectedCard"), this.setValue(a.value);
  }
};
let Yn = cl;
/**
 * this is name of the field internaly
 */
B(Yn, "fieldName", "cardSelect"), /**
 * this is the label name thats shown for users
 */
B(Yn, "fieldLabelName", "Card Select"), /**
 * this the flag that determens if the field is Base or a CustomField
 */
B(Yn, "isBaseField", !1);
const fl = class extends kt {
  /**
   * This function validates the _params of the property object
   */
  validateParams() {
  }
  /**
   * This function validates the _rules of the property object
   */
  validateRules() {
  }
  /**
   * This function validates the _rules of the property object
   */
  getFieldLabelName() {
    return fl.fieldLabelName;
  }
  /**
   * this function is responsible for drawing the Boolean field HTMLElement
   *
   * @returns {HTMLElement} html element object
   */
  draw() {
    const t = document.createElement("input");
    t.type = "date", t.classList.add("guifierTextField");
    const r = this.property._value.toISOString().split("T")[0];
    return t.value = r, t.placeholder = "Text Field", this.showSecondaryColors ? t.classList.add("guifierPrimaryBgColor") : t.classList.add("guifierSecondaryBgColor"), t.addEventListener("input", (s) => {
      this.inputEventHandler(s);
    }), t;
  }
  /**
   * This function handles the input event on the text field
   */
  inputEventHandler(t) {
    const r = t.target;
    this.setValue(new Date(r.value));
  }
};
let qn = fl;
/**
 * this is name of the field internaly
 */
B(qn, "fieldName", "date"), B(qn, "fieldLabelName", "Date"), /**
 * this is the icon thats shown for users
 */
B(qn, "fieldIcon", "calendar_month");
function df(e) {
  return e % 2 !== 0;
}
function wt(e) {
  const t = typeof e;
  return t === Ne.Object ? Array.isArray(e) ? Ne.Array : Ie.isDate(e) ? Ne.Date : e === null ? Ne.Null : Ne.Object : t === "number" && isNaN(e) ? Ne.NaN : t;
}
function Gw(e, t) {
  return {
    ...e,
    ...Object.fromEntries(Object.entries(t).filter(([r]) => !(r in e)))
  };
}
const kr = {
  text: {
    staticObject: Zn,
    defaultValue: "",
    getInstantiatedObject: (e, t, r) => new Zn(e, t, r)
  },
  number: {
    staticObject: Vn,
    defaultValue: 0,
    getInstantiatedObject: (e, t, r) => new Vn(e, t, r)
  },
  boolean: {
    staticObject: jn,
    defaultValue: !0,
    getInstantiatedObject: (e, t, r) => new jn(e, t, r)
  },
  null: {
    staticObject: Gn,
    defaultValue: null,
    getInstantiatedObject: (e, t, r) => new Gn(e, t, r)
  },
  object: {
    staticObject: xn,
    defaultValue: {},
    getInstantiatedObject: (e, t, r) => new xn(e, t, r)
  },
  array: {
    staticObject: Hn,
    defaultValue: [],
    getInstantiatedObject: (e, t, r) => new Hn(e, t, r)
  },
  cardSelect: {
    staticObject: Yn,
    defaultValue: "",
    getInstantiatedObject: (e, t, r) => new Yn(e, t, r)
  },
  date: {
    staticObject: qn,
    defaultValue: /* @__PURE__ */ new Date(),
    getInstantiatedObject: (e, t, r) => new qn(e, t, r)
  }
};
function As(e) {
  return Ie.cloneDeep(kr[e].defaultValue);
}
function el(e, t, r) {
  if (e._fieldType !== void 0)
    return kr[e._fieldType].getInstantiatedObject(e, t, r);
  throw new Error("property._fieldType is undefined");
}
function bt(e) {
  const t = document.createElement("span");
  return t.classList.add("material-icons-outlined"), t.innerHTML = e, t;
}
function Xf() {
  const e = document.createElement("div");
  return e.classList.add("guifierDescriptionSymbol"), e.append("!"), e;
}
function Jf(e, t) {
  const r = document.createElement("div");
  r.classList.add("guifierDescriptionTooltip"), r.insertAdjacentHTML("afterbegin", `
        <div class="descriptionHeader">
            <div class="guifierDescriptionSymbol">!</div>
            <div>
                ${e.keyName}
                <span class="descriptionFieldType">(${e.getFieldLabelName()})</span>
            </div>
        </div>
        <div class="descriptionBody">${e.property._params.description}</div>
    `), t.append(r);
  const s = document.createElement("div");
  s.classList.add("descriptionTooltipRefrence"), t.append(s);
  let a = 0;
  t.addEventListener("mouseenter", () => {
    clearTimeout(a), Hw(s, r, {
      placement: "top",
      middleware: [bw(15), Uw(), Ww()]
    }).then(({ x: l, y: u }) => {
      Object.assign(r.style, {
        left: `${l}px`,
        top: `${u}px`
      });
    }).then(() => {
    }).catch((l) => {
      console.log("ERROR: from positioning"), console.log(l);
    });
  }), t.addEventListener("mouseleave", () => {
    a = setTimeout(() => {
      r.removeAttribute("style");
    }, 250);
  });
}
function hf(e) {
  switch (e) {
    case "string":
      return "text";
    case "number":
      return "number";
    case "boolean":
      return "boolean";
    case "object":
      return "object";
    case "array":
      return "array";
    case "null":
      return "null";
    case "undefined":
      return "undefined";
    case "NaN":
      return "null";
    case "Date":
      return "date";
    default:
      throw new Error("value type is not supported");
  }
}
/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
function Qf(e) {
  return typeof e > "u" || e === null;
}
function Yw(e) {
  return typeof e == "object" && e !== null;
}
function qw(e) {
  return Array.isArray(e) ? e : Qf(e) ? [] : [e];
}
function zw(e, t) {
  var r, s, a, l;
  if (t)
    for (l = Object.keys(t), r = 0, s = l.length; r < s; r += 1)
      a = l[r], e[a] = t[a];
  return e;
}
function Kw(e, t) {
  var r = "", s;
  for (s = 0; s < t; s += 1)
    r += e;
  return r;
}
function Xw(e) {
  return e === 0 && Number.NEGATIVE_INFINITY === 1 / e;
}
var Jw = Qf, Qw = Yw, e1 = qw, t1 = Kw, n1 = Xw, r1 = zw, ke = {
  isNothing: Jw,
  isObject: Qw,
  toArray: e1,
  repeat: t1,
  isNegativeZero: n1,
  extend: r1
};
function ed(e, t) {
  var r = "", s = e.reason || "(unknown reason)";
  return e.mark ? (e.mark.name && (r += 'in "' + e.mark.name + '" '), r += "(" + (e.mark.line + 1) + ":" + (e.mark.column + 1) + ")", !t && e.mark.snippet && (r += `

` + e.mark.snippet), s + " " + r) : s;
}
function ui(e, t) {
  Error.call(this), this.name = "YAMLException", this.reason = e, this.mark = t, this.message = ed(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
ui.prototype = Object.create(Error.prototype);
ui.prototype.constructor = ui;
ui.prototype.toString = function(t) {
  return this.name + ": " + ed(this, t);
};
var tt = ui;
function uo(e, t, r, s, a) {
  var l = "", u = "", f = Math.floor(a / 2) - 1;
  return s - t > f && (l = " ... ", t = s - f + l.length), r - s > f && (u = " ...", r = s + f - u.length), {
    str: l + e.slice(t, r).replace(/\t/g, "") + u,
    pos: s - t + l.length
    // relative position
  };
}
function co(e, t) {
  return ke.repeat(" ", t - e.length) + e;
}
function i1(e, t) {
  if (t = Object.create(t || null), !e.buffer)
    return null;
  t.maxLength || (t.maxLength = 79), typeof t.indent != "number" && (t.indent = 1), typeof t.linesBefore != "number" && (t.linesBefore = 3), typeof t.linesAfter != "number" && (t.linesAfter = 2);
  for (var r = /\r?\n|\r|\0/g, s = [0], a = [], l, u = -1; l = r.exec(e.buffer); )
    a.push(l.index), s.push(l.index + l[0].length), e.position <= l.index && u < 0 && (u = s.length - 2);
  u < 0 && (u = s.length - 1);
  var f = "", d, g, _ = Math.min(e.line + t.linesAfter, a.length).toString().length, x = t.maxLength - (t.indent + _ + 3);
  for (d = 1; d <= t.linesBefore && !(u - d < 0); d++)
    g = uo(
      e.buffer,
      s[u - d],
      a[u - d],
      e.position - (s[u] - s[u - d]),
      x
    ), f = ke.repeat(" ", t.indent) + co((e.line - d + 1).toString(), _) + " | " + g.str + `
` + f;
  for (g = uo(e.buffer, s[u], a[u], e.position, x), f += ke.repeat(" ", t.indent) + co((e.line + 1).toString(), _) + " | " + g.str + `
`, f += ke.repeat("-", t.indent + _ + 3 + g.pos) + `^
`, d = 1; d <= t.linesAfter && !(u + d >= a.length); d++)
    g = uo(
      e.buffer,
      s[u + d],
      a[u + d],
      e.position - (s[u] - s[u + d]),
      x
    ), f += ke.repeat(" ", t.indent) + co((e.line + d + 1).toString(), _) + " | " + g.str + `
`;
  return f.replace(/\n$/, "");
}
var s1 = i1, a1 = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
], o1 = [
  "scalar",
  "sequence",
  "mapping"
];
function l1(e) {
  var t = {};
  return e !== null && Object.keys(e).forEach(function(r) {
    e[r].forEach(function(s) {
      t[String(s)] = r;
    });
  }), t;
}
function u1(e, t) {
  if (t = t || {}, Object.keys(t).forEach(function(r) {
    if (a1.indexOf(r) === -1)
      throw new tt('Unknown option "' + r + '" is met in definition of "' + e + '" YAML type.');
  }), this.options = t, this.tag = e, this.kind = t.kind || null, this.resolve = t.resolve || function() {
    return !0;
  }, this.construct = t.construct || function(r) {
    return r;
  }, this.instanceOf = t.instanceOf || null, this.predicate = t.predicate || null, this.represent = t.represent || null, this.representName = t.representName || null, this.defaultStyle = t.defaultStyle || null, this.multi = t.multi || !1, this.styleAliases = l1(t.styleAliases || null), o1.indexOf(this.kind) === -1)
    throw new tt('Unknown kind "' + this.kind + '" is specified for "' + e + '" YAML type.');
}
var Ue = u1;
function pf(e, t) {
  var r = [];
  return e[t].forEach(function(s) {
    var a = r.length;
    r.forEach(function(l, u) {
      l.tag === s.tag && l.kind === s.kind && l.multi === s.multi && (a = u);
    }), r[a] = s;
  }), r;
}
function c1() {
  var e = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, t, r;
  function s(a) {
    a.multi ? (e.multi[a.kind].push(a), e.multi.fallback.push(a)) : e[a.kind][a.tag] = e.fallback[a.tag] = a;
  }
  for (t = 0, r = arguments.length; t < r; t += 1)
    arguments[t].forEach(s);
  return e;
}
function Io(e) {
  return this.extend(e);
}
Io.prototype.extend = function(t) {
  var r = [], s = [];
  if (t instanceof Ue)
    s.push(t);
  else if (Array.isArray(t))
    s = s.concat(t);
  else if (t && (Array.isArray(t.implicit) || Array.isArray(t.explicit)))
    t.implicit && (r = r.concat(t.implicit)), t.explicit && (s = s.concat(t.explicit));
  else
    throw new tt("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  r.forEach(function(l) {
    if (!(l instanceof Ue))
      throw new tt("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (l.loadKind && l.loadKind !== "scalar")
      throw new tt("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (l.multi)
      throw new tt("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }), s.forEach(function(l) {
    if (!(l instanceof Ue))
      throw new tt("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  });
  var a = Object.create(Io.prototype);
  return a.implicit = (this.implicit || []).concat(r), a.explicit = (this.explicit || []).concat(s), a.compiledImplicit = pf(a, "implicit"), a.compiledExplicit = pf(a, "explicit"), a.compiledTypeMap = c1(a.compiledImplicit, a.compiledExplicit), a;
};
var f1 = Io, d1 = new Ue("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(e) {
    return e !== null ? e : "";
  }
}), h1 = new Ue("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(e) {
    return e !== null ? e : [];
  }
}), p1 = new Ue("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(e) {
    return e !== null ? e : {};
  }
}), g1 = new f1({
  explicit: [
    d1,
    h1,
    p1
  ]
});
function m1(e) {
  if (e === null)
    return !0;
  var t = e.length;
  return t === 1 && e === "~" || t === 4 && (e === "null" || e === "Null" || e === "NULL");
}
function v1() {
  return null;
}
function y1(e) {
  return e === null;
}
var _1 = new Ue("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: m1,
  construct: v1,
  predicate: y1,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function x1(e) {
  if (e === null)
    return !1;
  var t = e.length;
  return t === 4 && (e === "true" || e === "True" || e === "TRUE") || t === 5 && (e === "false" || e === "False" || e === "FALSE");
}
function w1(e) {
  return e === "true" || e === "True" || e === "TRUE";
}
function b1(e) {
  return Object.prototype.toString.call(e) === "[object Boolean]";
}
var E1 = new Ue("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: x1,
  construct: w1,
  predicate: b1,
  represent: {
    lowercase: function(e) {
      return e ? "true" : "false";
    },
    uppercase: function(e) {
      return e ? "TRUE" : "FALSE";
    },
    camelcase: function(e) {
      return e ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function A1(e) {
  return 48 <= e && e <= 57 || 65 <= e && e <= 70 || 97 <= e && e <= 102;
}
function C1(e) {
  return 48 <= e && e <= 55;
}
function T1(e) {
  return 48 <= e && e <= 57;
}
function S1(e) {
  if (e === null)
    return !1;
  var t = e.length, r = 0, s = !1, a;
  if (!t)
    return !1;
  if (a = e[r], (a === "-" || a === "+") && (a = e[++r]), a === "0") {
    if (r + 1 === t)
      return !0;
    if (a = e[++r], a === "b") {
      for (r++; r < t; r++)
        if (a = e[r], a !== "_") {
          if (a !== "0" && a !== "1")
            return !1;
          s = !0;
        }
      return s && a !== "_";
    }
    if (a === "x") {
      for (r++; r < t; r++)
        if (a = e[r], a !== "_") {
          if (!A1(e.charCodeAt(r)))
            return !1;
          s = !0;
        }
      return s && a !== "_";
    }
    if (a === "o") {
      for (r++; r < t; r++)
        if (a = e[r], a !== "_") {
          if (!C1(e.charCodeAt(r)))
            return !1;
          s = !0;
        }
      return s && a !== "_";
    }
  }
  if (a === "_")
    return !1;
  for (; r < t; r++)
    if (a = e[r], a !== "_") {
      if (!T1(e.charCodeAt(r)))
        return !1;
      s = !0;
    }
  return !(!s || a === "_");
}
function L1(e) {
  var t = e, r = 1, s;
  if (t.indexOf("_") !== -1 && (t = t.replace(/_/g, "")), s = t[0], (s === "-" || s === "+") && (s === "-" && (r = -1), t = t.slice(1), s = t[0]), t === "0")
    return 0;
  if (s === "0") {
    if (t[1] === "b")
      return r * parseInt(t.slice(2), 2);
    if (t[1] === "x")
      return r * parseInt(t.slice(2), 16);
    if (t[1] === "o")
      return r * parseInt(t.slice(2), 8);
  }
  return r * parseInt(t, 10);
}
function O1(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && e % 1 === 0 && !ke.isNegativeZero(e);
}
var N1 = new Ue("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: S1,
  construct: L1,
  predicate: O1,
  represent: {
    binary: function(e) {
      return e >= 0 ? "0b" + e.toString(2) : "-0b" + e.toString(2).slice(1);
    },
    octal: function(e) {
      return e >= 0 ? "0o" + e.toString(8) : "-0o" + e.toString(8).slice(1);
    },
    decimal: function(e) {
      return e.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(e) {
      return e >= 0 ? "0x" + e.toString(16).toUpperCase() : "-0x" + e.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
}), I1 = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function k1(e) {
  return !(e === null || !I1.test(e) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  e[e.length - 1] === "_");
}
function R1(e) {
  var t, r;
  return t = e.replace(/_/g, "").toLowerCase(), r = t[0] === "-" ? -1 : 1, "+-".indexOf(t[0]) >= 0 && (t = t.slice(1)), t === ".inf" ? r === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : t === ".nan" ? NaN : r * parseFloat(t, 10);
}
var P1 = /^[-+]?[0-9]+e/;
function F1(e, t) {
  var r;
  if (isNaN(e))
    switch (t) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (ke.isNegativeZero(e))
    return "-0.0";
  return r = e.toString(10), P1.test(r) ? r.replace("e", ".e") : r;
}
function B1(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && (e % 1 !== 0 || ke.isNegativeZero(e));
}
var M1 = new Ue("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: k1,
  construct: R1,
  predicate: B1,
  represent: F1,
  defaultStyle: "lowercase"
}), $1 = g1.extend({
  implicit: [
    _1,
    E1,
    N1,
    M1
  ]
}), D1 = $1, td = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
), nd = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function W1(e) {
  return e === null ? !1 : td.exec(e) !== null || nd.exec(e) !== null;
}
function U1(e) {
  var t, r, s, a, l, u, f, d = 0, g = null, _, x, T;
  if (t = td.exec(e), t === null && (t = nd.exec(e)), t === null)
    throw new Error("Date resolve error");
  if (r = +t[1], s = +t[2] - 1, a = +t[3], !t[4])
    return new Date(Date.UTC(r, s, a));
  if (l = +t[4], u = +t[5], f = +t[6], t[7]) {
    for (d = t[7].slice(0, 3); d.length < 3; )
      d += "0";
    d = +d;
  }
  return t[9] && (_ = +t[10], x = +(t[11] || 0), g = (_ * 60 + x) * 6e4, t[9] === "-" && (g = -g)), T = new Date(Date.UTC(r, s, a, l, u, f, d)), g && T.setTime(T.getTime() - g), T;
}
function H1(e) {
  return e.toISOString();
}
var Z1 = new Ue("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: W1,
  construct: U1,
  instanceOf: Date,
  represent: H1
});
function V1(e) {
  return e === "<<" || e === null;
}
var j1 = new Ue("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: V1
}), tl = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function G1(e) {
  if (e === null)
    return !1;
  var t, r, s = 0, a = e.length, l = tl;
  for (r = 0; r < a; r++)
    if (t = l.indexOf(e.charAt(r)), !(t > 64)) {
      if (t < 0)
        return !1;
      s += 6;
    }
  return s % 8 === 0;
}
function Y1(e) {
  var t, r, s = e.replace(/[\r\n=]/g, ""), a = s.length, l = tl, u = 0, f = [];
  for (t = 0; t < a; t++)
    t % 4 === 0 && t && (f.push(u >> 16 & 255), f.push(u >> 8 & 255), f.push(u & 255)), u = u << 6 | l.indexOf(s.charAt(t));
  return r = a % 4 * 6, r === 0 ? (f.push(u >> 16 & 255), f.push(u >> 8 & 255), f.push(u & 255)) : r === 18 ? (f.push(u >> 10 & 255), f.push(u >> 2 & 255)) : r === 12 && f.push(u >> 4 & 255), new Uint8Array(f);
}
function q1(e) {
  var t = "", r = 0, s, a, l = e.length, u = tl;
  for (s = 0; s < l; s++)
    s % 3 === 0 && s && (t += u[r >> 18 & 63], t += u[r >> 12 & 63], t += u[r >> 6 & 63], t += u[r & 63]), r = (r << 8) + e[s];
  return a = l % 3, a === 0 ? (t += u[r >> 18 & 63], t += u[r >> 12 & 63], t += u[r >> 6 & 63], t += u[r & 63]) : a === 2 ? (t += u[r >> 10 & 63], t += u[r >> 4 & 63], t += u[r << 2 & 63], t += u[64]) : a === 1 && (t += u[r >> 2 & 63], t += u[r << 4 & 63], t += u[64], t += u[64]), t;
}
function z1(e) {
  return Object.prototype.toString.call(e) === "[object Uint8Array]";
}
var K1 = new Ue("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: G1,
  construct: Y1,
  predicate: z1,
  represent: q1
}), X1 = Object.prototype.hasOwnProperty, J1 = Object.prototype.toString;
function Q1(e) {
  if (e === null)
    return !0;
  var t = [], r, s, a, l, u, f = e;
  for (r = 0, s = f.length; r < s; r += 1) {
    if (a = f[r], u = !1, J1.call(a) !== "[object Object]")
      return !1;
    for (l in a)
      if (X1.call(a, l))
        if (!u)
          u = !0;
        else
          return !1;
    if (!u)
      return !1;
    if (t.indexOf(l) === -1)
      t.push(l);
    else
      return !1;
  }
  return !0;
}
function eb(e) {
  return e !== null ? e : [];
}
var tb = new Ue("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: Q1,
  construct: eb
}), nb = Object.prototype.toString;
function rb(e) {
  if (e === null)
    return !0;
  var t, r, s, a, l, u = e;
  for (l = new Array(u.length), t = 0, r = u.length; t < r; t += 1) {
    if (s = u[t], nb.call(s) !== "[object Object]" || (a = Object.keys(s), a.length !== 1))
      return !1;
    l[t] = [a[0], s[a[0]]];
  }
  return !0;
}
function ib(e) {
  if (e === null)
    return [];
  var t, r, s, a, l, u = e;
  for (l = new Array(u.length), t = 0, r = u.length; t < r; t += 1)
    s = u[t], a = Object.keys(s), l[t] = [a[0], s[a[0]]];
  return l;
}
var sb = new Ue("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: rb,
  construct: ib
}), ab = Object.prototype.hasOwnProperty;
function ob(e) {
  if (e === null)
    return !0;
  var t, r = e;
  for (t in r)
    if (ab.call(r, t) && r[t] !== null)
      return !1;
  return !0;
}
function lb(e) {
  return e !== null ? e : {};
}
var ub = new Ue("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: ob,
  construct: lb
}), rd = D1.extend({
  implicit: [
    Z1,
    j1
  ],
  explicit: [
    K1,
    tb,
    sb,
    ub
  ]
}), Sn = Object.prototype.hasOwnProperty, Cs = 1, id = 2, sd = 3, Ts = 4, fo = 1, cb = 2, gf = 3, fb = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, db = /[\x85\u2028\u2029]/, hb = /[,\[\]\{\}]/, ad = /^(?:!|!!|![a-z\-]+!)$/i, od = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function mf(e) {
  return Object.prototype.toString.call(e);
}
function Ht(e) {
  return e === 10 || e === 13;
}
function Xn(e) {
  return e === 9 || e === 32;
}
function nt(e) {
  return e === 9 || e === 32 || e === 10 || e === 13;
}
function wr(e) {
  return e === 44 || e === 91 || e === 93 || e === 123 || e === 125;
}
function pb(e) {
  var t;
  return 48 <= e && e <= 57 ? e - 48 : (t = e | 32, 97 <= t && t <= 102 ? t - 97 + 10 : -1);
}
function gb(e) {
  return e === 120 ? 2 : e === 117 ? 4 : e === 85 ? 8 : 0;
}
function mb(e) {
  return 48 <= e && e <= 57 ? e - 48 : -1;
}
function vf(e) {
  return e === 48 ? "\0" : e === 97 ? "\x07" : e === 98 ? "\b" : e === 116 || e === 9 ? "	" : e === 110 ? `
` : e === 118 ? "\v" : e === 102 ? "\f" : e === 114 ? "\r" : e === 101 ? "\x1B" : e === 32 ? " " : e === 34 ? '"' : e === 47 ? "/" : e === 92 ? "\\" : e === 78 ? "" : e === 95 ? "" : e === 76 ? "\u2028" : e === 80 ? "\u2029" : "";
}
function vb(e) {
  return e <= 65535 ? String.fromCharCode(e) : String.fromCharCode(
    (e - 65536 >> 10) + 55296,
    (e - 65536 & 1023) + 56320
  );
}
var ld = new Array(256), ud = new Array(256);
for (var vr = 0; vr < 256; vr++)
  ld[vr] = vf(vr) ? 1 : 0, ud[vr] = vf(vr);
function yb(e, t) {
  this.input = e, this.filename = t.filename || null, this.schema = t.schema || rd, this.onWarning = t.onWarning || null, this.legacy = t.legacy || !1, this.json = t.json || !1, this.listener = t.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = e.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
}
function cd(e, t) {
  var r = {
    name: e.filename,
    buffer: e.input.slice(0, -1),
    // omit trailing \0
    position: e.position,
    line: e.line,
    column: e.position - e.lineStart
  };
  return r.snippet = s1(r), new tt(t, r);
}
function j(e, t) {
  throw cd(e, t);
}
function Ss(e, t) {
  e.onWarning && e.onWarning.call(null, cd(e, t));
}
var yf = {
  YAML: function(t, r, s) {
    var a, l, u;
    t.version !== null && j(t, "duplication of %YAML directive"), s.length !== 1 && j(t, "YAML directive accepts exactly one argument"), a = /^([0-9]+)\.([0-9]+)$/.exec(s[0]), a === null && j(t, "ill-formed argument of the YAML directive"), l = parseInt(a[1], 10), u = parseInt(a[2], 10), l !== 1 && j(t, "unacceptable YAML version of the document"), t.version = s[0], t.checkLineBreaks = u < 2, u !== 1 && u !== 2 && Ss(t, "unsupported YAML version of the document");
  },
  TAG: function(t, r, s) {
    var a, l;
    s.length !== 2 && j(t, "TAG directive accepts exactly two arguments"), a = s[0], l = s[1], ad.test(a) || j(t, "ill-formed tag handle (first argument) of the TAG directive"), Sn.call(t.tagMap, a) && j(t, 'there is a previously declared suffix for "' + a + '" tag handle'), od.test(l) || j(t, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      l = decodeURIComponent(l);
    } catch {
      j(t, "tag prefix is malformed: " + l);
    }
    t.tagMap[a] = l;
  }
};
function En(e, t, r, s) {
  var a, l, u, f;
  if (t < r) {
    if (f = e.input.slice(t, r), s)
      for (a = 0, l = f.length; a < l; a += 1)
        u = f.charCodeAt(a), u === 9 || 32 <= u && u <= 1114111 || j(e, "expected valid JSON character");
    else
      fb.test(f) && j(e, "the stream contains non-printable characters");
    e.result += f;
  }
}
function _f(e, t, r, s) {
  var a, l, u, f;
  for (ke.isObject(r) || j(e, "cannot merge mappings; the provided source object is unacceptable"), a = Object.keys(r), u = 0, f = a.length; u < f; u += 1)
    l = a[u], Sn.call(t, l) || (t[l] = r[l], s[l] = !0);
}
function br(e, t, r, s, a, l, u, f, d) {
  var g, _;
  if (Array.isArray(a))
    for (a = Array.prototype.slice.call(a), g = 0, _ = a.length; g < _; g += 1)
      Array.isArray(a[g]) && j(e, "nested arrays are not supported inside keys"), typeof a == "object" && mf(a[g]) === "[object Object]" && (a[g] = "[object Object]");
  if (typeof a == "object" && mf(a) === "[object Object]" && (a = "[object Object]"), a = String(a), t === null && (t = {}), s === "tag:yaml.org,2002:merge")
    if (Array.isArray(l))
      for (g = 0, _ = l.length; g < _; g += 1)
        _f(e, t, l[g], r);
    else
      _f(e, t, l, r);
  else
    !e.json && !Sn.call(r, a) && Sn.call(t, a) && (e.line = u || e.line, e.lineStart = f || e.lineStart, e.position = d || e.position, j(e, "duplicated mapping key")), a === "__proto__" ? Object.defineProperty(t, a, {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: l
    }) : t[a] = l, delete r[a];
  return t;
}
function nl(e) {
  var t;
  t = e.input.charCodeAt(e.position), t === 10 ? e.position++ : t === 13 ? (e.position++, e.input.charCodeAt(e.position) === 10 && e.position++) : j(e, "a line break is expected"), e.line += 1, e.lineStart = e.position, e.firstTabInLine = -1;
}
function Te(e, t, r) {
  for (var s = 0, a = e.input.charCodeAt(e.position); a !== 0; ) {
    for (; Xn(a); )
      a === 9 && e.firstTabInLine === -1 && (e.firstTabInLine = e.position), a = e.input.charCodeAt(++e.position);
    if (t && a === 35)
      do
        a = e.input.charCodeAt(++e.position);
      while (a !== 10 && a !== 13 && a !== 0);
    if (Ht(a))
      for (nl(e), a = e.input.charCodeAt(e.position), s++, e.lineIndent = 0; a === 32; )
        e.lineIndent++, a = e.input.charCodeAt(++e.position);
    else
      break;
  }
  return r !== -1 && s !== 0 && e.lineIndent < r && Ss(e, "deficient indentation"), s;
}
function Us(e) {
  var t = e.position, r;
  return r = e.input.charCodeAt(t), !!((r === 45 || r === 46) && r === e.input.charCodeAt(t + 1) && r === e.input.charCodeAt(t + 2) && (t += 3, r = e.input.charCodeAt(t), r === 0 || nt(r)));
}
function rl(e, t) {
  t === 1 ? e.result += " " : t > 1 && (e.result += ke.repeat(`
`, t - 1));
}
function _b(e, t, r) {
  var s, a, l, u, f, d, g, _, x = e.kind, T = e.result, A;
  if (A = e.input.charCodeAt(e.position), nt(A) || wr(A) || A === 35 || A === 38 || A === 42 || A === 33 || A === 124 || A === 62 || A === 39 || A === 34 || A === 37 || A === 64 || A === 96 || (A === 63 || A === 45) && (a = e.input.charCodeAt(e.position + 1), nt(a) || r && wr(a)))
    return !1;
  for (e.kind = "scalar", e.result = "", l = u = e.position, f = !1; A !== 0; ) {
    if (A === 58) {
      if (a = e.input.charCodeAt(e.position + 1), nt(a) || r && wr(a))
        break;
    } else if (A === 35) {
      if (s = e.input.charCodeAt(e.position - 1), nt(s))
        break;
    } else {
      if (e.position === e.lineStart && Us(e) || r && wr(A))
        break;
      if (Ht(A))
        if (d = e.line, g = e.lineStart, _ = e.lineIndent, Te(e, !1, -1), e.lineIndent >= t) {
          f = !0, A = e.input.charCodeAt(e.position);
          continue;
        } else {
          e.position = u, e.line = d, e.lineStart = g, e.lineIndent = _;
          break;
        }
    }
    f && (En(e, l, u, !1), rl(e, e.line - d), l = u = e.position, f = !1), Xn(A) || (u = e.position + 1), A = e.input.charCodeAt(++e.position);
  }
  return En(e, l, u, !1), e.result ? !0 : (e.kind = x, e.result = T, !1);
}
function xb(e, t) {
  var r, s, a;
  if (r = e.input.charCodeAt(e.position), r !== 39)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, s = a = e.position; (r = e.input.charCodeAt(e.position)) !== 0; )
    if (r === 39)
      if (En(e, s, e.position, !0), r = e.input.charCodeAt(++e.position), r === 39)
        s = e.position, e.position++, a = e.position;
      else
        return !0;
    else
      Ht(r) ? (En(e, s, a, !0), rl(e, Te(e, !1, t)), s = a = e.position) : e.position === e.lineStart && Us(e) ? j(e, "unexpected end of the document within a single quoted scalar") : (e.position++, a = e.position);
  j(e, "unexpected end of the stream within a single quoted scalar");
}
function wb(e, t) {
  var r, s, a, l, u, f;
  if (f = e.input.charCodeAt(e.position), f !== 34)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, r = s = e.position; (f = e.input.charCodeAt(e.position)) !== 0; ) {
    if (f === 34)
      return En(e, r, e.position, !0), e.position++, !0;
    if (f === 92) {
      if (En(e, r, e.position, !0), f = e.input.charCodeAt(++e.position), Ht(f))
        Te(e, !1, t);
      else if (f < 256 && ld[f])
        e.result += ud[f], e.position++;
      else if ((u = gb(f)) > 0) {
        for (a = u, l = 0; a > 0; a--)
          f = e.input.charCodeAt(++e.position), (u = pb(f)) >= 0 ? l = (l << 4) + u : j(e, "expected hexadecimal character");
        e.result += vb(l), e.position++;
      } else
        j(e, "unknown escape sequence");
      r = s = e.position;
    } else
      Ht(f) ? (En(e, r, s, !0), rl(e, Te(e, !1, t)), r = s = e.position) : e.position === e.lineStart && Us(e) ? j(e, "unexpected end of the document within a double quoted scalar") : (e.position++, s = e.position);
  }
  j(e, "unexpected end of the stream within a double quoted scalar");
}
function bb(e, t) {
  var r = !0, s, a, l, u = e.tag, f, d = e.anchor, g, _, x, T, A, C = /* @__PURE__ */ Object.create(null), E, P, U, H;
  if (H = e.input.charCodeAt(e.position), H === 91)
    _ = 93, A = !1, f = [];
  else if (H === 123)
    _ = 125, A = !0, f = {};
  else
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = f), H = e.input.charCodeAt(++e.position); H !== 0; ) {
    if (Te(e, !0, t), H = e.input.charCodeAt(e.position), H === _)
      return e.position++, e.tag = u, e.anchor = d, e.kind = A ? "mapping" : "sequence", e.result = f, !0;
    r ? H === 44 && j(e, "expected the node content, but found ','") : j(e, "missed comma between flow collection entries"), P = E = U = null, x = T = !1, H === 63 && (g = e.input.charCodeAt(e.position + 1), nt(g) && (x = T = !0, e.position++, Te(e, !0, t))), s = e.line, a = e.lineStart, l = e.position, Rr(e, t, Cs, !1, !0), P = e.tag, E = e.result, Te(e, !0, t), H = e.input.charCodeAt(e.position), (T || e.line === s) && H === 58 && (x = !0, H = e.input.charCodeAt(++e.position), Te(e, !0, t), Rr(e, t, Cs, !1, !0), U = e.result), A ? br(e, f, C, P, E, U, s, a, l) : x ? f.push(br(e, null, C, P, E, U, s, a, l)) : f.push(E), Te(e, !0, t), H = e.input.charCodeAt(e.position), H === 44 ? (r = !0, H = e.input.charCodeAt(++e.position)) : r = !1;
  }
  j(e, "unexpected end of the stream within a flow collection");
}
function Eb(e, t) {
  var r, s, a = fo, l = !1, u = !1, f = t, d = 0, g = !1, _, x;
  if (x = e.input.charCodeAt(e.position), x === 124)
    s = !1;
  else if (x === 62)
    s = !0;
  else
    return !1;
  for (e.kind = "scalar", e.result = ""; x !== 0; )
    if (x = e.input.charCodeAt(++e.position), x === 43 || x === 45)
      fo === a ? a = x === 43 ? gf : cb : j(e, "repeat of a chomping mode identifier");
    else if ((_ = mb(x)) >= 0)
      _ === 0 ? j(e, "bad explicit indentation width of a block scalar; it cannot be less than one") : u ? j(e, "repeat of an indentation width identifier") : (f = t + _ - 1, u = !0);
    else
      break;
  if (Xn(x)) {
    do
      x = e.input.charCodeAt(++e.position);
    while (Xn(x));
    if (x === 35)
      do
        x = e.input.charCodeAt(++e.position);
      while (!Ht(x) && x !== 0);
  }
  for (; x !== 0; ) {
    for (nl(e), e.lineIndent = 0, x = e.input.charCodeAt(e.position); (!u || e.lineIndent < f) && x === 32; )
      e.lineIndent++, x = e.input.charCodeAt(++e.position);
    if (!u && e.lineIndent > f && (f = e.lineIndent), Ht(x)) {
      d++;
      continue;
    }
    if (e.lineIndent < f) {
      a === gf ? e.result += ke.repeat(`
`, l ? 1 + d : d) : a === fo && l && (e.result += `
`);
      break;
    }
    for (s ? Xn(x) ? (g = !0, e.result += ke.repeat(`
`, l ? 1 + d : d)) : g ? (g = !1, e.result += ke.repeat(`
`, d + 1)) : d === 0 ? l && (e.result += " ") : e.result += ke.repeat(`
`, d) : e.result += ke.repeat(`
`, l ? 1 + d : d), l = !0, u = !0, d = 0, r = e.position; !Ht(x) && x !== 0; )
      x = e.input.charCodeAt(++e.position);
    En(e, r, e.position, !1);
  }
  return !0;
}
function xf(e, t) {
  var r, s = e.tag, a = e.anchor, l = [], u, f = !1, d;
  if (e.firstTabInLine !== -1)
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = l), d = e.input.charCodeAt(e.position); d !== 0 && (e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, j(e, "tab characters must not be used in indentation")), !(d !== 45 || (u = e.input.charCodeAt(e.position + 1), !nt(u)))); ) {
    if (f = !0, e.position++, Te(e, !0, -1) && e.lineIndent <= t) {
      l.push(null), d = e.input.charCodeAt(e.position);
      continue;
    }
    if (r = e.line, Rr(e, t, sd, !1, !0), l.push(e.result), Te(e, !0, -1), d = e.input.charCodeAt(e.position), (e.line === r || e.lineIndent > t) && d !== 0)
      j(e, "bad indentation of a sequence entry");
    else if (e.lineIndent < t)
      break;
  }
  return f ? (e.tag = s, e.anchor = a, e.kind = "sequence", e.result = l, !0) : !1;
}
function Ab(e, t, r) {
  var s, a, l, u, f, d, g = e.tag, _ = e.anchor, x = {}, T = /* @__PURE__ */ Object.create(null), A = null, C = null, E = null, P = !1, U = !1, H;
  if (e.firstTabInLine !== -1)
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = x), H = e.input.charCodeAt(e.position); H !== 0; ) {
    if (!P && e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, j(e, "tab characters must not be used in indentation")), s = e.input.charCodeAt(e.position + 1), l = e.line, (H === 63 || H === 58) && nt(s))
      H === 63 ? (P && (br(e, x, T, A, C, null, u, f, d), A = C = E = null), U = !0, P = !0, a = !0) : P ? (P = !1, a = !0) : j(e, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), e.position += 1, H = s;
    else {
      if (u = e.line, f = e.lineStart, d = e.position, !Rr(e, r, id, !1, !0))
        break;
      if (e.line === l) {
        for (H = e.input.charCodeAt(e.position); Xn(H); )
          H = e.input.charCodeAt(++e.position);
        if (H === 58)
          H = e.input.charCodeAt(++e.position), nt(H) || j(e, "a whitespace character is expected after the key-value separator within a block mapping"), P && (br(e, x, T, A, C, null, u, f, d), A = C = E = null), U = !0, P = !1, a = !1, A = e.tag, C = e.result;
        else if (U)
          j(e, "can not read an implicit mapping pair; a colon is missed");
        else
          return e.tag = g, e.anchor = _, !0;
      } else if (U)
        j(e, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return e.tag = g, e.anchor = _, !0;
    }
    if ((e.line === l || e.lineIndent > t) && (P && (u = e.line, f = e.lineStart, d = e.position), Rr(e, t, Ts, !0, a) && (P ? C = e.result : E = e.result), P || (br(e, x, T, A, C, E, u, f, d), A = C = E = null), Te(e, !0, -1), H = e.input.charCodeAt(e.position)), (e.line === l || e.lineIndent > t) && H !== 0)
      j(e, "bad indentation of a mapping entry");
    else if (e.lineIndent < t)
      break;
  }
  return P && br(e, x, T, A, C, null, u, f, d), U && (e.tag = g, e.anchor = _, e.kind = "mapping", e.result = x), U;
}
function Cb(e) {
  var t, r = !1, s = !1, a, l, u;
  if (u = e.input.charCodeAt(e.position), u !== 33)
    return !1;
  if (e.tag !== null && j(e, "duplication of a tag property"), u = e.input.charCodeAt(++e.position), u === 60 ? (r = !0, u = e.input.charCodeAt(++e.position)) : u === 33 ? (s = !0, a = "!!", u = e.input.charCodeAt(++e.position)) : a = "!", t = e.position, r) {
    do
      u = e.input.charCodeAt(++e.position);
    while (u !== 0 && u !== 62);
    e.position < e.length ? (l = e.input.slice(t, e.position), u = e.input.charCodeAt(++e.position)) : j(e, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; u !== 0 && !nt(u); )
      u === 33 && (s ? j(e, "tag suffix cannot contain exclamation marks") : (a = e.input.slice(t - 1, e.position + 1), ad.test(a) || j(e, "named tag handle cannot contain such characters"), s = !0, t = e.position + 1)), u = e.input.charCodeAt(++e.position);
    l = e.input.slice(t, e.position), hb.test(l) && j(e, "tag suffix cannot contain flow indicator characters");
  }
  l && !od.test(l) && j(e, "tag name cannot contain such characters: " + l);
  try {
    l = decodeURIComponent(l);
  } catch {
    j(e, "tag name is malformed: " + l);
  }
  return r ? e.tag = l : Sn.call(e.tagMap, a) ? e.tag = e.tagMap[a] + l : a === "!" ? e.tag = "!" + l : a === "!!" ? e.tag = "tag:yaml.org,2002:" + l : j(e, 'undeclared tag handle "' + a + '"'), !0;
}
function Tb(e) {
  var t, r;
  if (r = e.input.charCodeAt(e.position), r !== 38)
    return !1;
  for (e.anchor !== null && j(e, "duplication of an anchor property"), r = e.input.charCodeAt(++e.position), t = e.position; r !== 0 && !nt(r) && !wr(r); )
    r = e.input.charCodeAt(++e.position);
  return e.position === t && j(e, "name of an anchor node must contain at least one character"), e.anchor = e.input.slice(t, e.position), !0;
}
function Sb(e) {
  var t, r, s;
  if (s = e.input.charCodeAt(e.position), s !== 42)
    return !1;
  for (s = e.input.charCodeAt(++e.position), t = e.position; s !== 0 && !nt(s) && !wr(s); )
    s = e.input.charCodeAt(++e.position);
  return e.position === t && j(e, "name of an alias node must contain at least one character"), r = e.input.slice(t, e.position), Sn.call(e.anchorMap, r) || j(e, 'unidentified alias "' + r + '"'), e.result = e.anchorMap[r], Te(e, !0, -1), !0;
}
function Rr(e, t, r, s, a) {
  var l, u, f, d = 1, g = !1, _ = !1, x, T, A, C, E, P;
  if (e.listener !== null && e.listener("open", e), e.tag = null, e.anchor = null, e.kind = null, e.result = null, l = u = f = Ts === r || sd === r, s && Te(e, !0, -1) && (g = !0, e.lineIndent > t ? d = 1 : e.lineIndent === t ? d = 0 : e.lineIndent < t && (d = -1)), d === 1)
    for (; Cb(e) || Tb(e); )
      Te(e, !0, -1) ? (g = !0, f = l, e.lineIndent > t ? d = 1 : e.lineIndent === t ? d = 0 : e.lineIndent < t && (d = -1)) : f = !1;
  if (f && (f = g || a), (d === 1 || Ts === r) && (Cs === r || id === r ? E = t : E = t + 1, P = e.position - e.lineStart, d === 1 ? f && (xf(e, P) || Ab(e, P, E)) || bb(e, E) ? _ = !0 : (u && Eb(e, E) || xb(e, E) || wb(e, E) ? _ = !0 : Sb(e) ? (_ = !0, (e.tag !== null || e.anchor !== null) && j(e, "alias node should not have any properties")) : _b(e, E, Cs === r) && (_ = !0, e.tag === null && (e.tag = "?")), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : d === 0 && (_ = f && xf(e, P))), e.tag === null)
    e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
  else if (e.tag === "?") {
    for (e.result !== null && e.kind !== "scalar" && j(e, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + e.kind + '"'), x = 0, T = e.implicitTypes.length; x < T; x += 1)
      if (C = e.implicitTypes[x], C.resolve(e.result)) {
        e.result = C.construct(e.result), e.tag = C.tag, e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
        break;
      }
  } else if (e.tag !== "!") {
    if (Sn.call(e.typeMap[e.kind || "fallback"], e.tag))
      C = e.typeMap[e.kind || "fallback"][e.tag];
    else
      for (C = null, A = e.typeMap.multi[e.kind || "fallback"], x = 0, T = A.length; x < T; x += 1)
        if (e.tag.slice(0, A[x].tag.length) === A[x].tag) {
          C = A[x];
          break;
        }
    C || j(e, "unknown tag !<" + e.tag + ">"), e.result !== null && C.kind !== e.kind && j(e, "unacceptable node kind for !<" + e.tag + '> tag; it should be "' + C.kind + '", not "' + e.kind + '"'), C.resolve(e.result, e.tag) ? (e.result = C.construct(e.result, e.tag), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : j(e, "cannot resolve a node with !<" + e.tag + "> explicit tag");
  }
  return e.listener !== null && e.listener("close", e), e.tag !== null || e.anchor !== null || _;
}
function Lb(e) {
  var t = e.position, r, s, a, l = !1, u;
  for (e.version = null, e.checkLineBreaks = e.legacy, e.tagMap = /* @__PURE__ */ Object.create(null), e.anchorMap = /* @__PURE__ */ Object.create(null); (u = e.input.charCodeAt(e.position)) !== 0 && (Te(e, !0, -1), u = e.input.charCodeAt(e.position), !(e.lineIndent > 0 || u !== 37)); ) {
    for (l = !0, u = e.input.charCodeAt(++e.position), r = e.position; u !== 0 && !nt(u); )
      u = e.input.charCodeAt(++e.position);
    for (s = e.input.slice(r, e.position), a = [], s.length < 1 && j(e, "directive name must not be less than one character in length"); u !== 0; ) {
      for (; Xn(u); )
        u = e.input.charCodeAt(++e.position);
      if (u === 35) {
        do
          u = e.input.charCodeAt(++e.position);
        while (u !== 0 && !Ht(u));
        break;
      }
      if (Ht(u))
        break;
      for (r = e.position; u !== 0 && !nt(u); )
        u = e.input.charCodeAt(++e.position);
      a.push(e.input.slice(r, e.position));
    }
    u !== 0 && nl(e), Sn.call(yf, s) ? yf[s](e, s, a) : Ss(e, 'unknown document directive "' + s + '"');
  }
  if (Te(e, !0, -1), e.lineIndent === 0 && e.input.charCodeAt(e.position) === 45 && e.input.charCodeAt(e.position + 1) === 45 && e.input.charCodeAt(e.position + 2) === 45 ? (e.position += 3, Te(e, !0, -1)) : l && j(e, "directives end mark is expected"), Rr(e, e.lineIndent - 1, Ts, !1, !0), Te(e, !0, -1), e.checkLineBreaks && db.test(e.input.slice(t, e.position)) && Ss(e, "non-ASCII line breaks are interpreted as content"), e.documents.push(e.result), e.position === e.lineStart && Us(e)) {
    e.input.charCodeAt(e.position) === 46 && (e.position += 3, Te(e, !0, -1));
    return;
  }
  if (e.position < e.length - 1)
    j(e, "end of the stream or a document separator is expected");
  else
    return;
}
function fd(e, t) {
  e = String(e), t = t || {}, e.length !== 0 && (e.charCodeAt(e.length - 1) !== 10 && e.charCodeAt(e.length - 1) !== 13 && (e += `
`), e.charCodeAt(0) === 65279 && (e = e.slice(1)));
  var r = new yb(e, t), s = e.indexOf("\0");
  for (s !== -1 && (r.position = s, j(r, "null byte is not allowed in input")), r.input += "\0"; r.input.charCodeAt(r.position) === 32; )
    r.lineIndent += 1, r.position += 1;
  for (; r.position < r.length - 1; )
    Lb(r);
  return r.documents;
}
function Ob(e, t, r) {
  t !== null && typeof t == "object" && typeof r > "u" && (r = t, t = null);
  var s = fd(e, r);
  if (typeof t != "function")
    return s;
  for (var a = 0, l = s.length; a < l; a += 1)
    t(s[a]);
}
function Nb(e, t) {
  var r = fd(e, t);
  if (r.length !== 0) {
    if (r.length === 1)
      return r[0];
    throw new tt("expected a single document in the stream, but found more");
  }
}
var Ib = Ob, kb = Nb, Rb = {
  loadAll: Ib,
  load: kb
}, dd = Object.prototype.toString, hd = Object.prototype.hasOwnProperty, il = 65279, Pb = 9, ci = 10, Fb = 13, Bb = 32, Mb = 33, $b = 34, ko = 35, Db = 37, Wb = 38, Ub = 39, Hb = 42, pd = 44, Zb = 45, Ls = 58, Vb = 61, jb = 62, Gb = 63, Yb = 64, gd = 91, md = 93, qb = 96, vd = 123, zb = 124, yd = 125, He = {};
He[0] = "\\0";
He[7] = "\\a";
He[8] = "\\b";
He[9] = "\\t";
He[10] = "\\n";
He[11] = "\\v";
He[12] = "\\f";
He[13] = "\\r";
He[27] = "\\e";
He[34] = '\\"';
He[92] = "\\\\";
He[133] = "\\N";
He[160] = "\\_";
He[8232] = "\\L";
He[8233] = "\\P";
var Kb = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
], Xb = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function Jb(e, t) {
  var r, s, a, l, u, f, d;
  if (t === null)
    return {};
  for (r = {}, s = Object.keys(t), a = 0, l = s.length; a < l; a += 1)
    u = s[a], f = String(t[u]), u.slice(0, 2) === "!!" && (u = "tag:yaml.org,2002:" + u.slice(2)), d = e.compiledTypeMap.fallback[u], d && hd.call(d.styleAliases, f) && (f = d.styleAliases[f]), r[u] = f;
  return r;
}
function Qb(e) {
  var t, r, s;
  if (t = e.toString(16).toUpperCase(), e <= 255)
    r = "x", s = 2;
  else if (e <= 65535)
    r = "u", s = 4;
  else if (e <= 4294967295)
    r = "U", s = 8;
  else
    throw new tt("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + r + ke.repeat("0", s - t.length) + t;
}
var eE = 1, fi = 2;
function tE(e) {
  this.schema = e.schema || rd, this.indent = Math.max(1, e.indent || 2), this.noArrayIndent = e.noArrayIndent || !1, this.skipInvalid = e.skipInvalid || !1, this.flowLevel = ke.isNothing(e.flowLevel) ? -1 : e.flowLevel, this.styleMap = Jb(this.schema, e.styles || null), this.sortKeys = e.sortKeys || !1, this.lineWidth = e.lineWidth || 80, this.noRefs = e.noRefs || !1, this.noCompatMode = e.noCompatMode || !1, this.condenseFlow = e.condenseFlow || !1, this.quotingType = e.quotingType === '"' ? fi : eE, this.forceQuotes = e.forceQuotes || !1, this.replacer = typeof e.replacer == "function" ? e.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
function wf(e, t) {
  for (var r = ke.repeat(" ", t), s = 0, a = -1, l = "", u, f = e.length; s < f; )
    a = e.indexOf(`
`, s), a === -1 ? (u = e.slice(s), s = f) : (u = e.slice(s, a + 1), s = a + 1), u.length && u !== `
` && (l += r), l += u;
  return l;
}
function Ro(e, t) {
  return `
` + ke.repeat(" ", e.indent * t);
}
function nE(e, t) {
  var r, s, a;
  for (r = 0, s = e.implicitTypes.length; r < s; r += 1)
    if (a = e.implicitTypes[r], a.resolve(t))
      return !0;
  return !1;
}
function Os(e) {
  return e === Bb || e === Pb;
}
function di(e) {
  return 32 <= e && e <= 126 || 161 <= e && e <= 55295 && e !== 8232 && e !== 8233 || 57344 <= e && e <= 65533 && e !== il || 65536 <= e && e <= 1114111;
}
function bf(e) {
  return di(e) && e !== il && e !== Fb && e !== ci;
}
function Ef(e, t, r) {
  var s = bf(e), a = s && !Os(e);
  return (
    // ns-plain-safe
    (r ? (
      // c = flow-in
      s
    ) : s && e !== pd && e !== gd && e !== md && e !== vd && e !== yd) && e !== ko && !(t === Ls && !a) || bf(t) && !Os(t) && e === ko || t === Ls && a
  );
}
function rE(e) {
  return di(e) && e !== il && !Os(e) && e !== Zb && e !== Gb && e !== Ls && e !== pd && e !== gd && e !== md && e !== vd && e !== yd && e !== ko && e !== Wb && e !== Hb && e !== Mb && e !== zb && e !== Vb && e !== jb && e !== Ub && e !== $b && e !== Db && e !== Yb && e !== qb;
}
function iE(e) {
  return !Os(e) && e !== Ls;
}
function ii(e, t) {
  var r = e.charCodeAt(t), s;
  return r >= 55296 && r <= 56319 && t + 1 < e.length && (s = e.charCodeAt(t + 1), s >= 56320 && s <= 57343) ? (r - 55296) * 1024 + s - 56320 + 65536 : r;
}
function _d(e) {
  var t = /^\n* /;
  return t.test(e);
}
var xd = 1, Po = 2, wd = 3, bd = 4, xr = 5;
function sE(e, t, r, s, a, l, u, f) {
  var d, g = 0, _ = null, x = !1, T = !1, A = s !== -1, C = -1, E = rE(ii(e, 0)) && iE(ii(e, e.length - 1));
  if (t || u)
    for (d = 0; d < e.length; g >= 65536 ? d += 2 : d++) {
      if (g = ii(e, d), !di(g))
        return xr;
      E = E && Ef(g, _, f), _ = g;
    }
  else {
    for (d = 0; d < e.length; g >= 65536 ? d += 2 : d++) {
      if (g = ii(e, d), g === ci)
        x = !0, A && (T = T || // Foldable line = too long, and not more-indented.
        d - C - 1 > s && e[C + 1] !== " ", C = d);
      else if (!di(g))
        return xr;
      E = E && Ef(g, _, f), _ = g;
    }
    T = T || A && d - C - 1 > s && e[C + 1] !== " ";
  }
  return !x && !T ? E && !u && !a(e) ? xd : l === fi ? xr : Po : r > 9 && _d(e) ? xr : u ? l === fi ? xr : Po : T ? bd : wd;
}
function aE(e, t, r, s, a) {
  e.dump = function() {
    if (t.length === 0)
      return e.quotingType === fi ? '""' : "''";
    if (!e.noCompatMode && (Kb.indexOf(t) !== -1 || Xb.test(t)))
      return e.quotingType === fi ? '"' + t + '"' : "'" + t + "'";
    var l = e.indent * Math.max(1, r), u = e.lineWidth === -1 ? -1 : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - l), f = s || e.flowLevel > -1 && r >= e.flowLevel;
    function d(g) {
      return nE(e, g);
    }
    switch (sE(
      t,
      f,
      e.indent,
      u,
      d,
      e.quotingType,
      e.forceQuotes && !s,
      a
    )) {
      case xd:
        return t;
      case Po:
        return "'" + t.replace(/'/g, "''") + "'";
      case wd:
        return "|" + Af(t, e.indent) + Cf(wf(t, l));
      case bd:
        return ">" + Af(t, e.indent) + Cf(wf(oE(t, u), l));
      case xr:
        return '"' + lE(t) + '"';
      default:
        throw new tt("impossible error: invalid scalar style");
    }
  }();
}
function Af(e, t) {
  var r = _d(e) ? String(t) : "", s = e[e.length - 1] === `
`, a = s && (e[e.length - 2] === `
` || e === `
`), l = a ? "+" : s ? "" : "-";
  return r + l + `
`;
}
function Cf(e) {
  return e[e.length - 1] === `
` ? e.slice(0, -1) : e;
}
function oE(e, t) {
  for (var r = /(\n+)([^\n]*)/g, s = function() {
    var g = e.indexOf(`
`);
    return g = g !== -1 ? g : e.length, r.lastIndex = g, Tf(e.slice(0, g), t);
  }(), a = e[0] === `
` || e[0] === " ", l, u; u = r.exec(e); ) {
    var f = u[1], d = u[2];
    l = d[0] === " ", s += f + (!a && !l && d !== "" ? `
` : "") + Tf(d, t), a = l;
  }
  return s;
}
function Tf(e, t) {
  if (e === "" || e[0] === " ")
    return e;
  for (var r = / [^ ]/g, s, a = 0, l, u = 0, f = 0, d = ""; s = r.exec(e); )
    f = s.index, f - a > t && (l = u > a ? u : f, d += `
` + e.slice(a, l), a = l + 1), u = f;
  return d += `
`, e.length - a > t && u > a ? d += e.slice(a, u) + `
` + e.slice(u + 1) : d += e.slice(a), d.slice(1);
}
function lE(e) {
  for (var t = "", r = 0, s, a = 0; a < e.length; r >= 65536 ? a += 2 : a++)
    r = ii(e, a), s = He[r], !s && di(r) ? (t += e[a], r >= 65536 && (t += e[a + 1])) : t += s || Qb(r);
  return t;
}
function uE(e, t, r) {
  var s = "", a = e.tag, l, u, f;
  for (l = 0, u = r.length; l < u; l += 1)
    f = r[l], e.replacer && (f = e.replacer.call(r, String(l), f)), (un(e, t, f, !1, !1) || typeof f > "u" && un(e, t, null, !1, !1)) && (s !== "" && (s += "," + (e.condenseFlow ? "" : " ")), s += e.dump);
  e.tag = a, e.dump = "[" + s + "]";
}
function Sf(e, t, r, s) {
  var a = "", l = e.tag, u, f, d;
  for (u = 0, f = r.length; u < f; u += 1)
    d = r[u], e.replacer && (d = e.replacer.call(r, String(u), d)), (un(e, t + 1, d, !0, !0, !1, !0) || typeof d > "u" && un(e, t + 1, null, !0, !0, !1, !0)) && ((!s || a !== "") && (a += Ro(e, t)), e.dump && ci === e.dump.charCodeAt(0) ? a += "-" : a += "- ", a += e.dump);
  e.tag = l, e.dump = a || "[]";
}
function cE(e, t, r) {
  var s = "", a = e.tag, l = Object.keys(r), u, f, d, g, _;
  for (u = 0, f = l.length; u < f; u += 1)
    _ = "", s !== "" && (_ += ", "), e.condenseFlow && (_ += '"'), d = l[u], g = r[d], e.replacer && (g = e.replacer.call(r, d, g)), un(e, t, d, !1, !1) && (e.dump.length > 1024 && (_ += "? "), _ += e.dump + (e.condenseFlow ? '"' : "") + ":" + (e.condenseFlow ? "" : " "), un(e, t, g, !1, !1) && (_ += e.dump, s += _));
  e.tag = a, e.dump = "{" + s + "}";
}
function fE(e, t, r, s) {
  var a = "", l = e.tag, u = Object.keys(r), f, d, g, _, x, T;
  if (e.sortKeys === !0)
    u.sort();
  else if (typeof e.sortKeys == "function")
    u.sort(e.sortKeys);
  else if (e.sortKeys)
    throw new tt("sortKeys must be a boolean or a function");
  for (f = 0, d = u.length; f < d; f += 1)
    T = "", (!s || a !== "") && (T += Ro(e, t)), g = u[f], _ = r[g], e.replacer && (_ = e.replacer.call(r, g, _)), un(e, t + 1, g, !0, !0, !0) && (x = e.tag !== null && e.tag !== "?" || e.dump && e.dump.length > 1024, x && (e.dump && ci === e.dump.charCodeAt(0) ? T += "?" : T += "? "), T += e.dump, x && (T += Ro(e, t)), un(e, t + 1, _, !0, x) && (e.dump && ci === e.dump.charCodeAt(0) ? T += ":" : T += ": ", T += e.dump, a += T));
  e.tag = l, e.dump = a || "{}";
}
function Lf(e, t, r) {
  var s, a, l, u, f, d;
  for (a = r ? e.explicitTypes : e.implicitTypes, l = 0, u = a.length; l < u; l += 1)
    if (f = a[l], (f.instanceOf || f.predicate) && (!f.instanceOf || typeof t == "object" && t instanceof f.instanceOf) && (!f.predicate || f.predicate(t))) {
      if (r ? f.multi && f.representName ? e.tag = f.representName(t) : e.tag = f.tag : e.tag = "?", f.represent) {
        if (d = e.styleMap[f.tag] || f.defaultStyle, dd.call(f.represent) === "[object Function]")
          s = f.represent(t, d);
        else if (hd.call(f.represent, d))
          s = f.represent[d](t, d);
        else
          throw new tt("!<" + f.tag + '> tag resolver accepts not "' + d + '" style');
        e.dump = s;
      }
      return !0;
    }
  return !1;
}
function un(e, t, r, s, a, l, u) {
  e.tag = null, e.dump = r, Lf(e, r, !1) || Lf(e, r, !0);
  var f = dd.call(e.dump), d = s, g;
  s && (s = e.flowLevel < 0 || e.flowLevel > t);
  var _ = f === "[object Object]" || f === "[object Array]", x, T;
  if (_ && (x = e.duplicates.indexOf(r), T = x !== -1), (e.tag !== null && e.tag !== "?" || T || e.indent !== 2 && t > 0) && (a = !1), T && e.usedDuplicates[x])
    e.dump = "*ref_" + x;
  else {
    if (_ && T && !e.usedDuplicates[x] && (e.usedDuplicates[x] = !0), f === "[object Object]")
      s && Object.keys(e.dump).length !== 0 ? (fE(e, t, e.dump, a), T && (e.dump = "&ref_" + x + e.dump)) : (cE(e, t, e.dump), T && (e.dump = "&ref_" + x + " " + e.dump));
    else if (f === "[object Array]")
      s && e.dump.length !== 0 ? (e.noArrayIndent && !u && t > 0 ? Sf(e, t - 1, e.dump, a) : Sf(e, t, e.dump, a), T && (e.dump = "&ref_" + x + e.dump)) : (uE(e, t, e.dump), T && (e.dump = "&ref_" + x + " " + e.dump));
    else if (f === "[object String]")
      e.tag !== "?" && aE(e, e.dump, t, l, d);
    else {
      if (f === "[object Undefined]")
        return !1;
      if (e.skipInvalid)
        return !1;
      throw new tt("unacceptable kind of an object to dump " + f);
    }
    e.tag !== null && e.tag !== "?" && (g = encodeURI(
      e.tag[0] === "!" ? e.tag.slice(1) : e.tag
    ).replace(/!/g, "%21"), e.tag[0] === "!" ? g = "!" + g : g.slice(0, 18) === "tag:yaml.org,2002:" ? g = "!!" + g.slice(18) : g = "!<" + g + ">", e.dump = g + " " + e.dump);
  }
  return !0;
}
function dE(e, t) {
  var r = [], s = [], a, l;
  for (Fo(e, r, s), a = 0, l = s.length; a < l; a += 1)
    t.duplicates.push(r[s[a]]);
  t.usedDuplicates = new Array(l);
}
function Fo(e, t, r) {
  var s, a, l;
  if (e !== null && typeof e == "object")
    if (a = t.indexOf(e), a !== -1)
      r.indexOf(a) === -1 && r.push(a);
    else if (t.push(e), Array.isArray(e))
      for (a = 0, l = e.length; a < l; a += 1)
        Fo(e[a], t, r);
    else
      for (s = Object.keys(e), a = 0, l = s.length; a < l; a += 1)
        Fo(e[s[a]], t, r);
}
function hE(e, t) {
  t = t || {};
  var r = new tE(t);
  r.noRefs || dE(e, r);
  var s = e;
  return r.replacer && (s = r.replacer.call({ "": s }, "", s)), un(r, 0, s, !0, !0) ? r.dump + `
` : "";
}
var pE = hE, gE = {
  dump: pE
}, mE = Rb.load, vE = gE.dump, Bo = { exports: {} }, Mo = { exports: {} };
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ParsingError = void 0;
  class r extends Error {
    constructor(Z, k) {
      super(Z), this.cause = k;
    }
  }
  t.ParsingError = r;
  let s;
  function a() {
    return d(!1) || T() || x() || _();
  }
  function l() {
    return E(/\s*/), d(!0) || x() || g() || f(!1);
  }
  function u() {
    const $ = f(!0), Z = [];
    let k, se = l();
    for (; se; ) {
      if (se.node.type === "Element") {
        if (k)
          throw new Error("Found multiple root nodes");
        k = se.node;
      }
      se.excluded || Z.push(se.node), se = l();
    }
    if (!k)
      throw new r("Failed to parse XML", "Root Element not found");
    if (s.xml.length !== 0)
      throw new r("Failed to parse XML", "Not Well-Formed XML");
    return {
      declaration: $ ? $.node : null,
      root: k,
      children: Z
    };
  }
  function f($) {
    const Z = E($ ? /^<\?(xml)\s*/ : /^<\?([\w-:.]+)\s*/);
    if (!Z)
      return;
    const k = {
      name: Z[1],
      type: "ProcessingInstruction",
      attributes: {}
    };
    for (; !(P() || U("?>")); ) {
      const se = A();
      if (se)
        k.attributes[se.name] = se.value;
      else
        return;
    }
    return E(/\?>/), {
      excluded: $ ? !1 : s.options.filter(k) === !1,
      node: k
    };
  }
  function d($) {
    const Z = E(/^<([^?!</>\s]+)\s*/);
    if (!Z)
      return;
    const k = {
      type: "Element",
      name: Z[1],
      attributes: {},
      children: []
    }, se = $ ? !1 : s.options.filter(k) === !1;
    for (; !(P() || U(">") || U("?>") || U("/>")); ) {
      const ge = A();
      if (ge)
        k.attributes[ge.name] = ge.value;
      else
        return;
    }
    if (E(/^\s*\/>/))
      return k.children = null, {
        excluded: se,
        node: k
      };
    E(/\??>/);
    let Y = a();
    for (; Y; )
      Y.excluded || k.children.push(Y.node), Y = a();
    if (s.options.strictMode) {
      const ge = `</${k.name}>`;
      if (s.xml.startsWith(ge))
        s.xml = s.xml.slice(ge.length);
      else
        throw new r("Failed to parse XML", `Closing tag not matching "${ge}"`);
    } else
      E(/^<\/\s*[\w-:.\u00C0-\u00FF]+>/);
    return {
      excluded: se,
      node: k
    };
  }
  function g() {
    const $ = E(/^<!DOCTYPE\s+\S+\s+SYSTEM[^>]*>/) || E(/^<!DOCTYPE\s+\S+\s+PUBLIC[^>]*>/) || E(/^<!DOCTYPE\s+\S+\s*\[[^\]]*]>/) || E(/^<!DOCTYPE\s+\S+\s*>/);
    if ($) {
      const Z = {
        type: "DocumentType",
        content: $[0]
      };
      return {
        excluded: s.options.filter(Z) === !1,
        node: Z
      };
    }
  }
  function _() {
    if (s.xml.startsWith("<![CDATA[")) {
      const $ = s.xml.indexOf("]]>");
      if ($ > -1) {
        const Z = $ + 3, k = {
          type: "CDATA",
          content: s.xml.substring(0, Z)
        };
        return s.xml = s.xml.slice(Z), {
          excluded: s.options.filter(k) === !1,
          node: k
        };
      }
    }
  }
  function x() {
    const $ = E(/^<!--[\s\S]*?-->/);
    if ($) {
      const Z = {
        type: "Comment",
        content: $[0]
      };
      return {
        excluded: s.options.filter(Z) === !1,
        node: Z
      };
    }
  }
  function T() {
    const $ = E(/^([^<]+)/);
    if ($) {
      const Z = {
        type: "Text",
        content: $[1]
      };
      return {
        excluded: s.options.filter(Z) === !1,
        node: Z
      };
    }
  }
  function A() {
    const $ = E(/([^=]+)\s*=\s*("[^"]*"|'[^']*'|[^>\s]+)\s*/);
    if ($)
      return {
        name: $[1].trim(),
        value: C($[2].trim())
      };
  }
  function C($) {
    return $.replace(/^['"]|['"]$/g, "");
  }
  function E($) {
    const Z = s.xml.match($);
    if (Z)
      return s.xml = s.xml.slice(Z[0].length), Z;
  }
  function P() {
    return s.xml.length === 0;
  }
  function U($) {
    return s.xml.indexOf($) === 0;
  }
  function H($, Z = {}) {
    $ = $.trim();
    const k = Z.filter || (() => !0);
    return s = {
      xml: $,
      options: Object.assign(Object.assign({}, Z), { filter: k, strictMode: Z.strictMode === !0 })
    }, u();
  }
  e.exports = H, t.default = H;
})(Mo, Mo.exports);
var yE = Mo.exports;
(function(e, t) {
  var r = Wn && Wn.__importDefault || function(C) {
    return C && C.__esModule ? C : { default: C };
  };
  Object.defineProperty(t, "__esModule", { value: !0 });
  const s = r(yE);
  function a(C) {
    if (!C.options.indentation && !C.options.lineSeparator)
      return;
    C.content += C.options.lineSeparator;
    let E;
    for (E = 0; E < C.level; E++)
      C.content += C.options.indentation;
  }
  function l(C) {
    C.content = C.content.replace(/ +$/, "");
    let E;
    for (E = 0; E < C.level; E++)
      C.content += C.options.indentation;
  }
  function u(C, E) {
    C.content += E;
  }
  function f(C, E, P) {
    if (typeof C.content == "string")
      d(C.content, E, P);
    else if (C.type === "Element")
      _(C, E, P);
    else if (C.type === "ProcessingInstruction")
      T(C, E);
    else
      throw new Error("Unknown node type: " + C.type);
  }
  function d(C, E, P) {
    if (!P) {
      const U = C.trim();
      (E.options.lineSeparator || U.length === 0) && (C = U);
    }
    C.length > 0 && (!P && E.content.length > 0 && a(E), u(E, C));
  }
  function g(C, E) {
    const P = "/" + C.join("/"), U = C[C.length - 1];
    return E.includes(U) || E.includes(P);
  }
  function _(C, E, P) {
    if (E.path.push(C.name), !P && E.content.length > 0 && a(E), u(E, "<" + C.name), x(E, C.attributes), C.children === null || E.options.forceSelfClosingEmptyTag && C.children.length === 0) {
      const U = E.options.whiteSpaceAtEndOfSelfclosingTag ? " />" : "/>";
      u(E, U);
    } else if (C.children.length === 0)
      u(E, "></" + C.name + ">");
    else {
      const U = C.children;
      u(E, ">"), E.level++;
      let H = C.attributes["xml:space"] === "preserve", $ = !1;
      if (!H && E.options.ignoredPaths && ($ = g(E.path, E.options.ignoredPaths), H = $), !H && E.options.collapseContent) {
        let Z = !1, k = !1, se = !1;
        U.forEach(function(Y, ge) {
          Y.type === "Text" ? (Y.content.includes(`
`) ? (k = !0, Y.content = Y.content.trim()) : (ge === 0 || ge === U.length - 1) && Y.content.trim().length === 0 && (Y.content = ""), Y.content.trim().length > 0 && (Z = !0)) : Y.type === "CDATA" ? Z = !0 : se = !0;
        }), Z && (!se || !k) && (H = !0);
      }
      U.forEach(function(Z) {
        f(Z, E, P || H);
      }), E.level--, !P && !H && a(E), $ && l(E), u(E, "</" + C.name + ">");
    }
    E.path.pop();
  }
  function x(C, E) {
    Object.keys(E).forEach(function(P) {
      const U = E[P].replace(/"/g, "&quot;");
      u(C, " " + P + '="' + U + '"');
    });
  }
  function T(C, E) {
    E.content.length > 0 && a(E), u(E, "<?" + C.name), x(E, C.attributes), u(E, "?>");
  }
  function A(C, E = {}) {
    E.indentation = "indentation" in E ? E.indentation : "    ", E.collapseContent = E.collapseContent === !0, E.lineSeparator = "lineSeparator" in E ? E.lineSeparator : `\r
`, E.whiteSpaceAtEndOfSelfclosingTag = E.whiteSpaceAtEndOfSelfclosingTag === !0, E.throwOnFailure = E.throwOnFailure !== !1;
    try {
      const P = (0, s.default)(C, { filter: E.filter, strictMode: E.strictMode }), U = { content: "", level: 0, options: E, path: [] };
      return P.declaration && T(P.declaration, U), P.children.forEach(function(H) {
        f(H, U, !1);
      }), E.lineSeparator ? U.content.replace(/\r\n/g, `
`).replace(/\n/g, E.lineSeparator) : U.content;
    } catch (P) {
      if (E.throwOnFailure)
        throw P;
      return C;
    }
  }
  A.minify = (C, E = {}) => A(C, Object.assign(Object.assign({}, E), { indentation: "", lineSeparator: "" })), e.exports = A, t.default = A;
})(Bo, Bo.exports);
var _E = Bo.exports;
const xE = /* @__PURE__ */ $o(_E);
class It {
  constructor(t, r, s) {
    B(this, "rawData");
    B(this, "parsedData", af);
    B(this, "params");
    B(this, "path", []);
    this.params = s, this.rawData = this.deserializeData(t, r), this.parsedData = this.addMetaDataRecursively(this.rawData, "root"), this.normalizingRules();
  }
  /**
   * This method returns the data
   */
  getData(t) {
    const r = {};
    for (const [s, a] of this.iterateOverProperties()) {
      if (a.length === 1)
        continue;
      const l = It.convertPathArrayToStringPathFormat(a, !1);
      Ie.set(r, l, Vc(s._value));
    }
    return this.serializeData(r, t);
  }
  /**
   * This method converts DataType string into a JS object
   *
   * @param {string | any} data is the data string
   * @param {DataType} dataType is the data type
   * @returns {AnyObject} javascript object
   */
  deserializeData(t, r) {
    switch (r) {
      case et.Js:
        return t;
      case et.Json:
        try {
          return JSON.parse(t);
        } catch (s) {
          throw new Error(s);
        }
      case et.Yaml:
        try {
          return mE(t);
        } catch (s) {
          throw new Error(s);
        }
      case et.Xml:
        try {
          xE(t);
          const s = new Kc.XMLParser().parse(t), a = Object.keys(s)[0];
          return this.params.xmlRootName = a, s[a];
        } catch (s) {
          throw new Error(s);
        }
      case et.Toml:
        try {
          return Wx(t);
        } catch (s) {
          throw new Error(s);
        }
      default:
        throw new Error("Invalid datatype");
    }
  }
  /**
   * This method converts JS object into a DataType string
   *
   * @param {string} data is the data JS object
   * @param {DataType} dataType is the data type
   * @returns {AnyObject} is data string
   */
  serializeData(t, r) {
    switch (r) {
      case et.Js:
        return t;
      case et.Json:
        try {
          return JSON.stringify(t);
        } catch (s) {
          throw new Error(s);
        }
      case et.Yaml:
        try {
          return vE(t);
        } catch (s) {
          throw new Error(s);
        }
      case et.Xml:
        try {
          const s = {};
          return this.params.xmlRootName !== void 0 ? s[this.params.xmlRootName] = t : s.root = t, new Kc.XMLBuilder().build(s);
        } catch (s) {
          throw new Error(s);
        }
      case et.Toml:
        try {
          const s = Ie.cloneDeepWith(t, (a) => {
            if (a instanceof Date)
              return a = new us(a.toISOString().split("T")[0]), a;
          });
          return jx(s);
        } catch (s) {
          throw new Error(s);
        }
      default:
        throw new Error("Invalid datatype");
    }
  }
  /**
   * This method adds meta data (private properties) to the data object and all its
   * nested properties if they dont have it and ignore the ones that have it
   *
   * @param {Property} field is the input you want to add meta data to it and to its properties
   * @param {string} key the key of that property
   * @returns {Property} the new object containing required meta data (includes meta data added by the user)
   */
  addMetaDataRecursively(t, r, s = !1) {
    const a = s ? parseInt(r) : r;
    this.path.push(a);
    let l = wt(t);
    if (wt(t) === Ne.Object && "_value" in t && (l = wt(t._value)), l === Ne.Object) {
      t = It.addRequiredMetaDataToProperties(t, a, this.path);
      for (const u in t._value)
        t._value[u] = this.addMetaDataRecursively(t._value[u], u);
    } else if (l === Ne.Array) {
      t = It.addRequiredMetaDataToProperties(t, a, this.path);
      for (const u in t._value)
        t._value[u] = this.addMetaDataRecursively(t._value[u], u, !0);
    } else
      t = It.addRequiredMetaDataToProperties(t, a, this.path);
    return this.path.pop(), t;
  }
  /**
   * This method fills metadata for properties that dont have metadata.
   * it fills those required metadata based on the property type
   *
   * @example
   * From this:
   * ```js
   * {
   *      name: "malik najjar"
   * }
   * ```
   * To this:
   * ```js
   * {
   *      name: {
              _path: ["root", "name"],
              _key: "name",
              _valueType: "string",
              _value: "malik najjar"
          }
   * }
   * ```
   *
   * @param {Property} field is the primitive type that will be filled with default meta data
   * @param {string} key is the key of the property
   * @param {string[]} path is an array that represents the path of the property
   * @returns {AnyObject} the new object filled with meta data
   */
  static addRequiredMetaDataToProperties(t, r, s) {
    s = Array.from(s);
    let a = Vc(af);
    return a._path = s, a._key = r, wt(t) === Ne.Object && "_value" in t ? (a._value = t._value, a._valueType = wt(t._value), a = Gw(a, t)) : (a._value = t, a._valueType = wt(t)), a._valueType === Ne.Null || typeof t._fieldType > "u" ? a._fieldType = hf(a._valueType) : a._fieldType = t._fieldType, a;
  }
  /**
   * This method gives the ability to iterate over parsed data object easily
   * with a simple for loop syntax
   *
   * @example
   * ```ts
   * const data = new Data('{"name": "malik"}', 'json')
   * for (const [obj, path] of data.iterateOverProperties()) {
   *      console.log(path)
   *      console.log(obj)
   * }
   * ```
   */
  *iterateOverProperties(t) {
    if (t == null && (t = this.parsedData), t._valueType === Ne.Object) {
      yield [t, t._path];
      const r = t._value;
      for (const s in r)
        yield* this.iterateOverProperties(r[s]);
    } else if (t._valueType === Ne.Array) {
      yield [t, t._path];
      const r = t._value;
      for (const s in r)
        yield* this.iterateOverProperties(r[s]);
    } else
      yield [t, t._path];
  }
  /**
   * This method normalizes the _rule private parameter of a property
   * @example
   * Converts this:
   * ```js
   * {
   *      _rules: ["READ_ONLY", "DELETE_DISABLED"]
   * }
   * ```
   * To this:
   * ```js
   * {
   *      _rules: [
   *          {
   *              rule: "READ_ONLY",
   *              params: null
   *          },
   *          {
   *              rule: "DELETE_DISABLED",
   *              params: null
   *          }
   *      ]
   * }
   * ```
   */
  normalizingRules() {
    for (const [t] of this.iterateOverProperties())
      if (t._rules !== void 0)
        for (let r = 0; r < t._rules.length; r++)
          wt(t._rules[r]) === Ne.String && (t._rules[r] = {
            rule: t._rules[r],
            params: void 0
          });
  }
  /**
   * This method adds an object property.
   */
  addProperty(t) {
    const r = It.convertPathArrayToStringPathFormat(t._path);
    Ie.set(this.parsedData, r, t);
  }
  /**
   * This method adds an array element.
   */
  addElement(t) {
    const r = Ie.cloneDeep(t._path);
    r.pop();
    const s = It.convertPathArrayToStringPathFormat(r), a = r.length === 1 ? "" : "._value";
    Ie.get(this.parsedData, s + a).push(t);
  }
  /**
   * This method removes an array element or an object property.
   */
  removeData(t) {
    const r = It.convertPathArrayToStringPathFormat(t);
    Ie.unset(this.parsedData, r);
    const s = Ie.last(t);
    if (wt(s) === Ne.Number) {
      t.pop();
      const a = t.length === 1 ? "" : "._value", l = It.convertPathArrayToStringPathFormat(t) + a, u = Ie.get(this.parsedData, l), f = It.resetArrayIndexes(u);
      for (let d = 0; d < f.length; d++) {
        f[d]._key = d;
        const g = f[d]._path.length;
        f[d]._path[g - 1] = d;
      }
      Ie.set(this.parsedData, l, f);
    }
  }
  /**
   * This method converts this._path array into a js string path thats usable with lodash
   * @param {boolean} forParsedData is boolean that will make the function generate a path for data that has meta data in it
   */
  static convertPathArrayToStringPathFormat(t, r = !0) {
    let s = "";
    for (let a = 0; a < t.length; a++) {
      const l = t[a];
      wt(l) === Ne.String ? a === 0 ? s += `${l}${r ? "._value" : ""}` : a === t.length - 1 ? s += `.${l}` : s += `.${l}${r ? "._value" : ""}` : wt(l) === Ne.Number && (a === t.length - 1 ? s += `[${l}]` : s += `[${l}]${r ? "._value" : ""}`);
    }
    return s.substring(5);
  }
  /**
   * This method resets the indexes of the array when there is an empty element in an array
   */
  static resetArrayIndexes(t) {
    return Ie.compact(t);
  }
}
class wE {
  constructor(t, r) {
    B(this, "data");
    B(this, "params");
    B(this, "generatedHTML", document.createElement("null"));
    this.params = r, this.data = t, this.drawData();
  }
  /**
   * This method returns the HTMLElement based on the data
   */
  drawData() {
    const t = document.createElement("div");
    t.classList.add("guifierMainWrapper");
    const r = el(this.data.parsedData, this.data, this.params);
    this.params.flipBackgroundColors && (r.showSecondaryColors = !r.showSecondaryColors);
    let s;
    this.params.withoutContainer ? s = r.draw() : s = r.drawContentWithContainer(), t.append(s);
    const a = s.querySelector(".guifierContainerHeaderButtons");
    xn.addingEventListenerForHeaderButtons(a, r, r), this.generatedHTML = t;
  }
  /**
   * This method returns the generated HTMLElement
   */
  getGeneratedHTML() {
    return this.generatedHTML;
  }
}
class bE {
  constructor(t) {
    B(this, "params");
    B(this, "data");
    B(this, "view");
    B(this, "containerElement", null);
    B(this, "guifierElement", null);
    try {
      this.params = cw.parse(t), this.checkIfMainElementExist(), this.setData(this.params.data, this.params.dataType);
    } catch (r) {
      console.error(r), this.drawErrorHtmlElement(r);
    }
  }
  /**
   * This function draws the generated htmlElement from the data into params element
   */
  drawGeneratedHtmlElement() {
    this.containerElement !== null && this.containerElement.append(this.getGeneratedHtmlElement());
  }
  /**
   * This function draws the generated htmlElement from the data into params element
   */
  drawErrorHtmlElement(t) {
    this.guifierElement = this.drawErrorElement(t), this.containerElement !== null && this.containerElement.append(this.guifierElement);
  }
  /**
   * This function throws an error if it didnt find the params element
   */
  checkIfMainElementExist() {
    if (document.querySelector(this.params.elementSelector) === null)
      throw new Error("Did not find the Main Element");
  }
  /**
   * This function returns the generate htmlElement
   */
  getGeneratedHtmlElement() {
    return this.guifierElement = this.view.getGeneratedHTML(), this.guifierElement;
  }
  /**
   * This method gets the current state of the data from the GUI
   */
  getData(t) {
    return this.data.getData(t);
  }
  /**
   * This method empties the main element
   */
  emptyThisElement() {
    this.guifierElement !== null && this.guifierElement.remove();
  }
  /**
   * This method sets new data. you can use it to change the data shown in the Guifier element
   */
  setData(t, r) {
    this.containerElement = document.querySelector(this.params.elementSelector);
    try {
      this.params.data = t, this.params.dataType = r, this.data = new It(t, r, this.params), this.view = new wE(this.data, this.params), this.emptyThisElement(), this.drawGeneratedHtmlElement();
    } catch (s) {
      console.error(s), this.emptyThisElement(), this.drawErrorHtmlElement(s);
    }
  }
  /**
   * This function will draw an error on the element that has the this.params.elementId
   */
  drawErrorElement(t) {
    const r = document.createElement("div");
    r.classList.add("guifierErrorContainer");
    const s = document.createElement("div");
    s.classList.add("guifierErrorContainerError"), s.innerHTML = "Error Occured", r.append(s);
    const a = document.createElement("pre");
    return a.classList.add("guifierErrorContainerContent"), a.style.whiteSpace = "pre-wrap", a.innerHTML = t, r.append(a), r;
  }
}



/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/***/ (function(module) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/marked/lib/marked.cjs":
/*!********************************************!*\
  !*** ./node_modules/marked/lib/marked.cjs ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
/**
 * marked v4.3.0 - a markdown parser
 * Copyright (c) 2011-2023, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */



function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

function getDefaults() {
  return {
    async: false,
    baseUrl: null,
    breaks: false,
    extensions: null,
    gfm: true,
    headerIds: true,
    headerPrefix: '',
    highlight: null,
    hooks: null,
    langPrefix: 'language-',
    mangle: true,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
  };
}
exports.defaults = getDefaults();
function changeDefaults(newDefaults) {
  exports.defaults = newDefaults;
}

/**
 * Helpers
 */
var escapeTest = /[&<>"']/;
var escapeReplace = new RegExp(escapeTest.source, 'g');
var escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
var escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');
var escapeReplacements = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};
var getEscapeReplacement = function getEscapeReplacement(ch) {
  return escapeReplacements[ch];
};
function escape(html, encode) {
  if (encode) {
    if (escapeTest.test(html)) {
      return html.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html)) {
      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html;
}
var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;

/**
 * @param {string} html
 */
function unescape(html) {
  // explicitly match decimal, hex, and named HTML entities
  return html.replace(unescapeTest, function (_, n) {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}
var caret = /(^|[^\[])\^/g;

/**
 * @param {string | RegExp} regex
 * @param {string} opt
 */
function edit(regex, opt) {
  regex = typeof regex === 'string' ? regex : regex.source;
  opt = opt || '';
  var obj = {
    replace: function replace(name, val) {
      val = val.source || val;
      val = val.replace(caret, '$1');
      regex = regex.replace(name, val);
      return obj;
    },
    getRegex: function getRegex() {
      return new RegExp(regex, opt);
    }
  };
  return obj;
}
var nonWordAndColonTest = /[^\w:]/g;
var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

/**
 * @param {boolean} sanitize
 * @param {string} base
 * @param {string} href
 */
function cleanUrl(sanitize, base, href) {
  if (sanitize) {
    var prot;
    try {
      prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, '').toLowerCase();
    } catch (e) {
      return null;
    }
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
      return null;
    }
  }
  if (base && !originIndependentUrl.test(href)) {
    href = resolveUrl(base, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, '%');
  } catch (e) {
    return null;
  }
  return href;
}
var baseUrls = {};
var justDomain = /^[^:]+:\/*[^/]*$/;
var protocol = /^([^:]+:)[\s\S]*$/;
var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;

/**
 * @param {string} base
 * @param {string} href
 */
function resolveUrl(base, href) {
  if (!baseUrls[' ' + base]) {
    // we can ignore everything in base after the last slash of its path component,
    // but we might need to add _that_
    // https://tools.ietf.org/html/rfc3986#section-3
    if (justDomain.test(base)) {
      baseUrls[' ' + base] = base + '/';
    } else {
      baseUrls[' ' + base] = rtrim(base, '/', true);
    }
  }
  base = baseUrls[' ' + base];
  var relativeBase = base.indexOf(':') === -1;
  if (href.substring(0, 2) === '//') {
    if (relativeBase) {
      return href;
    }
    return base.replace(protocol, '$1') + href;
  } else if (href.charAt(0) === '/') {
    if (relativeBase) {
      return href;
    }
    return base.replace(domain, '$1') + href;
  } else {
    return base + href;
  }
}
var noopTest = {
  exec: function noopTest() {}
};
function splitCells(tableRow, count) {
  // ensure that every cell-delimiting pipe has a space
  // before it to distinguish it from an escaped pipe
  var row = tableRow.replace(/\|/g, function (match, offset, str) {
      var escaped = false,
        curr = offset;
      while (--curr >= 0 && str[curr] === '\\') {
        escaped = !escaped;
      }
      if (escaped) {
        // odd number of slashes means | is escaped
        // so we leave it alone
        return '|';
      } else {
        // add space before unescaped |
        return ' |';
      }
    }),
    cells = row.split(/ \|/);
  var i = 0;

  // First/last cell in a row cannot be empty if it has no leading/trailing pipe
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (cells.length > count) {
    cells.splice(count);
  } else {
    while (cells.length < count) {
      cells.push('');
    }
  }
  for (; i < cells.length; i++) {
    // leading or trailing whitespace is ignored per the gfm spec
    cells[i] = cells[i].trim().replace(/\\\|/g, '|');
  }
  return cells;
}

/**
 * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
 * /c*$/ is vulnerable to REDOS.
 *
 * @param {string} str
 * @param {string} c
 * @param {boolean} invert Remove suffix of non-c chars instead. Default falsey.
 */
function rtrim(str, c, invert) {
  var l = str.length;
  if (l === 0) {
    return '';
  }

  // Length of suffix matching the invert condition.
  var suffLen = 0;

  // Step left until we fail to match the invert condition.
  while (suffLen < l) {
    var currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l - suffLen);
}
function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  var l = str.length;
  var level = 0,
    i = 0;
  for (; i < l; i++) {
    if (str[i] === '\\') {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}
function checkSanitizeDeprecation(opt) {
  if (opt && opt.sanitize && !opt.silent) {
    console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
  }
}

// copied from https://stackoverflow.com/a/5450113/806777
/**
 * @param {string} pattern
 * @param {number} count
 */
function repeatString(pattern, count) {
  if (count < 1) {
    return '';
  }
  var result = '';
  while (count > 1) {
    if (count & 1) {
      result += pattern;
    }
    count >>= 1;
    pattern += pattern;
  }
  return result + pattern;
}

function outputLink(cap, link, raw, lexer) {
  var href = link.href;
  var title = link.title ? escape(link.title) : null;
  var text = cap[1].replace(/\\([\[\]])/g, '$1');
  if (cap[0].charAt(0) !== '!') {
    lexer.state.inLink = true;
    var token = {
      type: 'link',
      raw: raw,
      href: href,
      title: title,
      text: text,
      tokens: lexer.inlineTokens(text)
    };
    lexer.state.inLink = false;
    return token;
  }
  return {
    type: 'image',
    raw: raw,
    href: href,
    title: title,
    text: escape(text)
  };
}
function indentCodeCompensation(raw, text) {
  var matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text;
  }
  var indentToCode = matchIndentToCode[1];
  return text.split('\n').map(function (node) {
    var matchIndentInNode = node.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node;
    }
    var indentInNode = matchIndentInNode[0];
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join('\n');
}

/**
 * Tokenizer
 */
var Tokenizer = /*#__PURE__*/function () {
  function Tokenizer(options) {
    this.options = options || exports.defaults;
  }
  var _proto = Tokenizer.prototype;
  _proto.space = function space(src) {
    var cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: 'space',
        raw: cap[0]
      };
    }
  };
  _proto.code = function code(src) {
    var cap = this.rules.block.code.exec(src);
    if (cap) {
      var text = cap[0].replace(/^ {1,4}/gm, '');
      return {
        type: 'code',
        raw: cap[0],
        codeBlockStyle: 'indented',
        text: !this.options.pedantic ? rtrim(text, '\n') : text
      };
    }
  };
  _proto.fences = function fences(src) {
    var cap = this.rules.block.fences.exec(src);
    if (cap) {
      var raw = cap[0];
      var text = indentCodeCompensation(raw, cap[3] || '');
      return {
        type: 'code',
        raw: raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, '$1') : cap[2],
        text: text
      };
    }
  };
  _proto.heading = function heading(src) {
    var cap = this.rules.block.heading.exec(src);
    if (cap) {
      var text = cap[2].trim();

      // remove trailing #s
      if (/#$/.test(text)) {
        var trimmed = rtrim(text, '#');
        if (this.options.pedantic) {
          text = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          // CommonMark requires space before trailing #s
          text = trimmed.trim();
        }
      }
      return {
        type: 'heading',
        raw: cap[0],
        depth: cap[1].length,
        text: text,
        tokens: this.lexer.inline(text)
      };
    }
  };
  _proto.hr = function hr(src) {
    var cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: 'hr',
        raw: cap[0]
      };
    }
  };
  _proto.blockquote = function blockquote(src) {
    var cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      var text = cap[0].replace(/^ *>[ \t]?/gm, '');
      var top = this.lexer.state.top;
      this.lexer.state.top = true;
      var tokens = this.lexer.blockTokens(text);
      this.lexer.state.top = top;
      return {
        type: 'blockquote',
        raw: cap[0],
        tokens: tokens,
        text: text
      };
    }
  };
  _proto.list = function list(src) {
    var cap = this.rules.block.list.exec(src);
    if (cap) {
      var raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
      var bull = cap[1].trim();
      var isordered = bull.length > 1;
      var list = {
        type: 'list',
        raw: '',
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : '',
        loose: false,
        items: []
      };
      bull = isordered ? "\\d{1,9}\\" + bull.slice(-1) : "\\" + bull;
      if (this.options.pedantic) {
        bull = isordered ? bull : '[*+-]';
      }

      // Get next list item
      var itemRegex = new RegExp("^( {0,3}" + bull + ")((?:[\t ][^\\n]*)?(?:\\n|$))");

      // Check if current bullet point can start a new List Item
      while (src) {
        endEarly = false;
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          // End list if bullet was actually HR (possibly move into itemRegex?)
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        line = cap[2].split('\n', 1)[0].replace(/^\t+/, function (t) {
          return ' '.repeat(3 * t.length);
        });
        nextLine = src.split('\n', 1)[0];
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimLeft();
        } else {
          indent = cap[2].search(/[^ ]/); // Find first non-space char
          indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        blankLine = false;
        if (!line && /^ *$/.test(nextLine)) {
          // Items begin with at most one blank line
          raw += nextLine + '\n';
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          var nextBulletRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}(?:[*+-]|\\d{1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|$))");
          var hrRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)");
          var fencesBeginRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}(?:```|~~~)");
          var headingBeginRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}#");

          // Check if following lines should be included in List Item
          while (src) {
            rawLine = src.split('\n', 1)[0];
            nextLine = rawLine;

            // Re-align to follow commonmark nesting rules
            if (this.options.pedantic) {
              nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');
            }

            // End list item if found code fences
            if (fencesBeginRegex.test(nextLine)) {
              break;
            }

            // End list item if found start of new heading
            if (headingBeginRegex.test(nextLine)) {
              break;
            }

            // End list item if found start of new bullet
            if (nextBulletRegex.test(nextLine)) {
              break;
            }

            // Horizontal rule found
            if (hrRegex.test(src)) {
              break;
            }
            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
              // Dedent if possible
              itemContents += '\n' + nextLine.slice(indent);
            } else {
              // not enough indentation
              if (blankLine) {
                break;
              }

              // paragraph continuation unless last line was a different block level element
              if (line.search(/[^ ]/) >= 4) {
                // indented code block
                break;
              }
              if (fencesBeginRegex.test(line)) {
                break;
              }
              if (headingBeginRegex.test(line)) {
                break;
              }
              if (hrRegex.test(line)) {
                break;
              }
              itemContents += '\n' + nextLine;
            }
            if (!blankLine && !nextLine.trim()) {
              // Check if current line is blank
              blankLine = true;
            }
            raw += rawLine + '\n';
            src = src.substring(rawLine.length + 1);
            line = nextLine.slice(indent);
          }
        }
        if (!list.loose) {
          // If the previous item ended with a blank line, the list is loose
          if (endsWithBlankLine) {
            list.loose = true;
          } else if (/\n *\n *$/.test(raw)) {
            endsWithBlankLine = true;
          }
        }

        // Check for task list items
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== '[ ] ';
            itemContents = itemContents.replace(/^\[[ xX]\] +/, '');
          }
        }
        list.items.push({
          type: 'list_item',
          raw: raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents
        });
        list.raw += raw;
      }

      // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic
      list.items[list.items.length - 1].raw = raw.trimRight();
      list.items[list.items.length - 1].text = itemContents.trimRight();
      list.raw = list.raw.trimRight();
      var l = list.items.length;

      // Item child tokens handled here at end because we needed to have the final item to trim it first
      for (i = 0; i < l; i++) {
        this.lexer.state.top = false;
        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
        if (!list.loose) {
          // Check if list should be loose
          var spacers = list.items[i].tokens.filter(function (t) {
            return t.type === 'space';
          });
          var hasMultipleLineBreaks = spacers.length > 0 && spacers.some(function (t) {
            return /\n.*\n/.test(t.raw);
          });
          list.loose = hasMultipleLineBreaks;
        }
      }

      // Set all items to loose if list is loose
      if (list.loose) {
        for (i = 0; i < l; i++) {
          list.items[i].loose = true;
        }
      }
      return list;
    }
  };
  _proto.html = function html(src) {
    var cap = this.rules.block.html.exec(src);
    if (cap) {
      var token = {
        type: 'html',
        raw: cap[0],
        pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
        text: cap[0]
      };
      if (this.options.sanitize) {
        var text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
        token.type = 'paragraph';
        token.text = text;
        token.tokens = this.lexer.inline(text);
      }
      return token;
    }
  };
  _proto.def = function def(src) {
    var cap = this.rules.block.def.exec(src);
    if (cap) {
      var tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
      var href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline._escapes, '$1') : '';
      var title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, '$1') : cap[3];
      return {
        type: 'def',
        tag: tag,
        raw: cap[0],
        href: href,
        title: title
      };
    }
  };
  _proto.table = function table(src) {
    var cap = this.rules.block.table.exec(src);
    if (cap) {
      var item = {
        type: 'table',
        header: splitCells(cap[1]).map(function (c) {
          return {
            text: c
          };
        }),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, '').split('\n') : []
      };
      if (item.header.length === item.align.length) {
        item.raw = cap[0];
        var l = item.align.length;
        var i, j, k, row;
        for (i = 0; i < l; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = 'right';
          } else if (/^ *:-+: *$/.test(item.align[i])) {
            item.align[i] = 'center';
          } else if (/^ *:-+ *$/.test(item.align[i])) {
            item.align[i] = 'left';
          } else {
            item.align[i] = null;
          }
        }
        l = item.rows.length;
        for (i = 0; i < l; i++) {
          item.rows[i] = splitCells(item.rows[i], item.header.length).map(function (c) {
            return {
              text: c
            };
          });
        }

        // parse child tokens inside headers and cells

        // header child tokens
        l = item.header.length;
        for (j = 0; j < l; j++) {
          item.header[j].tokens = this.lexer.inline(item.header[j].text);
        }

        // cell child tokens
        l = item.rows.length;
        for (j = 0; j < l; j++) {
          row = item.rows[j];
          for (k = 0; k < row.length; k++) {
            row[k].tokens = this.lexer.inline(row[k].text);
          }
        }
        return item;
      }
    }
  };
  _proto.lheading = function lheading(src) {
    var cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: 'heading',
        raw: cap[0],
        depth: cap[2].charAt(0) === '=' ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  };
  _proto.paragraph = function paragraph(src) {
    var cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      var text = cap[1].charAt(cap[1].length - 1) === '\n' ? cap[1].slice(0, -1) : cap[1];
      return {
        type: 'paragraph',
        raw: cap[0],
        text: text,
        tokens: this.lexer.inline(text)
      };
    }
  };
  _proto.text = function text(src) {
    var cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: 'text',
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      };
    }
  };
  _proto.escape = function escape$1(src) {
    var cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: 'escape',
        raw: cap[0],
        text: escape(cap[1])
      };
    }
  };
  _proto.tag = function tag(src) {
    var cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: this.options.sanitize ? 'text' : 'html',
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
      };
    }
  };
  _proto.link = function link(src) {
    var cap = this.rules.inline.link.exec(src);
    if (cap) {
      var trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        // commonmark requires matching angle brackets
        if (!/>$/.test(trimmedUrl)) {
          return;
        }

        // ending angle bracket cannot be escaped
        var rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\');
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        // find closing parenthesis
        var lastParenIndex = findClosingBracket(cap[2], '()');
        if (lastParenIndex > -1) {
          var start = cap[0].indexOf('!') === 0 ? 5 : 4;
          var linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = '';
        }
      }
      var href = cap[2];
      var title = '';
      if (this.options.pedantic) {
        // split pedantic href and title
        var link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
        if (link) {
          href = link[1];
          title = link[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : '';
      }
      href = href.trim();
      if (/^</.test(href)) {
        if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
          // pedantic allows starting angle bracket without ending angle bracket
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline._escapes, '$1') : href,
        title: title ? title.replace(this.rules.inline._escapes, '$1') : title
      }, cap[0], this.lexer);
    }
  };
  _proto.reflink = function reflink(src, links) {
    var cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      var link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = links[link.toLowerCase()];
      if (!link) {
        var text = cap[0].charAt(0);
        return {
          type: 'text',
          raw: text,
          text: text
        };
      }
      return outputLink(cap, link, cap[0], this.lexer);
    }
  };
  _proto.emStrong = function emStrong(src, maskedSrc, prevChar) {
    if (prevChar === void 0) {
      prevChar = '';
    }
    var match = this.rules.inline.emStrong.lDelim.exec(src);
    if (!match) return;

    // _ can't be between two alphanumerics. \p{L}\p{N} includes non-english alphabet/numbers as well
    if (match[3] && prevChar.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDF70-\uDF81\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/)) return;
    var nextChar = match[1] || match[2] || '';
    if (!nextChar || nextChar && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar))) {
      var lLength = match[0].length - 1;
      var rDelim,
        rLength,
        delimTotal = lLength,
        midDelimTotal = 0;
      var endReg = match[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      endReg.lastIndex = 0;

      // Clip maskedSrc to same section of string as src (move to lexer?)
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim) continue; // skip single * in __abc*abc__

        rLength = rDelim.length;
        if (match[3] || match[4]) {
          // found another Left Delim
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          // either Left or Right Delim
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue; // CommonMark Emphasis Rules 9-10
          }
        }

        delimTotal -= rLength;
        if (delimTotal > 0) continue; // Haven't found enough closing delimiters

        // Remove extra characters. *a*** -> *a*
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        var raw = src.slice(0, lLength + match.index + (match[0].length - rDelim.length) + rLength);

        // Create `em` if smallest delimiter has odd char count. *a***
        if (Math.min(lLength, rLength) % 2) {
          var _text = raw.slice(1, -1);
          return {
            type: 'em',
            raw: raw,
            text: _text,
            tokens: this.lexer.inlineTokens(_text)
          };
        }

        // Create 'strong' if smallest delimiter has even char count. **a***
        var text = raw.slice(2, -2);
        return {
          type: 'strong',
          raw: raw,
          text: text,
          tokens: this.lexer.inlineTokens(text)
        };
      }
    }
  };
  _proto.codespan = function codespan(src) {
    var cap = this.rules.inline.code.exec(src);
    if (cap) {
      var text = cap[2].replace(/\n/g, ' ');
      var hasNonSpaceChars = /[^ ]/.test(text);
      var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text = text.substring(1, text.length - 1);
      }
      text = escape(text, true);
      return {
        type: 'codespan',
        raw: cap[0],
        text: text
      };
    }
  };
  _proto.br = function br(src) {
    var cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: 'br',
        raw: cap[0]
      };
    }
  };
  _proto.del = function del(src) {
    var cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: 'del',
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
      };
    }
  };
  _proto.autolink = function autolink(src, mangle) {
    var cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      var text, href;
      if (cap[2] === '@') {
        text = escape(this.options.mangle ? mangle(cap[1]) : cap[1]);
        href = 'mailto:' + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      return {
        type: 'link',
        raw: cap[0],
        text: text,
        href: href,
        tokens: [{
          type: 'text',
          raw: text,
          text: text
        }]
      };
    }
  };
  _proto.url = function url(src, mangle) {
    var cap;
    if (cap = this.rules.inline.url.exec(src)) {
      var text, href;
      if (cap[2] === '@') {
        text = escape(this.options.mangle ? mangle(cap[0]) : cap[0]);
        href = 'mailto:' + text;
      } else {
        // do extended autolink path validation
        var prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
        } while (prevCapZero !== cap[0]);
        text = escape(cap[0]);
        if (cap[1] === 'www.') {
          href = 'http://' + cap[0];
        } else {
          href = cap[0];
        }
      }
      return {
        type: 'link',
        raw: cap[0],
        text: text,
        href: href,
        tokens: [{
          type: 'text',
          raw: text,
          text: text
        }]
      };
    }
  };
  _proto.inlineText = function inlineText(src, smartypants) {
    var cap = this.rules.inline.text.exec(src);
    if (cap) {
      var text;
      if (this.lexer.state.inRawBlock) {
        text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
      } else {
        text = escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);
      }
      return {
        type: 'text',
        raw: cap[0],
        text: text
      };
    }
  };
  return Tokenizer;
}();

/**
 * Block-Level Grammar
 */
var block = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
  html: '^ {0,3}(?:' // optional indentation
  + '<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
  + '|comment[^\\n]*(\\n+|$)' // (2)
  + '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)' // (3)
  + '|<![A-Z][\\s\\S]*?(?:>\\n*|$)' // (4)
  + '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)' // (5)
  + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (6)
  + '|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) open tag
  + '|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) closing tag
  + ')',
  def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: noopTest,
  lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  // regex template, placeholders will be replaced according to different paragraph
  // interruption rules of commonmark and the original markdown spec:
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
};
block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def).replace('label', block._label).replace('title', block._title).getRegex();
block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
block.listItemStart = edit(/^( *)(bull) */).replace('bull', block.bullet).getRegex();
block.list = edit(block.list).replace(/bull/g, block.bullet).replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))').replace('def', '\\n+(?=' + block.def.source + ')').getRegex();
block._tag = 'address|article|aside|base|basefont|blockquote|body|caption' + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr' + '|track|ul';
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
block.html = edit(block.html, 'i').replace('comment', block._comment).replace('tag', block._tag).replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
block.paragraph = edit(block._paragraph).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
.replace('|table', '').replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
.replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
.getRegex();
block.blockquote = edit(block.blockquote).replace('paragraph', block.paragraph).getRegex();

/**
 * Normal Block Grammar
 */

block.normal = _extends({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = _extends({}, block.normal, {
  table: '^ *([^\\n ].*\\|.*)\\n' // Header
  + ' {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?' // Align
  + '(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)' // Cells
});

block.gfm.table = edit(block.gfm.table).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
.replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block._tag) // tables can be interrupted by type (6) html blocks
.getRegex();
block.gfm.paragraph = edit(block._paragraph).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
.replace('table', block.gfm.table) // interrupt paragraphs with table
.replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
.replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
.getRegex();
/**
 * Pedantic grammar (original John Gruber's loose markdown specification)
 */

block.pedantic = _extends({}, block.normal, {
  html: edit('^ *(?:comment *(?:\\n|\\s*$)' + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
  + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))').replace('comment', block._comment).replace(/tag/g, '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b').getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(block.normal._paragraph).replace('hr', block.hr).replace('heading', ' *#{1,6} *[^\n]').replace('lheading', block.lheading).replace('blockquote', ' {0,3}>').replace('|fences', '').replace('|list', '').replace('|html', '').getRegex()
});

/**
 * Inline-Level Grammar
 */
var inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noopTest,
  tag: '^comment' + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
  + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
  + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
  + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
  + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>',
  // CDATA section
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: 'reflink|nolink(?!\\()',
  emStrong: {
    lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
    //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
    //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
    rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
    rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/ // ^- Not allowed for _
  },

  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noopTest,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^([\spunctuation])/
};

// list of punctuation marks from CommonMark spec
// without * and _ to handle the different emphasis markers * and _
inline._punctuation = '!"#$%&\'()+\\-.,/:;<=>?@\\[\\]`^{|}~';
inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();

// sequences em should skip over [title](link), `code`, <html>
inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
// lookbehind is not available on Safari as of version 16
// inline.escapedEmSt = /(?<=(?:^|[^\\)(?:\\[^])*)\\[*_]/g;
inline.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g;
inline._comment = edit(block._comment).replace('(?:-->|$)', '-->').getRegex();
inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, 'g').replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, 'g').replace(/punct/g, inline._punctuation).getRegex();
inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink).replace('scheme', inline._scheme).replace('email', inline._email).getRegex();
inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
inline.tag = edit(inline.tag).replace('comment', inline._comment).replace('attribute', inline._attribute).getRegex();
inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
inline.link = edit(inline.link).replace('label', inline._label).replace('href', inline._href).replace('title', inline._title).getRegex();
inline.reflink = edit(inline.reflink).replace('label', inline._label).replace('ref', block._label).getRegex();
inline.nolink = edit(inline.nolink).replace('ref', block._label).getRegex();
inline.reflinkSearch = edit(inline.reflinkSearch, 'g').replace('reflink', inline.reflink).replace('nolink', inline.nolink).getRegex();

/**
 * Normal Inline Grammar
 */

inline.normal = _extends({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = _extends({}, inline.normal, {
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
  },
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace('label', inline._label).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace('label', inline._label).getRegex()
});

/**
 * GFM Inline Grammar
 */

inline.gfm = _extends({}, inline.normal, {
  escape: edit(inline.escape).replace('])', '~|])').getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
});
inline.gfm.url = edit(inline.gfm.url, 'i').replace('email', inline.gfm._extended_email).getRegex();
/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = _extends({}, inline.gfm, {
  br: edit(inline.br).replace('{2,}', '*').getRegex(),
  text: edit(inline.gfm.text).replace('\\b_', '\\b_| {2,}\\n').replace(/\{2,\}/g, '*').getRegex()
});

/**
 * smartypants text replacement
 * @param {string} text
 */
function smartypants(text) {
  return text
  // em-dashes
  .replace(/---/g, "\u2014")
  // en-dashes
  .replace(/--/g, "\u2013")
  // opening singles
  .replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018")
  // closing singles & apostrophes
  .replace(/'/g, "\u2019")
  // opening doubles
  .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C")
  // closing doubles
  .replace(/"/g, "\u201D")
  // ellipses
  .replace(/\.{3}/g, "\u2026");
}

/**
 * mangle email addresses
 * @param {string} text
 */
function mangle(text) {
  var out = '',
    i,
    ch;
  var l = text.length;
  for (i = 0; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }
  return out;
}

/**
 * Block Lexer
 */
var Lexer = /*#__PURE__*/function () {
  function Lexer(options) {
    this.tokens = [];
    this.tokens.links = Object.create(null);
    this.options = options || exports.defaults;
    this.options.tokenizer = this.options.tokenizer || new Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    var rules = {
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline.breaks;
      } else {
        rules.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }

  /**
   * Expose Rules
   */
  /**
   * Static Lex Method
   */
  Lexer.lex = function lex(src, options) {
    var lexer = new Lexer(options);
    return lexer.lex(src);
  }

  /**
   * Static Lex Inline Method
   */;
  Lexer.lexInline = function lexInline(src, options) {
    var lexer = new Lexer(options);
    return lexer.inlineTokens(src);
  }

  /**
   * Preprocessing
   */;
  var _proto = Lexer.prototype;
  _proto.lex = function lex(src) {
    src = src.replace(/\r\n|\r/g, '\n');
    this.blockTokens(src, this.tokens);
    var next;
    while (next = this.inlineQueue.shift()) {
      this.inlineTokens(next.src, next.tokens);
    }
    return this.tokens;
  }

  /**
   * Lexing
   */;
  _proto.blockTokens = function blockTokens(src, tokens) {
    var _this = this;
    if (tokens === void 0) {
      tokens = [];
    }
    if (this.options.pedantic) {
      src = src.replace(/\t/g, '    ').replace(/^ +$/gm, '');
    } else {
      src = src.replace(/^( *)(\t+)/gm, function (_, leading, tabs) {
        return leading + '    '.repeat(tabs.length);
      });
    }
    var token, lastToken, cutSrc, lastParagraphClipped;
    while (src) {
      if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(function (extTokenizer) {
        if (token = extTokenizer.call({
          lexer: _this
        }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }

      // newline
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        if (token.raw.length === 1 && tokens.length > 0) {
          // if there's a single \n as a spacer, it's terminating the last line,
          // so move it there so that we don't get unecessary paragraph tags
          tokens[tokens.length - 1].raw += '\n';
        } else {
          tokens.push(token);
        }
        continue;
      }

      // code
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        // An indented code block cannot interrupt a paragraph.
        if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
          lastToken.raw += '\n' + token.raw;
          lastToken.text += '\n' + token.text;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }

      // fences
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // heading
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // hr
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // blockquote
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // list
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // html
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // def
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
          lastToken.raw += '\n' + token.raw;
          lastToken.text += '\n' + token.raw;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }

      // table (gfm)
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // lheading
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // top-level paragraph
      // prevent paragraph consuming extensions by clipping 'src' to extension start
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startBlock) {
        (function () {
          var startIndex = Infinity;
          var tempSrc = src.slice(1);
          var tempStart = void 0;
          _this.options.extensions.startBlock.forEach(function (getStartIndex) {
            tempStart = getStartIndex.call({
              lexer: this
            }, tempSrc);
            if (typeof tempStart === 'number' && tempStart >= 0) {
              startIndex = Math.min(startIndex, tempStart);
            }
          });
          if (startIndex < Infinity && startIndex >= 0) {
            cutSrc = src.substring(0, startIndex + 1);
          }
        })();
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        lastToken = tokens[tokens.length - 1];
        if (lastParagraphClipped && lastToken.type === 'paragraph') {
          lastToken.raw += '\n' + token.raw;
          lastToken.text += '\n' + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }

      // text
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === 'text') {
          lastToken.raw += '\n' + token.raw;
          lastToken.text += '\n' + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  };
  _proto.inline = function inline(src, tokens) {
    if (tokens === void 0) {
      tokens = [];
    }
    this.inlineQueue.push({
      src: src,
      tokens: tokens
    });
    return tokens;
  }

  /**
   * Lexing/Compiling
   */;
  _proto.inlineTokens = function inlineTokens(src, tokens) {
    var _this2 = this;
    if (tokens === void 0) {
      tokens = [];
    }
    var token, lastToken, cutSrc;

    // String with links masked to avoid interference with em and strong
    var maskedSrc = src;
    var match;
    var keepPrevChar, prevChar;

    // Mask out reflinks
    if (this.tokens.links) {
      var links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    // Mask out other blocks
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }

    // Mask out escaped em & strong delimiters
    while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index + match[0].length - 2) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
      this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
    }
    while (src) {
      if (!keepPrevChar) {
        prevChar = '';
      }
      keepPrevChar = false;

      // extensions
      if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(function (extTokenizer) {
        if (token = extTokenizer.call({
          lexer: _this2
        }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }

      // escape
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // tag
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === 'text' && lastToken.type === 'text') {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }

      // link
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // reflink, nolink
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === 'text' && lastToken.type === 'text') {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }

      // em & strong
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // code
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // br
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // del (gfm)
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // autolink
      if (token = this.tokenizer.autolink(src, mangle)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // url (gfm)
      if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // text
      // prevent inlineText consuming extensions by clipping 'src' to extension start
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startInline) {
        (function () {
          var startIndex = Infinity;
          var tempSrc = src.slice(1);
          var tempStart = void 0;
          _this2.options.extensions.startInline.forEach(function (getStartIndex) {
            tempStart = getStartIndex.call({
              lexer: this
            }, tempSrc);
            if (typeof tempStart === 'number' && tempStart >= 0) {
              startIndex = Math.min(startIndex, tempStart);
            }
          });
          if (startIndex < Infinity && startIndex >= 0) {
            cutSrc = src.substring(0, startIndex + 1);
          }
        })();
      }
      if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== '_') {
          // Track prevChar before string of ____ started
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === 'text') {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  };
  _createClass(Lexer, null, [{
    key: "rules",
    get: function get() {
      return {
        block: block,
        inline: inline
      };
    }
  }]);
  return Lexer;
}();

/**
 * Renderer
 */
var Renderer = /*#__PURE__*/function () {
  function Renderer(options) {
    this.options = options || exports.defaults;
  }
  var _proto = Renderer.prototype;
  _proto.code = function code(_code, infostring, escaped) {
    var lang = (infostring || '').match(/\S*/)[0];
    if (this.options.highlight) {
      var out = this.options.highlight(_code, lang);
      if (out != null && out !== _code) {
        escaped = true;
        _code = out;
      }
    }
    _code = _code.replace(/\n$/, '') + '\n';
    if (!lang) {
      return '<pre><code>' + (escaped ? _code : escape(_code, true)) + '</code></pre>\n';
    }
    return '<pre><code class="' + this.options.langPrefix + escape(lang) + '">' + (escaped ? _code : escape(_code, true)) + '</code></pre>\n';
  }

  /**
   * @param {string} quote
   */;
  _proto.blockquote = function blockquote(quote) {
    return "<blockquote>\n" + quote + "</blockquote>\n";
  };
  _proto.html = function html(_html) {
    return _html;
  }

  /**
   * @param {string} text
   * @param {string} level
   * @param {string} raw
   * @param {any} slugger
   */;
  _proto.heading = function heading(text, level, raw, slugger) {
    if (this.options.headerIds) {
      var id = this.options.headerPrefix + slugger.slug(raw);
      return "<h" + level + " id=\"" + id + "\">" + text + "</h" + level + ">\n";
    }

    // ignore IDs
    return "<h" + level + ">" + text + "</h" + level + ">\n";
  };
  _proto.hr = function hr() {
    return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
  };
  _proto.list = function list(body, ordered, start) {
    var type = ordered ? 'ol' : 'ul',
      startatt = ordered && start !== 1 ? ' start="' + start + '"' : '';
    return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
  }

  /**
   * @param {string} text
   */;
  _proto.listitem = function listitem(text) {
    return "<li>" + text + "</li>\n";
  };
  _proto.checkbox = function checkbox(checked) {
    return '<input ' + (checked ? 'checked="" ' : '') + 'disabled="" type="checkbox"' + (this.options.xhtml ? ' /' : '') + '> ';
  }

  /**
   * @param {string} text
   */;
  _proto.paragraph = function paragraph(text) {
    return "<p>" + text + "</p>\n";
  }

  /**
   * @param {string} header
   * @param {string} body
   */;
  _proto.table = function table(header, body) {
    if (body) body = "<tbody>" + body + "</tbody>";
    return '<table>\n' + '<thead>\n' + header + '</thead>\n' + body + '</table>\n';
  }

  /**
   * @param {string} content
   */;
  _proto.tablerow = function tablerow(content) {
    return "<tr>\n" + content + "</tr>\n";
  };
  _proto.tablecell = function tablecell(content, flags) {
    var type = flags.header ? 'th' : 'td';
    var tag = flags.align ? "<" + type + " align=\"" + flags.align + "\">" : "<" + type + ">";
    return tag + content + ("</" + type + ">\n");
  }

  /**
   * span level renderer
   * @param {string} text
   */;
  _proto.strong = function strong(text) {
    return "<strong>" + text + "</strong>";
  }

  /**
   * @param {string} text
   */;
  _proto.em = function em(text) {
    return "<em>" + text + "</em>";
  }

  /**
   * @param {string} text
   */;
  _proto.codespan = function codespan(text) {
    return "<code>" + text + "</code>";
  };
  _proto.br = function br() {
    return this.options.xhtml ? '<br/>' : '<br>';
  }

  /**
   * @param {string} text
   */;
  _proto.del = function del(text) {
    return "<del>" + text + "</del>";
  }

  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */;
  _proto.link = function link(href, title, text) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text;
    }
    var out = '<a href="' + href + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += '>' + text + '</a>';
    return out;
  }

  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */;
  _proto.image = function image(href, title, text) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text;
    }
    var out = "<img src=\"" + href + "\" alt=\"" + text + "\"";
    if (title) {
      out += " title=\"" + title + "\"";
    }
    out += this.options.xhtml ? '/>' : '>';
    return out;
  };
  _proto.text = function text(_text) {
    return _text;
  };
  return Renderer;
}();

/**
 * TextRenderer
 * returns only the textual part of the token
 */
var TextRenderer = /*#__PURE__*/function () {
  function TextRenderer() {}
  var _proto = TextRenderer.prototype;
  // no need for block level renderers
  _proto.strong = function strong(text) {
    return text;
  };
  _proto.em = function em(text) {
    return text;
  };
  _proto.codespan = function codespan(text) {
    return text;
  };
  _proto.del = function del(text) {
    return text;
  };
  _proto.html = function html(text) {
    return text;
  };
  _proto.text = function text(_text) {
    return _text;
  };
  _proto.link = function link(href, title, text) {
    return '' + text;
  };
  _proto.image = function image(href, title, text) {
    return '' + text;
  };
  _proto.br = function br() {
    return '';
  };
  return TextRenderer;
}();

/**
 * Slugger generates header id
 */
var Slugger = /*#__PURE__*/function () {
  function Slugger() {
    this.seen = {};
  }

  /**
   * @param {string} value
   */
  var _proto = Slugger.prototype;
  _proto.serialize = function serialize(value) {
    return value.toLowerCase().trim()
    // remove html tags
    .replace(/<[!\/a-z].*?>/ig, '')
    // remove unwanted chars
    .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '').replace(/\s/g, '-');
  }

  /**
   * Finds the next safe (unique) slug to use
   * @param {string} originalSlug
   * @param {boolean} isDryRun
   */;
  _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {
    var slug = originalSlug;
    var occurenceAccumulator = 0;
    if (this.seen.hasOwnProperty(slug)) {
      occurenceAccumulator = this.seen[originalSlug];
      do {
        occurenceAccumulator++;
        slug = originalSlug + '-' + occurenceAccumulator;
      } while (this.seen.hasOwnProperty(slug));
    }
    if (!isDryRun) {
      this.seen[originalSlug] = occurenceAccumulator;
      this.seen[slug] = 0;
    }
    return slug;
  }

  /**
   * Convert string to unique id
   * @param {object} [options]
   * @param {boolean} [options.dryrun] Generates the next unique slug without
   * updating the internal accumulator.
   */;
  _proto.slug = function slug(value, options) {
    if (options === void 0) {
      options = {};
    }
    var slug = this.serialize(value);
    return this.getNextSafeSlug(slug, options.dryrun);
  };
  return Slugger;
}();

/**
 * Parsing & Compiling
 */
var Parser = /*#__PURE__*/function () {
  function Parser(options) {
    this.options = options || exports.defaults;
    this.options.renderer = this.options.renderer || new Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new TextRenderer();
    this.slugger = new Slugger();
  }

  /**
   * Static Parse Method
   */
  Parser.parse = function parse(tokens, options) {
    var parser = new Parser(options);
    return parser.parse(tokens);
  }

  /**
   * Static Parse Inline Method
   */;
  Parser.parseInline = function parseInline(tokens, options) {
    var parser = new Parser(options);
    return parser.parseInline(tokens);
  }

  /**
   * Parse Loop
   */;
  var _proto = Parser.prototype;
  _proto.parse = function parse(tokens, top) {
    if (top === void 0) {
      top = true;
    }
    var out = '',
      i,
      j,
      k,
      l2,
      l3,
      row,
      cell,
      header,
      body,
      token,
      ordered,
      start,
      loose,
      itemBody,
      item,
      checked,
      task,
      checkbox,
      ret;
    var l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];

      // Run any renderer extensions
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({
          parser: this
        }, token);
        if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(token.type)) {
          out += ret || '';
          continue;
        }
      }
      switch (token.type) {
        case 'space':
          {
            continue;
          }
        case 'hr':
          {
            out += this.renderer.hr();
            continue;
          }
        case 'heading':
          {
            out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
            continue;
          }
        case 'code':
          {
            out += this.renderer.code(token.text, token.lang, token.escaped);
            continue;
          }
        case 'table':
          {
            header = '';

            // header
            cell = '';
            l2 = token.header.length;
            for (j = 0; j < l2; j++) {
              cell += this.renderer.tablecell(this.parseInline(token.header[j].tokens), {
                header: true,
                align: token.align[j]
              });
            }
            header += this.renderer.tablerow(cell);
            body = '';
            l2 = token.rows.length;
            for (j = 0; j < l2; j++) {
              row = token.rows[j];
              cell = '';
              l3 = row.length;
              for (k = 0; k < l3; k++) {
                cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {
                  header: false,
                  align: token.align[k]
                });
              }
              body += this.renderer.tablerow(cell);
            }
            out += this.renderer.table(header, body);
            continue;
          }
        case 'blockquote':
          {
            body = this.parse(token.tokens);
            out += this.renderer.blockquote(body);
            continue;
          }
        case 'list':
          {
            ordered = token.ordered;
            start = token.start;
            loose = token.loose;
            l2 = token.items.length;
            body = '';
            for (j = 0; j < l2; j++) {
              item = token.items[j];
              checked = item.checked;
              task = item.task;
              itemBody = '';
              if (item.task) {
                checkbox = this.renderer.checkbox(checked);
                if (loose) {
                  if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {
                    item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;
                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
                      item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;
                    }
                  } else {
                    item.tokens.unshift({
                      type: 'text',
                      text: checkbox
                    });
                  }
                } else {
                  itemBody += checkbox;
                }
              }
              itemBody += this.parse(item.tokens, loose);
              body += this.renderer.listitem(itemBody, task, checked);
            }
            out += this.renderer.list(body, ordered, start);
            continue;
          }
        case 'html':
          {
            // TODO parse inline content if parameter markdown=1
            out += this.renderer.html(token.text);
            continue;
          }
        case 'paragraph':
          {
            out += this.renderer.paragraph(this.parseInline(token.tokens));
            continue;
          }
        case 'text':
          {
            body = token.tokens ? this.parseInline(token.tokens) : token.text;
            while (i + 1 < l && tokens[i + 1].type === 'text') {
              token = tokens[++i];
              body += '\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);
            }
            out += top ? this.renderer.paragraph(body) : body;
            continue;
          }
        default:
          {
            var errMsg = 'Token with "' + token.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return;
            } else {
              throw new Error(errMsg);
            }
          }
      }
    }
    return out;
  }

  /**
   * Parse Inline Tokens
   */;
  _proto.parseInline = function parseInline(tokens, renderer) {
    renderer = renderer || this.renderer;
    var out = '',
      i,
      token,
      ret;
    var l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];

      // Run any renderer extensions
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({
          parser: this
        }, token);
        if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {
          out += ret || '';
          continue;
        }
      }
      switch (token.type) {
        case 'escape':
          {
            out += renderer.text(token.text);
            break;
          }
        case 'html':
          {
            out += renderer.html(token.text);
            break;
          }
        case 'link':
          {
            out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
            break;
          }
        case 'image':
          {
            out += renderer.image(token.href, token.title, token.text);
            break;
          }
        case 'strong':
          {
            out += renderer.strong(this.parseInline(token.tokens, renderer));
            break;
          }
        case 'em':
          {
            out += renderer.em(this.parseInline(token.tokens, renderer));
            break;
          }
        case 'codespan':
          {
            out += renderer.codespan(token.text);
            break;
          }
        case 'br':
          {
            out += renderer.br();
            break;
          }
        case 'del':
          {
            out += renderer.del(this.parseInline(token.tokens, renderer));
            break;
          }
        case 'text':
          {
            out += renderer.text(token.text);
            break;
          }
        default:
          {
            var errMsg = 'Token with "' + token.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return;
            } else {
              throw new Error(errMsg);
            }
          }
      }
    }
    return out;
  };
  return Parser;
}();

var Hooks = /*#__PURE__*/function () {
  function Hooks(options) {
    this.options = options || exports.defaults;
  }
  var _proto = Hooks.prototype;
  /**
   * Process markdown before marked
   */
  _proto.preprocess = function preprocess(markdown) {
    return markdown;
  }

  /**
   * Process HTML after marked is finished
   */;
  _proto.postprocess = function postprocess(html) {
    return html;
  };
  return Hooks;
}();
Hooks.passThroughHooks = new Set(['preprocess', 'postprocess']);

function onError(silent, async, callback) {
  return function (e) {
    e.message += '\nPlease report this to https://github.com/markedjs/marked.';
    if (silent) {
      var msg = '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';
      if (async) {
        return Promise.resolve(msg);
      }
      if (callback) {
        callback(null, msg);
        return;
      }
      return msg;
    }
    if (async) {
      return Promise.reject(e);
    }
    if (callback) {
      callback(e);
      return;
    }
    throw e;
  };
}
function parseMarkdown(lexer, parser) {
  return function (src, opt, callback) {
    if (typeof opt === 'function') {
      callback = opt;
      opt = null;
    }
    var origOpt = _extends({}, opt);
    opt = _extends({}, marked.defaults, origOpt);
    var throwError = onError(opt.silent, opt.async, callback);

    // throw error in case of non string input
    if (typeof src === 'undefined' || src === null) {
      return throwError(new Error('marked(): input parameter is undefined or null'));
    }
    if (typeof src !== 'string') {
      return throwError(new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected'));
    }
    checkSanitizeDeprecation(opt);
    if (opt.hooks) {
      opt.hooks.options = opt;
    }
    if (callback) {
      var highlight = opt.highlight;
      var tokens;
      try {
        if (opt.hooks) {
          src = opt.hooks.preprocess(src);
        }
        tokens = lexer(src, opt);
      } catch (e) {
        return throwError(e);
      }
      var done = function done(err) {
        var out;
        if (!err) {
          try {
            if (opt.walkTokens) {
              marked.walkTokens(tokens, opt.walkTokens);
            }
            out = parser(tokens, opt);
            if (opt.hooks) {
              out = opt.hooks.postprocess(out);
            }
          } catch (e) {
            err = e;
          }
        }
        opt.highlight = highlight;
        return err ? throwError(err) : callback(null, out);
      };
      if (!highlight || highlight.length < 3) {
        return done();
      }
      delete opt.highlight;
      if (!tokens.length) return done();
      var pending = 0;
      marked.walkTokens(tokens, function (token) {
        if (token.type === 'code') {
          pending++;
          setTimeout(function () {
            highlight(token.text, token.lang, function (err, code) {
              if (err) {
                return done(err);
              }
              if (code != null && code !== token.text) {
                token.text = code;
                token.escaped = true;
              }
              pending--;
              if (pending === 0) {
                done();
              }
            });
          }, 0);
        }
      });
      if (pending === 0) {
        done();
      }
      return;
    }
    if (opt.async) {
      return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then(function (src) {
        return lexer(src, opt);
      }).then(function (tokens) {
        return opt.walkTokens ? Promise.all(marked.walkTokens(tokens, opt.walkTokens)).then(function () {
          return tokens;
        }) : tokens;
      }).then(function (tokens) {
        return parser(tokens, opt);
      }).then(function (html) {
        return opt.hooks ? opt.hooks.postprocess(html) : html;
      })["catch"](throwError);
    }
    try {
      if (opt.hooks) {
        src = opt.hooks.preprocess(src);
      }
      var _tokens = lexer(src, opt);
      if (opt.walkTokens) {
        marked.walkTokens(_tokens, opt.walkTokens);
      }
      var html = parser(_tokens, opt);
      if (opt.hooks) {
        html = opt.hooks.postprocess(html);
      }
      return html;
    } catch (e) {
      return throwError(e);
    }
  };
}

/**
 * Marked
 */
function marked(src, opt, callback) {
  return parseMarkdown(Lexer.lex, Parser.parse)(src, opt, callback);
}

/**
 * Options
 */

marked.options = marked.setOptions = function (opt) {
  marked.defaults = _extends({}, marked.defaults, opt);
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = getDefaults;
marked.defaults = exports.defaults;

/**
 * Use Extension
 */

marked.use = function () {
  var extensions = marked.defaults.extensions || {
    renderers: {},
    childTokens: {}
  };
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  args.forEach(function (pack) {
    // copy options to new object
    var opts = _extends({}, pack);

    // set async to true if it was set to true before
    opts.async = marked.defaults.async || opts.async || false;

    // ==-- Parse "addon" extensions --== //
    if (pack.extensions) {
      pack.extensions.forEach(function (ext) {
        if (!ext.name) {
          throw new Error('extension name required');
        }
        if (ext.renderer) {
          // Renderer extensions
          var prevRenderer = extensions.renderers[ext.name];
          if (prevRenderer) {
            // Replace extension with func to run new extension but fall back if false
            extensions.renderers[ext.name] = function () {
              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
              }
              var ret = ext.renderer.apply(this, args);
              if (ret === false) {
                ret = prevRenderer.apply(this, args);
              }
              return ret;
            };
          } else {
            extensions.renderers[ext.name] = ext.renderer;
          }
        }
        if (ext.tokenizer) {
          // Tokenizer Extensions
          if (!ext.level || ext.level !== 'block' && ext.level !== 'inline') {
            throw new Error("extension level must be 'block' or 'inline'");
          }
          if (extensions[ext.level]) {
            extensions[ext.level].unshift(ext.tokenizer);
          } else {
            extensions[ext.level] = [ext.tokenizer];
          }
          if (ext.start) {
            // Function to check for start of token
            if (ext.level === 'block') {
              if (extensions.startBlock) {
                extensions.startBlock.push(ext.start);
              } else {
                extensions.startBlock = [ext.start];
              }
            } else if (ext.level === 'inline') {
              if (extensions.startInline) {
                extensions.startInline.push(ext.start);
              } else {
                extensions.startInline = [ext.start];
              }
            }
          }
        }
        if (ext.childTokens) {
          // Child tokens to be visited by walkTokens
          extensions.childTokens[ext.name] = ext.childTokens;
        }
      });
      opts.extensions = extensions;
    }

    // ==-- Parse "overwrite" extensions --== //
    if (pack.renderer) {
      (function () {
        var renderer = marked.defaults.renderer || new Renderer();
        var _loop = function _loop(prop) {
          var prevRenderer = renderer[prop];
          // Replace renderer with func to run extension, but fall back if false
          renderer[prop] = function () {
            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              args[_key3] = arguments[_key3];
            }
            var ret = pack.renderer[prop].apply(renderer, args);
            if (ret === false) {
              ret = prevRenderer.apply(renderer, args);
            }
            return ret;
          };
        };
        for (var prop in pack.renderer) {
          _loop(prop);
        }
        opts.renderer = renderer;
      })();
    }
    if (pack.tokenizer) {
      (function () {
        var tokenizer = marked.defaults.tokenizer || new Tokenizer();
        var _loop2 = function _loop2(prop) {
          var prevTokenizer = tokenizer[prop];
          // Replace tokenizer with func to run extension, but fall back if false
          tokenizer[prop] = function () {
            for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
              args[_key4] = arguments[_key4];
            }
            var ret = pack.tokenizer[prop].apply(tokenizer, args);
            if (ret === false) {
              ret = prevTokenizer.apply(tokenizer, args);
            }
            return ret;
          };
        };
        for (var prop in pack.tokenizer) {
          _loop2(prop);
        }
        opts.tokenizer = tokenizer;
      })();
    }

    // ==-- Parse Hooks extensions --== //
    if (pack.hooks) {
      (function () {
        var hooks = marked.defaults.hooks || new Hooks();
        var _loop3 = function _loop3(prop) {
          var prevHook = hooks[prop];
          if (Hooks.passThroughHooks.has(prop)) {
            hooks[prop] = function (arg) {
              if (marked.defaults.async) {
                return Promise.resolve(pack.hooks[prop].call(hooks, arg)).then(function (ret) {
                  return prevHook.call(hooks, ret);
                });
              }
              var ret = pack.hooks[prop].call(hooks, arg);
              return prevHook.call(hooks, ret);
            };
          } else {
            hooks[prop] = function () {
              for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                args[_key5] = arguments[_key5];
              }
              var ret = pack.hooks[prop].apply(hooks, args);
              if (ret === false) {
                ret = prevHook.apply(hooks, args);
              }
              return ret;
            };
          }
        };
        for (var prop in pack.hooks) {
          _loop3(prop);
        }
        opts.hooks = hooks;
      })();
    }

    // ==-- Parse WalkTokens extensions --== //
    if (pack.walkTokens) {
      var _walkTokens = marked.defaults.walkTokens;
      opts.walkTokens = function (token) {
        var values = [];
        values.push(pack.walkTokens.call(this, token));
        if (_walkTokens) {
          values = values.concat(_walkTokens.call(this, token));
        }
        return values;
      };
    }
    marked.setOptions(opts);
  });
};

/**
 * Run callback for every token
 */

marked.walkTokens = function (tokens, callback) {
  var values = [];
  var _loop4 = function _loop4() {
    var token = _step.value;
    values = values.concat(callback.call(marked, token));
    switch (token.type) {
      case 'table':
        {
          for (var _iterator2 = _createForOfIteratorHelperLoose(token.header), _step2; !(_step2 = _iterator2()).done;) {
            var cell = _step2.value;
            values = values.concat(marked.walkTokens(cell.tokens, callback));
          }
          for (var _iterator3 = _createForOfIteratorHelperLoose(token.rows), _step3; !(_step3 = _iterator3()).done;) {
            var row = _step3.value;
            for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done;) {
              var _cell = _step4.value;
              values = values.concat(marked.walkTokens(_cell.tokens, callback));
            }
          }
          break;
        }
      case 'list':
        {
          values = values.concat(marked.walkTokens(token.items, callback));
          break;
        }
      default:
        {
          if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
            // Walk any extensions
            marked.defaults.extensions.childTokens[token.type].forEach(function (childTokens) {
              values = values.concat(marked.walkTokens(token[childTokens], callback));
            });
          } else if (token.tokens) {
            values = values.concat(marked.walkTokens(token.tokens, callback));
          }
        }
    }
  };
  for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done;) {
    _loop4();
  }
  return values;
};

/**
 * Parse Inline
 * @param {string} src
 */
marked.parseInline = parseMarkdown(Lexer.lexInline, Parser.parseInline);

/**
 * Expose
 */
marked.Parser = Parser;
marked.parser = Parser.parse;
marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;
marked.Lexer = Lexer;
marked.lexer = Lexer.lex;
marked.Tokenizer = Tokenizer;
marked.Slugger = Slugger;
marked.Hooks = Hooks;
marked.parse = marked;
var options = marked.options;
var setOptions = marked.setOptions;
var use = marked.use;
var walkTokens = marked.walkTokens;
var parseInline = marked.parseInline;
var parse = marked;
var parser = Parser.parse;
var lexer = Lexer.lex;

exports.Hooks = Hooks;
exports.Lexer = Lexer;
exports.Parser = Parser;
exports.Renderer = Renderer;
exports.Slugger = Slugger;
exports.TextRenderer = TextRenderer;
exports.Tokenizer = Tokenizer;
exports.getDefaults = getDefaults;
exports.lexer = lexer;
exports.marked = marked;
exports.options = options;
exports.parse = parse;
exports.parseInline = parseInline;
exports.parser = parser;
exports.setOptions = setOptions;
exports.use = use;
exports.walkTokens = walkTokens;


/***/ }),

/***/ "./node_modules/qrcode/lib/browser.js":
/*!********************************************!*\
  !*** ./node_modules/qrcode/lib/browser.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


const canPromise = __webpack_require__(/*! ./can-promise */ "./node_modules/qrcode/lib/can-promise.js")

const QRCode = __webpack_require__(/*! ./core/qrcode */ "./node_modules/qrcode/lib/core/qrcode.js")
const CanvasRenderer = __webpack_require__(/*! ./renderer/canvas */ "./node_modules/qrcode/lib/renderer/canvas.js")
const SvgRenderer = __webpack_require__(/*! ./renderer/svg-tag.js */ "./node_modules/qrcode/lib/renderer/svg-tag.js")

function renderCanvas (renderFunc, canvas, text, opts, cb) {
  const args = [].slice.call(arguments, 1)
  const argsNum = args.length
  const isLastArgCb = typeof args[argsNum - 1] === 'function'

  if (!isLastArgCb && !canPromise()) {
    throw new Error('Callback required as last argument')
  }

  if (isLastArgCb) {
    if (argsNum < 2) {
      throw new Error('Too few arguments provided')
    }

    if (argsNum === 2) {
      cb = text
      text = canvas
      canvas = opts = undefined
    } else if (argsNum === 3) {
      if (canvas.getContext && typeof cb === 'undefined') {
        cb = opts
        opts = undefined
      } else {
        cb = opts
        opts = text
        text = canvas
        canvas = undefined
      }
    }
  } else {
    if (argsNum < 1) {
      throw new Error('Too few arguments provided')
    }

    if (argsNum === 1) {
      text = canvas
      canvas = opts = undefined
    } else if (argsNum === 2 && !canvas.getContext) {
      opts = text
      text = canvas
      canvas = undefined
    }

    return new Promise(function (resolve, reject) {
      try {
        const data = QRCode.create(text, opts)
        resolve(renderFunc(data, canvas, opts))
      } catch (e) {
        reject(e)
      }
    })
  }

  try {
    const data = QRCode.create(text, opts)
    cb(null, renderFunc(data, canvas, opts))
  } catch (e) {
    cb(e)
  }
}

exports.create = QRCode.create
exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render)
exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL)

// only svg for now.
exports.toString = renderCanvas.bind(null, function (data, _, opts) {
  return SvgRenderer.render(data, opts)
})


/***/ }),

/***/ "./node_modules/qrcode/lib/can-promise.js":
/*!************************************************!*\
  !*** ./node_modules/qrcode/lib/can-promise.js ***!
  \************************************************/
/***/ (function(module) {

// can-promise has a crash in some versions of react native that dont have
// standard global objects
// https://github.com/soldair/node-qrcode/issues/157

module.exports = function () {
  return typeof Promise === 'function' && Promise.prototype && Promise.prototype.then
}


/***/ }),

/***/ "./node_modules/qrcode/lib/core/alignment-pattern.js":
/*!***********************************************************!*\
  !*** ./node_modules/qrcode/lib/core/alignment-pattern.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/**
 * Alignment pattern are fixed reference pattern in defined positions
 * in a matrix symbology, which enables the decode software to re-synchronise
 * the coordinate mapping of the image modules in the event of moderate amounts
 * of distortion of the image.
 *
 * Alignment patterns are present only in QR Code symbols of version 2 or larger
 * and their number depends on the symbol version.
 */

const getSymbolSize = (__webpack_require__(/*! ./utils */ "./node_modules/qrcode/lib/core/utils.js").getSymbolSize)

/**
 * Calculate the row/column coordinates of the center module of each alignment pattern
 * for the specified QR Code version.
 *
 * The alignment patterns are positioned symmetrically on either side of the diagonal
 * running from the top left corner of the symbol to the bottom right corner.
 *
 * Since positions are simmetrical only half of the coordinates are returned.
 * Each item of the array will represent in turn the x and y coordinate.
 * @see {@link getPositions}
 *
 * @param  {Number} version QR Code version
 * @return {Array}          Array of coordinate
 */
exports.getRowColCoords = function getRowColCoords (version) {
  if (version === 1) return []

  const posCount = Math.floor(version / 7) + 2
  const size = getSymbolSize(version)
  const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2
  const positions = [size - 7] // Last coord is always (size - 7)

  for (let i = 1; i < posCount - 1; i++) {
    positions[i] = positions[i - 1] - intervals
  }

  positions.push(6) // First coord is always 6

  return positions.reverse()
}

/**
 * Returns an array containing the positions of each alignment pattern.
 * Each array's element represent the center point of the pattern as (x, y) coordinates
 *
 * Coordinates are calculated expanding the row/column coordinates returned by {@link getRowColCoords}
 * and filtering out the items that overlaps with finder pattern
 *
 * @example
 * For a Version 7 symbol {@link getRowColCoords} returns values 6, 22 and 38.
 * The alignment patterns, therefore, are to be centered on (row, column)
 * positions (6,22), (22,6), (22,22), (22,38), (38,22), (38,38).
 * Note that the coordinates (6,6), (6,38), (38,6) are occupied by finder patterns
 * and are not therefore used for alignment patterns.
 *
 * let pos = getPositions(7)
 * // [[6,22], [22,6], [22,22], [22,38], [38,22], [38,38]]
 *
 * @param  {Number} version QR Code version
 * @return {Array}          Array of coordinates
 */
exports.getPositions = function getPositions (version) {
  const coords = []
  const pos = exports.getRowColCoords(version)
  const posLength = pos.length

  for (let i = 0; i < posLength; i++) {
    for (let j = 0; j < posLength; j++) {
      // Skip if position is occupied by finder patterns
      if ((i === 0 && j === 0) || // top-left
          (i === 0 && j === posLength - 1) || // bottom-left
          (i === posLength - 1 && j === 0)) { // top-right
        continue
      }

      coords.push([pos[i], pos[j]])
    }
  }

  return coords
}


/***/ }),

/***/ "./node_modules/qrcode/lib/core/alphanumeric-data.js":
/*!***********************************************************!*\
  !*** ./node_modules/qrcode/lib/core/alphanumeric-data.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const Mode = __webpack_require__(/*! ./mode */ "./node_modules/qrcode/lib/core/mode.js")

/**
 * Array of characters available in alphanumeric mode
 *
 * As per QR Code specification, to each character
 * is assigned a value from 0 to 44 which in this case coincides
 * with the array index
 *
 * @type {Array}
 */
const ALPHA_NUM_CHARS = [
  '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
  'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
  'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
  ' ', '$', '%', '*', '+', '-', '.', '/', ':'
]

function AlphanumericData (data) {
  this.mode = Mode.ALPHANUMERIC
  this.data = data
}

AlphanumericData.getBitsLength = function getBitsLength (length) {
  return 11 * Math.floor(length / 2) + 6 * (length % 2)
}

AlphanumericData.prototype.getLength = function getLength () {
  return this.data.length
}

AlphanumericData.prototype.getBitsLength = function getBitsLength () {
  return AlphanumericData.getBitsLength(this.data.length)
}

AlphanumericData.prototype.write = function write (bitBuffer) {
  let i

  // Input data characters are divided into groups of two characters
  // and encoded as 11-bit binary codes.
  for (i = 0; i + 2 <= this.data.length; i += 2) {
    // The character value of the first character is multiplied by 45
    let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45

    // The character value of the second digit is added to the product
    value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1])

    // The sum is then stored as 11-bit binary number
    bitBuffer.put(value, 11)
  }

  // If the number of input data characters is not a multiple of two,
  // the character value of the final character is encoded as a 6-bit binary number.
  if (this.data.length % 2) {
    bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6)
  }
}

module.exports = AlphanumericData


/***/ }),

/***/ "./node_modules/qrcode/lib/core/bit-buffer.js":
/*!****************************************************!*\
  !*** ./node_modules/qrcode/lib/core/bit-buffer.js ***!
  \****************************************************/
/***/ (function(module) {

function BitBuffer () {
  this.buffer = []
  this.length = 0
}

BitBuffer.prototype = {

  get: function (index) {
    const bufIndex = Math.floor(index / 8)
    return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) === 1
  },

  put: function (num, length) {
    for (let i = 0; i < length; i++) {
      this.putBit(((num >>> (length - i - 1)) & 1) === 1)
    }
  },

  getLengthInBits: function () {
    return this.length
  },

  putBit: function (bit) {
    const bufIndex = Math.floor(this.length / 8)
    if (this.buffer.length <= bufIndex) {
      this.buffer.push(0)
    }

    if (bit) {
      this.buffer[bufIndex] |= (0x80 >>> (this.length % 8))
    }

    this.length++
  }
}

module.exports = BitBuffer


/***/ }),

/***/ "./node_modules/qrcode/lib/core/bit-matrix.js":
/*!****************************************************!*\
  !*** ./node_modules/qrcode/lib/core/bit-matrix.js ***!
  \****************************************************/
/***/ (function(module) {

/**
 * Helper class to handle QR Code symbol modules
 *
 * @param {Number} size Symbol size
 */
function BitMatrix (size) {
  if (!size || size < 1) {
    throw new Error('BitMatrix size must be defined and greater than 0')
  }

  this.size = size
  this.data = new Uint8Array(size * size)
  this.reservedBit = new Uint8Array(size * size)
}

/**
 * Set bit value at specified location
 * If reserved flag is set, this bit will be ignored during masking process
 *
 * @param {Number}  row
 * @param {Number}  col
 * @param {Boolean} value
 * @param {Boolean} reserved
 */
BitMatrix.prototype.set = function (row, col, value, reserved) {
  const index = row * this.size + col
  this.data[index] = value
  if (reserved) this.reservedBit[index] = true
}

/**
 * Returns bit value at specified location
 *
 * @param  {Number}  row
 * @param  {Number}  col
 * @return {Boolean}
 */
BitMatrix.prototype.get = function (row, col) {
  return this.data[row * this.size + col]
}

/**
 * Applies xor operator at specified location
 * (used during masking process)
 *
 * @param {Number}  row
 * @param {Number}  col
 * @param {Boolean} value
 */
BitMatrix.prototype.xor = function (row, col, value) {
  this.data[row * this.size + col] ^= value
}

/**
 * Check if bit at specified location is reserved
 *
 * @param {Number}   row
 * @param {Number}   col
 * @return {Boolean}
 */
BitMatrix.prototype.isReserved = function (row, col) {
  return this.reservedBit[row * this.size + col]
}

module.exports = BitMatrix


/***/ }),

/***/ "./node_modules/qrcode/lib/core/byte-data.js":
/*!***************************************************!*\
  !*** ./node_modules/qrcode/lib/core/byte-data.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const Mode = __webpack_require__(/*! ./mode */ "./node_modules/qrcode/lib/core/mode.js")

function ByteData (data) {
  this.mode = Mode.BYTE
  if (typeof (data) === 'string') {
    this.data = new TextEncoder().encode(data)
  } else {
    this.data = new Uint8Array(data)
  }
}

ByteData.getBitsLength = function getBitsLength (length) {
  return length * 8
}

ByteData.prototype.getLength = function getLength () {
  return this.data.length
}

ByteData.prototype.getBitsLength = function getBitsLength () {
  return ByteData.getBitsLength(this.data.length)
}

ByteData.prototype.write = function (bitBuffer) {
  for (let i = 0, l = this.data.length; i < l; i++) {
    bitBuffer.put(this.data[i], 8)
  }
}

module.exports = ByteData


/***/ }),

/***/ "./node_modules/qrcode/lib/core/error-correction-code.js":
/*!***************************************************************!*\
  !*** ./node_modules/qrcode/lib/core/error-correction-code.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

const ECLevel = __webpack_require__(/*! ./error-correction-level */ "./node_modules/qrcode/lib/core/error-correction-level.js")

const EC_BLOCKS_TABLE = [
// L  M  Q  H
  1, 1, 1, 1,
  1, 1, 1, 1,
  1, 1, 2, 2,
  1, 2, 2, 4,
  1, 2, 4, 4,
  2, 4, 4, 4,
  2, 4, 6, 5,
  2, 4, 6, 6,
  2, 5, 8, 8,
  4, 5, 8, 8,
  4, 5, 8, 11,
  4, 8, 10, 11,
  4, 9, 12, 16,
  4, 9, 16, 16,
  6, 10, 12, 18,
  6, 10, 17, 16,
  6, 11, 16, 19,
  6, 13, 18, 21,
  7, 14, 21, 25,
  8, 16, 20, 25,
  8, 17, 23, 25,
  9, 17, 23, 34,
  9, 18, 25, 30,
  10, 20, 27, 32,
  12, 21, 29, 35,
  12, 23, 34, 37,
  12, 25, 34, 40,
  13, 26, 35, 42,
  14, 28, 38, 45,
  15, 29, 40, 48,
  16, 31, 43, 51,
  17, 33, 45, 54,
  18, 35, 48, 57,
  19, 37, 51, 60,
  19, 38, 53, 63,
  20, 40, 56, 66,
  21, 43, 59, 70,
  22, 45, 62, 74,
  24, 47, 65, 77,
  25, 49, 68, 81
]

const EC_CODEWORDS_TABLE = [
// L  M  Q  H
  7, 10, 13, 17,
  10, 16, 22, 28,
  15, 26, 36, 44,
  20, 36, 52, 64,
  26, 48, 72, 88,
  36, 64, 96, 112,
  40, 72, 108, 130,
  48, 88, 132, 156,
  60, 110, 160, 192,
  72, 130, 192, 224,
  80, 150, 224, 264,
  96, 176, 260, 308,
  104, 198, 288, 352,
  120, 216, 320, 384,
  132, 240, 360, 432,
  144, 280, 408, 480,
  168, 308, 448, 532,
  180, 338, 504, 588,
  196, 364, 546, 650,
  224, 416, 600, 700,
  224, 442, 644, 750,
  252, 476, 690, 816,
  270, 504, 750, 900,
  300, 560, 810, 960,
  312, 588, 870, 1050,
  336, 644, 952, 1110,
  360, 700, 1020, 1200,
  390, 728, 1050, 1260,
  420, 784, 1140, 1350,
  450, 812, 1200, 1440,
  480, 868, 1290, 1530,
  510, 924, 1350, 1620,
  540, 980, 1440, 1710,
  570, 1036, 1530, 1800,
  570, 1064, 1590, 1890,
  600, 1120, 1680, 1980,
  630, 1204, 1770, 2100,
  660, 1260, 1860, 2220,
  720, 1316, 1950, 2310,
  750, 1372, 2040, 2430
]

/**
 * Returns the number of error correction block that the QR Code should contain
 * for the specified version and error correction level.
 *
 * @param  {Number} version              QR Code version
 * @param  {Number} errorCorrectionLevel Error correction level
 * @return {Number}                      Number of error correction blocks
 */
exports.getBlocksCount = function getBlocksCount (version, errorCorrectionLevel) {
  switch (errorCorrectionLevel) {
    case ECLevel.L:
      return EC_BLOCKS_TABLE[(version - 1) * 4 + 0]
    case ECLevel.M:
      return EC_BLOCKS_TABLE[(version - 1) * 4 + 1]
    case ECLevel.Q:
      return EC_BLOCKS_TABLE[(version - 1) * 4 + 2]
    case ECLevel.H:
      return EC_BLOCKS_TABLE[(version - 1) * 4 + 3]
    default:
      return undefined
  }
}

/**
 * Returns the number of error correction codewords to use for the specified
 * version and error correction level.
 *
 * @param  {Number} version              QR Code version
 * @param  {Number} errorCorrectionLevel Error correction level
 * @return {Number}                      Number of error correction codewords
 */
exports.getTotalCodewordsCount = function getTotalCodewordsCount (version, errorCorrectionLevel) {
  switch (errorCorrectionLevel) {
    case ECLevel.L:
      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0]
    case ECLevel.M:
      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1]
    case ECLevel.Q:
      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2]
    case ECLevel.H:
      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3]
    default:
      return undefined
  }
}


/***/ }),

/***/ "./node_modules/qrcode/lib/core/error-correction-level.js":
/*!****************************************************************!*\
  !*** ./node_modules/qrcode/lib/core/error-correction-level.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports) {

exports.L = { bit: 1 }
exports.M = { bit: 0 }
exports.Q = { bit: 3 }
exports.H = { bit: 2 }

function fromString (string) {
  if (typeof string !== 'string') {
    throw new Error('Param is not a string')
  }

  const lcStr = string.toLowerCase()

  switch (lcStr) {
    case 'l':
    case 'low':
      return exports.L

    case 'm':
    case 'medium':
      return exports.M

    case 'q':
    case 'quartile':
      return exports.Q

    case 'h':
    case 'high':
      return exports.H

    default:
      throw new Error('Unknown EC Level: ' + string)
  }
}

exports.isValid = function isValid (level) {
  return level && typeof level.bit !== 'undefined' &&
    level.bit >= 0 && level.bit < 4
}

exports.from = function from (value, defaultValue) {
  if (exports.isValid(value)) {
    return value
  }

  try {
    return fromString(value)
  } catch (e) {
    return defaultValue
  }
}


/***/ }),

/***/ "./node_modules/qrcode/lib/core/finder-pattern.js":
/*!********************************************************!*\
  !*** ./node_modules/qrcode/lib/core/finder-pattern.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

const getSymbolSize = (__webpack_require__(/*! ./utils */ "./node_modules/qrcode/lib/core/utils.js").getSymbolSize)
const FINDER_PATTERN_SIZE = 7

/**
 * Returns an array containing the positions of each finder pattern.
 * Each array's element represent the top-left point of the pattern as (x, y) coordinates
 *
 * @param  {Number} version QR Code version
 * @return {Array}          Array of coordinates
 */
exports.getPositions = function getPositions (version) {
  const size = getSymbolSize(version)

  return [
    // top-left
    [0, 0],
    // top-right
    [size - FINDER_PATTERN_SIZE, 0],
    // bottom-left
    [0, size - FINDER_PATTERN_SIZE]
  ]
}


/***/ }),

/***/ "./node_modules/qrcode/lib/core/format-info.js":
/*!*****************************************************!*\
  !*** ./node_modules/qrcode/lib/core/format-info.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

const Utils = __webpack_require__(/*! ./utils */ "./node_modules/qrcode/lib/core/utils.js")

const G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0)
const G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1)
const G15_BCH = Utils.getBCHDigit(G15)

/**
 * Returns format information with relative error correction bits
 *
 * The format information is a 15-bit sequence containing 5 data bits,
 * with 10 error correction bits calculated using the (15, 5) BCH code.
 *
 * @param  {Number} errorCorrectionLevel Error correction level
 * @param  {Number} mask                 Mask pattern
 * @return {Number}                      Encoded format information bits
 */
exports.getEncodedBits = function getEncodedBits (errorCorrectionLevel, mask) {
  const data = ((errorCorrectionLevel.bit << 3) | mask)
  let d = data << 10

  while (Utils.getBCHDigit(d) - G15_BCH >= 0) {
    d ^= (G15 << (Utils.getBCHDigit(d) - G15_BCH))
  }

  // xor final data with mask pattern in order to ensure that
  // no combination of Error Correction Level and data mask pattern
  // will result in an all-zero data string
  return ((data << 10) | d) ^ G15_MASK
}


/***/ }),

/***/ "./node_modules/qrcode/lib/core/galois-field.js":
/*!******************************************************!*\
  !*** ./node_modules/qrcode/lib/core/galois-field.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports) {

const EXP_TABLE = new Uint8Array(512)
const LOG_TABLE = new Uint8Array(256)
/**
 * Precompute the log and anti-log tables for faster computation later
 *
 * For each possible value in the galois field 2^8, we will pre-compute
 * the logarithm and anti-logarithm (exponential) of this value
 *
 * ref {@link https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders#Introduction_to_mathematical_fields}
 */
;(function initTables () {
  let x = 1
  for (let i = 0; i < 255; i++) {
    EXP_TABLE[i] = x
    LOG_TABLE[x] = i

    x <<= 1 // multiply by 2

    // The QR code specification says to use byte-wise modulo 100011101 arithmetic.
    // This means that when a number is 256 or larger, it should be XORed with 0x11D.
    if (x & 0x100) { // similar to x >= 256, but a lot faster (because 0x100 == 256)
      x ^= 0x11D
    }
  }

  // Optimization: double the size of the anti-log table so that we don't need to mod 255 to
  // stay inside the bounds (because we will mainly use this table for the multiplication of
  // two GF numbers, no more).
  // @see {@link mul}
  for (let i = 255; i < 512; i++) {
    EXP_TABLE[i] = EXP_TABLE[i - 255]
  }
}())

/**
 * Returns log value of n inside Galois Field
 *
 * @param  {Number} n
 * @return {Number}
 */
exports.log = function log (n) {
  if (n < 1) throw new Error('log(' + n + ')')
  return LOG_TABLE[n]
}

/**
 * Returns anti-log value of n inside Galois Field
 *
 * @param  {Number} n
 * @return {Number}
 */
exports.exp = function exp (n) {
  return EXP_TABLE[n]
}

/**
 * Multiplies two number inside Galois Field
 *
 * @param  {Number} x
 * @param  {Number} y
 * @return {Number}
 */
exports.mul = function mul (x, y) {
  if (x === 0 || y === 0) return 0

  // should be EXP_TABLE[(LOG_TABLE[x] + LOG_TABLE[y]) % 255] if EXP_TABLE wasn't oversized
  // @see {@link initTables}
  return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]]
}


/***/ }),

/***/ "./node_modules/qrcode/lib/core/kanji-data.js":
/*!****************************************************!*\
  !*** ./node_modules/qrcode/lib/core/kanji-data.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const Mode = __webpack_require__(/*! ./mode */ "./node_modules/qrcode/lib/core/mode.js")
const Utils = __webpack_require__(/*! ./utils */ "./node_modules/qrcode/lib/core/utils.js")

function KanjiData (data) {
  this.mode = Mode.KANJI
  this.data = data
}

KanjiData.getBitsLength = function getBitsLength (length) {
  return length * 13
}

KanjiData.prototype.getLength = function getLength () {
  return this.data.length
}

KanjiData.prototype.getBitsLength = function getBitsLength () {
  return KanjiData.getBitsLength(this.data.length)
}

KanjiData.prototype.write = function (bitBuffer) {
  let i

  // In the Shift JIS system, Kanji characters are represented by a two byte combination.
  // These byte values are shifted from the JIS X 0208 values.
  // JIS X 0208 gives details of the shift coded representation.
  for (i = 0; i < this.data.length; i++) {
    let value = Utils.toSJIS(this.data[i])

    // For characters with Shift JIS values from 0x8140 to 0x9FFC:
    if (value >= 0x8140 && value <= 0x9FFC) {
      // Subtract 0x8140 from Shift JIS value
      value -= 0x8140

    // For characters with Shift JIS values from 0xE040 to 0xEBBF
    } else if (value >= 0xE040 && value <= 0xEBBF) {
      // Subtract 0xC140 from Shift JIS value
      value -= 0xC140
    } else {
      throw new Error(
        'Invalid SJIS character: ' + this.data[i] + '\n' +
        'Make sure your charset is UTF-8')
    }

    // Multiply most significant byte of result by 0xC0
    // and add least significant byte to product
    value = (((value >>> 8) & 0xff) * 0xC0) + (value & 0xff)

    // Convert result to a 13-bit binary string
    bitBuffer.put(value, 13)
  }
}

module.exports = KanjiData


/***/ }),

/***/ "./node_modules/qrcode/lib/core/mask-pattern.js":
/*!******************************************************!*\
  !*** ./node_modules/qrcode/lib/core/mask-pattern.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports) {

/**
 * Data mask pattern reference
 * @type {Object}
 */
exports.Patterns = {
  PATTERN000: 0,
  PATTERN001: 1,
  PATTERN010: 2,
  PATTERN011: 3,
  PATTERN100: 4,
  PATTERN101: 5,
  PATTERN110: 6,
  PATTERN111: 7
}

/**
 * Weighted penalty scores for the undesirable features
 * @type {Object}
 */
const PenaltyScores = {
  N1: 3,
  N2: 3,
  N3: 40,
  N4: 10
}

/**
 * Check if mask pattern value is valid
 *
 * @param  {Number}  mask    Mask pattern
 * @return {Boolean}         true if valid, false otherwise
 */
exports.isValid = function isValid (mask) {
  return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7
}

/**
 * Returns mask pattern from a value.
 * If value is not valid, returns undefined
 *
 * @param  {Number|String} value        Mask pattern value
 * @return {Number}                     Valid mask pattern or undefined
 */
exports.from = function from (value) {
  return exports.isValid(value) ? parseInt(value, 10) : undefined
}

/**
* Find adjacent modules in row/column with the same color
* and assign a penalty value.
*
* Points: N1 + i
* i is the amount by which the number of adjacent modules of the same color exceeds 5
*/
exports.getPenaltyN1 = function getPenaltyN1 (data) {
  const size = data.size
  let points = 0
  let sameCountCol = 0
  let sameCountRow = 0
  let lastCol = null
  let lastRow = null

  for (let row = 0; row < size; row++) {
    sameCountCol = sameCountRow = 0
    lastCol = lastRow = null

    for (let col = 0; col < size; col++) {
      let module = data.get(row, col)
      if (module === lastCol) {
        sameCountCol++
      } else {
        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5)
        lastCol = module
        sameCountCol = 1
      }

      module = data.get(col, row)
      if (module === lastRow) {
        sameCountRow++
      } else {
        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5)
        lastRow = module
        sameCountRow = 1
      }
    }

    if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5)
    if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5)
  }

  return points
}

/**
 * Find 2x2 blocks with the same color and assign a penalty value
 *
 * Points: N2 * (m - 1) * (n - 1)
 */
exports.getPenaltyN2 = function getPenaltyN2 (data) {
  const size = data.size
  let points = 0

  for (let row = 0; row < size - 1; row++) {
    for (let col = 0; col < size - 1; col++) {
      const last = data.get(row, col) +
        data.get(row, col + 1) +
        data.get(row + 1, col) +
        data.get(row + 1, col + 1)

      if (last === 4 || last === 0) points++
    }
  }

  return points * PenaltyScores.N2
}

/**
 * Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,
 * preceded or followed by light area 4 modules wide
 *
 * Points: N3 * number of pattern found
 */
exports.getPenaltyN3 = function getPenaltyN3 (data) {
  const size = data.size
  let points = 0
  let bitsCol = 0
  let bitsRow = 0

  for (let row = 0; row < size; row++) {
    bitsCol = bitsRow = 0
    for (let col = 0; col < size; col++) {
      bitsCol = ((bitsCol << 1) & 0x7FF) | data.get(row, col)
      if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D)) points++

      bitsRow = ((bitsRow << 1) & 0x7FF) | data.get(col, row)
      if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D)) points++
    }
  }

  return points * PenaltyScores.N3
}

/**
 * Calculate proportion of dark modules in entire symbol
 *
 * Points: N4 * k
 *
 * k is the rating of the deviation of the proportion of dark modules
 * in the symbol from 50% in steps of 5%
 */
exports.getPenaltyN4 = function getPenaltyN4 (data) {
  let darkCount = 0
  const modulesCount = data.data.length

  for (let i = 0; i < modulesCount; i++) darkCount += data.data[i]

  const k = Math.abs(Math.ceil((darkCount * 100 / modulesCount) / 5) - 10)

  return k * PenaltyScores.N4
}

/**
 * Return mask value at given position
 *
 * @param  {Number} maskPattern Pattern reference value
 * @param  {Number} i           Row
 * @param  {Number} j           Column
 * @return {Boolean}            Mask value
 */
function getMaskAt (maskPattern, i, j) {
  switch (maskPattern) {
    case exports.Patterns.PATTERN000: return (i + j) % 2 === 0
    case exports.Patterns.PATTERN001: return i % 2 === 0
    case exports.Patterns.PATTERN010: return j % 3 === 0
    case exports.Patterns.PATTERN011: return (i + j) % 3 === 0
    case exports.Patterns.PATTERN100: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0
    case exports.Patterns.PATTERN101: return (i * j) % 2 + (i * j) % 3 === 0
    case exports.Patterns.PATTERN110: return ((i * j) % 2 + (i * j) % 3) % 2 === 0
    case exports.Patterns.PATTERN111: return ((i * j) % 3 + (i + j) % 2) % 2 === 0

    default: throw new Error('bad maskPattern:' + maskPattern)
  }
}

/**
 * Apply a mask pattern to a BitMatrix
 *
 * @param  {Number}    pattern Pattern reference number
 * @param  {BitMatrix} data    BitMatrix data
 */
exports.applyMask = function applyMask (pattern, data) {
  const size = data.size

  for (let col = 0; col < size; col++) {
    for (let row = 0; row < size; row++) {
      if (data.isReserved(row, col)) continue
      data.xor(row, col, getMaskAt(pattern, row, col))
    }
  }
}

/**
 * Returns the best mask pattern for data
 *
 * @param  {BitMatrix} data
 * @return {Number} Mask pattern reference number
 */
exports.getBestMask = function getBestMask (data, setupFormatFunc) {
  const numPatterns = Object.keys(exports.Patterns).length
  let bestPattern = 0
  let lowerPenalty = Infinity

  for (let p = 0; p < numPatterns; p++) {
    setupFormatFunc(p)
    exports.applyMask(p, data)

    // Calculate penalty
    const penalty =
      exports.getPenaltyN1(data) +
      exports.getPenaltyN2(data) +
      exports.getPenaltyN3(data) +
      exports.getPenaltyN4(data)

    // Undo previously applied mask
    exports.applyMask(p, data)

    if (penalty < lowerPenalty) {
      lowerPenalty = penalty
      bestPattern = p
    }
  }

  return bestPattern
}


/***/ }),

/***/ "./node_modules/qrcode/lib/core/mode.js":
/*!**********************************************!*\
  !*** ./node_modules/qrcode/lib/core/mode.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

const VersionCheck = __webpack_require__(/*! ./version-check */ "./node_modules/qrcode/lib/core/version-check.js")
const Regex = __webpack_require__(/*! ./regex */ "./node_modules/qrcode/lib/core/regex.js")

/**
 * Numeric mode encodes data from the decimal digit set (0 - 9)
 * (byte values 30HEX to 39HEX).
 * Normally, 3 data characters are represented by 10 bits.
 *
 * @type {Object}
 */
exports.NUMERIC = {
  id: 'Numeric',
  bit: 1 << 0,
  ccBits: [10, 12, 14]
}

/**
 * Alphanumeric mode encodes data from a set of 45 characters,
 * i.e. 10 numeric digits (0 - 9),
 *      26 alphabetic characters (A - Z),
 *   and 9 symbols (SP, $, %, *, +, -, ., /, :).
 * Normally, two input characters are represented by 11 bits.
 *
 * @type {Object}
 */
exports.ALPHANUMERIC = {
  id: 'Alphanumeric',
  bit: 1 << 1,
  ccBits: [9, 11, 13]
}

/**
 * In byte mode, data is encoded at 8 bits per character.
 *
 * @type {Object}
 */
exports.BYTE = {
  id: 'Byte',
  bit: 1 << 2,
  ccBits: [8, 16, 16]
}

/**
 * The Kanji mode efficiently encodes Kanji characters in accordance with
 * the Shift JIS system based on JIS X 0208.
 * The Shift JIS values are shifted from the JIS X 0208 values.
 * JIS X 0208 gives details of the shift coded representation.
 * Each two-byte character value is compacted to a 13-bit binary codeword.
 *
 * @type {Object}
 */
exports.KANJI = {
  id: 'Kanji',
  bit: 1 << 3,
  ccBits: [8, 10, 12]
}

/**
 * Mixed mode will contain a sequences of data in a combination of any of
 * the modes described above
 *
 * @type {Object}
 */
exports.MIXED = {
  bit: -1
}

/**
 * Returns the number of bits needed to store the data length
 * according to QR Code specifications.
 *
 * @param  {Mode}   mode    Data mode
 * @param  {Number} version QR Code version
 * @return {Number}         Number of bits
 */
exports.getCharCountIndicator = function getCharCountIndicator (mode, version) {
  if (!mode.ccBits) throw new Error('Invalid mode: ' + mode)

  if (!VersionCheck.isValid(version)) {
    throw new Error('Invalid version: ' + version)
  }

  if (version >= 1 && version < 10) return mode.ccBits[0]
  else if (version < 27) return mode.ccBits[1]
  return mode.ccBits[2]
}

/**
 * Returns the most efficient mode to store the specified data
 *
 * @param  {String} dataStr Input data string
 * @return {Mode}           Best mode
 */
exports.getBestModeForData = function getBestModeForData (dataStr) {
  if (Regex.testNumeric(dataStr)) return exports.NUMERIC
  else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC
  else if (Regex.testKanji(dataStr)) return exports.KANJI
  else return exports.BYTE
}

/**
 * Return mode name as string
 *
 * @param {Mode} mode Mode object
 * @returns {String}  Mode name
 */
exports.toString = function toString (mode) {
  if (mode && mode.id) return mode.id
  throw new Error('Invalid mode')
}

/**
 * Check if input param is a valid mode object
 *
 * @param   {Mode}    mode Mode object
 * @returns {Boolean} True if valid mode, false otherwise
 */
exports.isValid = function isValid (mode) {
  return mode && mode.bit && mode.ccBits
}

/**
 * Get mode object from its name
 *
 * @param   {String} string Mode name
 * @returns {Mode}          Mode object
 */
function fromString (string) {
  if (typeof string !== 'string') {
    throw new Error('Param is not a string')
  }

  const lcStr = string.toLowerCase()

  switch (lcStr) {
    case 'numeric':
      return exports.NUMERIC
    case 'alphanumeric':
      return exports.ALPHANUMERIC
    case 'kanji':
      return exports.KANJI
    case 'byte':
      return exports.BYTE
    default:
      throw new Error('Unknown mode: ' + string)
  }
}

/**
 * Returns mode from a value.
 * If value is not a valid mode, returns defaultValue
 *
 * @param  {Mode|String} value        Encoding mode
 * @param  {Mode}        defaultValue Fallback value
 * @return {Mode}                     Encoding mode
 */
exports.from = function from (value, defaultValue) {
  if (exports.isValid(value)) {
    return value
  }

  try {
    return fromString(value)
  } catch (e) {
    return defaultValue
  }
}


/***/ }),

/***/ "./node_modules/qrcode/lib/core/numeric-data.js":
/*!******************************************************!*\
  !*** ./node_modules/qrcode/lib/core/numeric-data.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const Mode = __webpack_require__(/*! ./mode */ "./node_modules/qrcode/lib/core/mode.js")

function NumericData (data) {
  this.mode = Mode.NUMERIC
  this.data = data.toString()
}

NumericData.getBitsLength = function getBitsLength (length) {
  return 10 * Math.floor(length / 3) + ((length % 3) ? ((length % 3) * 3 + 1) : 0)
}

NumericData.prototype.getLength = function getLength () {
  return this.data.length
}

NumericData.prototype.getBitsLength = function getBitsLength () {
  return NumericData.getBitsLength(this.data.length)
}

NumericData.prototype.write = function write (bitBuffer) {
  let i, group, value

  // The input data string is divided into groups of three digits,
  // and each group is converted to its 10-bit binary equivalent.
  for (i = 0; i + 3 <= this.data.length; i += 3) {
    group = this.data.substr(i, 3)
    value = parseInt(group, 10)

    bitBuffer.put(value, 10)
  }

  // If the number of input digits is not an exact multiple of three,
  // the final one or two digits are converted to 4 or 7 bits respectively.
  const remainingNum = this.data.length - i
  if (remainingNum > 0) {
    group = this.data.substr(i)
    value = parseInt(group, 10)

    bitBuffer.put(value, remainingNum * 3 + 1)
  }
}

module.exports = NumericData


/***/ }),

/***/ "./node_modules/qrcode/lib/core/polynomial.js":
/*!****************************************************!*\
  !*** ./node_modules/qrcode/lib/core/polynomial.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

const GF = __webpack_require__(/*! ./galois-field */ "./node_modules/qrcode/lib/core/galois-field.js")

/**
 * Multiplies two polynomials inside Galois Field
 *
 * @param  {Uint8Array} p1 Polynomial
 * @param  {Uint8Array} p2 Polynomial
 * @return {Uint8Array}    Product of p1 and p2
 */
exports.mul = function mul (p1, p2) {
  const coeff = new Uint8Array(p1.length + p2.length - 1)

  for (let i = 0; i < p1.length; i++) {
    for (let j = 0; j < p2.length; j++) {
      coeff[i + j] ^= GF.mul(p1[i], p2[j])
    }
  }

  return coeff
}

/**
 * Calculate the remainder of polynomials division
 *
 * @param  {Uint8Array} divident Polynomial
 * @param  {Uint8Array} divisor  Polynomial
 * @return {Uint8Array}          Remainder
 */
exports.mod = function mod (divident, divisor) {
  let result = new Uint8Array(divident)

  while ((result.length - divisor.length) >= 0) {
    const coeff = result[0]

    for (let i = 0; i < divisor.length; i++) {
      result[i] ^= GF.mul(divisor[i], coeff)
    }

    // remove all zeros from buffer head
    let offset = 0
    while (offset < result.length && result[offset] === 0) offset++
    result = result.slice(offset)
  }

  return result
}

/**
 * Generate an irreducible generator polynomial of specified degree
 * (used by Reed-Solomon encoder)
 *
 * @param  {Number} degree Degree of the generator polynomial
 * @return {Uint8Array}    Buffer containing polynomial coefficients
 */
exports.generateECPolynomial = function generateECPolynomial (degree) {
  let poly = new Uint8Array([1])
  for (let i = 0; i < degree; i++) {
    poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]))
  }

  return poly
}


/***/ }),

/***/ "./node_modules/qrcode/lib/core/qrcode.js":
/*!************************************************!*\
  !*** ./node_modules/qrcode/lib/core/qrcode.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

const Utils = __webpack_require__(/*! ./utils */ "./node_modules/qrcode/lib/core/utils.js")
const ECLevel = __webpack_require__(/*! ./error-correction-level */ "./node_modules/qrcode/lib/core/error-correction-level.js")
const BitBuffer = __webpack_require__(/*! ./bit-buffer */ "./node_modules/qrcode/lib/core/bit-buffer.js")
const BitMatrix = __webpack_require__(/*! ./bit-matrix */ "./node_modules/qrcode/lib/core/bit-matrix.js")
const AlignmentPattern = __webpack_require__(/*! ./alignment-pattern */ "./node_modules/qrcode/lib/core/alignment-pattern.js")
const FinderPattern = __webpack_require__(/*! ./finder-pattern */ "./node_modules/qrcode/lib/core/finder-pattern.js")
const MaskPattern = __webpack_require__(/*! ./mask-pattern */ "./node_modules/qrcode/lib/core/mask-pattern.js")
const ECCode = __webpack_require__(/*! ./error-correction-code */ "./node_modules/qrcode/lib/core/error-correction-code.js")
const ReedSolomonEncoder = __webpack_require__(/*! ./reed-solomon-encoder */ "./node_modules/qrcode/lib/core/reed-solomon-encoder.js")
const Version = __webpack_require__(/*! ./version */ "./node_modules/qrcode/lib/core/version.js")
const FormatInfo = __webpack_require__(/*! ./format-info */ "./node_modules/qrcode/lib/core/format-info.js")
const Mode = __webpack_require__(/*! ./mode */ "./node_modules/qrcode/lib/core/mode.js")
const Segments = __webpack_require__(/*! ./segments */ "./node_modules/qrcode/lib/core/segments.js")

/**
 * QRCode for JavaScript
 *
 * modified by Ryan Day for nodejs support
 * Copyright (c) 2011 Ryan Day
 *
 * Licensed under the MIT license:
 *   http://www.opensource.org/licenses/mit-license.php
 *
//---------------------------------------------------------------------
// QRCode for JavaScript
//
// Copyright (c) 2009 Kazuhiko Arase
//
// URL: http://www.d-project.com/
//
// Licensed under the MIT license:
//   http://www.opensource.org/licenses/mit-license.php
//
// The word "QR Code" is registered trademark of
// DENSO WAVE INCORPORATED
//   http://www.denso-wave.com/qrcode/faqpatent-e.html
//
//---------------------------------------------------------------------
*/

/**
 * Add finder patterns bits to matrix
 *
 * @param  {BitMatrix} matrix  Modules matrix
 * @param  {Number}    version QR Code version
 */
function setupFinderPattern (matrix, version) {
  const size = matrix.size
  const pos = FinderPattern.getPositions(version)

  for (let i = 0; i < pos.length; i++) {
    const row = pos[i][0]
    const col = pos[i][1]

    for (let r = -1; r <= 7; r++) {
      if (row + r <= -1 || size <= row + r) continue

      for (let c = -1; c <= 7; c++) {
        if (col + c <= -1 || size <= col + c) continue

        if ((r >= 0 && r <= 6 && (c === 0 || c === 6)) ||
          (c >= 0 && c <= 6 && (r === 0 || r === 6)) ||
          (r >= 2 && r <= 4 && c >= 2 && c <= 4)) {
          matrix.set(row + r, col + c, true, true)
        } else {
          matrix.set(row + r, col + c, false, true)
        }
      }
    }
  }
}

/**
 * Add timing pattern bits to matrix
 *
 * Note: this function must be called before {@link setupAlignmentPattern}
 *
 * @param  {BitMatrix} matrix Modules matrix
 */
function setupTimingPattern (matrix) {
  const size = matrix.size

  for (let r = 8; r < size - 8; r++) {
    const value = r % 2 === 0
    matrix.set(r, 6, value, true)
    matrix.set(6, r, value, true)
  }
}

/**
 * Add alignment patterns bits to matrix
 *
 * Note: this function must be called after {@link setupTimingPattern}
 *
 * @param  {BitMatrix} matrix  Modules matrix
 * @param  {Number}    version QR Code version
 */
function setupAlignmentPattern (matrix, version) {
  const pos = AlignmentPattern.getPositions(version)

  for (let i = 0; i < pos.length; i++) {
    const row = pos[i][0]
    const col = pos[i][1]

    for (let r = -2; r <= 2; r++) {
      for (let c = -2; c <= 2; c++) {
        if (r === -2 || r === 2 || c === -2 || c === 2 ||
          (r === 0 && c === 0)) {
          matrix.set(row + r, col + c, true, true)
        } else {
          matrix.set(row + r, col + c, false, true)
        }
      }
    }
  }
}

/**
 * Add version info bits to matrix
 *
 * @param  {BitMatrix} matrix  Modules matrix
 * @param  {Number}    version QR Code version
 */
function setupVersionInfo (matrix, version) {
  const size = matrix.size
  const bits = Version.getEncodedBits(version)
  let row, col, mod

  for (let i = 0; i < 18; i++) {
    row = Math.floor(i / 3)
    col = i % 3 + size - 8 - 3
    mod = ((bits >> i) & 1) === 1

    matrix.set(row, col, mod, true)
    matrix.set(col, row, mod, true)
  }
}

/**
 * Add format info bits to matrix
 *
 * @param  {BitMatrix} matrix               Modules matrix
 * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level
 * @param  {Number}    maskPattern          Mask pattern reference value
 */
function setupFormatInfo (matrix, errorCorrectionLevel, maskPattern) {
  const size = matrix.size
  const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern)
  let i, mod

  for (i = 0; i < 15; i++) {
    mod = ((bits >> i) & 1) === 1

    // vertical
    if (i < 6) {
      matrix.set(i, 8, mod, true)
    } else if (i < 8) {
      matrix.set(i + 1, 8, mod, true)
    } else {
      matrix.set(size - 15 + i, 8, mod, true)
    }

    // horizontal
    if (i < 8) {
      matrix.set(8, size - i - 1, mod, true)
    } else if (i < 9) {
      matrix.set(8, 15 - i - 1 + 1, mod, true)
    } else {
      matrix.set(8, 15 - i - 1, mod, true)
    }
  }

  // fixed module
  matrix.set(size - 8, 8, 1, true)
}

/**
 * Add encoded data bits to matrix
 *
 * @param  {BitMatrix}  matrix Modules matrix
 * @param  {Uint8Array} data   Data codewords
 */
function setupData (matrix, data) {
  const size = matrix.size
  let inc = -1
  let row = size - 1
  let bitIndex = 7
  let byteIndex = 0

  for (let col = size - 1; col > 0; col -= 2) {
    if (col === 6) col--

    while (true) {
      for (let c = 0; c < 2; c++) {
        if (!matrix.isReserved(row, col - c)) {
          let dark = false

          if (byteIndex < data.length) {
            dark = (((data[byteIndex] >>> bitIndex) & 1) === 1)
          }

          matrix.set(row, col - c, dark)
          bitIndex--

          if (bitIndex === -1) {
            byteIndex++
            bitIndex = 7
          }
        }
      }

      row += inc

      if (row < 0 || size <= row) {
        row -= inc
        inc = -inc
        break
      }
    }
  }
}

/**
 * Create encoded codewords from data input
 *
 * @param  {Number}   version              QR Code version
 * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level
 * @param  {ByteData} data                 Data input
 * @return {Uint8Array}                    Buffer containing encoded codewords
 */
function createData (version, errorCorrectionLevel, segments) {
  // Prepare data buffer
  const buffer = new BitBuffer()

  segments.forEach(function (data) {
    // prefix data with mode indicator (4 bits)
    buffer.put(data.mode.bit, 4)

    // Prefix data with character count indicator.
    // The character count indicator is a string of bits that represents the
    // number of characters that are being encoded.
    // The character count indicator must be placed after the mode indicator
    // and must be a certain number of bits long, depending on the QR version
    // and data mode
    // @see {@link Mode.getCharCountIndicator}.
    buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version))

    // add binary data sequence to buffer
    data.write(buffer)
  })

  // Calculate required number of bits
  const totalCodewords = Utils.getSymbolTotalCodewords(version)
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)
  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8

  // Add a terminator.
  // If the bit string is shorter than the total number of required bits,
  // a terminator of up to four 0s must be added to the right side of the string.
  // If the bit string is more than four bits shorter than the required number of bits,
  // add four 0s to the end.
  if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
    buffer.put(0, 4)
  }

  // If the bit string is fewer than four bits shorter, add only the number of 0s that
  // are needed to reach the required number of bits.

  // After adding the terminator, if the number of bits in the string is not a multiple of 8,
  // pad the string on the right with 0s to make the string's length a multiple of 8.
  while (buffer.getLengthInBits() % 8 !== 0) {
    buffer.putBit(0)
  }

  // Add pad bytes if the string is still shorter than the total number of required bits.
  // Extend the buffer to fill the data capacity of the symbol corresponding to
  // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)
  // and 00010001 (0x11) alternately.
  const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8
  for (let i = 0; i < remainingByte; i++) {
    buffer.put(i % 2 ? 0x11 : 0xEC, 8)
  }

  return createCodewords(buffer, version, errorCorrectionLevel)
}

/**
 * Encode input data with Reed-Solomon and return codewords with
 * relative error correction bits
 *
 * @param  {BitBuffer} bitBuffer            Data to encode
 * @param  {Number}    version              QR Code version
 * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level
 * @return {Uint8Array}                     Buffer containing encoded codewords
 */
function createCodewords (bitBuffer, version, errorCorrectionLevel) {
  // Total codewords for this QR code version (Data + Error correction)
  const totalCodewords = Utils.getSymbolTotalCodewords(version)

  // Total number of error correction codewords
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)

  // Total number of data codewords
  const dataTotalCodewords = totalCodewords - ecTotalCodewords

  // Total number of blocks
  const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel)

  // Calculate how many blocks each group should contain
  const blocksInGroup2 = totalCodewords % ecTotalBlocks
  const blocksInGroup1 = ecTotalBlocks - blocksInGroup2

  const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks)

  const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks)
  const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1

  // Number of EC codewords is the same for both groups
  const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1

  // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount
  const rs = new ReedSolomonEncoder(ecCount)

  let offset = 0
  const dcData = new Array(ecTotalBlocks)
  const ecData = new Array(ecTotalBlocks)
  let maxDataSize = 0
  const buffer = new Uint8Array(bitBuffer.buffer)

  // Divide the buffer into the required number of blocks
  for (let b = 0; b < ecTotalBlocks; b++) {
    const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2

    // extract a block of data from buffer
    dcData[b] = buffer.slice(offset, offset + dataSize)

    // Calculate EC codewords for this data block
    ecData[b] = rs.encode(dcData[b])

    offset += dataSize
    maxDataSize = Math.max(maxDataSize, dataSize)
  }

  // Create final data
  // Interleave the data and error correction codewords from each block
  const data = new Uint8Array(totalCodewords)
  let index = 0
  let i, r

  // Add data codewords
  for (i = 0; i < maxDataSize; i++) {
    for (r = 0; r < ecTotalBlocks; r++) {
      if (i < dcData[r].length) {
        data[index++] = dcData[r][i]
      }
    }
  }

  // Apped EC codewords
  for (i = 0; i < ecCount; i++) {
    for (r = 0; r < ecTotalBlocks; r++) {
      data[index++] = ecData[r][i]
    }
  }

  return data
}

/**
 * Build QR Code symbol
 *
 * @param  {String} data                 Input string
 * @param  {Number} version              QR Code version
 * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level
 * @param  {MaskPattern} maskPattern     Mask pattern
 * @return {Object}                      Object containing symbol data
 */
function createSymbol (data, version, errorCorrectionLevel, maskPattern) {
  let segments

  if (Array.isArray(data)) {
    segments = Segments.fromArray(data)
  } else if (typeof data === 'string') {
    let estimatedVersion = version

    if (!estimatedVersion) {
      const rawSegments = Segments.rawSplit(data)

      // Estimate best version that can contain raw splitted segments
      estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel)
    }

    // Build optimized segments
    // If estimated version is undefined, try with the highest version
    segments = Segments.fromString(data, estimatedVersion || 40)
  } else {
    throw new Error('Invalid data')
  }

  // Get the min version that can contain data
  const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel)

  // If no version is found, data cannot be stored
  if (!bestVersion) {
    throw new Error('The amount of data is too big to be stored in a QR Code')
  }

  // If not specified, use min version as default
  if (!version) {
    version = bestVersion

  // Check if the specified version can contain the data
  } else if (version < bestVersion) {
    throw new Error('\n' +
      'The chosen QR Code version cannot contain this amount of data.\n' +
      'Minimum version required to store current data is: ' + bestVersion + '.\n'
    )
  }

  const dataBits = createData(version, errorCorrectionLevel, segments)

  // Allocate matrix buffer
  const moduleCount = Utils.getSymbolSize(version)
  const modules = new BitMatrix(moduleCount)

  // Add function modules
  setupFinderPattern(modules, version)
  setupTimingPattern(modules)
  setupAlignmentPattern(modules, version)

  // Add temporary dummy bits for format info just to set them as reserved.
  // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}
  // since the masking operation must be performed only on the encoding region.
  // These blocks will be replaced with correct values later in code.
  setupFormatInfo(modules, errorCorrectionLevel, 0)

  if (version >= 7) {
    setupVersionInfo(modules, version)
  }

  // Add data codewords
  setupData(modules, dataBits)

  if (isNaN(maskPattern)) {
    // Find best mask pattern
    maskPattern = MaskPattern.getBestMask(modules,
      setupFormatInfo.bind(null, modules, errorCorrectionLevel))
  }

  // Apply mask pattern
  MaskPattern.applyMask(maskPattern, modules)

  // Replace format info bits with correct values
  setupFormatInfo(modules, errorCorrectionLevel, maskPattern)

  return {
    modules: modules,
    version: version,
    errorCorrectionLevel: errorCorrectionLevel,
    maskPattern: maskPattern,
    segments: segments
  }
}

/**
 * QR Code
 *
 * @param {String | Array} data                 Input data
 * @param {Object} options                      Optional configurations
 * @param {Number} options.version              QR Code version
 * @param {String} options.errorCorrectionLevel Error correction level
 * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis
 */
exports.create = function create (data, options) {
  if (typeof data === 'undefined' || data === '') {
    throw new Error('No input text')
  }

  let errorCorrectionLevel = ECLevel.M
  let version
  let mask

  if (typeof options !== 'undefined') {
    // Use higher error correction level as default
    errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M)
    version = Version.from(options.version)
    mask = MaskPattern.from(options.maskPattern)

    if (options.toSJISFunc) {
      Utils.setToSJISFunction(options.toSJISFunc)
    }
  }

  return createSymbol(data, version, errorCorrectionLevel, mask)
}


/***/ }),

/***/ "./node_modules/qrcode/lib/core/reed-solomon-encoder.js":
/*!**************************************************************!*\
  !*** ./node_modules/qrcode/lib/core/reed-solomon-encoder.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const Polynomial = __webpack_require__(/*! ./polynomial */ "./node_modules/qrcode/lib/core/polynomial.js")

function ReedSolomonEncoder (degree) {
  this.genPoly = undefined
  this.degree = degree

  if (this.degree) this.initialize(this.degree)
}

/**
 * Initialize the encoder.
 * The input param should correspond to the number of error correction codewords.
 *
 * @param  {Number} degree
 */
ReedSolomonEncoder.prototype.initialize = function initialize (degree) {
  // create an irreducible generator polynomial
  this.degree = degree
  this.genPoly = Polynomial.generateECPolynomial(this.degree)
}

/**
 * Encodes a chunk of data
 *
 * @param  {Uint8Array} data Buffer containing input data
 * @return {Uint8Array}      Buffer containing encoded data
 */
ReedSolomonEncoder.prototype.encode = function encode (data) {
  if (!this.genPoly) {
    throw new Error('Encoder not initialized')
  }

  // Calculate EC for this data block
  // extends data size to data+genPoly size
  const paddedData = new Uint8Array(data.length + this.degree)
  paddedData.set(data)

  // The error correction codewords are the remainder after dividing the data codewords
  // by a generator polynomial
  const remainder = Polynomial.mod(paddedData, this.genPoly)

  // return EC data blocks (last n byte, where n is the degree of genPoly)
  // If coefficients number in remainder are less than genPoly degree,
  // pad with 0s to the left to reach the needed number of coefficients
  const start = this.degree - remainder.length
  if (start > 0) {
    const buff = new Uint8Array(this.degree)
    buff.set(remainder, start)

    return buff
  }

  return remainder
}

module.exports = ReedSolomonEncoder


/***/ }),

/***/ "./node_modules/qrcode/lib/core/regex.js":
/*!***********************************************!*\
  !*** ./node_modules/qrcode/lib/core/regex.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports) {

const numeric = '[0-9]+'
const alphanumeric = '[A-Z $%*+\\-./:]+'
let kanji = '(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|' +
  '[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|' +
  '[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|' +
  '[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+'
kanji = kanji.replace(/u/g, '\\u')

const byte = '(?:(?![A-Z0-9 $%*+\\-./:]|' + kanji + ')(?:.|[\r\n]))+'

exports.KANJI = new RegExp(kanji, 'g')
exports.BYTE_KANJI = new RegExp('[^A-Z0-9 $%*+\\-./:]+', 'g')
exports.BYTE = new RegExp(byte, 'g')
exports.NUMERIC = new RegExp(numeric, 'g')
exports.ALPHANUMERIC = new RegExp(alphanumeric, 'g')

const TEST_KANJI = new RegExp('^' + kanji + '$')
const TEST_NUMERIC = new RegExp('^' + numeric + '$')
const TEST_ALPHANUMERIC = new RegExp('^[A-Z0-9 $%*+\\-./:]+$')

exports.testKanji = function testKanji (str) {
  return TEST_KANJI.test(str)
}

exports.testNumeric = function testNumeric (str) {
  return TEST_NUMERIC.test(str)
}

exports.testAlphanumeric = function testAlphanumeric (str) {
  return TEST_ALPHANUMERIC.test(str)
}


/***/ }),

/***/ "./node_modules/qrcode/lib/core/segments.js":
/*!**************************************************!*\
  !*** ./node_modules/qrcode/lib/core/segments.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

const Mode = __webpack_require__(/*! ./mode */ "./node_modules/qrcode/lib/core/mode.js")
const NumericData = __webpack_require__(/*! ./numeric-data */ "./node_modules/qrcode/lib/core/numeric-data.js")
const AlphanumericData = __webpack_require__(/*! ./alphanumeric-data */ "./node_modules/qrcode/lib/core/alphanumeric-data.js")
const ByteData = __webpack_require__(/*! ./byte-data */ "./node_modules/qrcode/lib/core/byte-data.js")
const KanjiData = __webpack_require__(/*! ./kanji-data */ "./node_modules/qrcode/lib/core/kanji-data.js")
const Regex = __webpack_require__(/*! ./regex */ "./node_modules/qrcode/lib/core/regex.js")
const Utils = __webpack_require__(/*! ./utils */ "./node_modules/qrcode/lib/core/utils.js")
const dijkstra = __webpack_require__(/*! dijkstrajs */ "./node_modules/dijkstrajs/dijkstra.js")

/**
 * Returns UTF8 byte length
 *
 * @param  {String} str Input string
 * @return {Number}     Number of byte
 */
function getStringByteLength (str) {
  return unescape(encodeURIComponent(str)).length
}

/**
 * Get a list of segments of the specified mode
 * from a string
 *
 * @param  {Mode}   mode Segment mode
 * @param  {String} str  String to process
 * @return {Array}       Array of object with segments data
 */
function getSegments (regex, mode, str) {
  const segments = []
  let result

  while ((result = regex.exec(str)) !== null) {
    segments.push({
      data: result[0],
      index: result.index,
      mode: mode,
      length: result[0].length
    })
  }

  return segments
}

/**
 * Extracts a series of segments with the appropriate
 * modes from a string
 *
 * @param  {String} dataStr Input string
 * @return {Array}          Array of object with segments data
 */
function getSegmentsFromString (dataStr) {
  const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr)
  const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr)
  let byteSegs
  let kanjiSegs

  if (Utils.isKanjiModeEnabled()) {
    byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr)
    kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr)
  } else {
    byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr)
    kanjiSegs = []
  }

  const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs)

  return segs
    .sort(function (s1, s2) {
      return s1.index - s2.index
    })
    .map(function (obj) {
      return {
        data: obj.data,
        mode: obj.mode,
        length: obj.length
      }
    })
}

/**
 * Returns how many bits are needed to encode a string of
 * specified length with the specified mode
 *
 * @param  {Number} length String length
 * @param  {Mode} mode     Segment mode
 * @return {Number}        Bit length
 */
function getSegmentBitsLength (length, mode) {
  switch (mode) {
    case Mode.NUMERIC:
      return NumericData.getBitsLength(length)
    case Mode.ALPHANUMERIC:
      return AlphanumericData.getBitsLength(length)
    case Mode.KANJI:
      return KanjiData.getBitsLength(length)
    case Mode.BYTE:
      return ByteData.getBitsLength(length)
  }
}

/**
 * Merges adjacent segments which have the same mode
 *
 * @param  {Array} segs Array of object with segments data
 * @return {Array}      Array of object with segments data
 */
function mergeSegments (segs) {
  return segs.reduce(function (acc, curr) {
    const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null
    if (prevSeg && prevSeg.mode === curr.mode) {
      acc[acc.length - 1].data += curr.data
      return acc
    }

    acc.push(curr)
    return acc
  }, [])
}

/**
 * Generates a list of all possible nodes combination which
 * will be used to build a segments graph.
 *
 * Nodes are divided by groups. Each group will contain a list of all the modes
 * in which is possible to encode the given text.
 *
 * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.
 * The group for '12345' will contain then 3 objects, one for each
 * possible encoding mode.
 *
 * Each node represents a possible segment.
 *
 * @param  {Array} segs Array of object with segments data
 * @return {Array}      Array of object with segments data
 */
function buildNodes (segs) {
  const nodes = []
  for (let i = 0; i < segs.length; i++) {
    const seg = segs[i]

    switch (seg.mode) {
      case Mode.NUMERIC:
        nodes.push([seg,
          { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
          { data: seg.data, mode: Mode.BYTE, length: seg.length }
        ])
        break
      case Mode.ALPHANUMERIC:
        nodes.push([seg,
          { data: seg.data, mode: Mode.BYTE, length: seg.length }
        ])
        break
      case Mode.KANJI:
        nodes.push([seg,
          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
        ])
        break
      case Mode.BYTE:
        nodes.push([
          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
        ])
    }
  }

  return nodes
}

/**
 * Builds a graph from a list of nodes.
 * All segments in each node group will be connected with all the segments of
 * the next group and so on.
 *
 * At each connection will be assigned a weight depending on the
 * segment's byte length.
 *
 * @param  {Array} nodes    Array of object with segments data
 * @param  {Number} version QR Code version
 * @return {Object}         Graph of all possible segments
 */
function buildGraph (nodes, version) {
  const table = {}
  const graph = { start: {} }
  let prevNodeIds = ['start']

  for (let i = 0; i < nodes.length; i++) {
    const nodeGroup = nodes[i]
    const currentNodeIds = []

    for (let j = 0; j < nodeGroup.length; j++) {
      const node = nodeGroup[j]
      const key = '' + i + j

      currentNodeIds.push(key)
      table[key] = { node: node, lastCount: 0 }
      graph[key] = {}

      for (let n = 0; n < prevNodeIds.length; n++) {
        const prevNodeId = prevNodeIds[n]

        if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
          graph[prevNodeId][key] =
            getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) -
            getSegmentBitsLength(table[prevNodeId].lastCount, node.mode)

          table[prevNodeId].lastCount += node.length
        } else {
          if (table[prevNodeId]) table[prevNodeId].lastCount = node.length

          graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) +
            4 + Mode.getCharCountIndicator(node.mode, version) // switch cost
        }
      }
    }

    prevNodeIds = currentNodeIds
  }

  for (let n = 0; n < prevNodeIds.length; n++) {
    graph[prevNodeIds[n]].end = 0
  }

  return { map: graph, table: table }
}

/**
 * Builds a segment from a specified data and mode.
 * If a mode is not specified, the more suitable will be used.
 *
 * @param  {String} data             Input data
 * @param  {Mode | String} modesHint Data mode
 * @return {Segment}                 Segment
 */
function buildSingleSegment (data, modesHint) {
  let mode
  const bestMode = Mode.getBestModeForData(data)

  mode = Mode.from(modesHint, bestMode)

  // Make sure data can be encoded
  if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
    throw new Error('"' + data + '"' +
      ' cannot be encoded with mode ' + Mode.toString(mode) +
      '.\n Suggested mode is: ' + Mode.toString(bestMode))
  }

  // Use Mode.BYTE if Kanji support is disabled
  if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
    mode = Mode.BYTE
  }

  switch (mode) {
    case Mode.NUMERIC:
      return new NumericData(data)

    case Mode.ALPHANUMERIC:
      return new AlphanumericData(data)

    case Mode.KANJI:
      return new KanjiData(data)

    case Mode.BYTE:
      return new ByteData(data)
  }
}

/**
 * Builds a list of segments from an array.
 * Array can contain Strings or Objects with segment's info.
 *
 * For each item which is a string, will be generated a segment with the given
 * string and the more appropriate encoding mode.
 *
 * For each item which is an object, will be generated a segment with the given
 * data and mode.
 * Objects must contain at least the property "data".
 * If property "mode" is not present, the more suitable mode will be used.
 *
 * @param  {Array} array Array of objects with segments data
 * @return {Array}       Array of Segments
 */
exports.fromArray = function fromArray (array) {
  return array.reduce(function (acc, seg) {
    if (typeof seg === 'string') {
      acc.push(buildSingleSegment(seg, null))
    } else if (seg.data) {
      acc.push(buildSingleSegment(seg.data, seg.mode))
    }

    return acc
  }, [])
}

/**
 * Builds an optimized sequence of segments from a string,
 * which will produce the shortest possible bitstream.
 *
 * @param  {String} data    Input string
 * @param  {Number} version QR Code version
 * @return {Array}          Array of segments
 */
exports.fromString = function fromString (data, version) {
  const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled())

  const nodes = buildNodes(segs)
  const graph = buildGraph(nodes, version)
  const path = dijkstra.find_path(graph.map, 'start', 'end')

  const optimizedSegs = []
  for (let i = 1; i < path.length - 1; i++) {
    optimizedSegs.push(graph.table[path[i]].node)
  }

  return exports.fromArray(mergeSegments(optimizedSegs))
}

/**
 * Splits a string in various segments with the modes which
 * best represent their content.
 * The produced segments are far from being optimized.
 * The output of this function is only used to estimate a QR Code version
 * which may contain the data.
 *
 * @param  {string} data Input string
 * @return {Array}       Array of segments
 */
exports.rawSplit = function rawSplit (data) {
  return exports.fromArray(
    getSegmentsFromString(data, Utils.isKanjiModeEnabled())
  )
}


/***/ }),

/***/ "./node_modules/qrcode/lib/core/utils.js":
/*!***********************************************!*\
  !*** ./node_modules/qrcode/lib/core/utils.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports) {

let toSJISFunction
const CODEWORDS_COUNT = [
  0, // Not used
  26, 44, 70, 100, 134, 172, 196, 242, 292, 346,
  404, 466, 532, 581, 655, 733, 815, 901, 991, 1085,
  1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185,
  2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706
]

/**
 * Returns the QR Code size for the specified version
 *
 * @param  {Number} version QR Code version
 * @return {Number}         size of QR code
 */
exports.getSymbolSize = function getSymbolSize (version) {
  if (!version) throw new Error('"version" cannot be null or undefined')
  if (version < 1 || version > 40) throw new Error('"version" should be in range from 1 to 40')
  return version * 4 + 17
}

/**
 * Returns the total number of codewords used to store data and EC information.
 *
 * @param  {Number} version QR Code version
 * @return {Number}         Data length in bits
 */
exports.getSymbolTotalCodewords = function getSymbolTotalCodewords (version) {
  return CODEWORDS_COUNT[version]
}

/**
 * Encode data with Bose-Chaudhuri-Hocquenghem
 *
 * @param  {Number} data Value to encode
 * @return {Number}      Encoded value
 */
exports.getBCHDigit = function (data) {
  let digit = 0

  while (data !== 0) {
    digit++
    data >>>= 1
  }

  return digit
}

exports.setToSJISFunction = function setToSJISFunction (f) {
  if (typeof f !== 'function') {
    throw new Error('"toSJISFunc" is not a valid function.')
  }

  toSJISFunction = f
}

exports.isKanjiModeEnabled = function () {
  return typeof toSJISFunction !== 'undefined'
}

exports.toSJIS = function toSJIS (kanji) {
  return toSJISFunction(kanji)
}


/***/ }),

/***/ "./node_modules/qrcode/lib/core/version-check.js":
/*!*******************************************************!*\
  !*** ./node_modules/qrcode/lib/core/version-check.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports) {

/**
 * Check if QR Code version is valid
 *
 * @param  {Number}  version QR Code version
 * @return {Boolean}         true if valid version, false otherwise
 */
exports.isValid = function isValid (version) {
  return !isNaN(version) && version >= 1 && version <= 40
}


/***/ }),

/***/ "./node_modules/qrcode/lib/core/version.js":
/*!*************************************************!*\
  !*** ./node_modules/qrcode/lib/core/version.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

const Utils = __webpack_require__(/*! ./utils */ "./node_modules/qrcode/lib/core/utils.js")
const ECCode = __webpack_require__(/*! ./error-correction-code */ "./node_modules/qrcode/lib/core/error-correction-code.js")
const ECLevel = __webpack_require__(/*! ./error-correction-level */ "./node_modules/qrcode/lib/core/error-correction-level.js")
const Mode = __webpack_require__(/*! ./mode */ "./node_modules/qrcode/lib/core/mode.js")
const VersionCheck = __webpack_require__(/*! ./version-check */ "./node_modules/qrcode/lib/core/version-check.js")

// Generator polynomial used to encode version information
const G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0)
const G18_BCH = Utils.getBCHDigit(G18)

function getBestVersionForDataLength (mode, length, errorCorrectionLevel) {
  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
      return currentVersion
    }
  }

  return undefined
}

function getReservedBitsCount (mode, version) {
  // Character count indicator + mode indicator bits
  return Mode.getCharCountIndicator(mode, version) + 4
}

function getTotalBitsFromDataArray (segments, version) {
  let totalBits = 0

  segments.forEach(function (data) {
    const reservedBits = getReservedBitsCount(data.mode, version)
    totalBits += reservedBits + data.getBitsLength()
  })

  return totalBits
}

function getBestVersionForMixedData (segments, errorCorrectionLevel) {
  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
    const length = getTotalBitsFromDataArray(segments, currentVersion)
    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
      return currentVersion
    }
  }

  return undefined
}

/**
 * Returns version number from a value.
 * If value is not a valid version, returns defaultValue
 *
 * @param  {Number|String} value        QR Code version
 * @param  {Number}        defaultValue Fallback value
 * @return {Number}                     QR Code version number
 */
exports.from = function from (value, defaultValue) {
  if (VersionCheck.isValid(value)) {
    return parseInt(value, 10)
  }

  return defaultValue
}

/**
 * Returns how much data can be stored with the specified QR code version
 * and error correction level
 *
 * @param  {Number} version              QR Code version (1-40)
 * @param  {Number} errorCorrectionLevel Error correction level
 * @param  {Mode}   mode                 Data mode
 * @return {Number}                      Quantity of storable data
 */
exports.getCapacity = function getCapacity (version, errorCorrectionLevel, mode) {
  if (!VersionCheck.isValid(version)) {
    throw new Error('Invalid QR Code version')
  }

  // Use Byte mode as default
  if (typeof mode === 'undefined') mode = Mode.BYTE

  // Total codewords for this QR code version (Data + Error correction)
  const totalCodewords = Utils.getSymbolTotalCodewords(version)

  // Total number of error correction codewords
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)

  // Total number of data codewords
  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8

  if (mode === Mode.MIXED) return dataTotalCodewordsBits

  const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version)

  // Return max number of storable codewords
  switch (mode) {
    case Mode.NUMERIC:
      return Math.floor((usableBits / 10) * 3)

    case Mode.ALPHANUMERIC:
      return Math.floor((usableBits / 11) * 2)

    case Mode.KANJI:
      return Math.floor(usableBits / 13)

    case Mode.BYTE:
    default:
      return Math.floor(usableBits / 8)
  }
}

/**
 * Returns the minimum version needed to contain the amount of data
 *
 * @param  {Segment} data                    Segment of data
 * @param  {Number} [errorCorrectionLevel=H] Error correction level
 * @param  {Mode} mode                       Data mode
 * @return {Number}                          QR Code version
 */
exports.getBestVersionForData = function getBestVersionForData (data, errorCorrectionLevel) {
  let seg

  const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M)

  if (Array.isArray(data)) {
    if (data.length > 1) {
      return getBestVersionForMixedData(data, ecl)
    }

    if (data.length === 0) {
      return 1
    }

    seg = data[0]
  } else {
    seg = data
  }

  return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl)
}

/**
 * Returns version information with relative error correction bits
 *
 * The version information is included in QR Code symbols of version 7 or larger.
 * It consists of an 18-bit sequence containing 6 data bits,
 * with 12 error correction bits calculated using the (18, 6) Golay code.
 *
 * @param  {Number} version QR Code version
 * @return {Number}         Encoded version info bits
 */
exports.getEncodedBits = function getEncodedBits (version) {
  if (!VersionCheck.isValid(version) || version < 7) {
    throw new Error('Invalid QR Code version')
  }

  let d = version << 12

  while (Utils.getBCHDigit(d) - G18_BCH >= 0) {
    d ^= (G18 << (Utils.getBCHDigit(d) - G18_BCH))
  }

  return (version << 12) | d
}


/***/ }),

/***/ "./node_modules/qrcode/lib/renderer/canvas.js":
/*!****************************************************!*\
  !*** ./node_modules/qrcode/lib/renderer/canvas.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

const Utils = __webpack_require__(/*! ./utils */ "./node_modules/qrcode/lib/renderer/utils.js")

function clearCanvas (ctx, canvas, size) {
  ctx.clearRect(0, 0, canvas.width, canvas.height)

  if (!canvas.style) canvas.style = {}
  canvas.height = size
  canvas.width = size
  canvas.style.height = size + 'px'
  canvas.style.width = size + 'px'
}

function getCanvasElement () {
  try {
    return document.createElement('canvas')
  } catch (e) {
    throw new Error('You need to specify a canvas element')
  }
}

exports.render = function render (qrData, canvas, options) {
  let opts = options
  let canvasEl = canvas

  if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {
    opts = canvas
    canvas = undefined
  }

  if (!canvas) {
    canvasEl = getCanvasElement()
  }

  opts = Utils.getOptions(opts)
  const size = Utils.getImageWidth(qrData.modules.size, opts)

  const ctx = canvasEl.getContext('2d')
  const image = ctx.createImageData(size, size)
  Utils.qrToImageData(image.data, qrData, opts)

  clearCanvas(ctx, canvasEl, size)
  ctx.putImageData(image, 0, 0)

  return canvasEl
}

exports.renderToDataURL = function renderToDataURL (qrData, canvas, options) {
  let opts = options

  if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {
    opts = canvas
    canvas = undefined
  }

  if (!opts) opts = {}

  const canvasEl = exports.render(qrData, canvas, opts)

  const type = opts.type || 'image/png'
  const rendererOpts = opts.rendererOpts || {}

  return canvasEl.toDataURL(type, rendererOpts.quality)
}


/***/ }),

/***/ "./node_modules/qrcode/lib/renderer/svg-tag.js":
/*!*****************************************************!*\
  !*** ./node_modules/qrcode/lib/renderer/svg-tag.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

const Utils = __webpack_require__(/*! ./utils */ "./node_modules/qrcode/lib/renderer/utils.js")

function getColorAttrib (color, attrib) {
  const alpha = color.a / 255
  const str = attrib + '="' + color.hex + '"'

  return alpha < 1
    ? str + ' ' + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"'
    : str
}

function svgCmd (cmd, x, y) {
  let str = cmd + x
  if (typeof y !== 'undefined') str += ' ' + y

  return str
}

function qrToPath (data, size, margin) {
  let path = ''
  let moveBy = 0
  let newRow = false
  let lineLength = 0

  for (let i = 0; i < data.length; i++) {
    const col = Math.floor(i % size)
    const row = Math.floor(i / size)

    if (!col && !newRow) newRow = true

    if (data[i]) {
      lineLength++

      if (!(i > 0 && col > 0 && data[i - 1])) {
        path += newRow
          ? svgCmd('M', col + margin, 0.5 + row + margin)
          : svgCmd('m', moveBy, 0)

        moveBy = 0
        newRow = false
      }

      if (!(col + 1 < size && data[i + 1])) {
        path += svgCmd('h', lineLength)
        lineLength = 0
      }
    } else {
      moveBy++
    }
  }

  return path
}

exports.render = function render (qrData, options, cb) {
  const opts = Utils.getOptions(options)
  const size = qrData.modules.size
  const data = qrData.modules.data
  const qrcodesize = size + opts.margin * 2

  const bg = !opts.color.light.a
    ? ''
    : '<path ' + getColorAttrib(opts.color.light, 'fill') +
      ' d="M0 0h' + qrcodesize + 'v' + qrcodesize + 'H0z"/>'

  const path =
    '<path ' + getColorAttrib(opts.color.dark, 'stroke') +
    ' d="' + qrToPath(data, size, opts.margin) + '"/>'

  const viewBox = 'viewBox="' + '0 0 ' + qrcodesize + ' ' + qrcodesize + '"'

  const width = !opts.width ? '' : 'width="' + opts.width + '" height="' + opts.width + '" '

  const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + '</svg>\n'

  if (typeof cb === 'function') {
    cb(null, svgTag)
  }

  return svgTag
}


/***/ }),

/***/ "./node_modules/qrcode/lib/renderer/utils.js":
/*!***************************************************!*\
  !*** ./node_modules/qrcode/lib/renderer/utils.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports) {

function hex2rgba (hex) {
  if (typeof hex === 'number') {
    hex = hex.toString()
  }

  if (typeof hex !== 'string') {
    throw new Error('Color should be defined as hex string')
  }

  let hexCode = hex.slice().replace('#', '').split('')
  if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
    throw new Error('Invalid hex color: ' + hex)
  }

  // Convert from short to long form (fff -> ffffff)
  if (hexCode.length === 3 || hexCode.length === 4) {
    hexCode = Array.prototype.concat.apply([], hexCode.map(function (c) {
      return [c, c]
    }))
  }

  // Add default alpha value
  if (hexCode.length === 6) hexCode.push('F', 'F')

  const hexValue = parseInt(hexCode.join(''), 16)

  return {
    r: (hexValue >> 24) & 255,
    g: (hexValue >> 16) & 255,
    b: (hexValue >> 8) & 255,
    a: hexValue & 255,
    hex: '#' + hexCode.slice(0, 6).join('')
  }
}

exports.getOptions = function getOptions (options) {
  if (!options) options = {}
  if (!options.color) options.color = {}

  const margin = typeof options.margin === 'undefined' ||
    options.margin === null ||
    options.margin < 0
    ? 4
    : options.margin

  const width = options.width && options.width >= 21 ? options.width : undefined
  const scale = options.scale || 4

  return {
    width: width,
    scale: width ? 4 : scale,
    margin: margin,
    color: {
      dark: hex2rgba(options.color.dark || '#000000ff'),
      light: hex2rgba(options.color.light || '#ffffffff')
    },
    type: options.type,
    rendererOpts: options.rendererOpts || {}
  }
}

exports.getScale = function getScale (qrSize, opts) {
  return opts.width && opts.width >= qrSize + opts.margin * 2
    ? opts.width / (qrSize + opts.margin * 2)
    : opts.scale
}

exports.getImageWidth = function getImageWidth (qrSize, opts) {
  const scale = exports.getScale(qrSize, opts)
  return Math.floor((qrSize + opts.margin * 2) * scale)
}

exports.qrToImageData = function qrToImageData (imgData, qr, opts) {
  const size = qr.modules.size
  const data = qr.modules.data
  const scale = exports.getScale(size, opts)
  const symbolSize = Math.floor((size + opts.margin * 2) * scale)
  const scaledMargin = opts.margin * scale
  const palette = [opts.color.light, opts.color.dark]

  for (let i = 0; i < symbolSize; i++) {
    for (let j = 0; j < symbolSize; j++) {
      let posDst = (i * symbolSize + j) * 4
      let pxColor = opts.color.light

      if (i >= scaledMargin && j >= scaledMargin &&
        i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
        const iSrc = Math.floor((i - scaledMargin) / scale)
        const jSrc = Math.floor((j - scaledMargin) / scale)
        pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0]
      }

      imgData[posDst++] = pxColor.r
      imgData[posDst++] = pxColor.g
      imgData[posDst++] = pxColor.b
      imgData[posDst] = pxColor.a
    }
  }
}


/***/ }),

/***/ "./node_modules/typo-js/typo.js":
/*!**************************************!*\
  !*** ./node_modules/typo-js/typo.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var __dirname = "/";
/* globals chrome: false */
/* globals __dirname: false */
/* globals require: false */
/* globals Buffer: false */
/* globals module: false */
/**
 * Typo is a JavaScript implementation of a spellchecker using hunspell-style
 * dictionaries.
 */
var Typo;
(function () {
    "use strict";
    /**
     * Typo constructor.
     *
     * @param {string} [dictionary] The locale code of the dictionary being used. e.g.,
     *                              "en_US". This is only used to auto-load dictionaries.
     * @param {string} [affData]    The data from the dictionary's .aff file. If omitted
     *                              and Typo.js is being used in a Chrome extension, the .aff
     *                              file will be loaded automatically from
     *                              lib/typo/dictionaries/[dictionary]/[dictionary].aff
     *                              In other environments, it will be loaded from
     *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].aff
     * @param {string} [wordsData]  The data from the dictionary's .dic file. If omitted
     *                              and Typo.js is being used in a Chrome extension, the .dic
     *                              file will be loaded automatically from
     *                              lib/typo/dictionaries/[dictionary]/[dictionary].dic
     *                              In other environments, it will be loaded from
     *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].dic
     * @param {Object} [settings]   Constructor settings. Available properties are:
     *                              {string} [dictionaryPath]: path to load dictionary from in non-chrome
     *                              environment.
     *                              {Object} [flags]: flag information.
     *                              {boolean} [asyncLoad]: If true, affData and wordsData will be loaded
     *                              asynchronously.
     *                              {Function} [loadedCallback]: Called when both affData and wordsData
     *                              have been loaded. Only used if asyncLoad is set to true. The parameter
     *                              is the instantiated Typo object.
     *
     * @returns {Typo} A Typo object.
     */
    Typo = function (dictionary, affData, wordsData, settings) {
        settings = settings || {};
        this.dictionary = null;
        this.rules = {};
        this.dictionaryTable = {};
        this.compoundRules = [];
        this.compoundRuleCodes = {};
        this.replacementTable = [];
        this.flags = settings.flags || {};
        this.memoized = {};
        this.loaded = false;
        var self = this;
        var path;
        // Loop-control variables.
        var i, j, _len, _jlen;
        if (dictionary) {
            self.dictionary = dictionary;
            // If the data is preloaded, just setup the Typo object.
            if (affData && wordsData) {
                setup();
            }
            // Loading data for browser extentions.
            else if (typeof window !== 'undefined' && ((window.chrome && window.chrome.runtime) || (window.browser && window.browser.runtime))) {
                var runtime = window.chrome && window.chrome.runtime ? window.chrome.runtime : window.browser.runtime;
                if (settings.dictionaryPath) {
                    path = settings.dictionaryPath;
                }
                else {
                    path = "typo/dictionaries";
                }
                if (!affData)
                    readDataFile(runtime.getURL(path + "/" + dictionary + "/" + dictionary + ".aff"), setAffData);
                if (!wordsData)
                    readDataFile(runtime.getURL(path + "/" + dictionary + "/" + dictionary + ".dic"), setWordsData);
            }
            // Loading data for Node.js or other environments.
            else {
                if (settings.dictionaryPath) {
                    path = settings.dictionaryPath;
                }
                else if (true) {
                    path = __dirname + '/dictionaries';
                }
                else // removed by dead control flow
{}
                if (!affData)
                    readDataFile(path + "/" + dictionary + "/" + dictionary + ".aff", setAffData);
                if (!wordsData)
                    readDataFile(path + "/" + dictionary + "/" + dictionary + ".dic", setWordsData);
            }
        }
        function readDataFile(url, setFunc) {
            var response = self._readFile(url, null, settings === null || settings === void 0 ? void 0 : settings.asyncLoad);
            if (settings === null || settings === void 0 ? void 0 : settings.asyncLoad) {
                response.then(function (data) {
                    setFunc(data);
                });
            }
            else {
                setFunc(response);
            }
        }
        function setAffData(data) {
            affData = data;
            if (wordsData) {
                setup();
            }
        }
        function setWordsData(data) {
            wordsData = data;
            if (affData) {
                setup();
            }
        }
        function setup() {
            self.rules = self._parseAFF(affData);
            // Save the rule codes that are used in compound rules.
            self.compoundRuleCodes = {};
            for (i = 0, _len = self.compoundRules.length; i < _len; i++) {
                var rule = self.compoundRules[i];
                for (j = 0, _jlen = rule.length; j < _jlen; j++) {
                    self.compoundRuleCodes[rule[j]] = [];
                }
            }
            // If we add this ONLYINCOMPOUND flag to self.compoundRuleCodes, then _parseDIC
            // will do the work of saving the list of words that are compound-only.
            if ("ONLYINCOMPOUND" in self.flags) {
                self.compoundRuleCodes[self.flags.ONLYINCOMPOUND] = [];
            }
            self.dictionaryTable = self._parseDIC(wordsData);
            // Get rid of any codes from the compound rule codes that are never used
            // (or that were special regex characters).  Not especially necessary...
            for (i in self.compoundRuleCodes) {
                if (self.compoundRuleCodes[i].length === 0) {
                    delete self.compoundRuleCodes[i];
                }
            }
            // Build the full regular expressions for each compound rule.
            // I have a feeling (but no confirmation yet) that this method of
            // testing for compound words is probably slow.
            for (i = 0, _len = self.compoundRules.length; i < _len; i++) {
                var ruleText = self.compoundRules[i];
                var expressionText = "";
                for (j = 0, _jlen = ruleText.length; j < _jlen; j++) {
                    var character = ruleText[j];
                    if (character in self.compoundRuleCodes) {
                        expressionText += "(" + self.compoundRuleCodes[character].join("|") + ")";
                    }
                    else {
                        expressionText += character;
                    }
                }
                self.compoundRules[i] = new RegExp('^' + expressionText + '$', "i");
            }
            self.loaded = true;
            if ((settings === null || settings === void 0 ? void 0 : settings.asyncLoad) && (settings === null || settings === void 0 ? void 0 : settings.loadedCallback)) {
                settings.loadedCallback(self);
            }
        }
        return this;
    };
    Typo.prototype = {
        /**
         * Loads a Typo instance from a hash of all of the Typo properties.
         *
         * @param {object} obj A hash of Typo properties, probably gotten from a JSON.parse(JSON.stringify(typo_instance)).
         */
        load: function (obj) {
            for (var i in obj) {
                if (obj.hasOwnProperty(i)) {
                    this[i] = obj[i];
                }
            }
            return this;
        },
        /**
         * Read the contents of a file.
         *
         * @param {string} path The path (relative) to the file.
         * @param {string} [charset="ISO8859-1"] The expected charset of the file
         * @param {boolean} async If true, the file will be read asynchronously. For node.js this does nothing, all
         *        files are read synchronously.
         * @returns {string} The file data if async is false, otherwise a promise object. If running node.js, the data is
         *          always returned.
         */
        _readFile: function (path, charset, async) {
            var _a;
            charset = charset || "utf8";
            if (typeof XMLHttpRequest !== 'undefined') {
                var req_1 = new XMLHttpRequest();
                req_1.open("GET", path, !!async);
                (_a = req_1.overrideMimeType) === null || _a === void 0 ? void 0 : _a.call(req_1, "text/plain; charset=" + charset);
                if (!!async) {
                    var promise = new Promise(function (resolve, reject) {
                        req_1.onload = function () {
                            if (req_1.status === 200) {
                                resolve(req_1.responseText);
                            }
                            else {
                                reject(req_1.statusText);
                            }
                        };
                        req_1.onerror = function () {
                            reject(req_1.statusText);
                        };
                    });
                    req_1.send(null);
                    return promise;
                }
                else {
                    req_1.send(null);
                    return req_1.responseText;
                }
            }
            else if (true) {
                // Node.js
                var fs = __webpack_require__(/*! fs */ "?f052");
                try {
                    if (fs.existsSync(path)) {
                        return fs.readFileSync(path, charset);
                    }
                    else {
                        console.log("Path " + path + " does not exist.");
                    }
                }
                catch (e) {
                    console.log(e);
                }
                return '';
            }
            // removed by dead control flow
{}
        },
        /**
         * Parse the rules out from a .aff file.
         *
         * @param {string} data The contents of the affix file.
         * @returns object The rules from the file.
         */
        _parseAFF: function (data) {
            var rules = {};
            var line, subline, numEntries, lineParts;
            var i, j, _len, _jlen;
            var lines = data.split(/\r?\n/);
            for (i = 0, _len = lines.length; i < _len; i++) {
                // Remove comment lines
                line = this._removeAffixComments(lines[i]);
                line = line.trim();
                if (!line) {
                    continue;
                }
                var definitionParts = line.split(/\s+/);
                var ruleType = definitionParts[0];
                if (ruleType === "PFX" || ruleType === "SFX") {
                    var ruleCode = definitionParts[1];
                    var combineable = definitionParts[2];
                    numEntries = parseInt(definitionParts[3], 10);
                    var entries = [];
                    for (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {
                        subline = lines[j];
                        lineParts = subline.split(/\s+/);
                        var charactersToRemove = lineParts[2];
                        var additionParts = lineParts[3].split("/");
                        var charactersToAdd = additionParts[0];
                        if (charactersToAdd === "0")
                            charactersToAdd = "";
                        var continuationClasses = this.parseRuleCodes(additionParts[1]);
                        var regexToMatch = lineParts[4];
                        var entry = {
                            add: charactersToAdd
                        };
                        if (continuationClasses.length > 0)
                            entry.continuationClasses = continuationClasses;
                        if (regexToMatch !== ".") {
                            if (ruleType === "SFX") {
                                entry.match = new RegExp(regexToMatch + "$");
                            }
                            else {
                                entry.match = new RegExp("^" + regexToMatch);
                            }
                        }
                        if (charactersToRemove != "0") {
                            if (ruleType === "SFX") {
                                entry.remove = new RegExp(charactersToRemove + "$");
                            }
                            else {
                                entry.remove = charactersToRemove;
                            }
                        }
                        entries.push(entry);
                    }
                    rules[ruleCode] = { "type": ruleType, "combineable": (combineable === "Y"), "entries": entries };
                    i += numEntries;
                }
                else if (ruleType === "COMPOUNDRULE") {
                    numEntries = parseInt(definitionParts[1], 10);
                    for (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {
                        line = lines[j];
                        lineParts = line.split(/\s+/);
                        this.compoundRules.push(lineParts[1]);
                    }
                    i += numEntries;
                }
                else if (ruleType === "REP") {
                    lineParts = line.split(/\s+/);
                    if (lineParts.length === 3) {
                        this.replacementTable.push([lineParts[1], lineParts[2]]);
                    }
                }
                else {
                    // ONLYINCOMPOUND
                    // COMPOUNDMIN
                    // FLAG
                    // KEEPCASE
                    // NEEDAFFIX
                    this.flags[ruleType] = definitionParts[1];
                }
            }
            return rules;
        },
        /**
         * Removes comments.
         *
         * @param {string} data A line from an affix file.
         * @return {string} The cleaned-up line.
         */
        _removeAffixComments: function (line) {
            // This used to remove any string starting with '#' up to the end of the line,
            // but some COMPOUNDRULE definitions include '#' as part of the rule.
            // So, only remove lines that begin with a comment, optionally preceded by whitespace.
            if (line.match(/^\s*#/)) {
                return '';
            }
            return line;
        },
        /**
         * Parses the words out from the .dic file.
         *
         * @param {string} data The data from the dictionary file.
         * @returns HashMap The lookup table containing all of the words and
         *                 word forms from the dictionary.
         */
        _parseDIC: function (data) {
            data = this._removeDicComments(data);
            var lines = data.split(/\r?\n/);
            var dictionaryTable = {};
            function addWord(word, rules) {
                // Some dictionaries will list the same word multiple times with different rule sets.
                if (!dictionaryTable.hasOwnProperty(word)) {
                    dictionaryTable[word] = null;
                }
                if (rules.length > 0) {
                    if (dictionaryTable[word] === null) {
                        dictionaryTable[word] = [];
                    }
                    dictionaryTable[word].push(rules);
                }
            }
            // The first line is the number of words in the dictionary.
            for (var i = 1, _len = lines.length; i < _len; i++) {
                var line = lines[i];
                if (!line) {
                    // Ignore empty lines.
                    continue;
                }
                // The line format is one of:
                //     word
                //     word/flags
                //     word/flags xx:abc yy:def
                //     word xx:abc yy:def
                // We don't use the morphological flags (xx:abc, yy:def) and we don't want them included
                // in the extracted flags.
                var just_word_and_flags = line.replace(/\s.*$/, '');
                // just_word_and_flags is definitely one of:
                //     word
                //     word/flags
                var parts = just_word_and_flags.split('/', 2);
                var word = parts[0];
                // Now for each affix rule, generate that form of the word.
                if (parts.length > 1) {
                    var ruleCodesArray = this.parseRuleCodes(parts[1]);
                    // Save the ruleCodes for compound word situations.
                    if (!("NEEDAFFIX" in this.flags) || ruleCodesArray.indexOf(this.flags.NEEDAFFIX) === -1) {
                        addWord(word, ruleCodesArray);
                    }
                    for (var j = 0, _jlen = ruleCodesArray.length; j < _jlen; j++) {
                        var code = ruleCodesArray[j];
                        var rule = this.rules[code];
                        if (rule) {
                            var newWords = this._applyRule(word, rule);
                            for (var ii = 0, _iilen = newWords.length; ii < _iilen; ii++) {
                                var newWord = newWords[ii];
                                addWord(newWord, []);
                                if (rule.combineable) {
                                    for (var k = j + 1; k < _jlen; k++) {
                                        var combineCode = ruleCodesArray[k];
                                        var combineRule = this.rules[combineCode];
                                        if (combineRule) {
                                            if (combineRule.combineable && (rule.type != combineRule.type)) {
                                                var otherNewWords = this._applyRule(newWord, combineRule);
                                                for (var iii = 0, _iiilen = otherNewWords.length; iii < _iiilen; iii++) {
                                                    var otherNewWord = otherNewWords[iii];
                                                    addWord(otherNewWord, []);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (code in this.compoundRuleCodes) {
                            this.compoundRuleCodes[code].push(word);
                        }
                    }
                }
                else {
                    addWord(word.trim(), []);
                }
            }
            return dictionaryTable;
        },
        /**
         * Removes comment lines and then cleans up blank lines and trailing whitespace.
         *
         * @param {string} data The data from a .dic file.
         * @return {string} The cleaned-up data.
         */
        _removeDicComments: function (data) {
            // I can't find any official documentation on it, but at least the de_DE
            // dictionary uses tab-indented lines as comments.
            // Remove comments
            data = data.replace(/^\t.*$/mg, "");
            return data;
        },
        parseRuleCodes: function (textCodes) {
            if (!textCodes) {
                return [];
            }
            else if (!("FLAG" in this.flags)) {
                // The flag symbols are single characters
                return textCodes.split("");
            }
            else if (this.flags.FLAG === "long") {
                // The flag symbols are two characters long.
                var flags = [];
                for (var i = 0, _len = textCodes.length; i < _len; i += 2) {
                    flags.push(textCodes.substr(i, 2));
                }
                return flags;
            }
            else if (this.flags.FLAG === "num") {
                // The flag symbols are a CSV list of numbers.
                return textCodes.split(",");
            }
            else if (this.flags.FLAG === "UTF-8") {
                // The flags are single UTF-8 characters.
                // @see https://github.com/cfinke/Typo.js/issues/57
                return Array.from(textCodes);
            }
            else {
                // It's possible that this fallback case will not work for all FLAG values,
                // but I think it's more likely to work than not returning anything at all.
                return textCodes.split("");
            }
        },
        /**
         * Applies an affix rule to a word.
         *
         * @param {string} word The base word.
         * @param {Object} rule The affix rule.
         * @returns {string[]} The new words generated by the rule.
         */
        _applyRule: function (word, rule) {
            var entries = rule.entries;
            var newWords = [];
            for (var i = 0, _len = entries.length; i < _len; i++) {
                var entry = entries[i];
                if (!entry.match || word.match(entry.match)) {
                    var newWord = word;
                    if (entry.remove) {
                        newWord = newWord.replace(entry.remove, "");
                    }
                    if (rule.type === "SFX") {
                        newWord = newWord + entry.add;
                    }
                    else {
                        newWord = entry.add + newWord;
                    }
                    newWords.push(newWord);
                    if ("continuationClasses" in entry) {
                        for (var j = 0, _jlen = entry.continuationClasses.length; j < _jlen; j++) {
                            var continuationRule = this.rules[entry.continuationClasses[j]];
                            if (continuationRule) {
                                newWords = newWords.concat(this._applyRule(newWord, continuationRule));
                            }
                            /*
                            else {
                                // This shouldn't happen, but it does, at least in the de_DE dictionary.
                                // I think the author mistakenly supplied lower-case rule codes instead
                                // of upper-case.
                            }
                            */
                        }
                    }
                }
            }
            return newWords;
        },
        /**
         * Checks whether a word or a capitalization variant exists in the current dictionary.
         * The word is trimmed and several variations of capitalizations are checked.
         * If you want to check a word without any changes made to it, call checkExact()
         *
         * @see http://blog.stevenlevithan.com/archives/faster-trim-javascript re:trimming function
         *
         * @param {string} aWord The word to check.
         * @returns {boolean}
         */
        check: function (aWord) {
            if (!this.loaded) {
                throw "Dictionary not loaded.";
            }
            if (!aWord) {
                return false;
            }
            // Remove leading and trailing whitespace
            var trimmedWord = aWord.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
            if (this.checkExact(trimmedWord)) {
                return true;
            }
            // The exact word is not in the dictionary.
            if (trimmedWord.toUpperCase() === trimmedWord) {
                // The word was supplied in all uppercase.
                // Check for a capitalized form of the word.
                var capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();
                if (this.hasFlag(capitalizedWord, "KEEPCASE")) {
                    // Capitalization variants are not allowed for this word.
                    return false;
                }
                if (this.checkExact(capitalizedWord)) {
                    // The all-caps word is a capitalized word spelled correctly.
                    return true;
                }
                if (this.checkExact(trimmedWord.toLowerCase())) {
                    // The all-caps is a lowercase word spelled correctly.
                    return true;
                }
            }
            var uncapitalizedWord = trimmedWord[0].toLowerCase() + trimmedWord.substring(1);
            if (uncapitalizedWord !== trimmedWord) {
                if (this.hasFlag(uncapitalizedWord, "KEEPCASE")) {
                    // Capitalization variants are not allowed for this word.
                    return false;
                }
                // Check for an uncapitalized form
                if (this.checkExact(uncapitalizedWord)) {
                    // The word is spelled correctly but with the first letter capitalized.
                    return true;
                }
            }
            return false;
        },
        /**
         * Checks whether a word exists in the current dictionary.
         *
         * @param {string} word The word to check.
         * @returns {boolean}
         */
        checkExact: function (word) {
            if (!this.loaded) {
                throw "Dictionary not loaded.";
            }
            var ruleCodes = this.dictionaryTable[word];
            var i, _len;
            if (typeof ruleCodes === 'undefined') {
                // Check if this might be a compound word.
                if ("COMPOUNDMIN" in this.flags && word.length >= this.flags.COMPOUNDMIN) {
                    for (i = 0, _len = this.compoundRules.length; i < _len; i++) {
                        if (word.match(this.compoundRules[i])) {
                            return true;
                        }
                    }
                }
            }
            else if (ruleCodes === null) {
                // a null (but not undefined) value for an entry in the dictionary table
                // means that the word is in the dictionary but has no flags.
                return true;
            }
            else if (typeof ruleCodes === 'object') { // this.dictionary['hasOwnProperty'] will be a function.
                for (i = 0, _len = ruleCodes.length; i < _len; i++) {
                    if (!this.hasFlag(word, "ONLYINCOMPOUND", ruleCodes[i])) {
                        return true;
                    }
                }
            }
            return false;
        },
        /**
         * Looks up whether a given word is flagged with a given flag.
         *
         * @param {string} word The word in question.
         * @param {string} flag The flag in question.
         * @return {boolean}
         */
        hasFlag: function (word, flag, wordFlags) {
            if (!this.loaded) {
                throw "Dictionary not loaded.";
            }
            if (flag in this.flags) {
                if (typeof wordFlags === 'undefined') {
                    wordFlags = Array.prototype.concat.apply([], this.dictionaryTable[word]);
                }
                if (wordFlags && wordFlags.indexOf(this.flags[flag]) !== -1) {
                    return true;
                }
            }
            return false;
        },
        /**
         * Returns a list of suggestions for a misspelled word.
         *
         * @see http://www.norvig.com/spell-correct.html for the basis of this suggestor.
         * This suggestor is primitive, but it works.
         *
         * @param {string} word The misspelling.
         * @param {number} [limit=5] The maximum number of suggestions to return.
         * @returns {string[]} The array of suggestions.
         */
        alphabet: "",
        suggest: function (word, limit) {
            if (!this.loaded) {
                throw "Dictionary not loaded.";
            }
            limit = limit || 5;
            if (this.memoized.hasOwnProperty(word)) {
                var memoizedLimit = this.memoized[word]['limit'];
                // Only return the cached list if it's big enough or if there weren't enough suggestions
                // to fill a smaller limit.
                if (limit <= memoizedLimit || this.memoized[word]['suggestions'].length < memoizedLimit) {
                    return this.memoized[word]['suggestions'].slice(0, limit);
                }
            }
            if (this.check(word))
                return [];
            // Check the replacement table.
            for (var i = 0, _len = this.replacementTable.length; i < _len; i++) {
                var replacementEntry = this.replacementTable[i];
                if (word.indexOf(replacementEntry[0]) !== -1) {
                    var correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);
                    if (this.check(correctedWord)) {
                        return [correctedWord];
                    }
                }
            }
            if (!this.alphabet) {
                // Use the English alphabet as the default. Problematic, but backwards-compatible.
                this.alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
                // Any characters defined in the affix file as substitutions can go in the alphabet too.
                // Note that dictionaries do not include the entire alphabet in the TRY flag when it's there.
                // For example, Q is not in the default English TRY list; that's why having the default
                // alphabet above is useful.
                if ('TRY' in this.flags) {
                    this.alphabet += this.flags['TRY'];
                }
                // Plus any additional characters specifically defined as being allowed in words.
                if ('WORDCHARS' in this.flags) {
                    this.alphabet += this.flags['WORDCHARS'];
                }
                // Remove any duplicates.
                var alphaArray = this.alphabet.split("");
                alphaArray.sort();
                var alphaHash = {};
                for (var i = 0; i < alphaArray.length; i++) {
                    alphaHash[alphaArray[i]] = true;
                }
                this.alphabet = '';
                for (var i in alphaHash) {
                    this.alphabet += i;
                }
            }
            var self = this;
            /**
             * Returns a hash keyed by all of the strings that can be made by making a single edit to the word (or words in) `words`
             * The value of each entry is the number of unique ways that the resulting word can be made.
             *
             * @arg HashMap words A hash keyed by words (all with the value `true` to make lookups very quick).
             * @arg boolean known_only Whether this function should ignore strings that are not in the dictionary.
             */
            function edits1(words, known_only) {
                var rv = {};
                var i, j, _iilen, _len, _jlen, _edit;
                var alphabetLength = self.alphabet.length;
                for (var word_1 in words) {
                    for (i = 0, _len = word_1.length + 1; i < _len; i++) {
                        var s = [word_1.substring(0, i), word_1.substring(i)];
                        // Remove a letter.
                        if (s[1]) {
                            _edit = s[0] + s[1].substring(1);
                            if (!known_only || self.check(_edit)) {
                                if (!(_edit in rv)) {
                                    rv[_edit] = 1;
                                }
                                else {
                                    rv[_edit] += 1;
                                }
                            }
                        }
                        // Transpose letters
                        // Eliminate transpositions of identical letters
                        if (s[1].length > 1 && s[1][1] !== s[1][0]) {
                            _edit = s[0] + s[1][1] + s[1][0] + s[1].substring(2);
                            if (!known_only || self.check(_edit)) {
                                if (!(_edit in rv)) {
                                    rv[_edit] = 1;
                                }
                                else {
                                    rv[_edit] += 1;
                                }
                            }
                        }
                        if (s[1]) {
                            // Replace a letter with another letter.
                            var lettercase = (s[1].substring(0, 1).toUpperCase() === s[1].substring(0, 1)) ? 'uppercase' : 'lowercase';
                            for (j = 0; j < alphabetLength; j++) {
                                var replacementLetter = self.alphabet[j];
                                // Set the case of the replacement letter to the same as the letter being replaced.
                                if ('uppercase' === lettercase) {
                                    replacementLetter = replacementLetter.toUpperCase();
                                }
                                // Eliminate replacement of a letter by itself
                                if (replacementLetter != s[1].substring(0, 1)) {
                                    _edit = s[0] + replacementLetter + s[1].substring(1);
                                    if (!known_only || self.check(_edit)) {
                                        if (!(_edit in rv)) {
                                            rv[_edit] = 1;
                                        }
                                        else {
                                            rv[_edit] += 1;
                                        }
                                    }
                                }
                            }
                        }
                        if (s[1]) {
                            // Add a letter between each letter.
                            for (j = 0; j < alphabetLength; j++) {
                                // If the letters on each side are capitalized, capitalize the replacement.
                                var lettercase = (s[0].substring(-1).toUpperCase() === s[0].substring(-1) && s[1].substring(0, 1).toUpperCase() === s[1].substring(0, 1)) ? 'uppercase' : 'lowercase';
                                var replacementLetter = self.alphabet[j];
                                if ('uppercase' === lettercase) {
                                    replacementLetter = replacementLetter.toUpperCase();
                                }
                                _edit = s[0] + replacementLetter + s[1];
                                if (!known_only || self.check(_edit)) {
                                    if (!(_edit in rv)) {
                                        rv[_edit] = 1;
                                    }
                                    else {
                                        rv[_edit] += 1;
                                    }
                                }
                            }
                        }
                    }
                }
                return rv;
            }
            function correct(word) {
                var _a;
                // Get the edit-distance-1 and edit-distance-2 forms of this word.
                var ed1 = edits1((_a = {}, _a[word] = true, _a));
                var ed2 = edits1(ed1, true);
                // Sort the edits based on how many different ways they were created.
                var weighted_corrections = ed2;
                for (var ed1word in ed1) {
                    if (!self.check(ed1word)) {
                        continue;
                    }
                    if (ed1word in weighted_corrections) {
                        weighted_corrections[ed1word] += ed1[ed1word];
                    }
                    else {
                        weighted_corrections[ed1word] = ed1[ed1word];
                    }
                }
                var i, _len;
                var sorted_corrections = [];
                for (i in weighted_corrections) {
                    if (weighted_corrections.hasOwnProperty(i)) {
                        if (self.hasFlag(i, "PRIORITYSUGGEST")) {
                            // We've defined a new affix rule called PRIORITYSUGGEST, indicating that
                            // if this word is in the suggestions list for a misspelled word, it should
                            // be given priority over other suggestions.
                            //
                            // Add a large number to its weight to push it to the top of the list.
                            // If multiple priority suggestions are in the list, they'll still be ranked
                            // against each other, but they'll all be above non-priority suggestions.
                            weighted_corrections[i] += 1000;
                        }
                        sorted_corrections.push([i, weighted_corrections[i]]);
                    }
                }
                function sorter(a, b) {
                    var a_val = a[1];
                    var b_val = b[1];
                    if (a_val < b_val) {
                        return -1;
                    }
                    else if (a_val > b_val) {
                        return 1;
                    }
                    // @todo If a and b are equally weighted, add our own weight based on something like the key locations on this language's default keyboard.
                    return b[0].localeCompare(a[0]);
                }
                sorted_corrections.sort(sorter).reverse();
                var rv = [];
                var capitalization_scheme = "lowercase";
                if (word.toUpperCase() === word) {
                    capitalization_scheme = "uppercase";
                }
                else if (word.substr(0, 1).toUpperCase() + word.substr(1).toLowerCase() === word) {
                    capitalization_scheme = "capitalized";
                }
                var working_limit = limit;
                for (i = 0; i < Math.min(working_limit, sorted_corrections.length); i++) {
                    if ("uppercase" === capitalization_scheme) {
                        sorted_corrections[i][0] = sorted_corrections[i][0].toUpperCase();
                    }
                    else if ("capitalized" === capitalization_scheme) {
                        sorted_corrections[i][0] = sorted_corrections[i][0].substr(0, 1).toUpperCase() + sorted_corrections[i][0].substr(1);
                    }
                    if (!self.hasFlag(sorted_corrections[i][0], "NOSUGGEST") && rv.indexOf(sorted_corrections[i][0]) === -1) {
                        rv.push(sorted_corrections[i][0]);
                    }
                    else {
                        // If one of the corrections is not eligible as a suggestion , make sure we still return the right number of suggestions.
                        working_limit++;
                    }
                }
                return rv;
            }
            this.memoized[word] = {
                'suggestions': correct(word),
                'limit': limit
            };
            return this.memoized[word]['suggestions'];
        }
    };
})();
// Support for use as a node.js module.
if (true) {
    module.exports = Typo;
}


/***/ }),

/***/ "./plugins/Activities/assets/js/controllers/approve-and-assign-auth-controller.js":
/*!****************************************************************************************!*\
  !*** ./plugins/Activities/assets/js/controllers/approve-and-assign-auth-controller.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * Approve and Assign Authorization Controller - AJAX-based approver selection
 *
 * Targets: approvers, submitBtn, id
 * Values: url (String), approvalId (Number)
 * Outlets: outlet-btn
 */
class ActivitiesApproveAndAssignAuthorization extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static values = {
    url: String,
    approvalId: Number
  };
  static targets = ["approvers", "submitBtn", "id"];
  static outlets = ["outlet-btn"];

  /** Load approvers on connect if approvalId is pre-set. */
  connect() {
    if (this.hasApprovalIdValue && this.approvalIdValue > 0) {
      this.idTarget.value = this.approvalIdValue;
      this.getApprovers();
    }
  }

  /** Set activity ID from outlet event and fetch approvers. */
  setId(event) {
    this.idTarget.value = event.detail.id;
    this.getApprovers();
  }

  /** Register setId listener when outlet button connects. */
  outletBtnOutletConnected(outlet, element) {
    outlet.addListener(this.setId.bind(this));
  }

  /** Remove setId listener when outlet button disconnects. */
  outletBtnOutletDisconnected(outlet) {
    outlet.removeListener(this.setId.bind(this));
  }

  /** Fetch approvers from server and populate dropdown. */
  getApprovers() {
    if (this.hasApproversTarget) {
      this.approversTarget.value = "";
      let activityId = this.idTarget.value;
      let url = this.urlValue + "/" + activityId;
      fetch(url, this.optionsForFetch()).then(response => response.json()).then(data => {
        const emptyOption = this.approversTarget.options[0];
        this.approversTarget.innerHTML = '';
        if (emptyOption) {
          this.approversTarget.appendChild(emptyOption);
        }
        data.forEach(item => {
          const option = document.createElement('option');
          option.value = item.id;
          option.textContent = item.sca_name;
          this.approversTarget.appendChild(option);
        });
        this.submitBtnTarget.disabled = true;
        this.approversTarget.disabled = false;
      });
    }
  }

  /** Return AJAX request headers. */
  optionsForFetch() {
    return {
      headers: {
        "X-Requested-With": "XMLHttpRequest",
        "Accept": "application/json"
      }
    };
  }

  /** Enable submit button when valid approver is selected. */
  checkReadyToSubmit() {
    let approverValue = this.approversTarget.value;
    let approverNum = parseInt(approverValue);
    if (approverNum > 0) {
      this.submitBtnTarget.disabled = false;
    } else {
      this.submitBtnTarget.disabled = true;
    }
  }

  /** Disable submit button on initial connection. */
  submitBtnTargetConnected() {
    this.submitBtnTarget.disabled = true;
  }
}

// Register controller with global registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["activities-approve-and-assign-auth"] = ActivitiesApproveAndAssignAuthorization;

/***/ }),

/***/ "./plugins/Activities/assets/js/controllers/gw-sharing-controller.js":
/*!***************************************************************************!*\
  !*** ./plugins/Activities/assets/js/controllers/gw-sharing-controller.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * GW Sharing Stimulus Controller
 * 
 * **Purpose**: Provides automated form submission functionality for GW (Group Warrant)
 * sharing toggle switches in Activities plugin authorization management interfaces.
 * 
 * **Core Responsibilities**:
 * - Automatic Form Submission - Immediate form submission on toggle change
 * - Toggle Switch Integration - Seamless switch state management
 * - User Experience Optimization - Instant feedback for setting changes
 * - Authorization Configuration - GW sharing preference management
 * 
 * **Architecture**: 
 * This Stimulus controller extends the base Controller to provide automatic
 * form submission when GW sharing toggle switches are changed, ensuring
 * immediate persistence of user preferences without manual form submission.
 * 
 * **Controller Configuration**:
 * ```html
 * <div data-controller="gw_sharing">
 *   <form data-gw_sharing-target="form" method="post" action="/activities/update-gw-sharing">
 *     <input type="checkbox" data-action="change->gw_sharing#submit">
 *     <!-- Other form fields -->
 *   </form>
 * </div>
 * ```
 * 
 * **GW Sharing Context**:
 * GW (Group Warrant) sharing allows authorization configurations to be
 * shared across organizational groups, affecting authorization workflows
 * and approval processes within the Activities plugin.
 * 
 * **User Experience Features**:
 * - **Instant Persistence**: Changes saved immediately on toggle
 * - **No Manual Submission**: Eliminates need for separate save button
 * - **Seamless Integration**: Works with existing form infrastructure
 * - **Consistent Behavior**: Standardized across GW sharing interfaces
 * 
 * **Toggle Switch Integration**:
 * - Responds to switch state changes immediately
 * - Preserves existing form data during submission
 * - Maintains form validation and security measures
 * - Supports multiple toggle switches per form
 * 
 * **Security Considerations**:
 * - Maintains CSRF token protection through form submission
 * - Preserves server-side validation workflows
 * - Respects authorization and permission checking
 * - Uses standard HTTP methods for security compliance
 * 
 * **Performance Features**:
 * - Minimal JavaScript footprint for efficiency
 * - Direct form submission without AJAX overhead
 * - Browser-native form handling for reliability
 * - No additional network requests beyond form submission
 * 
 * **Error Handling**:
 * - Browser-native form validation integration
 * - Server-side error handling through standard form responses
 * - Graceful degradation if JavaScript disabled
 * - Form state preservation on submission errors
 * 
 * **Integration Points**:
 * - Activities Authorization Forms - GW sharing configuration
 * - Toggle Switch Components - Automatic submission trigger
 * - Authorization Workflows - Group warrant sharing settings
 * - Form Infrastructure - Standard form submission handling
 * 
 * **Usage Examples**:
 * ```html
 * <!-- GW sharing toggle with automatic submission -->
 * <div data-controller="gw_sharing">
 *   <form data-gw_sharing-target="form" method="post">
 *     <label class="form-check">
 *       <input type="checkbox" class="form-check-input"
 *              data-action="change->gw_sharing#submit"
 *              name="gw_sharing_enabled">
 *       Enable GW Sharing
 *     </label>
 *   </form>
 * </div>
 * ```
 * 
 * **Accessibility Features**:
 * - Preserves keyboard navigation functionality
 * - Maintains screen reader compatibility
 * - Supports assistive technology integration
 * - Follows WCAG guidelines for form interactions
 * 
 * **Browser Compatibility**:
 * - Uses standard DOM APIs for broad compatibility
 * - No modern JavaScript features requiring polyfills
 * - Graceful degradation in older browsers
 * - Progressive enhancement approach
 * 
 * **Troubleshooting**:
 * - Verify form target configuration is correct
 * - Check form action URL and method settings
 * - Validate toggle switch event binding
 * - Monitor network requests for form submission
 * 
 * @see ActivitiesController GW sharing configuration endpoints
 * @see Authorization Authorization entity with GW sharing settings
 * @see ToggleSwitch UI component integration patterns
 */

class GWSharingController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["form"];

  /**
   * Submit Form Automatically
   * 
   * Triggers immediate form submission when GW sharing toggle switches
   * are changed, providing instant persistence of user preferences.
   * 
   * **Automatic Submission**:
   * - Called by toggle switch change events
   * - Submits form using standard browser mechanisms
   * - Preserves all form data and validation
   * - Maintains CSRF protection and security measures
   * 
   * **User Experience**:
   * Eliminates need for manual save actions by automatically
   * persisting toggle changes when users interact with switches,
   * providing immediate feedback and seamless preference management.
   * 
   * **Form Integration**:
   * Uses browser-native form submission to maintain compatibility
   * with existing server-side validation, error handling, and
   * security measures without additional AJAX complexity.
   */
  submit() {
    this.formTarget.submit();
  }
}
// add to window.Controllers with a name of the controller
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["gw_sharing"] = GWSharingController;

/***/ }),

/***/ "./plugins/Activities/assets/js/controllers/mobile-request-auth-controller.js":
/*!************************************************************************************!*\
  !*** ./plugins/Activities/assets/js/controllers/mobile-request-auth-controller.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * Mobile Authorization Request Controller - Touch-optimized auth request workflow
 *
 * Targets: form, activitySelect, approverSelect, approverHelp, submitBtn, submitText, onlineStatus
 * Values: approversUrl (String), memberId (Number)
 */
class MobileRequestAuthController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["form", "activitySelect", "approverSelect", "approverHelp", "submitBtn", "submitText", "onlineStatus"];
  static values = {
    approversUrl: String,
    memberId: Number
  };

  /** Cache bound event handlers for proper cleanup. */
  initialize() {
    this._onOnline = this.checkOnlineStatus.bind(this);
    this._onOffline = this.checkOnlineStatus.bind(this);
    this._onSubmit = this.handleSubmit.bind(this);
  }

  /** Setup online/offline listeners and initial validation. */
  connect() {
    console.log("Mobile Request Auth controller connected");
    this.checkOnlineStatus();
    window.addEventListener('online', this._onOnline);
    window.addEventListener('offline', this._onOffline);
    this.formTarget.addEventListener('submit', this._onSubmit);
    this.validateForm();
  }

  /** Remove event listeners on disconnect. */
  disconnect() {
    window.removeEventListener('online', this._onOnline);
    window.removeEventListener('offline', this._onOffline);
    if (this.hasFormTarget) {
      this.formTarget.removeEventListener('submit', this._onSubmit);
    }
  }

  /** Update UI based on online/offline status. */
  checkOnlineStatus() {
    const isOnline = navigator.onLine;
    if (!isOnline) {
      this.onlineStatusTarget.hidden = false;
      this.onlineStatusTarget.classList.add('offline');
      this.activitySelectTarget.disabled = true;
      this.approverSelectTarget.disabled = true;
      this.submitBtnTarget.disabled = true;
      this.approverHelpTarget.textContent = "You must be online to submit requests";
    } else {
      this.onlineStatusTarget.hidden = true;
      this.onlineStatusTarget.classList.remove('offline');
      this.activitySelectTarget.disabled = false;
      this.approverSelectTarget.disabled = false;
      this.validateForm();
      if (!this.activitySelectTarget.value) {
        this.approverHelpTarget.textContent = "Select an activity to see available approvers";
      }
    }
  }

  /** Fetch approvers from API when activity is selected. */
  async loadApprovers(event) {
    const activityId = event.target.value;
    this.approverSelectTarget.innerHTML = '<option value="">-- Loading approvers... --</option>';
    this.approverSelectTarget.disabled = true;
    this.approverHelpTarget.textContent = "Loading approvers...";
    this.submitBtnTarget.disabled = true;
    if (!activityId) {
      this.approverSelectTarget.innerHTML = '<option value="">-- Select activity first --</option>';
      this.approverHelpTarget.textContent = "Select an activity to see available approvers";
      return;
    }
    if (!navigator.onLine) {
      this.approverSelectTarget.innerHTML = '<option value="">-- You must be online --</option>';
      this.approverHelpTarget.textContent = "You must be online to load approvers";
      return;
    }
    try {
      const url = `${this.approversUrlValue}/${activityId}/${this.memberIdValue}`;
      const response = await fetch(url, {
        headers: {
          'Accept': 'application/json',
          'X-Requested-With': 'XMLHttpRequest'
        }
      });
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      this.approverSelectTarget.innerHTML = '';
      const emptyOption = document.createElement('option');
      emptyOption.value = '';
      emptyOption.textContent = '-- Choose an approver --';
      this.approverSelectTarget.appendChild(emptyOption);
      if (data && Array.isArray(data) && data.length > 0) {
        data.forEach(approver => {
          const option = document.createElement('option');
          option.value = approver.id;
          option.textContent = approver.sca_name;
          this.approverSelectTarget.appendChild(option);
        });
        this.approverSelectTarget.disabled = false;
        this.approverHelpTarget.textContent = `${data.length} approver(s) available`;
      } else {
        const noApprovers = document.createElement('option');
        noApprovers.value = '';
        noApprovers.textContent = '-- No approvers available --';
        this.approverSelectTarget.appendChild(noApprovers);
        this.approverHelpTarget.textContent = "No approvers found for this activity";
      }
    } catch (error) {
      console.error('Error loading approvers:', error);
      this.approverSelectTarget.innerHTML = '<option value="">-- Error loading approvers --</option>';
      this.approverHelpTarget.textContent = "Failed to load approvers. Please try again.";
    }
    this.validateForm();
  }

  /** Enable submit button only when activity and approver are selected and online. */
  validateForm() {
    const activitySelected = this.activitySelectTarget.value !== '';
    const approverSelected = this.approverSelectTarget.value !== '';
    const isOnline = navigator.onLine;
    this.submitBtnTarget.disabled = !(activitySelected && approverSelected && isOnline);
  }

  /** Prevent submission if offline, show loading state otherwise. */
  handleSubmit(event) {
    if (!navigator.onLine) {
      event.preventDefault();
      alert('You must be online to submit authorization requests');
      return false;
    }
    this.submitBtnTarget.disabled = true;
    this.submitTextTarget.innerHTML = '<span class="loading-spinner"></span>Submitting...';
    return true;
  }
}

// Register controller with global registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["mobile-request-auth"] = MobileRequestAuthController;
/* harmony default export */ __webpack_exports__["default"] = (MobileRequestAuthController);

/***/ }),

/***/ "./plugins/Activities/assets/js/controllers/renew-auth-controller.js":
/*!***************************************************************************!*\
  !*** ./plugins/Activities/assets/js/controllers/renew-auth-controller.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * Renew Authorization Controller - Authorization renewal with approver selection
 *
 * Targets: activity, approvers, submitBtn, memberId, id
 * Values: url (String)
 * Outlets: outlet-btn
 */
class ActivitiesRenewAuthorization extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static values = {
    url: String
  };
  static targets = ["activity", "approvers", "submitBtn", "memberId", "id"];
  static outlets = ["outlet-btn"];

  /** Set authorization and activity IDs from outlet event, then fetch approvers. */
  setId(event) {
    this.idTarget.value = event.detail.id;
    this.activityTarget.value = event.detail.activity;
    this.getApprovers();
  }

  /** Register setId listener when outlet button connects. */
  outletBtnOutletConnected(outlet, element) {
    this._boundSetId = this._boundSetId || this.setId.bind(this);
    outlet.addListener(this._boundSetId);
  }

  /** Remove setId listener when outlet button disconnects. */
  outletBtnOutletDisconnected(outlet) {
    if (this._boundSetId) {
      outlet.removeListener(this._boundSetId);
      this._boundSetId = null;
    }
  }

  /** Fetch approvers for selected activity and member, populate dropdown. */
  getApprovers() {
    if (this.hasApproversTarget) {
      this.approversTarget.value = "";
      let activityId = this.activityTarget.value;
      let url = this.urlValue + "/" + activityId + "/" + this.memberIdTarget.value;
      fetch(url, this.optionsForFetch()).then(response => response.json()).then(data => {
        let list = [];
        data.forEach(item => {
          list.push({
            value: item.id,
            text: item.sca_name
          });
        });
        this.approversTarget.options = list;
        this.submitBtnTarget.disabled = true;
        this.approversTarget.disabled = false;
      });
    }
  }

  /** Return AJAX request headers. */
  optionsForFetch() {
    return {
      headers: {
        "X-Requested-With": "XMLHttpRequest",
        "Accept": "application/json"
      }
    };
  }

  /** Enable submit button when valid approver is selected. */
  checkReadyToSubmit() {
    let approverValue = this.approversTarget.value;
    let approverNum = parseInt(approverValue);
    if (approverNum > 0) {
      this.submitBtnTarget.disabled = false;
    } else {
      this.submitBtnTarget.disabled = true;
    }
  }

  /** Disable submit button on initial connection. */
  submitBtnTargetConnected() {
    this.submitBtnTarget.disabled = true;
  }
}

// Register controller with global registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["activities-renew-auth"] = ActivitiesRenewAuthorization;

/***/ }),

/***/ "./plugins/Activities/assets/js/controllers/request-auth-controller.js":
/*!*****************************************************************************!*\
  !*** ./plugins/Activities/assets/js/controllers/request-auth-controller.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/**
 * Request Authorization Controller - Authorization request with approver selection
 *
 * Targets: activity, approvers, submitBtn, memberId
 * Values: url (String)
 */


class ActivitiesRequestAuthorization extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static values = {
    url: String
  };
  static targets = ["activity", "approvers", "submitBtn", "memberId"];

  /** Fetch approvers from API for selected activity and member. */
  getApprovers(event) {
    this.approversTarget.value = "";
    let activityId = this.activityTarget.value;
    let url = this.urlValue + "/" + activityId + "/" + this.memberIdTarget.value;
    fetch(url, this.optionsForFetch()).then(response => response.json()).then(data => {
      let list = [];
      data.forEach(item => {
        list.push({
          value: item.id,
          text: item.sca_name
        });
      });
      this.approversTarget.options = list;
      this.submitBtnTarget.disabled = true;
      this.approversTarget.disabled = false;
    });
  }

  /** Disable approvers dropdown on initial connection. */
  acConnected() {
    if (this.hasApproversTarget) {
      this.approversTarget.disabled = true;
    }
  }

  /** Return AJAX request headers. */
  optionsForFetch() {
    return {
      headers: {
        "X-Requested-With": "XMLHttpRequest",
        "Accept": "application/json"
      }
    };
  }

  /** Enable submit button when valid approver is selected. */
  checkReadyToSubmit() {
    let approverValue = this.approversTarget.value;
    let approverNum = parseInt(approverValue);
    if (approverNum > 0) {
      this.submitBtnTarget.disabled = false;
    } else {
      this.submitBtnTarget.disabled = true;
    }
  }

  /** Disable submit button on initial connection. */
  submitBtnTargetConnected() {
    this.submitBtnTarget.disabled = true;
  }

  /** Disable approvers dropdown on initial connection. */
  approversTargetConnected() {
    this.approversTarget.disabled = true;
  }
}

// Register controller with global registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["activities-request-auth"] = ActivitiesRequestAuthorization;

/***/ }),

/***/ "./plugins/Awards/Assets/js/controllers/award-form-controller.js":
/*!***********************************************************************!*\
  !*** ./plugins/Awards/Assets/js/controllers/award-form-controller.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * Awards Award Form Controller
 *
 * Manages dynamic multi-value field lists (e.g., specialties) with add/remove
 * functionality and JSON serialization for form submission.
 *
 * Targets: new, formValue, displayList
 */
class AwardsAwardForm extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["new", "formValue", "displayList"];

  /** Initialize empty items array for list tracking. */
  initialize() {
    this.items = [];
  }

  /** Add new item to list, preventing duplicates and syncing form value. */
  add(event) {
    event.preventDefault();
    if (!this.newTarget.value) {
      return;
    }
    if (this.items.includes(this.newTarget.value)) {
      return;
    }
    let item = this.newTarget.value;
    this.items.push(item);
    this.createListItem(KMP_utils.sanitizeString(item));
    this.formValueTarget.value = JSON.stringify(this.items);
    this.newTarget.value = '';
  }

  /** Remove item from list and update form value. */
  remove(event) {
    event.preventDefault();
    let id = event.target.getAttribute('data-id');
    this.items = this.items.filter(item => {
      return item !== id;
    });
    this.formValueTarget.value = JSON.stringify(this.items);
    event.target.parentElement.remove();
  }

  /** Restore list from form value on connect. */
  connect() {
    if (this.formValueTarget.value && this.formValueTarget.value.length > 0) {
      this.items = JSON.parse(this.formValueTarget.value);
      if (!Array.isArray(this.items)) {
        this.items = [];
      }
      this.items.forEach(item => {
        this.createListItem(item);
      });
    }
  }

  /** Create Bootstrap-styled list item with remove button. */
  createListItem(item) {
    let removeButton = document.createElement('button');
    removeButton.innerHTML = 'Remove';
    removeButton.setAttribute('data-action', 'awards-award-form#remove');
    removeButton.setAttribute('data-id', item);
    removeButton.setAttribute('class', 'btn btn-danger btn-sm');
    removeButton.setAttribute('type', 'button');
    let inputGroup = document.createElement('div');
    inputGroup.setAttribute('class', 'input-group mb-1');
    let span = document.createElement('span');
    span.innerHTML = item;
    span.setAttribute('class', 'form-control');
    inputGroup.appendChild(span);
    inputGroup.appendChild(removeButton);
    this.displayListTarget.appendChild(inputGroup);
  }
}
// add to window.Controllers with a name of the controller
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["awards-award-form"] = AwardsAwardForm;

/***/ }),

/***/ "./plugins/Awards/Assets/js/controllers/rec-add-controller.js":
/*!********************************************************************!*\
  !*** ./plugins/Awards/Assets/js/controllers/rec-add-controller.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * Awards Recommendation Add Form Controller
 *
 * Handles new recommendation submission with member validation, hierarchical award
 * selection via tabbed interface, and dynamic specialty population.
 *
 * Targets: scaMember, notFound, branch, externalLinks, awardDescriptions, award,
 *          reason, gatherings, specialty
 * Values: publicProfileUrl (String), awardListUrl (String), gatheringsUrl (String)
 */
class AwardsRecommendationAddForm extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["scaMember", "notFound", "branch", "externalLinks", "awardDescriptions", "award", "reason", "gatherings", "specialty"];
  static values = {
    publicProfileUrl: String,
    awardListUrl: String,
    gatheringsUrl: String
  };

  /** Enable disabled fields before form submission. */
  submit(event) {
    this.notFoundTarget.disabled = false;
    this.scaMemberTarget.disabled = false;
    this.specialtyTarget.disabled = false;
  }

  /** Handle award tab selection, populate specialties, and update gatherings. */
  setAward(event) {
    let awardId = event.target.dataset.awardId;
    this.awardTarget.value = awardId;
    this.populateSpecialties(event);
    this.updateGatherings(awardId);
  }

  /** Fetch gatherings filtered by award and update checkboxes. */
  updateGatherings(awardId) {
    if (!awardId || !this.hasGatheringsTarget) {
      return;
    }

    // Get member_id if available
    let memberId = this.hasScaMemberTarget ? this.scaMemberTarget.value : '';

    // Build URL with query params
    let url = this.gatheringsUrlValue + '/' + awardId;
    if (memberId) {
      url += '?member_id=' + memberId;
    }
    fetch(url, this.optionsForFetch()).then(response => response.json()).then(data => {
      if (data.gatherings) {
        // Get the container and find the fieldset/form-group within
        const container = this.gatheringsTarget;

        // Find and preserve the label
        const label = container.querySelector('label.form-label, legend');
        const labelText = label ? label.textContent : 'Gatherings/Events They May Attend:';

        // Clear existing content
        container.innerHTML = '';

        // Rebuild with new checkboxes
        if (data.gatherings.length > 0) {
          // Add the label back
          const newLabel = document.createElement('label');
          newLabel.className = 'form-label';
          newLabel.textContent = labelText;
          container.appendChild(newLabel);

          // Add hidden input for empty submission
          const hiddenInput = document.createElement('input');
          hiddenInput.type = 'hidden';
          hiddenInput.name = 'gatherings[_ids]';
          hiddenInput.value = '';
          container.appendChild(hiddenInput);

          // Add checkbox for each gathering
          data.gatherings.forEach(gathering => {
            const checkDiv = document.createElement('div');
            checkDiv.className = 'form-check';
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'form-check-input';
            checkbox.name = 'gatherings[_ids][]';
            checkbox.value = gathering.id;
            checkbox.id = 'gatherings-ids-' + gathering.id;
            const checkLabel = document.createElement('label');
            checkLabel.className = 'form-check-label';
            checkLabel.htmlFor = 'gatherings-ids-' + gathering.id;
            checkLabel.textContent = gathering.display;
            checkDiv.appendChild(checkbox);
            checkDiv.appendChild(checkLabel);
            container.appendChild(checkDiv);
          });
        } else {
          // No gatherings available - show message
          const newLabel = document.createElement('label');
          newLabel.className = 'form-label';
          newLabel.textContent = labelText;
          container.appendChild(newLabel);
          const noGatherings = document.createElement('p');
          noGatherings.className = 'text-muted';
          noGatherings.textContent = 'No gatherings available for this award.';
          container.appendChild(noGatherings);
        }
      }
    }).catch(error => {
      console.error('Error fetching gatherings:', error);
    });
  }

  /** Get standard fetch options with JSON headers. */
  optionsForFetch() {
    return {
      headers: {
        "X-Requested-With": "XMLHttpRequest",
        "Accept": "application/json"
      }
    };
  }

  /** Fetch awards for domain and create tabbed selection interface. */
  populateAwardDescriptions(event) {
    let url = this.awardListUrlValue + "/" + event.target.value;
    fetch(url, this.optionsForFetch()).then(response => response.json()).then(data => {
      this.awardDescriptionsTarget.innerHTML = "";
      let tabButtons = document.createElement("ul");
      tabButtons.classList.add("nav", "nav-pills");
      tabButtons.setAttribute("role", "tablist");
      let tabContentArea = document.createElement("div");
      tabContentArea.classList.add("tab-content");
      tabContentArea.classList.add("border");
      tabContentArea.classList.add("border-light-subtle");
      tabContentArea.classList.add("p-2");
      tabContentArea.innerHTML = "";
      this.awardTarget.value = "";
      let active = "active";
      let show = "show";
      let selected = "true";
      let awardList = [];
      if (data.length > 0) {
        data.forEach(function (award) {
          //create list item
          awardList.push({
            value: award.id,
            text: award.name,
            data: award
          });
          //create tab info
          var tabButton = document.createElement("li");
          tabButton.classList.add("nav-item");
          tabButton.setAttribute("role", "presentation");
          var button = document.createElement("button");
          button.classList.add("nav-link");
          if (active == "active") {
            button.classList.add("active");
          }
          button.setAttribute("data-action", "click->awards-rec-add#setAward");
          button.setAttribute("id", "award_" + award.id + "_btn");
          button.setAttribute("data-bs-toggle", "tab");
          button.setAttribute("data-bs-target", "#award_" + award.id);
          button.setAttribute('data-award-id', award.id);
          button.setAttribute("type", "button");
          button.setAttribute("role", "tab");
          button.setAttribute("aria-controls", "award_" + award.id);
          button.setAttribute("aria-selected", selected);
          button.innerHTML = award.name;
          tabButton.appendChild(button);
          var tabContent = document.createElement("div");
          tabContent.classList.add("tab-pane");
          tabContent.classList.add("fade");
          if (show == "show") {
            tabContent.classList.add("show");
          }
          if (active == "active") {
            tabContent.classList.add("active");
          }
          tabContent.setAttribute("id", "award_" + award.id);
          tabContent.setAttribute("role", "tabpanel");
          tabContent.setAttribute("aria-labelledby", "award_" + award.id + "_btn");
          tabContent.innerHTML = award.name + ": " + award.description;
          active = "";
          show = "";
          selected = "false";
          tabButtons.append(tabButton);
          tabContentArea.append(tabContent);
        });
        this.awardDescriptionsTarget.appendChild(tabButtons);
        this.awardDescriptionsTarget.appendChild(tabContentArea);
        this.awardTarget.options = awardList;
        this.awardTarget.disabled = false;
      } else {
        this.awardTarget.options = [{
          value: "No awards available",
          text: "No awards available"
        }];
        this.awardTarget.value = "No awards available";
        this.awardTarget.disabled = true;
      }
    });
  }
  /** Update specialty dropdown based on selected award's configuration. */
  populateSpecialties(event) {
    let awardId = this.awardTarget.value;
    let options = this.awardTarget.options;
    let award = this.awardTarget.options.find(award => award.value == awardId);
    let specialtyArray = [];
    if (award.data.specialties != null && award.data.specialties.length > 0) {
      award.data.specialties.forEach(function (specialty) {
        specialtyArray.push({
          value: specialty,
          text: specialty
        });
      });
      this.specialtyTarget.options = specialtyArray;
      this.specialtyTarget.value = "";
      this.specialtyTarget.disabled = false;
      this.specialtyTarget.hidden = false;
    } else {
      this.specialtyTarget.options = [{
        value: "No specialties available",
        text: "No specialties available"
      }];
      this.specialtyTarget.value = "No specialties available";
      this.specialtyTarget.disabled = true;
      this.specialtyTarget.hidden = true;
    }
  }

  /** Handle member field change, load profile or show branch field if not found. */
  loadScaMemberInfo(event) {
    //reset member metadata area
    this.externalLinksTarget.innerHTML = "";
    let memberPublicId = event.target.value;
    if (memberPublicId && memberPublicId.length > 0) {
      this.notFoundTarget.checked = false;
      this.branchTarget.hidden = true;
      this.branchTarget.disabled = true;
      this.loadMember(memberPublicId);
    } else {
      this.notFoundTarget.checked = true;
      this.branchTarget.hidden = false;
      this.branchTarget.disabled = false;
      this.branchTarget.focus();
    }
  }

  /** Fetch and display member profile external links. */
  loadMember(memberPublicId) {
    let url = this.publicProfileUrlValue + "/" + memberPublicId;
    fetch(url, this.optionsForFetch()).then(response => response.json()).then(data => {
      this.externalLinksTarget.innerHTML = "";
      let keys = Object.keys(data.external_links);
      if (keys.length > 0) {
        var LinksTitle = document.createElement("div");
        LinksTitle.innerHTML = "<h5>Public Links</h5>";
        LinksTitle.classList.add("col-12");
        this.externalLinksTarget.appendChild(LinksTitle);
        for (let key in data.external_links) {
          let div = document.createElement("div");
          div.classList.add("col-12");
          let a = document.createElement("a");
          a.href = data.external_links[key];
          a.text = key;
          a.target = "_blank";
          div.appendChild(a);
          this.externalLinksTarget.appendChild(div);
        }
      } else {
        var noLink = document.createElement("div");
        noLink.innerHTML = "<h5>No links available</h5>";
        noLink.classList.add("col-12");
        this.externalLinksTarget.appendChild(noLink);
      }
    });
  }

  /** Initialize field state when autocomplete connects. */
  acConnected(event) {
    var target = event.detail["awardsRecAddTarget"];
    switch (target) {
      case "branch":
        this.branchTarget.disabled = true;
        this.branchTarget.hidden = true;
        this.branchTarget.value = "";
        break;
      case "award":
        this.awardTarget.disabled = true;
        this.awardTarget.value = "Select Award Type First";
        break;
      case "scaMember":
        this.scaMemberTarget.value = "";
        break;
      case "specialty":
        this.specialtyTarget.value = "Select Award First";
        this.specialtyTarget.disabled = true;
        this.specialtyTarget.hidden = true;
        break;
      default:
        event.target.value = "";
        break;
    }
  }

  /** Initialize form state with disabled fields and empty values. */
  connect() {
    this.notFoundTarget.checked = false;
    this.notFoundTarget.disabled = true;
    this.reasonTarget.value = "";
    //this.personToNotifyTarget.value = "";
    if (this.hasGatheringsTarget) {
      // Disable all checkboxes within the gatherings container
      this.gatheringsTarget.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        checkbox.checked = false;
        checkbox.disabled = true;
      });
    }
  }
}
// add to window.Controllers with a name of the controller
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["awards-rec-add"] = AwardsRecommendationAddForm;

/***/ }),

/***/ "./plugins/Awards/Assets/js/controllers/rec-bulk-edit-controller.js":
/*!**************************************************************************!*\
  !*** ./plugins/Awards/Assets/js/controllers/rec-bulk-edit-controller.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * Awards Recommendation Bulk Edit Controller
 *
 * Modal form for batch state updates on multiple recommendations with
 * state-driven field rules and gathering intersection logic.
 *
 * Targets: bulkIds, gatherings, state, planToGiveBlock, planToGiveGathering,
 *          givenBlock, recId, turboFrame, givenDate, closeReason, closeReasonBlock,
 *          stateRulesBlock
 * Values: formUrl (String), turboFrameUrl (String), bulkIds (Array), gatheringsUrl (String)
 * Outlets: outlet-btn
 */
class AwardsRecommendationBulkEditForm extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["bulkIds", "gatherings", "state", "planToGiveBlock", "planToGiveGathering", "givenBlock", "recId", "turboFrame", "givenDate", "closeReason", "closeReasonBlock", "stateRulesBlock"];
  static values = {
    formUrl: String,
    turboFrameUrl: String,
    bulkIds: Array,
    gatheringsUrl: String
  };
  static outlets = ['outlet-btn'];

  /** Receive bulk IDs from table selection and update form action URL. */
  setId(event) {
    console.log("setId called", event.detail);
    //debugger;

    let selected = event.detail.ids;
    if (!selected) {
      return;
    }
    if (!selected.length) {
      return;
    }
    this.bulkIdsValue = selected;
    this.bulkIdsTarget.value = selected;
    let actionUrl = this.element.getAttribute("action");
    //replace url
    actionUrl = actionUrl.replace(/update-states/, "updateStates");
    this.element.setAttribute("action", actionUrl);
    console.log("setId", this.element["action"]);

    // Update gatherings list based on selected recommendations
    this.updateGatherings();
    return;
  }

  /** Fetch gatherings that can give all selected awards via intersection. */
  async updateGatherings() {
    // Need both IDs and URL to fetch gatherings
    if (!this.bulkIdsValue || this.bulkIdsValue.length === 0 || !this.gatheringsUrlValue) {
      return;
    }
    const status = this.stateTarget.value;
    const currentSelection = this.planToGiveGatheringTarget.value;
    try {
      const response = await fetch(this.gatheringsUrlValue, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Requested-With': 'XMLHttpRequest'
        },
        body: JSON.stringify({
          ids: this.bulkIdsValue,
          status: status
        })
      });
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();

      // Clear existing options except the first (empty) one
      while (this.planToGiveGatheringTarget.options.length > 1) {
        this.planToGiveGatheringTarget.remove(1);
      }

      // Add new options
      if (data.gatherings && data.gatherings.length > 0) {
        data.gatherings.forEach(gathering => {
          const option = document.createElement('option');
          option.value = gathering.id;
          option.textContent = gathering.display_name;
          this.planToGiveGatheringTarget.appendChild(option);
        });

        // Restore previous selection if it still exists
        if (currentSelection) {
          const optionExists = Array.from(this.planToGiveGatheringTarget.options).some(opt => opt.value === currentSelection);
          if (optionExists) {
            this.planToGiveGatheringTarget.value = currentSelection;
          }
        }
      }
    } catch (error) {
      console.error('Error fetching gatherings:', error);
    }
  }

  /** Register listener when outlet-btn connects. */
  outletBtnOutletConnected(outlet, element) {
    outlet.addListener(this.setId.bind(this));
  }

  /** Remove listener when outlet-btn disconnects. */
  outletBtnOutletDisconnected(outlet) {
    outlet.removeListener(this.setId.bind(this));
  }

  /** Close modal after form submission. */
  submit(event) {
    document.getElementById("recommendation_bulk_edit_close").click();
  }

  /** Apply field rules when state target connects. */
  stateTargetConnected() {
    this.setFieldRules();
  }

  /** Parse JSON state rules and apply Visible/Required/Disabled field states. */
  setFieldRules() {
    var rulesstring = this.stateRulesBlockTarget.textContent;
    var rules = JSON.parse(rulesstring);
    this.planToGiveBlockTarget.style.display = "none";
    this.givenBlockTarget.style.display = "none";
    this.planToGiveGatheringTarget.required = false;
    this.givenDateTarget.required = false;
    this.closeReasonBlockTarget.style.display = "none";
    this.closeReasonTarget.required = false;
    var state = this.stateTarget.value;

    //check status rules for the status
    if (rules[state]) {
      var statusRules = rules[state];
      var controller = this;
      if (statusRules["Visible"]) {
        statusRules["Visible"].forEach(function (field) {
          if (controller[field]) {
            controller[field].style.display = "block";
          }
        });
      }
      if (statusRules["Disabled"]) {
        statusRules["Disabled"].forEach(function (field) {
          if (controller[field]) {
            controller[field].disabled = true;
          }
        });
      }
      if (statusRules["Required"]) {
        statusRules["Required"].forEach(function (field) {
          if (controller[field]) {
            controller[field].required = true;
          }
        });
      }
    }

    // Update gatherings list when status changes (affects future vs all gatherings)
    this.updateGatherings();
  }

  /** Initialize bulk edit controller. */
  connect() {}
}
// add to window.Controllers with a name of the controller
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["awards-rec-bulk-edit"] = AwardsRecommendationBulkEditForm;

/***/ }),

/***/ "./plugins/Awards/Assets/js/controllers/rec-edit-controller.js":
/*!*********************************************************************!*\
  !*** ./plugins/Awards/Assets/js/controllers/rec-edit-controller.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * Awards Recommendation Edit Form Controller
 *
 * Manages edit interface for award recommendations with state-driven form behavior,
 * dynamic field validation, member discovery, and Turbo Frame integration.
 *
 * Targets: scaMember, notFound, branch, externalLinks, domain, award, reason,
 *          gatherings, specialty, state, planToGiveBlock, planToGiveGathering,
 *          givenBlock, recId, turboFrame, givenDate, closeReason, closeReasonBlock,
 *          stateRulesBlock
 * Values: publicProfileUrl (String), awardListUrl (String), formUrl (String),
 *         turboFrameUrl (String), gatheringsUrl (String)
 * Outlets: outlet-btn
 *
 * State rules parsed from stateRulesBlock JSON control field Visible/Required/Disabled states.
 */
class AwardsRecommendationEditForm extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["scaMember", "notFound", "branch", "externalLinks", "domain", "award", "reason", "gatherings", "specialty", "state", "planToGiveBlock", "planToGiveGathering", "givenBlock", "recId", "turboFrame", "givenDate", "closeReason", "closeReasonBlock", "stateRulesBlock"];
  static values = {
    publicProfileUrl: String,
    awardListUrl: String,
    formUrl: String,
    turboFrameUrl: String,
    gatheringsUrl: String
  };
  static outlets = ['outlet-btn'];

  /** Set recommendation ID and update Turbo Frame source and form action URL. */
  setId(event) {
    this.turboFrameTarget.setAttribute("src", this.turboFrameUrlValue + "/" + event.detail.id);
    this.element.setAttribute("action", this.formUrlValue + "/" + event.detail.id);
  }

  /** Register listener when outlet-btn connects. */
  outletBtnOutletConnected(outlet, element) {
    outlet.addListener(this.setId.bind(this));
  }

  /** Remove listener when outlet-btn disconnects. */
  outletBtnOutletDisconnected(outlet) {
    outlet.removeListener(this.setId.bind(this));
  }

  /** Enable disabled fields before form submission. */
  submit(event) {
    this.notFoundTarget.disabled = false;
    this.scaMemberTarget.disabled = false;
    this.specialtyTarget.disabled = false;
  }

  /** Handle award selection, populate specialties, and update gatherings list. */
  setAward(event) {
    let awardId = event.target.dataset.awardId;
    this.awardTarget.value = awardId;
    if (this.awardTarget.value != "") {
      this.populateSpecialties(event);
      this.updateGatherings(awardId);
    }
  }

  /** Fetch gatherings filtered by award and update checkboxes and dropdown. */
  updateGatherings(awardId) {
    if (!awardId) {
      return;
    }

    // Get member_id if available
    let memberId = this.hasScaMemberTarget ? this.scaMemberTarget.value : '';

    // Get status if available
    let status = this.hasStateTarget ? this.stateTarget.value : '';

    // Build URL with query params
    let url = this.gatheringsUrlValue + '/' + awardId;
    let params = new URLSearchParams();
    if (memberId) {
      params.append('member_id', memberId);
    }
    if (status) {
      params.append('status', status);
    }
    if (params.toString()) {
      url += '?' + params.toString();
    }
    fetch(url, this.optionsForFetch()).then(response => response.json()).then(data => {
      if (data.gatherings) {
        // Update the gatherings checkboxes
        const gatheringsContainer = document.getElementById('recommendation__gathering_ids');
        if (gatheringsContainer) {
          // Save currently selected values
          const selectedValues = [];
          gatheringsContainer.querySelectorAll('input[type="checkbox"]:checked').forEach(cb => {
            selectedValues.push(cb.value);
          });

          // Clear existing options
          gatheringsContainer.innerHTML = '';

          // Add new options as checkboxes
          data.gatherings.forEach(gathering => {
            const div = document.createElement('div');
            div.className = 'form-check';
            const input = document.createElement('input');
            input.type = 'checkbox';
            input.className = 'form-check-input';
            input.name = 'gatherings[_ids][]';
            input.value = gathering.id;
            input.id = `gathering-${gathering.id}`;

            // Restore checked state if it was previously selected
            if (selectedValues.includes(gathering.id.toString())) {
              input.checked = true;
            }
            const label = document.createElement('label');
            label.className = 'form-check-label';
            label.htmlFor = `gathering-${gathering.id}`;
            label.textContent = gathering.display;
            div.appendChild(input);
            div.appendChild(label);
            gatheringsContainer.appendChild(div);
          });
        }

        // Also update the planToGiveGathering dropdown if it exists
        if (this.hasPlanToGiveGatheringTarget) {
          // Try to get current value, fallback to initial value stored on connect
          const currentValue = this.planToGiveGatheringTarget.value || this.planToGiveGatheringTarget.dataset.initialValue || '';

          // Clear existing options
          this.planToGiveGatheringTarget.innerHTML = '';

          // Add default option
          const defaultOption = document.createElement('option');
          defaultOption.value = '';
          defaultOption.textContent = 'Select Gathering';
          this.planToGiveGatheringTarget.appendChild(defaultOption);

          // Add gathering options
          data.gatherings.forEach(gathering => {
            const option = document.createElement('option');
            option.value = gathering.id;
            option.textContent = gathering.display;

            // Restore selected state if it matches current or initial value
            if (gathering.id.toString() === currentValue) {
              option.selected = true;
            }
            this.planToGiveGatheringTarget.appendChild(option);
          });

          // Update the stored value for next time
          if (currentValue) {
            this.planToGiveGatheringTarget.dataset.initialValue = currentValue;
          }
        }
      }
    }).catch(error => {
      console.error('Error fetching gatherings:', error);
    });
  }

  /** Fetch awards for domain and populate award selection with autocomplete. */
  populateAwardDescriptions(event) {
    let url = this.awardListUrlValue + "/" + event.target.value;
    fetch(url, this.optionsForFetch()).then(response => response.json()).then(data => {
      this.awardTarget.value = "";
      let active = "active";
      let show = "show";
      let selected = "true";
      let awardList = [];
      if (data.length > 0) {
        data.forEach(function (award) {
          awardList.push({
            value: award.id,
            text: award.name,
            data: award
          });
        });
        this.awardTarget.options = awardList;
        this.awardTarget.disabled = false;
        if (this.awardTarget.dataset.acInitSelectionValue) {
          let val = JSON.parse(this.awardTarget.dataset.acInitSelectionValue);
          this.awardTarget.value = val.value;
          if (this.awardTarget.value != "") {
            this.populateSpecialties({
              target: {
                value: val.value
              }
            });
          }
        }
      } else {
        this.awardTarget.options = [{
          value: "No awards available",
          text: "No awards available"
        }];
        this.awardTarget.value = "No awards available";
        this.awardTarget.disabled = true;
        this.specialtyTarget.options = [{
          value: "No specialties available",
          text: "No specialties available"
        }];
        this.specialtyTarget.value = "No specialties available";
        this.specialtyTarget.disabled = true;
        this.specialtyTarget.hidden = true;
      }
    });
  }

  /** Update specialty dropdown based on selected award's configuration. */
  populateSpecialties(event) {
    let awardId = this.awardTarget.value;
    let options = this.awardTarget.options;
    let award = this.awardTarget.options.find(award => award.value == awardId);
    let specialtyArray = [];
    if (award.data.specialties != null && award.data.specialties.length > 0) {
      award.data.specialties.forEach(function (specialty) {
        specialtyArray.push({
          value: specialty,
          text: specialty
        });
      });
      this.specialtyTarget.options = specialtyArray;
      this.specialtyTarget.value = "";
      this.specialtyTarget.disabled = false;
      this.specialtyTarget.hidden = false;
      if (this.specialtyTarget.dataset.acInitSelectionValue) {
        let val = JSON.parse(this.specialtyTarget.dataset.acInitSelectionValue);
        this.specialtyTarget.value = val.value;
      }
    } else {
      this.specialtyTarget.options = [{
        value: "No specialties available",
        text: "No specialties available"
      }];
      this.specialtyTarget.value = "No specialties available";
      this.specialtyTarget.disabled = true;
      this.specialtyTarget.hidden = true;
    }
  }

  /** Handle member field change, load profile or show branch field if not found. */
  loadScaMemberInfo(event) {
    this.externalLinksTarget.innerHTML = "";
    let memberId = Number(event.target.value.replace(/_/g, ""));
    if (memberId > 0) {
      this.notFoundTarget.checked = false;
      this.branchTarget.hidden = true;
      this.branchTarget.disabled = true;
      this.loadMember(memberId);
    } else {
      this.notFoundTarget.checked = true;
      this.branchTarget.hidden = false;
      this.branchTarget.disabled = false;
      this.branchTarget.focus();
    }
  }

  /** Get standard fetch options with JSON headers. */
  optionsForFetch() {
    return {
      headers: {
        "X-Requested-With": "XMLHttpRequest",
        "Accept": "application/json"
      }
    };
  }

  /** Fetch and display member profile external links. */
  loadMember(memberId) {
    let url = this.publicProfileUrlValue + "/" + memberId;
    fetch(url, this.optionsForFetch()).then(response => response.json()).then(data => {
      this.externalLinksTarget.innerHTML = "";
      let keys = Object.keys(data.external_links);
      if (keys.length > 0) {
        var LinksTitle = document.createElement("div");
        LinksTitle.innerHTML = "<h5>Public Links</h5>";
        LinksTitle.classList.add("col-12");
        this.externalLinksTarget.appendChild(LinksTitle);
        for (let key in data.external_links) {
          let div = document.createElement("div");
          div.classList.add("col-12");
          let a = document.createElement("a");
          a.href = data.external_links[key];
          a.text = key;
          a.target = "_blank";
          div.appendChild(a);
          this.externalLinksTarget.appendChild(div);
        }
      } else {
        var noLink = document.createElement("div");
        noLink.innerHTML = "<h5>No links available</h5>";
        noLink.classList.add("col-12");
        this.externalLinksTarget.appendChild(noLink);
      }
    });
  }

  /** Load member info when scaMember target connects with existing value. */
  scaMemberTargetConnected() {
    if (this.scaMemberTarget.value != "") {
      this.loadScaMemberInfo({
        target: {
          value: this.scaMemberTarget.value
        }
      });
    }
  }

  /** Apply field rules when state target connects. */
  stateTargetConnected() {
    console.log("status connected");
    this.setFieldRules();
  }

  /** Parse JSON state rules and apply Visible/Required/Disabled field states. */
  setFieldRules() {
    console.log("setting field rules");
    var rulesstring = this.stateRulesBlockTarget.textContent;
    var rules = JSON.parse(rulesstring);
    if (this.specialtyTarget.options.length == 0) {
      this.specialtyTarget.hidden = true;
      this.specialtyTarget.disabled = true;
    }
    this.planToGiveBlockTarget.style.display = "none";
    this.givenBlockTarget.style.display = "none";

    // Store the current givenDate value before potentially clearing it
    if (this.givenDateTarget.value && !this.givenDateTarget.dataset.initialValue) {
      this.givenDateTarget.dataset.initialValue = this.givenDateTarget.value;
    }

    // Only clear givenDate if it doesn't have an initial value stored
    if (!this.givenDateTarget.dataset.initialValue) {
      this.givenDateTarget.value = "";
    } else {
      // Restore the initial value if it was cleared
      if (!this.givenDateTarget.value) {
        this.givenDateTarget.value = this.givenDateTarget.dataset.initialValue;
      }
    }
    this.domainTarget.disabled = false;
    this.awardTarget.disabled = false;
    this.specialtyTarget.disabled = this.specialtyTarget.hidden;
    this.scaMemberTarget.disabled = false;
    this.planToGiveGatheringTarget.required = false;
    this.givenDateTarget.required = false;
    this.closeReasonBlockTarget.style.display = "none";
    this.closeReasonTarget.required = false;
    if (this.notFoundTarget.checked) {
      this.branchTarget.disabled = false;
      this.branchTarget.hidden = false;
    } else {
      this.branchTarget.disabled = true;
      this.branchTarget.hidden = true;
    }
    var state = this.stateTarget.value;

    //check status rules for the status
    if (rules[state]) {
      var statusRules = rules[state];
      var controller = this;
      if (statusRules["Visible"]) {
        statusRules["Visible"].forEach(function (field) {
          if (controller[field]) {
            controller[field].style.display = "block";
          }
        });
      }
      if (statusRules["Disabled"]) {
        statusRules["Disabled"].forEach(function (field) {
          if (controller[field]) {
            controller[field].disabled = true;
          }
        });
      }
      if (statusRules["Required"]) {
        statusRules["Required"].forEach(function (field) {
          if (controller[field]) {
            controller[field].required = true;
          }
        });
      }
    }

    // Update gatherings when state changes (e.g., to/from "Given")
    if (this.hasAwardTarget && this.awardTarget.value) {
      this.updateGatherings(this.awardTarget.value);
    }
  }

  /** Store initial gathering value on connect for persistence through updates. */
  connect() {
    // Store the initial gathering_id value so it persists through option updates
    if (this.hasPlanToGiveGatheringTarget && this.planToGiveGatheringTarget.value) {
      this.planToGiveGatheringTarget.dataset.initialValue = this.planToGiveGatheringTarget.value;
    }
  }

  /** Update form action URL when recId target connects. */
  recIdTargetConnected() {
    let recId = this.recIdTarget.value;
    let actionUrl = this.element.getAttribute("action");
    //trim the last / off of the end of the action url
    actionUrl = actionUrl.replace(/\/\d+$/, "");
    actionUrl = actionUrl + "/" + recId;
    this.element.setAttribute("action", actionUrl);
  }

  /** Store initial gathering value on target connect. */
  planToGiveGatheringTargetConnected() {
    // Store the initial value from the server-rendered form
    if (this.planToGiveGatheringTarget.value) {
      this.planToGiveGatheringTarget.dataset.initialValue = this.planToGiveGatheringTarget.value;
    }
  }

  /** Store initial given date value on target connect. */
  givenDateTargetConnected() {
    // Store the initial value from the server-rendered form
    if (this.givenDateTarget.value) {
      this.givenDateTarget.dataset.initialValue = this.givenDateTarget.value;
    }
  }
}
// add to window.Controllers with a name of the controller
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["awards-rec-edit"] = AwardsRecommendationEditForm;

/***/ }),

/***/ "./plugins/Awards/Assets/js/controllers/rec-quick-edit-controller.js":
/*!***************************************************************************!*\
  !*** ./plugins/Awards/Assets/js/controllers/rec-quick-edit-controller.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * Awards Recommendation Quick Edit Form Controller
 *
 * Streamlined modal form for rapid recommendation updates with state-driven
 * field rules. Simplified version of rec-edit for administrative efficiency.
 *
 * Targets: domain, award, reason, gatherings, specialty, state, planToGiveBlock,
 *          planToGiveGathering, givenBlock, recId, memberId, turboFrame, givenDate,
 *          closeReason, closeReasonBlock, stateRulesBlock
 * Values: publicProfileUrl (String), awardListUrl (String), formUrl (String),
 *         turboFrameUrl (String), gatheringsUrl (String)
 * Outlets: outlet-btn
 */
class AwardsRecommendationQuickEditForm extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["domain", "award", "reason", "gatherings", "specialty", "state", "planToGiveBlock", "planToGiveGathering", "givenBlock", "recId", "memberId", "turboFrame", "givenDate", "closeReason", "closeReasonBlock", "stateRulesBlock"];
  static values = {
    publicProfileUrl: String,
    awardListUrl: String,
    formUrl: String,
    turboFrameUrl: String,
    gatheringsUrl: String
  };
  static outlets = ['outlet-btn'];

  /** Set recommendation ID and update Turbo Frame source and form action. */
  setId(event) {
    if (event.detail.id) {
      this.turboFrameTarget.setAttribute("src", this.turboFrameUrlValue + "/" + event.detail.id);
      this.element.setAttribute("action", this.formUrlValue + "/" + event.detail.id);
    }
  }

  /** Register listener when outlet-btn connects. */
  outletBtnOutletConnected(outlet, element) {
    outlet.addListener(this.setId.bind(this));
  }

  /** Remove listener when outlet-btn disconnects. */
  outletBtnOutletDisconnected(outlet) {
    outlet.removeListener(this.setId.bind(this));
  }

  /** Close modal after form submission. */
  submit(event) {
    document.getElementById("recommendation_edit_close").click();
  }

  /** Handle award selection, populate specialties, and update gatherings. */
  setAward(event) {
    let awardId = event.target.dataset.awardId;
    this.awardTarget.value = awardId;
    if (this.awardTarget.value != "") {
      this.populateSpecialties(event);
      this.updateGatherings(awardId);
    }
  }

  /** Fetch gatherings filtered by award and update checkboxes and dropdown. */
  updateGatherings(awardId) {
    if (!awardId) {
      return;
    }

    // Get member_id if available
    let memberId = this.hasMemberIdTarget ? this.memberIdTarget.value : '';

    // Get status if available
    let status = this.hasStateTarget ? this.stateTarget.value : '';

    // Build URL with query params
    let url = this.gatheringsUrlValue + '/' + awardId;
    let params = new URLSearchParams();
    if (memberId) {
      params.append('member_id', memberId);
    }
    if (status) {
      params.append('status', status);
    }
    if (params.toString()) {
      url += '?' + params.toString();
    }
    fetch(url, this.optionsForFetch()).then(response => response.json()).then(data => {
      if (data.gatherings) {
        // Update the gatherings checkboxes
        const gatheringsContainer = document.getElementById('recommendation__gathering_ids');
        if (gatheringsContainer) {
          // Save currently selected values
          const selectedValues = [];
          gatheringsContainer.querySelectorAll('input[type="checkbox"]:checked').forEach(cb => {
            selectedValues.push(cb.value);
          });

          // Clear existing options
          gatheringsContainer.innerHTML = '';

          // Add new options as checkboxes
          data.gatherings.forEach(gathering => {
            const div = document.createElement('div');
            div.className = 'form-check';
            const input = document.createElement('input');
            input.type = 'checkbox';
            input.className = 'form-check-input';
            input.name = 'gatherings[_ids][]';
            input.value = gathering.id;
            input.id = `gathering-${gathering.id}`;

            // Restore checked state if it was previously selected
            if (selectedValues.includes(gathering.id.toString())) {
              input.checked = true;
            }
            const label = document.createElement('label');
            label.className = 'form-check-label';
            label.htmlFor = `gathering-${gathering.id}`;
            label.textContent = gathering.display;
            div.appendChild(input);
            div.appendChild(label);
            gatheringsContainer.appendChild(div);
          });
        }

        // Also update the planToGiveGathering dropdown if it exists
        if (this.hasPlanToGiveGatheringTarget) {
          // Try to get current value, fallback to initial value stored on connect
          const currentValue = this.planToGiveGatheringTarget.value || this.planToGiveGatheringTarget.dataset.initialValue || '';

          // Clear existing options
          this.planToGiveGatheringTarget.innerHTML = '';

          // Add default option
          const defaultOption = document.createElement('option');
          defaultOption.value = '';
          defaultOption.textContent = 'Select Gathering';
          this.planToGiveGatheringTarget.appendChild(defaultOption);

          // Add gathering options
          data.gatherings.forEach(gathering => {
            const option = document.createElement('option');
            option.value = gathering.id;
            option.textContent = gathering.display;

            // Restore selected state if it matches current or initial value
            if (gathering.id.toString() === currentValue) {
              option.selected = true;
            }
            this.planToGiveGatheringTarget.appendChild(option);
          });

          // Update the stored value for next time
          if (currentValue) {
            this.planToGiveGatheringTarget.dataset.initialValue = currentValue;
          }
        }
      }
    }).catch(error => {
      console.error('Error fetching gatherings:', error);
    });
  }

  /** Fetch awards for domain and populate award selection with autocomplete. */
  populateAwardDescriptions(event) {
    let url = this.awardListUrlValue + "/" + event.target.value;
    fetch(url, this.optionsForFetch()).then(response => response.json()).then(data => {
      this.awardTarget.value = "";
      let active = "active";
      let show = "show";
      let selected = "true";
      let awardList = [];
      if (data.length > 0) {
        data.forEach(function (award) {
          awardList.push({
            value: award.id,
            text: award.name,
            data: award
          });
        });
        this.awardTarget.options = awardList;
        this.awardTarget.disabled = false;
        if (this.awardTarget.dataset.acInitSelectionValue) {
          let val = JSON.parse(this.awardTarget.dataset.acInitSelectionValue);
          this.awardTarget.value = val.value;
          if (this.awardTarget.value != "") {
            this.populateSpecialties({
              target: {
                value: val.value
              }
            });
          }
        }
      } else {
        this.awardTarget.options = [{
          value: "No awards available",
          text: "No awards available"
        }];
        this.awardTarget.value = "No awards available";
        this.awardTarget.disabled = true;
        this.specialtyTarget.options = [{
          value: "No specialties available",
          text: "No specialties available"
        }];
        this.specialtyTarget.value = "No specialties available";
        this.specialtyTarget.disabled = true;
        this.specialtyTarget.hidden = true;
      }
    });
  }

  /** Update specialty dropdown based on selected award's configuration. */
  populateSpecialties(event) {
    let awardId = this.awardTarget.value;
    let options = this.awardTarget.options;
    let award = this.awardTarget.options.find(award => award.value == awardId);
    let specialtyArray = [];
    if (award.data.specialties != null && award.data.specialties.length > 0) {
      award.data.specialties.forEach(function (specialty) {
        specialtyArray.push({
          value: specialty,
          text: specialty
        });
      });
      this.specialtyTarget.options = specialtyArray;
      this.specialtyTarget.value = "";
      this.specialtyTarget.disabled = false;
      this.specialtyTarget.hidden = false;
      if (this.specialtyTarget.dataset.acInitSelectionValue) {
        let val = JSON.parse(this.specialtyTarget.dataset.acInitSelectionValue);
        this.specialtyTarget.value = val.value;
      }
    } else {
      this.specialtyTarget.options = [{
        value: "No specialties available",
        text: "No specialties available"
      }];
      this.specialtyTarget.value = "No specialties available";
      this.specialtyTarget.disabled = true;
      this.specialtyTarget.hidden = true;
    }
  }

  /** Placeholder for member info loading (not used in quick edit). */
  loadScaMemberInfo(event) {}

  /** Get standard fetch options with JSON headers. */
  optionsForFetch() {
    return {
      headers: {
        "X-Requested-With": "XMLHttpRequest",
        "Accept": "application/json"
      }
    };
  }

  /** Apply field rules when state target connects. */
  stateTargetConnected() {
    console.log("status connected");
    this.setFieldRules();
  }

  /** Parse JSON state rules and apply Visible/Required/Disabled field states. */
  setFieldRules() {
    console.log("setting field rules");
    var rulesstring = this.stateRulesBlockTarget.textContent;
    var rules = JSON.parse(rulesstring);
    if (this.specialtyTarget.options.length == 0) {
      this.specialtyTarget.hidden = true;
      this.specialtyTarget.disabled = true;
    }
    this.planToGiveBlockTarget.style.display = "none";
    this.givenBlockTarget.style.display = "none";

    // Store the current givenDate value before potentially clearing it
    if (this.givenDateTarget.value && !this.givenDateTarget.dataset.initialValue) {
      this.givenDateTarget.dataset.initialValue = this.givenDateTarget.value;
    }

    // Only clear givenDate if it doesn't have an initial value stored
    if (!this.givenDateTarget.dataset.initialValue) {
      this.givenDateTarget.value = "";
    } else {
      // Restore the initial value if it was cleared
      if (!this.givenDateTarget.value) {
        this.givenDateTarget.value = this.givenDateTarget.dataset.initialValue;
      }
    }
    this.domainTarget.disabled = false;
    this.awardTarget.disabled = false;
    this.specialtyTarget.disabled = this.specialtyTarget.hidden;
    this.planToGiveGatheringTarget.required = false;
    this.givenDateTarget.required = false;
    this.closeReasonBlockTarget.style.display = "none";
    this.closeReasonTarget.required = false;
    var state = this.stateTarget.value;

    //check status rules for the status
    if (rules[state]) {
      var statusRules = rules[state];
      var controller = this;
      if (statusRules["Visible"]) {
        statusRules["Visible"].forEach(function (field) {
          if (controller[field]) {
            controller[field].style.display = "block";
          }
        });
      }
      if (statusRules["Disabled"]) {
        statusRules["Disabled"].forEach(function (field) {
          if (controller[field]) {
            controller[field].disabled = true;
          }
        });
      }
      if (statusRules["Required"]) {
        statusRules["Required"].forEach(function (field) {
          if (controller[field]) {
            controller[field].required = true;
          }
        });
      }
    }

    // Update gatherings when state changes (e.g., to/from "Given")
    if (this.hasAwardTarget && this.awardTarget.value) {
      this.updateGatherings(this.awardTarget.value);
    }
  }

  /** Store initial gathering value on connect for persistence through updates. */
  connect() {
    // Store the initial gathering_id value so it persists through option updates
    if (this.hasPlanToGiveGatheringTarget && this.planToGiveGatheringTarget.value) {
      this.planToGiveGatheringTarget.dataset.initialValue = this.planToGiveGatheringTarget.value;
    }
  }

  /** Update form action URL when recId target connects. */
  recIdTargetConnected() {
    let recId = this.recIdTarget.value;
    let actionUrl = this.element.getAttribute("action");
    //trim the last / off of the end of the action url
    actionUrl = actionUrl.replace(/\/\d+$/, "");
    actionUrl = actionUrl + "/" + recId;
    this.element.setAttribute("action", actionUrl);
  }

  /** Store initial gathering value on target connect. */
  planToGiveGatheringTargetConnected() {
    // Store the initial value from the server-rendered form
    if (this.planToGiveGatheringTarget.value) {
      this.planToGiveGatheringTarget.dataset.initialValue = this.planToGiveGatheringTarget.value;
    }
  }

  /** Store initial given date value on target connect. */
  givenDateTargetConnected() {
    // Store the initial value from the server-rendered form
    if (this.givenDateTarget.value) {
      this.givenDateTarget.dataset.initialValue = this.givenDateTarget.value;
    }
  }
}
// add to window.Controllers with a name of the controller
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["awards-rec-quick-edit"] = AwardsRecommendationQuickEditForm;

/***/ }),

/***/ "./plugins/Awards/Assets/js/controllers/rec-table-controller.js":
/*!**********************************************************************!*\
  !*** ./plugins/Awards/Assets/js/controllers/rec-table-controller.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * Awards Recommendation Table Controller
 *
 * Manages recommendation table with multi-selection checkboxes for bulk operations.
 * Communicates selected IDs to outlet controllers for coordinated actions.
 *
 * Targets: rowCheckbox, CheckAllBox
 * Outlets: outlet-btn
 */
class AwardsRecommendationTable extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["rowCheckbox", "CheckAllBox"];
  static outlets = ["outlet-btn"];

  /** Collect checked IDs and send to outlet button for bulk operations. */
  checked(event) {
    console.log("Check button checked ", this.element);
    let idList = [];
    this.outletBtnOutlet.btnDataValue = {};
    this.rowCheckboxTargets.forEach(input => {
      if (input.checked) {
        idList.push(input.value);
      }
    });
    if (idList.length > 0) {
      this.outletBtnOutlet.btnDataValue = {
        "ids": idList
      };
    }
  }

  /** Initialize table controller. */
  connect() {}

  /** Toggle all checkboxes and update outlet with selected IDs. */
  checkAll(ele) {
    if (this.CheckAllBoxTarget.checked) {
      console.log("Checking All Checkboxes!", this.element);
      let idList = [];
      for (var i = 0; i < this.rowCheckboxTargets.length; i++) {
        this.rowCheckboxTargets[i].checked = true;
        idList.push(this.rowCheckboxTargets[i].value);
      }
      this.outletBtnOutlet.btnDataValue = {
        "ids": idList
      };
    } else {
      console.log("Unchecking All Checkboxes!", this.element);
      this.outletBtnOutlet.btnDataValue = {};
      for (var i = 0; i < this.rowCheckboxTargets.length; i++) {
        this.rowCheckboxTargets[i].checked = false;
      }
      this.outletBtnOutlet.btnDataValue = {};
    }
  }
}

// add to window.Controllers with a name of the controller
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["awards-rec-table"] = AwardsRecommendationTable;

/***/ }),

/***/ "./plugins/Awards/Assets/js/controllers/recommendation-kanban-controller.js":
/*!**********************************************************************************!*\
  !*** ./plugins/Awards/Assets/js/controllers/recommendation-kanban-controller.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * Recommendation Kanban Controller
 *
 * Manages kanban-style workflow for recommendations with drag-and-drop
 * state transitions and business rule validation.
 *
 * Targets: stateRulesBlock
 * Outlets: kanban
 */
class RecommendationKanbanController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["stateRulesBlock"];
  static outlets = ["kanban"];
  board = null;

  /** Register validation callback when kanban outlet connects. */
  kanbanOutletConnected(outlet, element) {
    this.board = outlet;
    var controller = this;
    this.board.registerBeforeDrop((recId, toCol) => {
      return controller.checkRules(recId, toCol);
    });
  }

  /** Validate state transition rules for drag-and-drop operations. */
  checkRules(recId, toCol) {
    console.log({
      recId: recId,
      toCol: toCol
    });
    return true;
  }
}
// add to window.Controllers with a name of the controller
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["recommendation-kanban"] = RecommendationKanbanController;

/***/ }),

/***/ "./plugins/GitHubIssueSubmitter/assets/js/controllers/github-submitter-controller.js":
/*!*******************************************************************************************!*\
  !*** ./plugins/GitHubIssueSubmitter/assets/js/controllers/github-submitter-controller.js ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * GitHub Submitter Controller - AJAX feedback submission to GitHub Issues
 *
 * Targets: success, formBlock, submitBtn, issueLink, form, modal
 * Values: url (String) - API endpoint for issue submission
 */
class GitHubSubmitter extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["success", "formBlock", "submitBtn", "issueLink", "form", "modal"];

  // Define configurable values from HTML data attributes
  static values = {
    url: String
  };

  /**
   * Handle form submission via AJAX to GitHub Issues API.
   * @param {Event} event - Form submission event
   */
  submit(event) {
    event.preventDefault();
    let url = this.urlValue;
    let form = this.formTarget;
    let formData = new FormData(form);
    fetch(url, {
      method: 'POST',
      body: formData
    }).then(response => {
      if (response.ok) {
        return response.json();
      } else {
        throw new Error('An error occurred while creating the issue.');
      }
    }).then(data => {
      if (data.message) {
        alert("Error: " + data.message);
        return;
      }
      form.reset();
      this.formBlockTarget.style.display = 'none';
      this.submitBtnTarget.style.display = 'none';
      this.issueLinkTarget.href = data.url;
      this.successTarget.style.display = 'block';
    }).catch(error => {
      console.error(error);
      alert('An error occurred while creating the issue.');
    });
  }

  /** Reset UI state when modal is hidden. */
  modalTargetConnected() {
    this.modalTarget.addEventListener('hidden.bs.modal', () => {
      this.formBlockTarget.style.display = 'block';
      this.successTarget.style.display = 'none';
      this.submitBtnTarget.style.display = 'block';
    });
  }

  /** Clean up modal event listeners. */
  modalTargetDisconnected() {
    this.modalTarget.removeEventListener('hidden.bs.modal', () => {
      this.formBlockTarget.style.display = 'block';
      this.successTarget.style.display = 'none';
      this.submitBtnTarget.style.display = 'block';
    });
  }

  /** Initialize UI state on controller connect. */
  connect() {
    this.formBlockTarget.style.display = 'block';
    this.successTarget.style.display = 'none';
    this.submitBtnTarget.style.display = 'block';
  }
}

// Register controller with global registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["github-submitter"] = GitHubSubmitter;

/***/ }),

/***/ "./plugins/Officers/assets/js/controllers/assign-officer-controller.js":
/*!*****************************************************************************!*\
  !*** ./plugins/Officers/assets/js/controllers/assign-officer-controller.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/**
 * Officer Assignment Controller - Member-to-office assignment interface
 *
 * Targets: assignee, submitBtn, deputyDescBlock, deputyDesc, office, endDateBlock, endDate, emailAddress, emailAddressBlock
 * Values: url (String)
 * Outlets: outlet-btn, member-serach
 */


class OfficersAssignOfficer extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static values = {
    url: String
  };
  static targets = ["assignee", "submitBtn", "deputyDescBlock", "deputyDesc", "office", "endDateBlock", "endDate", "emailAddress", "emailAddressBlock"];
  static outlets = ["outlet-btn", "member-serach"];

  /** Configure form fields based on selected office (deputy fields, email, etc). */
  setOfficeQuestions() {
    this.deputyDescBlockTarget.classList.add('d-none');
    this.endDateBlockTarget.classList.add('d-none');
    this.emailAddressBlockTarget.classList.add('d-none');
    this.endDateTarget.disabled = true;
    this.deputyDescTarget.disabled = true;
    this.emailAddressTarget.disabled = true;
    var officeVal = this.officeTarget.value;
    // set the member search url by taking the current url and removing the last part (if it is a number) and replacing it with the officeVal
    var url = this.assigneeTarget.getAttribute('data-ac-url-value');
    var urlParts = url.split('/');
    var lastPart = urlParts[urlParts.length - 1];
    if (parseInt(lastPart)) {
      urlParts.pop();
    }
    urlParts.push(officeVal);
    var newUrl = urlParts.join('/');
    this.assigneeTarget.setAttribute('data-ac-url-value', newUrl);
    var office = this.officeTarget.options.find(option => option.value == officeVal);
    if (office) {
      if (office.data.is_deputy) {
        this.deputyDescBlockTarget.classList.remove('d-none');
        this.endDateBlockTarget.classList.remove('d-none');
        this.endDateTarget.disabled = false;
        this.deputyDescTarget.disabled = false;
      }
      if (office.data.email_address) {
        this.emailAddressBlockTarget.classList.remove('d-none');
        this.emailAddressTarget.disabled = false;
        this.emailAddressTarget.value = office.data.email_address;
      }
      this.checkReadyToSubmit();
      return;
    }
  }

  /** Enable/disable submit button based on assignee and office selection. */
  checkReadyToSubmit() {
    var assigneeVal = this.assigneeTarget.value;
    var officeVal = this.officeTarget.value;
    var assignId = parseInt(assigneeVal);
    var officeId = parseInt(officeVal);
    if (assignId > 0 && officeId > 0) {
      this.submitBtnTarget.disabled = false;
    } else {
      this.submitBtnTarget.disabled = true;
    }
  }

  /** Disable submit button on initial connection. */
  submitBtnTargetConnected() {
    this.submitBtnTarget.disabled = true;
  }

  /** Disable end date field on initial connection. */
  endDateTargetConnected() {
    this.endDateTarget.disabled = true;
  }

  /** Disable deputy description field on initial connection. */
  deputyDescTargetConnected() {
    this.deputyDescTarget.disabled = true;
  }

  /** Hide optional field blocks on controller connect. */
  connect() {
    this.deputyDescBlockTarget.classList.add('d-none');
    this.endDateBlockTarget.classList.add('d-none');
    this.emailAddressBlockTarget.classList.add('d-none');
  }
}

// Register controller with global registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["officers-assign-officer"] = OfficersAssignOfficer;

/***/ }),

/***/ "./plugins/Officers/assets/js/controllers/edit-officer-controller.js":
/*!***************************************************************************!*\
  !*** ./plugins/Officers/assets/js/controllers/edit-officer-controller.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/**
 * Officer Edit Controller - Populates edit form from officer selection events
 *
 * Targets: deputyDescBlock, deputyDesc, id, emailAddress, emailAddressBlock
 * Outlets: outlet-btn
 */


class EditOfficer extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["deputyDescBlock", "deputyDesc", "id", "emailAddress", "emailAddressBlock"];
  static outlets = ["outlet-btn"];

  /**
   * Populate edit form with officer data from selection event.
   * @param {Event} event - Event containing officer data (id, deputy_description, email_address, is_deputy)
   */
  setId(event) {
    this.idTarget.value = event.detail.id;
    this.deputyDescTarget.value = event.detail.deputy_description;
    this.emailAddressTarget.value = event.detail.email_address;
    if (event.detail.is_deputy == '1') {
      this.deputyDescBlockTarget.classList.remove('d-none');
      this.deputyDescTarget.value = event.detail.deputy_description.replace(/:/g, '').trim();
    } else {
      this.deputyDescBlockTarget.classList.add('d-none');
    }
    if (event.detail.email_address != '') {
      this.emailAddressBlockTarget.classList.remove('d-none');
    } else {
      this.emailAddressBlockTarget.classList.add('d-none');
    }
  }

  /** Register setId listener when outlet button connects. */
  outletBtnOutletConnected(outlet, element) {
    outlet.addListener(this.setId.bind(this));
  }

  /** Remove setId listener when outlet button disconnects. */
  outletBtnOutletDisconnected(outlet) {
    outlet.removeListener(this.setId.bind(this));
  }
}

// Register controller with global registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["officers-edit-officer"] = EditOfficer;

/***/ }),

/***/ "./plugins/Officers/assets/js/controllers/office-form-controller.js":
/*!**************************************************************************!*\
  !*** ./plugins/Officers/assets/js/controllers/office-form-controller.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/**
 * Office Form Controller - Manages deputy/reporting structure toggle
 *
 * Targets: reportsTo, reportsToBlock, deputyTo, deputyToBlock, isDeputy
 */


class OfficeFormController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["reportsTo", "reportsToBlock", "deputyTo", "deputyToBlock", "isDeputy"];

  /** Toggle between deputy and reports-to fields based on isDeputy checkbox. */
  toggleIsDeputy() {
    if (this.isDeputyTarget.checked) {
      this.deputyToBlockTarget.hidden = false;
      this.deputyToTarget.disabled = false;
      this.reportsToBlockTarget.hidden = true;
      this.reportsToTarget.disabled = true;
    } else {
      this.deputyToBlockTarget.hidden = true;
      this.deputyToTarget.disabled = true;
      this.deputyToTarget.value = "";
      this.reportsToBlockTarget.hidden = false;
      this.reportsToTarget.disabled = false;
    }
  }

  /** Initialize form state on controller connect. */
  connect() {
    console.log("connected");
    this.toggleIsDeputy();
  }
}

// Register controller with global registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["office-form"] = OfficeFormController;

/***/ }),

/***/ "./plugins/Officers/assets/js/controllers/officer-roster-search-controller.js":
/*!************************************************************************************!*\
  !*** ./plugins/Officers/assets/js/controllers/officer-roster-search-controller.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/**
 * Officer Roster Search Controller - Search form validation
 *
 * Targets: warrantPeriods, departments, showBtn
 */


class OfficerRosterSearchForm extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["warrantPeriods", "departments", "showBtn"];

  /** Enable search button when both warrant period and department are selected. */
  checkEnable() {
    if (this.warrantPeriodsTarget.value > 0 && this.departmentsTarget.value > 0) {
      this.showBtnTarget.disabled = false;
    } else {
      this.showBtnTarget.disabled = true;
    }
  }
  connect() {}
}

// Register controller with global registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["officer-roster-search"] = OfficerRosterSearchForm;

/***/ }),

/***/ "./plugins/Officers/assets/js/controllers/officer-roster-table-controller.js":
/*!***********************************************************************************!*\
  !*** ./plugins/Officers/assets/js/controllers/officer-roster-table-controller.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/**
 * Officer Roster Table Controller - Row selection and bulk operations
 *
 * Targets: rowCheckbox
 * Outlets: outlet-btn
 */


class OfficerRosterTableForm extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["rowCheckbox"];
  static outlets = ['outlet-btn'];
  ids = [];
  submitBtn = null;

  /** Store submit button reference and enable if selections exist. */
  outletBtnOutletConnected(outlet, element) {
    this.submitBtn = outlet;
    if (this.ids.length > 0) {
      this.submitBtn.element.disabled = false;
    }
  }

  /** Clear submit button reference on disconnect. */
  outletBtnOutletDisconnected(outlet) {
    this.submitBtn = null;
  }

  /** Register checkbox ID on target connect. */
  rowCheckboxTargetConnected(element) {
    this.ids.push(element.value);
    console.log(this.ids);
  }

  /** Update selection array and enable/disable submit button on checkbox change. */
  rowChecked(event) {
    if (event.target.checked) {
      this.ids.push(event.target.value);
    } else {
      this.ids = this.ids.filter(id => id != event.target.value);
    }
    this.submitBtn.element.disabled = true;
    if (this.ids.length > 0) {
      this.submitBtn.element.disabled = false;
    }
    console.log(this.ids);
  }
  connect() {}
}

// Register controller with global registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["officer-roster-table"] = OfficerRosterTableForm;

/***/ }),

/***/ "./plugins/Template/assets/js/controllers/hello-world-controller.js":
/*!**************************************************************************!*\
  !*** ./plugins/Template/assets/js/controllers/hello-world-controller.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * Hello World Stimulus Controller
 * 
 * This controller demonstrates the Stimulus.js pattern used in KMP plugins.
 * Stimulus controllers provide interactive behavior for frontend components
 * without requiring a full JavaScript framework.
 * 
 * Key Concepts:
 * - Targets: DOM elements the controller interacts with
 * - Values: Properties that can be set from HTML attributes
 * - Actions: Event handlers triggered by user interaction
 * - Outlets: Connections to other Stimulus controllers
 * 
 * Usage in HTML:
 * <div data-controller="hello-world"
 *      data-hello-world-message-value="Hello from Stimulus!">
 *   <input data-hello-world-target="input" type="text">
 *   <button data-action="click->hello-world#greet">Greet</button>
 *   <div data-hello-world-target="output"></div>
 * </div>
 */
class HelloWorldController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  // Define targets - elements this controller interacts with
  static targets = ["input", "output", "counter"];

  // Define values - properties that can be set from HTML data attributes
  static values = {
    message: {
      type: String,
      default: "Hello, World!"
    },
    count: {
      type: Number,
      default: 0
    }
  };

  /**
   * Initialize the controller
   * Called once when the controller is first instantiated
   */
  initialize() {
    console.log("HelloWorld controller initialized");
  }

  /**
   * Connect the controller to the DOM
   * Called when the controller is connected to the DOM
   */
  connect() {
    console.log("HelloWorld controller connected to:", this.element);
    this.updateCounter();
  }

  /**
   * Disconnect the controller from the DOM
   * Called when the controller is disconnected from the DOM
   * Use for cleanup (removing event listeners, timers, etc.)
   */
  disconnect() {
    console.log("HelloWorld controller disconnected");
  }

  /**
   * Greet action - Display a greeting message
   * Triggered by: data-action="click->hello-world#greet"
   */
  greet(event) {
    event.preventDefault();

    // Get the input value if available
    const name = this.hasInputTarget ? this.inputTarget.value : "World";

    // Create greeting message
    const greeting = name ? `${this.messageValue}, ${name}!` : this.messageValue;

    // Display in output target
    if (this.hasOutputTarget) {
      this.outputTarget.textContent = greeting;
      this.outputTarget.classList.add("alert", "alert-success", "mt-3");
    }

    // Increment counter
    this.countValue++;
  }

  /**
   * Clear action - Clear the output
   * Triggered by: data-action="click->hello-world#clear"
   */
  clear(event) {
    event.preventDefault();
    if (this.hasInputTarget) {
      this.inputTarget.value = "";
    }
    if (this.hasOutputTarget) {
      this.outputTarget.textContent = "";
      this.outputTarget.className = "";
    }
  }

  /**
   * Value changed callback - Called when message value changes
   * Automatically called when messageValue is updated
   */
  messageValueChanged() {
    console.log("Message value changed to:", this.messageValue);
  }

  /**
   * Value changed callback - Called when count value changes
   * Automatically called when countValue is updated
   */
  countValueChanged() {
    this.updateCounter();
  }

  /**
   * Update the counter display
   */
  updateCounter() {
    if (this.hasCounterTarget) {
      this.counterTarget.textContent = this.countValue;
    }
  }

  /**
   * Example of a method that could be called from other controllers
   * or JavaScript code
   */
  showMessage(message) {
    if (this.hasOutputTarget) {
      this.outputTarget.textContent = message;
      this.outputTarget.classList.add("alert", "alert-info", "mt-3");
    }
  }

  /**
   * Example of an async method - fetch data from server
   */
  async fetchData(url) {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      return data;
    } catch (error) {
      console.error("Error fetching data:", error);
      if (this.hasOutputTarget) {
        this.outputTarget.textContent = "Error loading data";
        this.outputTarget.classList.add("alert", "alert-danger", "mt-3");
      }
      return null;
    }
  }
}

// Register the controller globally
// This makes it available to the Stimulus application
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["hello-world"] = HelloWorldController;
/* harmony default export */ __webpack_exports__["default"] = (HelloWorldController);

/***/ }),

/***/ "./plugins/Waivers/assets/css/waiver-upload.css":
/*!******************************************************!*\
  !*** ./plugins/Waivers/assets/css/waiver-upload.css ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./plugins/Waivers/assets/css/waivers.css":
/*!************************************************!*\
  !*** ./plugins/Waivers/assets/css/waivers.css ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./plugins/Waivers/assets/js/controllers/add-requirement-controller.js":
/*!*****************************************************************************!*\
  !*** ./plugins/Waivers/assets/js/controllers/add-requirement-controller.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/**
 * Waivers Add Requirement Controller
 *
 * Manages waiver requirement form with dynamic waiver type discovery
 * for gathering activities. Fetches available types excluding already assigned.
 *
 * Targets: waiverType, submitBtn, activityId
 * Values: url (String)
 */


class WaiversAddRequirement extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static values = {
    url: String
  };
  static targets = ["waiverType", "submitBtn", "activityId"];

  /** Fetch available waiver types for activity and populate dropdown. */
  loadWaiverTypes() {
    let activityId = this.activityIdTarget.value;
    let url = this.urlValue + "/" + activityId;
    fetch(url, this.optionsForFetch()).then(response => response.json()).then(data => {
      let list = [];
      if (data.waiverTypes && data.waiverTypes.length > 0) {
        data.waiverTypes.forEach(item => {
          list.push({
            value: item.id,
            text: item.name
          });
        });
      }
      this.waiverTypeTarget.options = list;
      this.submitBtnTarget.disabled = true;
    }).catch(error => {
      console.error('Error loading waiver types:', error);
      this.submitBtnTarget.disabled = true;
    });
  }

  /** Get standard fetch options with JSON headers. */
  optionsForFetch() {
    return {
      headers: {
        "X-Requested-With": "XMLHttpRequest",
        "Accept": "application/json"
      }
    };
  }

  /** Enable submit button when valid waiver type selected. */
  checkReadyToSubmit() {
    let waiverTypeValue = this.waiverTypeTarget.value;
    let waiverTypeNum = parseInt(waiverTypeValue);
    if (waiverTypeNum > 0) {
      this.submitBtnTarget.disabled = false;
    } else {
      this.submitBtnTarget.disabled = true;
    }
  }

  /** Disable submit button on connect. */
  submitBtnTargetConnected() {
    if (this.hasSubmitBtnTarget) {
      this.submitBtnTarget.disabled = true;
    }
  }
}

// Add to global controllers registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["waivers-add-requirement"] = WaiversAddRequirement;

/***/ }),

/***/ "./plugins/Waivers/assets/js/controllers/camera-capture-controller.js":
/*!****************************************************************************!*\
  !*** ./plugins/Waivers/assets/js/controllers/camera-capture-controller.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * Camera Capture Controller
 * 
 * Provides enhanced mobile camera capture functionality.
 * Works in conjunction with HTML5 file input capture attribute.
 * 
 * Note: Most camera functionality is handled by HTML5 capture="environment"
 * attribute. This controller provides UI enhancements and fallback behavior.
 * 
 * Targets:
 * - cameraInput: File input with camera capture
 * - cameraButton: Optional button to trigger camera
 * - preview: Preview area for captured images
 * 
 * Actions:
 * - triggerCamera: Open device camera
 * - handleCapture: Handle image capture
 */
class CameraCaptureController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["cameraInput", "cameraButton", "preview"];

  /**
   * Initialize controller
   */
  connect() {
    console.log('CameraCaptureController connected');
    this.detectMobileDevice();
  }

  /**
   * Detect if user is on mobile device
   * Updates UI to show mobile-specific instructions
   */
  detectMobileDevice() {
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    if (isMobile) {
      console.log('Mobile device detected - camera capture available');

      // Could add visual indicators that camera is available
      if (this.hasCameraInputTarget) {
        const parent = this.cameraInputTarget.parentElement;
        const helpText = parent.querySelector('.form-text');
        if (helpText) {
          helpText.classList.add('text-success');
          helpText.innerHTML = '<i class="bi bi-camera-fill"></i> ' + helpText.innerHTML;
        }
      }
    }
  }

  /**
   * Trigger camera input
   * Useful if you have a custom camera button instead of using the file input directly
   * 
   * @param {Event} event Button click event
   */
  triggerCamera(event) {
    event.preventDefault();
    if (this.hasCameraInputTarget) {
      this.cameraInputTarget.click();
    }
  }

  /**
   * Handle image capture
   * Called when user selects/captures an image
   * 
   * @param {Event} event File input change event
   */
  handleCapture(event) {
    const files = event.target.files;
    if (files && files.length > 0) {
      console.log(`Captured ${files.length} image(s)`);

      // Show preview if target exists
      if (this.hasPreviewTarget) {
        this.showImagePreview(files[0]);
      }

      // Dispatch custom event for other controllers to handle
      this.dispatch('imageCaptured', {
        detail: {
          files: Array.from(files)
        }
      });
    }
  }

  /**
   * Show image preview (optional enhancement)
   * 
   * @param {File} file Image file to preview
   */
  showImagePreview(file) {
    const reader = new FileReader();
    reader.onload = e => {
      this.previewTarget.innerHTML = `
                <div class="card">
                    <img src="${e.target.result}" class="card-img-top" alt="Preview" style="max-height: 300px; object-fit: contain;">
                    <div class="card-body">
                        <p class="card-text text-center">
                            <small class="text-muted">${file.name} (${this.formatFileSize(file.size)})</small>
                        </p>
                    </div>
                </div>
            `;
      this.previewTarget.style.display = 'block';
    };
    reader.readAsDataURL(file);
  }

  /**
   * Format file size
   * 
   * @param {number} bytes File size in bytes
   * @returns {string} Formatted size
   */
  formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
  }

  /**
   * Check if browser supports camera capture
   * 
   * @returns {boolean} True if capture is supported
   */
  static supportsCameraCapture() {
    const input = document.createElement('input');
    input.setAttribute('capture', 'camera');
    return input.capture !== undefined;
  }
}

// Add to global controllers registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["camera-capture"] = CameraCaptureController;

/***/ }),

/***/ "./plugins/Waivers/assets/js/controllers/exemption-reasons-controller.js":
/*!*******************************************************************************!*\
  !*** ./plugins/Waivers/assets/js/controllers/exemption-reasons-controller.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * Exemption Reasons Controller
 * 
 * Manages the dynamic list of exemption reasons for waiver types.
 * Allows administrators to add/remove reasons that can be selected when
 * attesting that a waiver is not needed for a gathering activity.
 */
class ExemptionReasonsController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["container", "template", "hiddenInput", "reasonInput"];
  static values = {
    reasons: {
      type: Array,
      default: []
    }
  };
  connect() {
    // Initialize with existing reasons or add one empty field
    if (this.reasonsValue && this.reasonsValue.length > 0) {
      this.reasonsValue.forEach(reason => {
        this.addReason(reason);
      });
    } else {
      this.addReason("");
    }
    this.updateHiddenInput();
  }

  /**
   * Add a new reason input field
   */
  addReason(value = "") {
    const template = this.templateTarget.content.cloneNode(true);
    const input = template.querySelector('input[type="text"]');
    const container = template.querySelector('.exemption-reason-item');
    if (value) {
      input.value = value;
    }
    this.containerTarget.appendChild(template);

    // Focus the new input if it's empty
    if (!value) {
      input.focus();
    }
  }

  /**
   * Remove a reason input field
   */
  removeReason(event) {
    const item = event.target.closest('.exemption-reason-item');

    // Always keep at least one field
    if (this.containerTarget.children.length > 1) {
      item.remove();
      this.updateHiddenInput();
    } else {
      // Clear the last field instead of removing it
      const input = item.querySelector('input[type="text"]');
      input.value = "";
      this.updateHiddenInput();
    }
  }

  /**
   * Update the hidden input with JSON array of reasons
   */
  updateHiddenInput() {
    const reasons = [];
    this.reasonInputTargets.forEach(input => {
      const value = input.value.trim();
      if (value) {
        reasons.push(value);
      }
    });
    this.hiddenInputTarget.value = JSON.stringify(reasons);
  }

  /**
   * Handle input changes to update hidden field
   */
  reasonChanged(event) {
    this.updateHiddenInput();
  }

  /**
   * Handle when an input loses focus
   * Add a new empty field if the last input now has a value
   */
  reasonBlurred(event) {
    const inputs = this.reasonInputTargets;
    const lastInput = inputs[inputs.length - 1];

    // If this is the last input and it has a value, add a new empty field
    if (event.target === lastInput && event.target.value.trim()) {
      this.addReason("");
    }
  }
}

// Add to global controllers registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["exemption-reasons"] = ExemptionReasonsController;

/***/ }),

/***/ "./plugins/Waivers/assets/js/controllers/hello-world-controller.js":
/*!*************************************************************************!*\
  !*** ./plugins/Waivers/assets/js/controllers/hello-world-controller.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * Hello World Stimulus Controller
 * 
 * This controller demonstrates the Stimulus.js pattern used in KMP plugins.
 * Stimulus controllers provide interactive behavior for frontend components
 * without requiring a full JavaScript framework.
 * 
 * Key Concepts:
 * - Targets: DOM elements the controller interacts with
 * - Values: Properties that can be set from HTML attributes
 * - Actions: Event handlers triggered by user interaction
 * - Outlets: Connections to other Stimulus controllers
 * 
 * Usage in HTML:
 * <div data-controller="hello-world"
 *      data-hello-world-message-value="Hello from Stimulus!">
 *   <input data-hello-world-target="input" type="text">
 *   <button data-action="click->hello-world#greet">Greet</button>
 *   <div data-hello-world-target="output"></div>
 * </div>
 */
class HelloWorldController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  // Define targets - elements this controller interacts with
  static targets = ["input", "output", "counter"];

  // Define values - properties that can be set from HTML data attributes
  static values = {
    message: {
      type: String,
      default: "Hello, World!"
    },
    count: {
      type: Number,
      default: 0
    }
  };

  /**
   * Initialize the controller
   * Called once when the controller is first instantiated
   */
  initialize() {
    console.log("HelloWorld controller initialized");
  }

  /**
   * Connect the controller to the DOM
   * Called when the controller is connected to the DOM
   */
  connect() {
    console.log("HelloWorld controller connected to:", this.element);
    this.updateCounter();
  }

  /**
   * Disconnect the controller from the DOM
   * Called when the controller is disconnected from the DOM
   * Use for cleanup (removing event listeners, timers, etc.)
   */
  disconnect() {
    console.log("HelloWorld controller disconnected");
  }

  /**
   * Greet action - Display a greeting message
   * Triggered by: data-action="click->hello-world#greet"
   */
  greet(event) {
    event.preventDefault();

    // Get the input value if available
    const name = this.hasInputTarget ? this.inputTarget.value : "World";

    // Create greeting message
    const greeting = name ? `${this.messageValue}, ${name}!` : this.messageValue;

    // Display in output target
    if (this.hasOutputTarget) {
      this.outputTarget.textContent = greeting;
      this.outputTarget.classList.add("alert", "alert-success", "mt-3");
    }

    // Increment counter
    this.countValue++;
  }

  /**
   * Clear action - Clear the output
   * Triggered by: data-action="click->hello-world#clear"
   */
  clear(event) {
    event.preventDefault();
    if (this.hasInputTarget) {
      this.inputTarget.value = "";
    }
    if (this.hasOutputTarget) {
      this.outputTarget.textContent = "";
      this.outputTarget.className = "";
    }
  }

  /**
   * Value changed callback - Called when message value changes
   * Automatically called when messageValue is updated
   */
  messageValueChanged() {
    console.log("Message value changed to:", this.messageValue);
  }

  /**
   * Value changed callback - Called when count value changes
   * Automatically called when countValue is updated
   */
  countValueChanged() {
    this.updateCounter();
  }

  /**
   * Update the counter display
   */
  updateCounter() {
    if (this.hasCounterTarget) {
      this.counterTarget.textContent = this.countValue;
    }
  }

  /**
   * Example of a method that could be called from other controllers
   * or JavaScript code
   */
  showMessage(message) {
    if (this.hasOutputTarget) {
      this.outputTarget.textContent = message;
      this.outputTarget.classList.add("alert", "alert-info", "mt-3");
    }
  }

  /**
   * Example of an async method - fetch data from server
   */
  async fetchData(url) {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      return data;
    } catch (error) {
      console.error("Error fetching data:", error);
      if (this.hasOutputTarget) {
        this.outputTarget.textContent = "Error loading data";
        this.outputTarget.classList.add("alert", "alert-danger", "mt-3");
      }
      return null;
    }
  }
}

// Register the controller globally
// This makes it available to the Stimulus application
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["hello-world"] = HelloWorldController;
/* harmony default export */ __webpack_exports__["default"] = (HelloWorldController);

/***/ }),

/***/ "./plugins/Waivers/assets/js/controllers/retention-policy-input-controller.js":
/*!************************************************************************************!*\
  !*** ./plugins/Waivers/assets/js/controllers/retention-policy-input-controller.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * Retention Policy Input Controller
 * 
 * Provides a structured interface for retention policy configuration with real-time preview.
 * Replaces simple JSON textarea with user-friendly inputs (years, months, days, anchor).
 * 
 * Targets:
 * - anchorSelect: The anchor point selection (gathering_end_date, upload_date, permanent)
 * - yearsInput: Years input field
 * - monthsInput: Months input field
 * - daysInput: Days input field
 * - durationSection: Container for duration inputs (hidden when anchor=permanent)
 * - preview: Preview text showing formatted policy
 * - hiddenInput: Hidden input that stores the JSON value for form submission
 * 
 * Actions:
 * - updatePreview: Updates preview text and hidden JSON field when any input changes
 */
class RetentionPolicyInputController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["anchorSelect", "yearsInput", "monthsInput", "daysInput", "durationSection", "preview", "hiddenInput"];

  /**
   * Initialize controller
   */
  connect() {
    // Initialize preview on load
    this.updatePreview();
  }

  /**
   * Update preview text and hidden JSON field
   * Called whenever any input changes
   */
  updatePreview() {
    const anchor = this.anchorSelectTarget.value;
    const years = parseInt(this.yearsInputTarget.value) || 0;
    const months = parseInt(this.monthsInputTarget.value) || 0;
    const days = parseInt(this.daysInputTarget.value) || 0;

    // Show/hide duration section based on anchor
    if (anchor === 'permanent') {
      this.durationSectionTarget.style.display = 'none';
    } else {
      this.durationSectionTarget.style.display = 'block';
    }

    // Build JSON structure
    let policy = {
      anchor: anchor
    };

    // Add duration if not permanent
    if (anchor !== 'permanent') {
      policy.duration = {};
      if (years > 0) policy.duration.years = years;
      if (months > 0) policy.duration.months = months;
      if (days > 0) policy.duration.days = days;
    }

    // Update hidden input with JSON
    this.hiddenInputTarget.value = JSON.stringify(policy);

    // Update preview text
    this.previewTarget.textContent = this.formatPreviewText(anchor, years, months, days);
  }

  /**
   * Format preview text in human-readable format
   * 
   * @param {string} anchor - The anchor point
   * @param {number} years - Years duration
   * @param {number} months - Months duration
   * @param {number} days - Days duration
   * @returns {string} Formatted preview text
   */
  formatPreviewText(anchor, years, months, days) {
    // Handle permanent retention
    if (anchor === 'permanent') {
      return 'Permanent retention (never expires)';
    }

    // Build duration parts
    const parts = [];
    if (years > 0) {
      parts.push(`${years} ${years === 1 ? 'year' : 'years'}`);
    }
    if (months > 0) {
      parts.push(`${months} ${months === 1 ? 'month' : 'months'}`);
    }
    if (days > 0) {
      parts.push(`${days} ${days === 1 ? 'day' : 'days'}`);
    }

    // If no duration specified, show warning
    if (parts.length === 0) {
      return ' No duration specified';
    }

    // Format anchor point text
    const anchorText = anchor === 'gathering_end_date' ? 'from gathering end date' : 'from upload date';
    return `${parts.join(', ')} ${anchorText}`;
  }

  /**
   * Parse existing JSON value into form fields
   * Called when editing an existing waiver type
   * 
   * @param {string} jsonValue - JSON string from database
   */
  parseJson(jsonValue) {
    try {
      const policy = JSON.parse(jsonValue);

      // Set anchor
      if (policy.anchor) {
        this.anchorSelectTarget.value = policy.anchor;
      }

      // Set duration values
      if (policy.duration) {
        this.yearsInputTarget.value = policy.duration.years || 0;
        this.monthsInputTarget.value = policy.duration.months || 0;
        this.daysInputTarget.value = policy.duration.days || 0;
      }

      // Update preview
      this.updatePreview();
    } catch (e) {
      console.error('Failed to parse retention policy JSON:', e);
      this.previewTarget.textContent = ' Invalid JSON format';
    }
  }

  /**
   * Validate inputs before form submission
   * 
   * @returns {boolean} True if valid, false otherwise
   */
  validate() {
    const anchor = this.anchorSelectTarget.value;

    // Permanent is always valid
    if (anchor === 'permanent') {
      return true;
    }

    // Check that at least one duration value is specified
    const years = parseInt(this.yearsInputTarget.value) || 0;
    const months = parseInt(this.monthsInputTarget.value) || 0;
    const days = parseInt(this.daysInputTarget.value) || 0;
    if (years === 0 && months === 0 && days === 0) {
      alert('Please specify at least one duration value (years, months, or days)');
      return false;
    }
    return true;
  }
}

// Add to global controllers registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["retention-policy-input"] = RetentionPolicyInputController;

/***/ }),

/***/ "./plugins/Waivers/assets/js/controllers/waiver-attestation-controller.js":
/*!********************************************************************************!*\
  !*** ./plugins/Waivers/assets/js/controllers/waiver-attestation-controller.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/* provided dependency */ var bootstrap = __webpack_require__(/*! bootstrap */ "./node_modules/bootstrap/dist/js/bootstrap.esm.js");


/**
 * Waiver Attestation Controller
 * 
 * Manages the modal for attesting that a waiver is not needed for a specific
 * activity/waiver type combination. Handles:
 * - Modal display with configurable reasons
 * - Reason selection
 * - Form submission via AJAX
 * - Success/error feedback
 * 
 * **Data Values**:
 * - activityId: Gathering activity ID
 * - waiverTypeId: Waiver type ID
 * - gatheringId: Gathering ID
 * - reasons: JSON array of exemption reasons
 * 
 * **Targets**:
 * - modal: The Bootstrap modal element
 * - reasonList: Container for reason radio buttons
 * - notes: Textarea for optional notes
 * - submitBtn: Submit button
 * - error: Error message container
 * - success: Success message container
 * 
 * **Actions**:
 * - showModal: Displays the modal with reasons
 * - submitAttestation: Submits the attestation form
 * 
 * @see GatheringWaiversController.attest() Server endpoint
 */
class WaiverAttestationController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["modal", "reasonList", "notes", "submitBtn", "error", "success"];
  static values = {
    activityId: Number,
    waiverTypeId: Number,
    gatheringId: Number,
    reasons: Array
  };

  /**
   * Initialize Bootstrap modal instance
   */
  connect() {
    if (this.hasModalTarget) {
      this.modalInstance = new bootstrap.Modal(this.modalTarget);
    }
  }

  /**
   * Show the modal and populate with reasons
   * Called when user clicks "Attest Not Needed" button
   */
  showModal(event) {
    event.preventDefault();

    // Get values from the button that was clicked
    const btn = event.currentTarget;
    this.activityIdValue = parseInt(btn.dataset.activityId);
    this.waiverTypeIdValue = parseInt(btn.dataset.waiverTypeId);
    this.gatheringIdValue = parseInt(btn.dataset.gatheringId);
    try {
      this.reasonsValue = JSON.parse(btn.dataset.reasons);
    } catch (e) {
      console.error('Failed to parse reasons:', e);
      this.reasonsValue = [];
    }

    // Populate reasons
    this.populateReasons();

    // Clear previous state
    this.clearMessages();
    if (this.hasNotesTarget) {
      this.notesTarget.value = '';
    }

    // Show modal
    if (this.modalInstance) {
      this.modalInstance.show();
    }
  }

  /**
   * Populate the reason selection radio buttons
   */
  populateReasons() {
    if (!this.hasReasonListTarget) return;
    const reasons = this.reasonsValue || [];
    if (reasons.length === 0) {
      this.reasonListTarget.innerHTML = `
                <div class="alert alert-warning">
                    <i class="bi bi-exclamation-triangle"></i>
                    No exemption reasons have been configured for this waiver type.
                </div>
            `;
      if (this.hasSubmitBtnTarget) {
        this.submitBtnTarget.disabled = true;
      }
      return;
    }

    // Build radio buttons
    let html = '<div class="list-group">';
    reasons.forEach((reason, index) => {
      const id = `reason_${index}`;
      html += `
                <label class="list-group-item list-group-item-action">
                    <input class="form-check-input me-2" type="radio" name="attestation_reason" 
                           id="${id}" value="${this.escapeHtml(reason)}">
                    ${this.escapeHtml(reason)}
                </label>
            `;
    });
    html += '</div>';
    this.reasonListTarget.innerHTML = html;
    if (this.hasSubmitBtnTarget) {
      this.submitBtnTarget.disabled = false;
    }
  }

  /**
   * Submit the attestation form
   */
  async submitAttestation(event) {
    event.preventDefault();

    // Get selected reason
    const selectedReason = this.reasonListTarget.querySelector('input[name="attestation_reason"]:checked');
    if (!selectedReason) {
      this.showError('Please select a reason for the exemption.');
      return;
    }
    const reason = selectedReason.value;
    const notes = this.hasNotesTarget ? this.notesTarget.value : '';

    // Disable submit button
    if (this.hasSubmitBtnTarget) {
      this.submitBtnTarget.disabled = true;
      this.submitBtnTarget.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span> Submitting...';
    }
    this.clearMessages();
    try {
      // Submit via AJAX
      const response = await fetch('/waivers/gathering-waivers/attest', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Requested-With': 'XMLHttpRequest',
          'X-CSRF-Token': this.getCsrfToken()
        },
        body: JSON.stringify({
          gathering_activity_id: this.activityIdValue,
          waiver_type_id: this.waiverTypeIdValue,
          gathering_id: this.gatheringIdValue,
          reason: reason,
          notes: notes
        })
      });
      const data = await response.json();
      if (response.ok && data.success) {
        this.showSuccess(data.message || 'Attestation recorded successfully.');

        // Reload page after short delay
        setTimeout(() => {
          window.location.reload();
        }, 1500);
      } else {
        this.showError(data.message || 'Failed to record attestation.');
        this.resetSubmitButton();
      }
    } catch (error) {
      console.error('Error submitting attestation:', error);
      this.showError('An error occurred while submitting the attestation.');
      this.resetSubmitButton();
    }
  }

  /**
   * Show error message
   */
  showError(message) {
    if (this.hasErrorTarget) {
      this.errorTarget.textContent = message;
      this.errorTarget.classList.remove('d-none');
    }
    if (this.hasSuccessTarget) {
      this.successTarget.classList.add('d-none');
    }
  }

  /**
   * Show success message
   */
  showSuccess(message) {
    if (this.hasSuccessTarget) {
      this.successTarget.textContent = message;
      this.successTarget.classList.remove('d-none');
    }
    if (this.hasErrorTarget) {
      this.errorTarget.classList.add('d-none');
    }
  }

  /**
   * Clear all messages
   */
  clearMessages() {
    if (this.hasErrorTarget) {
      this.errorTarget.classList.add('d-none');
    }
    if (this.hasSuccessTarget) {
      this.successTarget.classList.add('d-none');
    }
  }

  /**
   * Reset submit button to original state
   */
  resetSubmitButton() {
    if (this.hasSubmitBtnTarget) {
      this.submitBtnTarget.disabled = false;
      this.submitBtnTarget.innerHTML = '<i class="bi bi-shield-check"></i> Submit Attestation';
    }
  }

  /**
   * Get CSRF token from meta tag
   */
  getCsrfToken() {
    const meta = document.querySelector('meta[name="csrf-token"]');
    return meta ? meta.getAttribute('content') : '';
  }

  /**
   * Escape HTML to prevent XSS
   */
  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
}

// Register controller
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["waivers-waiver-attestation"] = WaiverAttestationController;

/***/ }),

/***/ "./plugins/Waivers/assets/js/controllers/waiver-template-controller.js":
/*!*****************************************************************************!*\
  !*** ./plugins/Waivers/assets/js/controllers/waiver-template-controller.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * WaiverTemplate Stimulus Controller
 * 
 * Manages the waiver template source selection interface, allowing users
 * to choose between uploading a PDF file or providing an external URL.
 * 
 * Features:
 * - Toggle between file upload and URL input
 * - Show/hide appropriate fields based on selection
 * - Clear unused fields when switching modes
 * 
 * Values:
 * - source: String - Current template source ('upload', 'url', or 'none')
 * 
 * Targets:
 * - uploadSection: Container for file upload field
 * - urlSection: Container for external URL field
 * - fileInput: File input element
 * - urlInput: URL text input element
 * 
 * Usage:
 * <div data-controller="waiver-template">
 *   <select data-action="change->waiver-template#toggleSource" 
 *           data-waiver-template-target="sourceSelect">
 *     <option value="none">No Template</option>
 *     <option value="upload">Upload PDF</option>
 *     <option value="url">External URL</option>
 *   </select>
 *   
 *   <div data-waiver-template-target="uploadSection">
 *     <input type="file" data-waiver-template-target="fileInput">
 *   </div>
 *   
 *   <div data-waiver-template-target="urlSection">
 *     <input type="text" data-waiver-template-target="urlInput">
 *   </div>
 * </div>
 */
class WaiverTemplateController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["uploadSection", "urlSection", "fileInput", "urlInput", "sourceSelect"];
  static values = {
    source: {
      type: String,
      default: "none"
    }
  };

  /**
   * Initialize controller
   */
  connect() {
    // Set initial state based on existing values
    this.updateDisplay();
  }

  /**
   * Handle template source selection change
   * 
   * @param {Event} event - Change event from source select
   */
  toggleSource(event) {
    this.sourceValue = event.target.value;
    this.updateDisplay();
  }

  /**
   * Handle file input change - auto-select upload option
   * 
   * @param {Event} event - Change event from file input
   */
  fileSelected(event) {
    if (event.target.files && event.target.files.length > 0) {
      // Auto-select "upload" in the dropdown
      if (this.hasSourceSelectTarget) {
        this.sourceSelectTarget.value = "upload";
        this.sourceValue = "upload";
        this.updateDisplay();
      }
    }
  }

  /**
   * Update the display based on current source value
   */
  updateDisplay() {
    const source = this.sourceValue;

    // Show/hide sections based on selection
    if (this.hasUploadSectionTarget) {
      this.uploadSectionTarget.style.display = source === "upload" ? "block" : "none";
    }
    if (this.hasUrlSectionTarget) {
      this.urlSectionTarget.style.display = source === "url" ? "block" : "none";
    }

    // Clear unused fields
    if (source !== "upload" && this.hasFileInputTarget) {
      this.fileInputTarget.value = "";
    }
    if (source !== "url" && this.hasUrlInputTarget) {
      this.urlInputTarget.value = "";
    }
  }

  /**
   * Handle source value changes
   */
  sourceValueChanged() {
    this.updateDisplay();
  }
}

// Register controller globally
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["waiver-template"] = WaiverTemplateController;

/***/ }),

/***/ "./plugins/Waivers/assets/js/controllers/waiver-upload-controller.js":
/*!***************************************************************************!*\
  !*** ./plugins/Waivers/assets/js/controllers/waiver-upload-controller.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");


/**
 * Waiver Upload Controller
 * 
 * Handles file selection, validation, preview, and upload progress for waiver images.
 * Supports multiple file uploads with mobile camera capture integration.
 * 
 * Targets:
 * - waiverType: Waiver type select dropdown
 * - fileInput: File input element
 * - preview: Preview area container
 * - progress: Progress bar container
 * - progressBar: Progress bar element
 * - progressText: Progress text element
 * - submitButton: Submit button
 * 
 * Actions:
 * - handleFileSelect: Triggered when files are selected
 * - handleSubmit: Triggered when form is submitted
 */
class WaiverUploadController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["waiverType", "fileInput", "preview", "progress", "progressBar", "progressText", "submitButton"];

  /**
   * Maximum file size in bytes (25MB)
   */
  static MAX_FILE_SIZE = 25 * 1024 * 1024;

  /**
   * Allowed MIME types for image uploads
   */
  static ALLOWED_TYPES = ['image/jpeg', 'image/jpg',
  // Some browsers/systems report JPEG as image/jpg
  'image/png', 'image/gif', 'image/bmp', 'image/webp', 'image/x-ms-bmp',
  // Alternative MIME type for BMP
  'image/x-windows-bmp' // Another BMP variant
  ];

  /**
   * Initialize controller
   */
  connect() {
    console.log('WaiverUploadController connected');
    this.selectedFiles = [];
  }

  /**
   * Handle file selection from input
   * 
   * @param {Event} event File input change event
   */
  handleFileSelect(event) {
    const files = Array.from(event.target.files);
    if (files.length === 0) {
      return;
    }

    // Validate files
    const validationResults = files.map(file => this.validateFile(file));
    const invalidFiles = validationResults.filter(result => !result.valid);
    if (invalidFiles.length > 0) {
      // Show error messages
      const errors = invalidFiles.map(result => result.error).join('\n');
      alert(`File validation errors:\n\n${errors}`);
    }

    // Filter to only valid files and append to existing selection
    const validFiles = files.filter((file, index) => validationResults[index].valid);

    // Append new valid files to existing selection
    this.selectedFiles = [...this.selectedFiles, ...validFiles];

    // Create a new DataTransfer to update the file input with all selected files
    const dataTransfer = new DataTransfer();
    this.selectedFiles.forEach(file => {
      dataTransfer.items.add(file);
    });
    this.fileInputTarget.files = dataTransfer.files;

    // Update preview
    if (this.selectedFiles.length > 0) {
      this.showPreview();
    } else {
      this.hidePreview();
    }
  }

  /**
   * Validate a single file
   * 
   * @param {File} file File to validate
   * @returns {Object} Validation result {valid: boolean, error: string}
   */
  validateFile(file) {
    // Check file size
    if (file.size > WaiverUploadController.MAX_FILE_SIZE) {
      return {
        valid: false,
        error: `${file.name}: File size (${this.formatFileSize(file.size)}) exceeds maximum of 25MB`
      };
    }

    // Check file type
    if (!WaiverUploadController.ALLOWED_TYPES.includes(file.type)) {
      return {
        valid: false,
        error: `${file.name}: Invalid file type (${file.type}). Only raster images are allowed (JPEG, PNG, GIF, BMP, WEBP). SVG and TIFF files are not supported.`
      };
    }
    return {
      valid: true
    };
  }

  /**
   * Format file size for display
   * 
   * @param {number} bytes File size in bytes
   * @returns {string} Formatted file size
   */
  formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
  }

  /**
   * Show file preview area with selected files
   */
  showPreview() {
    if (!this.hasPreviewTarget) return;

    // Build preview HTML
    const previewList = document.getElementById('file-preview-list');
    if (!previewList) return;
    previewList.innerHTML = '';
    this.selectedFiles.forEach((file, index) => {
      const item = document.createElement('div');
      item.className = 'list-group-item d-flex justify-content-between align-items-center';
      item.innerHTML = `
                <div>
                    <i class="bi bi-file-image text-primary"></i>
                    <strong>${this.escapeHtml(file.name)}</strong>
                    <br>
                    <small class="text-muted">${this.formatFileSize(file.size)}</small>
                </div>
                <button type="button" class="btn btn-sm btn-outline-danger" data-index="${index}">
                    <i class="bi bi-x"></i>
                </button>
            `;

      // Add click handler to remove button
      const removeBtn = item.querySelector('button');
      removeBtn.addEventListener('click', () => this.removeFile(index));
      previewList.appendChild(item);
    });

    // Show preview area
    this.previewTarget.style.display = 'block';
  }

  /**
   * Hide file preview area
   */
  hidePreview() {
    if (!this.hasPreviewTarget) return;
    this.previewTarget.style.display = 'none';
  }

  /**
   * Remove a file from selection
   * 
   * @param {number} index File index to remove
   */
  removeFile(index) {
    this.selectedFiles.splice(index, 1);
    if (this.selectedFiles.length === 0) {
      this.hidePreview();
      this.fileInputTarget.value = '';
    } else {
      // Update file input with remaining files
      const dataTransfer = new DataTransfer();
      this.selectedFiles.forEach(file => {
        dataTransfer.items.add(file);
      });
      this.fileInputTarget.files = dataTransfer.files;
      this.showPreview();
    }
  }

  /**
   * Handle form submission
   * 
   * @param {Event} event Form submit event
   */
  handleSubmit(event) {
    // Validate waiver type is selected
    if (!this.waiverTypeTarget.value) {
      event.preventDefault();
      alert('Please select a waiver type');
      return;
    }

    // Validate files are selected
    if (this.selectedFiles.length === 0) {
      event.preventDefault();
      alert('Please select at least one image file to upload');
      return;
    }

    // Show progress bar
    if (this.hasProgressTarget) {
      this.progressTarget.style.display = 'block';
      this.updateProgress(0);
    }

    // Disable submit button
    if (this.hasSubmitButtonTarget) {
      this.submitButtonTarget.disabled = true;
      this.submitButtonTarget.innerHTML = '<i class="bi bi-hourglass-split"></i> Uploading & Converting...';
    }

    // Form will submit normally - progress will be indeterminate
    // since we're doing synchronous conversion on the server
    this.simulateProgress();
  }

  /**
   * Simulate upload progress (since conversion is synchronous)
   */
  simulateProgress() {
    let progress = 0;
    const interval = setInterval(() => {
      progress += 5;
      if (progress >= 95) {
        progress = 95; // Stop at 95% until server responds
        clearInterval(interval);
      }
      this.updateProgress(progress);
    }, 200);
  }

  /**
   * Update progress bar
   * 
   * @param {number} percent Progress percentage (0-100)
   */
  updateProgress(percent) {
    if (!this.hasProgressBarTarget || !this.hasProgressTextTarget) return;
    this.progressBarTarget.style.width = `${percent}%`;
    this.progressBarTarget.setAttribute('aria-valuenow', percent);
    this.progressTextTarget.textContent = `${Math.round(percent)}%`;
  }

  /**
   * Escape HTML to prevent XSS
   * 
   * @param {string} text Text to escape
   * @returns {string} Escaped text
   */
  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
}

// Add to global controllers registry
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["waiver-upload"] = WaiverUploadController;

/***/ }),

/***/ "./plugins/Waivers/assets/js/controllers/waiver-upload-wizard-controller.js":
/*!**********************************************************************************!*\
  !*** ./plugins/Waivers/assets/js/controllers/waiver-upload-wizard-controller.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/* provided dependency */ var bootstrap = __webpack_require__(/*! bootstrap */ "./node_modules/bootstrap/dist/js/bootstrap.esm.js");


/**
 * Waiver Upload Wizard Controller
 *
 * Gathering-level workflow:
 * Step 1: Select waiver type
 * Step 2: Upload pages or attest not needed
 * Step 3: Review & submit
 */
class WaiverUploadWizardController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ["step", "stepIndicator", "prevButton", "nextButton", "submitButton", "submitButtonText", "waiverTypeOption", "waiverTypeSelect", "pagesPreview", "fileInput", "reviewWaiverType", "reviewPageCount", "reviewPagesList", "notesField", "progressBar", "uploadSection", "attestSection", "attestReasonList", "attestNotes", "reviewUploadSection", "reviewAttestSection", "reviewAttestReason", "reviewAttestNotes", "reviewAttestNotesSection", "modeToggle", "step3Lead"];
  static values = {
    currentStep: {
      type: Number,
      default: 1
    },
    totalSteps: {
      type: Number,
      default: 3
    },
    gatheringId: Number,
    gatheringPublicId: String,
    maxFileSize: Number,
    // Maximum single file size in bytes
    totalMaxSize: Number,
    // Maximum total upload size in bytes
    preSelectedWaiverTypeId: Number,
    // Pre-selected waiver type ID from URL
    attestUrl: String,
    // URL for attestation endpoint
    gatheringViewUrl: String,
    // URL for gathering view page
    mobileSelectUrl: String // URL for mobile select gathering page
  };
  connect() {
    this.uploadedPages = [];
    this.selectedWaiverType = null;
    this.notes = "";
    this.isAttestMode = false;
    this.attestReason = null;
    this.attestNotes = "";
    if (this.hasPreSelectedWaiverTypeIdValue) {
      setTimeout(() => {
        const waiverTypeRadio = document.querySelector(`input[name="waiver_type"][value="${this.preSelectedWaiverTypeIdValue}"]`);
        if (waiverTypeRadio) {
          waiverTypeRadio.checked = true;
          this.selectedWaiverType = {
            id: this.preSelectedWaiverTypeIdValue,
            name: waiverTypeRadio.dataset.name
          };
          this.checkAttestationAvailability();
        }
      }, 50);
    }
    this.showStep(1);
  }

  // Step Navigation
  nextStep() {
    if (this.validateCurrentStep()) {
      if (this.currentStepValue < this.totalStepsValue) {
        this.currentStepValue++;
        this.showStep(this.currentStepValue);
      }
    }
  }
  prevStep() {
    if (this.currentStepValue > 1) {
      this.currentStepValue--;
      this.showStep(this.currentStepValue);
    }
  }
  goToStep(event) {
    const step = parseInt(event.currentTarget.dataset.step);
    if (step < this.currentStepValue) {
      this.currentStepValue = step;
      this.showStep(this.currentStepValue);
    }
  }
  showStep(stepNumber) {
    // Hide all steps
    this.stepTargets.forEach(step => {
      step.classList.add('d-none');
    });

    // Show current step
    const currentStep = this.stepTargets.find(step => parseInt(step.dataset.stepNumber) === stepNumber);
    if (currentStep) {
      currentStep.classList.remove('d-none');
    }

    // Update step indicators
    this.updateStepIndicators(stepNumber);

    // Update navigation buttons
    this.updateNavigationButtons(stepNumber);

    // Update progress bar
    this.updateProgressBar(stepNumber);

    // Perform step-specific actions
    this.onStepChange(stepNumber);
  }
  updateStepIndicators(currentStep) {
    this.stepIndicatorTargets.forEach(indicator => {
      const step = parseInt(indicator.dataset.step);
      indicator.classList.remove('active', 'completed');
      if (step === currentStep) {
        indicator.classList.add('active');
      } else if (step < currentStep) {
        indicator.classList.add('completed');
      }
    });
  }
  updateNavigationButtons(stepNumber) {
    // Previous button
    if (this.hasPrevButtonTarget) {
      if (stepNumber === 1) {
        this.prevButtonTarget.classList.add('d-none');
      } else {
        this.prevButtonTarget.classList.remove('d-none');
      }
    }

    // Next button
    if (this.hasNextButtonTarget) {
      if (stepNumber === this.totalStepsValue) {
        this.nextButtonTarget.classList.add('d-none');
      } else {
        this.nextButtonTarget.classList.remove('d-none');

        // Update button text based on step
        if (stepNumber === 3) {
          this.nextButtonTarget.innerHTML = '<i class="bi bi-arrow-right"></i> Review';
        } else {
          this.nextButtonTarget.innerHTML = '<i class="bi bi-arrow-right"></i> Next';
        }
      }
    }

    // Submit button
    if (this.hasSubmitButtonTarget) {
      if (stepNumber === this.totalStepsValue) {
        this.submitButtonTarget.classList.remove('d-none');
        // Update submit button text based on mode
        if (this.hasSubmitButtonTextTarget) {
          this.submitButtonTextTarget.textContent = this.isAttestMode ? 'Submit Attestation' : 'Submit Waivers';
        }
      } else {
        this.submitButtonTarget.classList.add('d-none');
      }
    }
  }
  updateProgressBar(stepNumber) {
    if (this.hasProgressBarTarget) {
      const progress = stepNumber / this.totalStepsValue * 100;
      this.progressBarTarget.style.width = `${progress}%`;
      this.progressBarTarget.setAttribute('aria-valuenow', progress);
    }
  }
  onStepChange(stepNumber) {
    switch (stepNumber) {
      case 2:
        this.checkAttestationAvailability();
        break;
      case 3:
        this.updateReviewSection();
        break;
    }
  }

  // Check if attestation is available for selected waiver type
  checkAttestationAvailability() {
    if (!this.selectedWaiverType) {
      return;
    }

    // Find the waiver type to get exemption reasons
    const waiverTypeRadio = document.querySelector(`input[name="waiver_type"][value="${this.selectedWaiverType.id}"]`);
    let exemptionReasons = [];
    if (waiverTypeRadio && waiverTypeRadio.dataset.exemptionReasons) {
      try {
        exemptionReasons = JSON.parse(waiverTypeRadio.dataset.exemptionReasons);
      } catch (e) {
        console.error('Failed to parse exemption reasons:', e);
      }
    }

    // Show/hide mode toggle and update lead text based on exemption reasons availability
    if (exemptionReasons.length > 0) {
      // Has exemption reasons - show toggle
      if (this.hasModeToggleTarget) {
        this.modeToggleTarget.classList.remove('d-none');
      }
      if (this.hasStep3LeadTarget) {
        this.step3LeadTarget.textContent = 'Add one or more pages to your waiver document, or attest that a waiver is not needed';
      }
    } else {
      // No exemption reasons - hide toggle, force upload mode
      if (this.hasModeToggleTarget) {
        this.modeToggleTarget.classList.add('d-none');
      }
      if (this.hasStep3LeadTarget) {
        this.step3LeadTarget.textContent = 'Add one or more pages to your waiver document';
      }
      // Force upload mode
      this.isAttestMode = false;
      const uploadRadio = document.getElementById('mode-upload');
      if (uploadRadio) {
        uploadRadio.checked = true;
      }
      if (this.hasUploadSectionTarget && this.hasAttestSectionTarget) {
        this.uploadSectionTarget.classList.remove('d-none');
        this.attestSectionTarget.classList.add('d-none');
      }
    }

    // Populate attestation reasons if available
    if (exemptionReasons.length > 0) {
      this.populateAttestationReasons();
    }
  }

  // Step 3: Mode Toggle (Upload vs Attest)
  setModeUpload(event) {
    this.isAttestMode = false;
    if (this.hasUploadSectionTarget && this.hasAttestSectionTarget) {
      this.uploadSectionTarget.classList.remove('d-none');
      this.attestSectionTarget.classList.add('d-none');
    }
  }
  setModeAttest(event) {
    // Verify exemption reasons are available before allowing switch
    if (!this.selectedWaiverType) return;
    const waiverTypeRadio = document.querySelector(`input[name="waiver_type"][value="${this.selectedWaiverType.id}"]`);
    let exemptionReasons = [];
    if (waiverTypeRadio && waiverTypeRadio.dataset.exemptionReasons) {
      try {
        exemptionReasons = JSON.parse(waiverTypeRadio.dataset.exemptionReasons);
      } catch (e) {
        console.error('Failed to parse exemption reasons:', e);
      }
    }
    if (exemptionReasons.length === 0) {
      // No exemption reasons - prevent switching to attest mode
      this.showError('Attestation is not available for this waiver type.');
      const uploadRadio = document.getElementById('mode-upload');
      if (uploadRadio) {
        uploadRadio.checked = true;
      }
      return;
    }
    this.isAttestMode = true;
    if (this.hasUploadSectionTarget && this.hasAttestSectionTarget) {
      this.uploadSectionTarget.classList.add('d-none');
      this.attestSectionTarget.classList.remove('d-none');
    }
    this.populateAttestationReasons();
  }
  populateAttestationReasons() {
    if (!this.hasAttestReasonListTarget || !this.selectedWaiverType) return;

    // Find the waiver type to get exemption reasons
    const waiverTypeRadio = document.querySelector(`input[name="waiver_type"][value="${this.selectedWaiverType.id}"]`);
    let exemptionReasons = [];
    if (waiverTypeRadio && waiverTypeRadio.dataset.exemptionReasons) {
      try {
        exemptionReasons = JSON.parse(waiverTypeRadio.dataset.exemptionReasons);
      } catch (e) {
        console.error('Failed to parse exemption reasons:', e);
      }
    }
    if (exemptionReasons.length === 0) {
      this.attestReasonListTarget.innerHTML = `
                <div class="alert alert-warning">
                    <i class="bi bi-exclamation-triangle"></i>
                    No exemption reasons have been configured for this waiver type.
                </div>
            `;
      return;
    }

    // Build radio buttons
    let html = '<div class="list-group">';
    let hasMatchingSelection = false;
    exemptionReasons.forEach((reason, index) => {
      const id = `attest_reason_${index}`;
      const isSelected = this.attestReason === reason;
      if (isSelected) {
        hasMatchingSelection = true;
      }
      html += `
                <label class="list-group-item list-group-item-action">
                    <input class="form-check-input me-2" type="radio" name="attest_reason" 
                           id="${id}" value="${this.escapeHtml(reason)}"
                           data-action="change->waiver-upload-wizard#selectAttestReason"
                           ${isSelected ? 'checked' : ''}>
                    ${this.escapeHtml(reason)}
                </label>
            `;
    });
    html += '</div>';
    this.attestReasonListTarget.innerHTML = html;

    // Clear attestReason if the previously selected reason is not available for the current waiver type
    if (!hasMatchingSelection) {
      this.attestReason = null;
    }
  }
  selectAttestReason(event) {
    this.attestReason = event.currentTarget.value;
  }
  selectWaiverType(event) {
    const option = event.currentTarget;
    this.selectedWaiverType = {
      id: parseInt(option.value),
      name: option.dataset.name
    };
    this.checkAttestationAvailability();
  }
  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // Step 3: Add Pages
  triggerFileInput() {
    if (this.hasFileInputTarget) {
      this.fileInputTarget.click();
    }
  }
  handleFileSelect(event) {
    const files = Array.from(event.target.files);

    // Get max file size (use configured value or fallback to 5MB)
    const maxFileSize = this.hasMaxFileSizeValue ? this.maxFileSizeValue : 5 * 1024 * 1024;
    const totalMaxSize = this.hasTotalMaxSizeValue ? this.totalMaxSizeValue : maxFileSize;

    // Calculate current total size
    const currentTotalSize = this.uploadedPages.reduce((sum, page) => sum + page.size, 0);
    files.forEach(file => {
      // Validate file type
      if (!this.isValidImageFile(file)) {
        this.showError(`Invalid file type: ${file.name}. Please upload raster images only (JPEG, PNG, GIF, BMP, or WEBP). SVG and TIFF files are not supported.`);
        return;
      }

      // Validate individual file size
      if (file.size > maxFileSize) {
        const maxFormatted = this.formatBytes(maxFileSize);
        const fileFormatted = this.formatBytes(file.size);
        this.showError(`File too large: ${file.name} (${fileFormatted}). Maximum size per file is ${maxFormatted}.`);
        return;
      }

      // Check if adding this file would exceed total size limit
      const newTotalSize = currentTotalSize + file.size;
      if (newTotalSize > totalMaxSize) {
        const totalFormatted = this.formatBytes(newTotalSize);
        const maxFormatted = this.formatBytes(totalMaxSize);
        const currentFormatted = this.formatBytes(currentTotalSize);
        const fileFormatted = this.formatBytes(file.size);
        this.showError(`Cannot add ${file.name} (${fileFormatted}). ` + `Current total: ${currentFormatted}. ` + `Adding this file would exceed the maximum total upload size of ${maxFormatted} ` + `(would be ${totalFormatted}).`);
        return;
      }

      // Add to uploaded pages
      this.addPage(file);
    });

    // Clear input so same file can be selected again
    event.target.value = '';

    // Show total size info if we have files
    if (this.uploadedPages.length > 0) {
      this.updateTotalSizeDisplay();
    }
  }
  isValidImageFile(file) {
    const validTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/bmp', 'image/webp', 'image/x-ms-bmp',
    // Alternative MIME type for BMP
    'image/x-windows-bmp' // Another BMP variant
    ];
    return validTypes.includes(file.type);
  }
  addPage(file) {
    const pageNumber = this.uploadedPages.length + 1;
    const reader = new FileReader();
    reader.onload = e => {
      const page = {
        file: file,
        dataUrl: e.target.result,
        number: pageNumber,
        name: file.name,
        size: file.size
      };
      this.uploadedPages.push(page);
      this.renderPages();
    };
    reader.readAsDataURL(file);
  }
  removePage(event) {
    const index = parseInt(event.currentTarget.dataset.index);
    this.uploadedPages.splice(index, 1);

    // Renumber pages
    this.uploadedPages.forEach((page, idx) => {
      page.number = idx + 1;
    });
    this.renderPages();

    // Update total size display after removal
    if (this.uploadedPages.length > 0) {
      this.updateTotalSizeDisplay();
    }
  }
  renderPages() {
    if (!this.hasPagesPreviewTarget) return;
    if (this.uploadedPages.length === 0) {
      this.pagesPreviewTarget.innerHTML = `
                <div class="text-center text-muted py-5">
                    <i class="bi bi-file-earmark-image" style="font-size: 3rem;"></i>
                    <p class="mt-3">No pages added yet</p>
                    <p class="small">Click "Add Page" to select images</p>
                </div>
            `;
      return;
    }
    const html = this.uploadedPages.map((page, index) => `
            <div class="col-md-4 mb-3">
                <div class="card">
                    <div class="card-body p-2">
                        <div class="d-flex align-items-start">
                            <div class="flex-shrink-0">
                                <img src="${page.dataUrl}" 
                                     class="img-thumbnail" 
                                     style="width: 100px; height: 130px; object-fit: cover;"
                                     alt="Page ${page.number}">
                            </div>
                            <div class="flex-grow-1 ms-3">
                                <div class="d-flex justify-content-between align-items-start">
                                    <div>
                                        <strong>Page ${page.number}</strong><br>
                                        <small class="text-muted">${page.name}</small><br>
                                        <small class="text-muted">${this.formatFileSize(page.size)}</small>
                                    </div>
                                    <button type="button" 
                                            class="btn btn-sm btn-outline-danger"
                                            data-index="${index}"
                                            data-action="click->waiver-upload-wizard#removePage">
                                        <i class="bi bi-trash"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `).join('');
    this.pagesPreviewTarget.innerHTML = html;
  }
  formatFileSize(bytes) {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
    return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
  }

  // Step 3: Review
  updateReviewSection() {
    // Waiver Type
    if (this.hasReviewWaiverTypeTarget && this.selectedWaiverType) {
      this.reviewWaiverTypeTarget.textContent = this.selectedWaiverType.name;
    }

    // Show/hide sections based on mode
    if (this.isAttestMode) {
      // Attestation Mode
      if (this.hasReviewUploadSectionTarget) {
        this.reviewUploadSectionTarget.classList.add('d-none');
      }
      if (this.hasReviewAttestSectionTarget) {
        this.reviewAttestSectionTarget.classList.remove('d-none');
      }

      // Display attestation reason
      if (this.hasReviewAttestReasonTarget) {
        this.reviewAttestReasonTarget.textContent = this.attestReason || 'Not selected';
      }

      // Get notes from attest section
      if (this.hasAttestNotesTarget) {
        this.attestNotes = this.attestNotesTarget.value;
      }

      // Display attestation notes if provided
      if (this.hasReviewAttestNotesTarget && this.hasReviewAttestNotesSectionTarget) {
        if (this.attestNotes && this.attestNotes.trim().length > 0) {
          this.reviewAttestNotesTarget.textContent = this.attestNotes;
          this.reviewAttestNotesSectionTarget.classList.remove('d-none');
        } else {
          this.reviewAttestNotesSectionTarget.classList.add('d-none');
        }
      }
    } else {
      // Upload Mode
      if (this.hasReviewUploadSectionTarget) {
        this.reviewUploadSectionTarget.classList.remove('d-none');
      }
      if (this.hasReviewAttestSectionTarget) {
        this.reviewAttestSectionTarget.classList.add('d-none');
      }

      // Page Count
      if (this.hasReviewPageCountTarget) {
        this.reviewPageCountTarget.textContent = this.uploadedPages.length;
      }

      // Pages List
      if (this.hasReviewPagesListTarget) {
        const html = this.uploadedPages.map(page => `
                    <div class="col-md-3 mb-3">
                        <div class="card">
                            <img src="${page.dataUrl}" 
                                 class="card-img-top" 
                                 style="height: 200px; object-fit: cover;"
                                 alt="Page ${page.number}">
                            <div class="card-body p-2 text-center">
                                <small>Page ${page.number}</small>
                            </div>
                        </div>
                    </div>
                `).join('');
        this.reviewPagesListTarget.innerHTML = html;
      }

      // Get notes if available
      if (this.hasNotesFieldTarget) {
        this.notes = this.notesFieldTarget.value;
      }
    }
  }
  validateWaiverType() {
    if (!this.selectedWaiverType) {
      this.showError("Please select a waiver type");
      return false;
    }
    return true;
  }
  validateUploadOrAttest() {
    if (this.isAttestMode) {
      if (!this.attestReason) {
        this.showError("Please select a reason for the exemption");
        return false;
      }
      return true;
    }
    if (this.uploadedPages.length === 0) {
      this.showError("Please add at least one page");
      return false;
    }
    return true;
  }
  validateReview() {
    return this.validateWaiverType() && this.validateUploadOrAttest();
  }

  // Form Submission
  async submitForm(event) {
    event.preventDefault();
    if (!this.validateReview()) {
      return;
    }

    // Disable submit button and show processing page immediately
    if (this.hasSubmitButtonTarget) {
      this.submitButtonTarget.disabled = true;
    }
    this.showProcessingStep();

    // Track when we started (for minimum 2-second display)
    const startTime = Date.now();
    try {
      if (this.isAttestMode) {
        // Submit attestation
        await this.submitAttestation(startTime);
      } else {
        // Submit waiver upload
        await this.submitWaiverUpload(startTime);
      }
    } catch (error) {
      console.error('Submission error:', error);
      this.showError('An error occurred during submission. Please try again.');
      if (this.hasSubmitButtonTarget) {
        this.submitButtonTarget.disabled = false;
      }
      if (this.hasSubmitButtonTextTarget) {
        this.submitButtonTextTarget.textContent = this.isAttestMode ? 'Submit Attestation' : 'Submit Waivers';
      }
    }
  }
  async submitAttestation(startTime) {
    const attestUrl = this.hasAttestUrlValue ? this.attestUrlValue : '/waivers/gathering-waivers/attest';
    const response = await fetch(attestUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Requested-With': 'XMLHttpRequest',
        'X-CSRF-Token': this.getCsrfToken()
      },
      body: JSON.stringify({
        gathering_id: this.gatheringIdValue,
        waiver_type_id: this.selectedWaiverType.id,
        reason: this.attestReason,
        notes: this.attestNotes
      })
    });
    try {
      const data = await response.json();
      if (response.ok && data.success) {
        // Attestation succeeded
        const elapsed = Date.now() - startTime;
        const remainingTime = Math.max(0, 2000 - elapsed);
        setTimeout(() => {
          if (data.redirectUrl) {
            window.location.href = data.redirectUrl;
          } else {
            // Fallback redirect using gatheringViewUrl or construct from public_id
            const fallbackUrl = this.hasGatheringViewUrlValue ? this.gatheringViewUrlValue : `/gatherings/view/${this.gatheringPublicIdValue}?tab=gathering-waivers`;
            window.location.href = fallbackUrl;
          }
        }, remainingTime);
      } else {
        // Attestation failed
        this.showError(data.message || 'Attestation failed. Please try again.');
        if (this.hasSubmitButtonTarget) {
          this.submitButtonTarget.disabled = false;
        }
        if (this.hasSubmitButtonTextTarget) {
          this.submitButtonTextTarget.textContent = 'Submit Attestation';
        }
      }
    } catch (error) {
      this.showError('Network error. Please try again.');
      if (this.hasSubmitButtonTarget) {
        this.submitButtonTarget.disabled = false;
      }
      if (this.hasSubmitButtonTextTarget) {
        this.submitButtonTextTarget.textContent = 'Submit Attestation';
      }
    }
  }
  async submitWaiverUpload(startTime) {
    const formData = new FormData();

    // Add gathering ID
    formData.append('gathering_id', this.gatheringIdValue);

    // Add waiver type
    formData.append('waiver_type_id', this.selectedWaiverType.id);

    // Add notes
    formData.append('notes', this.notes);

    // Add all page files
    this.uploadedPages.forEach((page, index) => {
      formData.append('waiver_images[]', page.file);
    });

    // Get CSRF token and add to form data (CakePHP expects it in the body)
    const csrfToken = this.getCsrfToken();
    if (csrfToken) {
      formData.append('_csrfToken', csrfToken);
    }

    // Submit via fetch
    const response = await fetch(window.location.href, {
      method: 'POST',
      body: formData,
      headers: {
        'X-Requested-With': 'XMLHttpRequest'
      }
    });
    if (response.ok) {
      // Parse JSON response
      const data = await response.json().catch(err => {
        console.error('Failed to parse JSON response:', err);
        return {};
      });
      console.log('Upload response data:', data);

      // Calculate how long to wait (minimum 2 seconds total)
      const elapsed = Date.now() - startTime;
      const remainingTime = Math.max(0, 2000 - elapsed);

      // Wait for remaining time, then redirect
      setTimeout(() => {
        if (data.redirectUrl) {
          console.log('Redirecting to:', data.redirectUrl);
          window.location.href = data.redirectUrl;
        } else {
          // Fallback redirect using gatheringViewUrl or construct from gathering ID
          const fallbackUrl = this.hasGatheringViewUrlValue ? this.gatheringViewUrlValue : `/gatherings/view/${this.gatheringIdValue}`;
          window.location.href = fallbackUrl;
        }
      }, remainingTime);
    } else {
      const data = await response.json().catch(() => ({}));
      this.showError(data.message || 'Upload failed. Please try again.');
      if (this.hasSubmitButtonTarget) {
        this.submitButtonTarget.disabled = false;
      }
      if (this.hasSubmitButtonTextTarget) {
        this.submitButtonTextTarget.textContent = 'Submit Waivers';
      }
    }
  }
  showProcessingStep() {
    // Hide all regular steps
    this.stepTargets.forEach(step => step.classList.add('d-none'));

    // Show processing message based on mode
    let processingHtml;
    if (this.isAttestMode) {
      processingHtml = `
                <div class="text-center py-5">
                    <div class="mb-4">
                        <div class="spinner-border text-primary" role="status" style="width: 5rem; height: 5rem;">
                            <span class="visually-hidden">Processing...</span>
                        </div>
                    </div>
                    <h2 class="mb-3">Processing Your Attestation</h2>
                    <p class="lead text-muted mb-4">
                        Please wait while we record your attestation...
                    </p>
                    <div class="alert alert-info d-inline-block">
                        <i class="bi bi-shield-check"></i>
                        Attesting that a waiver is not needed for this gathering
                    </div>
                </div>
            `;
    } else {
      processingHtml = `
                <div class="text-center py-5">
                    <div class="mb-4">
                        <div class="spinner-border text-primary" role="status" style="width: 5rem; height: 5rem;">
                            <span class="visually-hidden">Uploading...</span>
                        </div>
                    </div>
                    <h2 class="mb-3">Processing Your Waiver</h2>
                    <p class="lead text-muted mb-4">
                        Please wait while we upload and process your waiver...
                    </p>
                    <div class="alert alert-info d-inline-block">
                        <i class="bi bi-info-circle"></i>
                        Uploading ${this.uploadedPages.length} page(s)
                    </div>
                </div>
            `;
    }
    const container = this.element.querySelector('.wizard-container') || this.element;
    container.innerHTML = processingHtml;
  }

  // Validation
  validateCurrentStep() {
    switch (this.currentStepValue) {
      case 1:
        return this.validateWaiverType();
      case 2:
        return this.validateUploadOrAttest();
      case 3:
        return this.validateReview();
      default:
        return true;
    }
  }

  // Error Handling
  showError(message) {
    // Check if we're showing the processing screen (wizard container innerHTML was replaced)
    const container = this.element.querySelector('.wizard-container') || this.element;
    const isProcessing = container.querySelector('h2') && (container.querySelector('h2').textContent.includes('Processing Your Attestation') || container.querySelector('h2').textContent.includes('Processing Your Waiver'));
    if (isProcessing) {
      // We're in the processing screen, so we can't show a toast
      // Check if we're in mobile mode by checking the URL
      const isMobile = window.location.pathname.includes('mobile-upload');
      if (isMobile) {
        // Redirect to mobile card using mobileSelectUrl if available, otherwise construct URL
        const mobileUrl = this.hasMobileSelectUrlValue ? `${this.mobileSelectUrlValue}?error=${encodeURIComponent(message)}` : `/waivers/gathering-waivers/mobile-select-gathering?error=${encodeURIComponent(message)}`;
        window.location.href = mobileUrl;
      } else {
        // Desktop mode - redirect back to the gathering with a flash message
        const gatheringPublicId = this.gatheringPublicIdValue;
        const desktopUrl = this.hasGatheringViewUrlValue ? `${this.gatheringViewUrlValue}&error=${encodeURIComponent(message)}` : `/gatherings/view/${gatheringPublicId}?tab=gathering-waivers&error=${encodeURIComponent(message)}`;
        window.location.href = desktopUrl;
      }
      return;
    }

    // Create toast notification
    const toastHtml = `
            <div class="toast align-items-center text-white bg-danger border-0" role="alert">
                <div class="d-flex">
                    <div class="toast-body">
                        <i class="bi bi-exclamation-triangle me-2"></i>${message}
                    </div>
                    <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
                </div>
            </div>
        `;

    // Add to toast container or create one
    let toastContainer = document.querySelector('.toast-container');
    if (!toastContainer) {
      toastContainer = document.createElement('div');
      toastContainer.className = 'toast-container position-fixed top-0 end-0 p-3';
      document.body.appendChild(toastContainer);
    }
    toastContainer.insertAdjacentHTML('beforeend', toastHtml);
    const toastElement = toastContainer.lastElementChild;
    const toast = new bootstrap.Toast(toastElement);
    toast.show();

    // Remove after hidden
    toastElement.addEventListener('hidden.bs.toast', () => {
      toastElement.remove();
    });
  }
  getCsrfToken() {
    // Try to get from meta tag first (CakePHP default)
    const metaTag = document.querySelector('meta[name="csrfToken"]');
    if (metaTag) {
      return metaTag.content;
    }

    // Try to get from cookie as fallback
    const match = document.cookie.match(/csrfToken=([^;]+)/);
    if (match) {
      return match[1];
    }

    // Try to get from hidden input in any form
    const hiddenInput = document.querySelector('input[name="_csrfToken"]');
    if (hiddenInput) {
      return hiddenInput.value;
    }
    console.error('CSRF token not found');
    return '';
  }

  /**
   * Format bytes to human-readable string
   * 
   * @param {number} bytes - Size in bytes
   * @param {number} decimals - Number of decimal places
   * @returns {string} Formatted size string
   */
  formatBytes(bytes, decimals = 2) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
  }

  /**
   * Update the display to show current total size
   */
  updateTotalSizeDisplay() {
    const totalSize = this.uploadedPages.reduce((sum, page) => sum + page.size, 0);
    const totalFormatted = this.formatBytes(totalSize);

    // If we're getting close to the limit, show a warning
    if (this.hasTotalMaxSizeValue) {
      const percentUsed = totalSize / this.totalMaxSizeValue * 100;
      if (percentUsed > 80 && percentUsed <= 100) {
        // Show warning when using 80-100% of limit
        const remaining = this.totalMaxSizeValue - totalSize;
        const remainingFormatted = this.formatBytes(remaining);
        const maxFormatted = this.formatBytes(this.totalMaxSizeValue);
        console.warn(`Upload size warning: ${totalFormatted} of ${maxFormatted} used. ` + `${remainingFormatted} remaining.`);
      }
    }
  }
}

// Register controller
if (!window.Controllers) {
  window.Controllers = {};
}
window.Controllers["waiver-upload-wizard"] = WaiverUploadWizardController;
/* harmony default export */ __webpack_exports__["default"] = (WaiverUploadWizardController);

/***/ }),

/***/ "?f052":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (function() {

/* (ignored) */

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["js/core","css/app","css/waivers","css/dashboard","css/cover","css/signin","css/waiver-upload"], function() { return __webpack_exec__("./assets/js/controllers/activity-toggle-controller.js"), __webpack_exec__("./assets/js/controllers/activity-waiver-manager-controller.js"), __webpack_exec__("./assets/js/controllers/add-activity-modal-controller.js"), __webpack_exec__("./assets/js/controllers/app-setting-form-controller.js"), __webpack_exec__("./assets/js/controllers/app-setting-modal-controller.js"), __webpack_exec__("./assets/js/controllers/auto-complete-controller.js"), __webpack_exec__("./assets/js/controllers/base-gathering-form-controller.js"), __webpack_exec__("./assets/js/controllers/branch-links-controller.js"), __webpack_exec__("./assets/js/controllers/code-editor-controller.js"), __webpack_exec__("./assets/js/controllers/csv-download-controller.js"), __webpack_exec__("./assets/js/controllers/delayed-forward-controller.js"), __webpack_exec__("./assets/js/controllers/delete-confirmation-controller.js"), __webpack_exec__("./assets/js/controllers/detail-tabs-controller.js"), __webpack_exec__("./assets/js/controllers/edit-activity-description-controller.js"), __webpack_exec__("./assets/js/controllers/email-template-editor-controller.js"), __webpack_exec__("./assets/js/controllers/email-template-form-controller.js"), __webpack_exec__("./assets/js/controllers/file-size-validator-controller.js"), __webpack_exec__("./assets/js/controllers/filter-grid-controller.js"), __webpack_exec__("./assets/js/controllers/gathering-clone-controller.js"), __webpack_exec__("./assets/js/controllers/gathering-form-controller.js"), __webpack_exec__("./assets/js/controllers/gathering-location-autocomplete-controller.js"), __webpack_exec__("./assets/js/controllers/gathering-map-controller.js"), __webpack_exec__("./assets/js/controllers/gathering-public-controller.js"), __webpack_exec__("./assets/js/controllers/gathering-schedule-controller.js"), __webpack_exec__("./assets/js/controllers/gathering-type-form-controller.js"), __webpack_exec__("./assets/js/controllers/gatherings-calendar-controller.js"), __webpack_exec__("./assets/js/controllers/grid-view-controller.js"), __webpack_exec__("./assets/js/controllers/guifier-controller.js"), __webpack_exec__("./assets/js/controllers/image-preview-controller.js"), __webpack_exec__("./assets/js/controllers/kanban-controller.js"), __webpack_exec__("./assets/js/controllers/markdown-editor-controller.js"), __webpack_exec__("./assets/js/controllers/member-card-profile-controller.js"), __webpack_exec__("./assets/js/controllers/member-mobile-card-menu-controller.js"), __webpack_exec__("./assets/js/controllers/member-mobile-card-profile-controller.js"), __webpack_exec__("./assets/js/controllers/member-mobile-card-pwa-controller.js"), __webpack_exec__("./assets/js/controllers/member-unique-email-controller.js"), __webpack_exec__("./assets/js/controllers/member-verify-form-controller.js"), __webpack_exec__("./assets/js/controllers/mobile-hub-controller.js"), __webpack_exec__("./assets/js/controllers/mobile-offline-overlay-controller.js"), __webpack_exec__("./assets/js/controllers/modal-opener-controller.js"), __webpack_exec__("./assets/js/controllers/nav-bar-controller.js"), __webpack_exec__("./assets/js/controllers/outlet-button-controller.js"), __webpack_exec__("./assets/js/controllers/permission-add-role-controller.js"), __webpack_exec__("./assets/js/controllers/permission-import-controller.js"), __webpack_exec__("./assets/js/controllers/permission-manage-policies-controller.js"), __webpack_exec__("./assets/js/controllers/popover-controller.js"), __webpack_exec__("./assets/js/controllers/qrcode-controller.js"), __webpack_exec__("./assets/js/controllers/revoke-form-controller.js"), __webpack_exec__("./assets/js/controllers/role-add-member-controller.js"), __webpack_exec__("./assets/js/controllers/role-add-permission-controller.js"), __webpack_exec__("./assets/js/controllers/security-debug-controller.js"), __webpack_exec__("./assets/js/controllers/select-all-switch-list-controller.js"), __webpack_exec__("./assets/js/controllers/session-extender-controller.js"), __webpack_exec__("./assets/js/controllers/sortable-list-controller.js"), __webpack_exec__("./assets/js/controllers/timezone-input-controller.js"), __webpack_exec__("./assets/js/controllers/turbo-modal-controller.js"), __webpack_exec__("./assets/js/controllers/variable-insert-controller.js"), __webpack_exec__("./plugins/Activities/assets/js/controllers/approve-and-assign-auth-controller.js"), __webpack_exec__("./plugins/Activities/assets/js/controllers/gw-sharing-controller.js"), __webpack_exec__("./plugins/Activities/assets/js/controllers/mobile-request-auth-controller.js"), __webpack_exec__("./plugins/Activities/assets/js/controllers/renew-auth-controller.js"), __webpack_exec__("./plugins/Activities/assets/js/controllers/request-auth-controller.js"), __webpack_exec__("./plugins/Awards/Assets/js/controllers/award-form-controller.js"), __webpack_exec__("./plugins/Awards/Assets/js/controllers/rec-add-controller.js"), __webpack_exec__("./plugins/Awards/Assets/js/controllers/rec-bulk-edit-controller.js"), __webpack_exec__("./plugins/Awards/Assets/js/controllers/rec-edit-controller.js"), __webpack_exec__("./plugins/Awards/Assets/js/controllers/rec-quick-edit-controller.js"), __webpack_exec__("./plugins/Awards/Assets/js/controllers/rec-table-controller.js"), __webpack_exec__("./plugins/Awards/Assets/js/controllers/recommendation-kanban-controller.js"), __webpack_exec__("./plugins/GitHubIssueSubmitter/assets/js/controllers/github-submitter-controller.js"), __webpack_exec__("./plugins/Officers/assets/js/controllers/assign-officer-controller.js"), __webpack_exec__("./plugins/Officers/assets/js/controllers/edit-officer-controller.js"), __webpack_exec__("./plugins/Officers/assets/js/controllers/office-form-controller.js"), __webpack_exec__("./plugins/Officers/assets/js/controllers/officer-roster-search-controller.js"), __webpack_exec__("./plugins/Officers/assets/js/controllers/officer-roster-table-controller.js"), __webpack_exec__("./plugins/Template/assets/js/controllers/hello-world-controller.js"), __webpack_exec__("./plugins/Waivers/assets/js/controllers/add-requirement-controller.js"), __webpack_exec__("./plugins/Waivers/assets/js/controllers/camera-capture-controller.js"), __webpack_exec__("./plugins/Waivers/assets/js/controllers/exemption-reasons-controller.js"), __webpack_exec__("./plugins/Waivers/assets/js/controllers/hello-world-controller.js"), __webpack_exec__("./plugins/Waivers/assets/js/controllers/retention-policy-input-controller.js"), __webpack_exec__("./plugins/Waivers/assets/js/controllers/waiver-attestation-controller.js"), __webpack_exec__("./plugins/Waivers/assets/js/controllers/waiver-template-controller.js"), __webpack_exec__("./plugins/Waivers/assets/js/controllers/waiver-upload-controller.js"), __webpack_exec__("./plugins/Waivers/assets/js/controllers/waiver-upload-wizard-controller.js"), __webpack_exec__("./assets/css/app.css"), __webpack_exec__("./assets/css/signin.css"), __webpack_exec__("./assets/css/cover.css"), __webpack_exec__("./assets/css/dashboard.css"), __webpack_exec__("./plugins/Waivers/assets/css/waivers.css"), __webpack_exec__("./plugins/Waivers/assets/css/waiver-upload.css"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);
//# sourceMappingURL=controllers.js.map